<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何实现文字输入效果</title>
      <link href="/2019/01/23/how-to-achieve-typewriter-effect/"/>
      <url>/2019/01/23/how-to-achieve-typewriter-effect/</url>
      
        <content type="html"><![CDATA[<p>我们看到有些网站的文字会有类似于输入的效果，就好像自动打字一样，虽然这个效果用的地方可能不多，但如果用的好的话可能会有奇效，比如在博客、演讲展示等方面应用。那么，怎么实现呢？</p><a id="more"></a><h2 id="使用setTimeout实现"><a href="#使用setTimeout实现" class="headerlink" title="使用setTimeout实现"></a>使用setTimeout实现</h2><p>第一种方法是使用setTimeout进行文字控制，每一个文字都是一个<code>span</code>，利用DOM操作以一定的间隔将每个文字添加到文档中，同时设置<code>opacity:1</code>使其显示出来。光标闪烁的效果则利用<code>border-left</code>进行animation动画展示。</p><h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>先看代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"input-container"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里是需要展示的原始文字，设为display:none;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"originWords"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"typewriter-container"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里是最终有文字输入效果的文字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"typewriter-output"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释一下，我们首先把原始文字设为<code>display: none;</code>，这样不会占用文档位置，然后我们给之后添加的文字<code>span</code>块指定class为<code>word</code>。</p><h3 id="CSS设置"><a href="#CSS设置" class="headerlink" title="CSS设置"></a>CSS设置</h3><p>先看代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.input-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.typewriter-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.word</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">2s</span> step-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.typewriter-output</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: shine <span class="number">1s</span> infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> shine &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对<code>word</code>设置<code>transition: opacity 2s step-start;</code>。这里之所以通过<code>opacity</code>来进行transition，是因为transition不支持<code>display</code>，而<code>opacity</code>只需要设置<code>0</code>或<code>1</code>就可以使元素进行显示而不需要重排。</p><p>这里<code>transition-timing-function</code>使用<code>step-start</code>，使其有跳跃的效果，<code>step-start</code>相当于<code>steps(1, jump-start)</code>，<code>steps(n, &lt;jumpterm&gt;)</code>代表transition会停顿n次，每一次的效果为<code>&lt;jumpterm&gt;</code>，<code>jump-start</code>代表第一个跳跃发生在<code>transition</code>刚开始的时候，更多效果见<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function">文档</a>。</p><p>为什么要使用<code>:after</code>呢？因为我是逐步向<code>typewriter-output</code>添加<code>span</code>块，所以一开始宽度是不确定的，而且光标高度也不好设置，所以我想了个笨方法，使用<code>after</code>伪元素生成一个光标，并用<code>animation</code>控制其<code>border-left</code>的显示。但这里有个bug就是文字显示的间隔不能超过300ms，所以说这样处理还是有些问题，以后可能会有更好的方法。</p><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><p>其实就是利用<code>setTimout</code>设置时间间隔，通过DOM操作进行添加文字，先看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="built_in">document</span>.querySelector(<span class="string">'.originWords'</span>).innerText;</span><br><span class="line"><span class="keyword">var</span> output = <span class="built_in">document</span>.querySelector(<span class="string">'.typewriter-output'</span>);</span><br><span class="line"><span class="keyword">var</span> word = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> lastWord = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = words.length; i&lt; l; i++) &#123;</span><br><span class="line">  setTimeout(writeWord(i), i * <span class="number">200</span>);<span class="comment">// 每隔0.2s输出一个文字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里使用闭包保存i</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeWord</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    word = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">    word.classList.add(<span class="string">'word'</span>);</span><br><span class="line">    output.appendChild(word);</span><br><span class="line">    <span class="keyword">if</span> (!lastWord) &#123;</span><br><span class="line">      lastWord = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastWord !== word) &#123;</span><br><span class="line">     lastWord.style.opacity = <span class="string">'1'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    word.innerText = words[index];</span><br><span class="line">    lastWord = word;</span><br><span class="line">    <span class="keyword">if</span> (index === words.length - <span class="number">1</span>) &#123;</span><br><span class="line">      lastWord.style.opacity = <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码部分很简单，就是先获取需要展示的文字内容，然后每个字都通过dom操作塞进去，设置<code>opacity:1</code>，再进行一下边界判断，就实现了文字的展示。</p><hr><h2 id="纯animation实现"><a href="#纯animation实现" class="headerlink" title="纯animation实现"></a>纯animation实现</h2><p>这次我们不用<code>setTimeout</code>，所有展示的动画全部用<code>animation</code>来实现。废话不多说，我们来看一下。</p><h3 id="HTML结构-1"><a href="#HTML结构-1" class="headerlink" title="HTML结构"></a>HTML结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"typewriter"</span>&gt;</span>Hello, My friend.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法的好处就是不用有一个隐藏的原始文字段落，直接显示想显示的内容。</p><h3 id="CSS设置-1"><a href="#CSS设置-1" class="headerlink" title="CSS设置"></a>CSS设置</h3><p>接下来我们设置CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: bold <span class="number">100%</span> monospace;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">0.1em</span> solid;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> typing &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> cursor-blink &#123;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">border-color</span>: transparent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很简单对不对？挨？说好的动画呢？别急，我们通过JS来设置<code>animation</code>。</p><h3 id="JS部分-1"><a href="#JS部分-1" class="headerlink" title="JS部分"></a>JS部分</h3><p>先看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> typewriter = <span class="built_in">document</span>.getElementById(<span class="string">'typewriter'</span>);</span><br><span class="line"><span class="keyword">var</span> words = typewriter.innerText.length;</span><br><span class="line"><span class="keyword">if</span> (words) &#123;</span><br><span class="line">    typewriter.style.width = words + <span class="string">'ch'</span>;</span><br><span class="line">    typewriter.style.animation = <span class="string">'typing 3s steps('</span> + words + <span class="string">', end), cursor-blink 0.5s step-end infinite alternate'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们所做的事就是获取文字段落字符串的长度，然后设置其宽度和动画效果。非常简单！</p><p>那么，为什么这样做可以呢？别急，我们来分析分析。</p><p>首先，在获取了文字字符串长度后，我们设置段落的宽度为<code>width: Xch;</code>，这里X代表字符串长度，<code>ch</code>是长度单位，代表数字“0”的宽度，通常也就是一个字符的宽度。</p><p>然后，我们直接设置<code>animation: typing 3s steps(X, end), cursor-blink 0.5s step-end infinite alternate;</code>，一切就搞定了！为啥？通过CSS我们设置了<code>@keyframe</code>typing，表示宽度从0开始，一直到设置的<code>Xch</code>，持续3s，用<code>steps</code>动画函数，分为X步，也就是有多少个字符，就停顿多少下，达到输入的效果。至于光标的效果，我们直接通过动画设定<code>50%</code>的时候<code>border-color</code>为<code>transparent</code>，则每一秒闪烁一次，因为只有<code>border-right</code>设置了宽度，所以完美达到光标的效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两种方法比较起来，第二种方法更加实用简便，推荐大家使用。这只是简单的CSS3 animation动画应用，今后还可以开动脑筋，实现更多炫酷有趣的效果。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> setTimeout </tag>
            
            <tag> animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现页面不同内容之间的跳转</title>
      <link href="/2019/01/12/use-anchor-jump-to-anywhere-in-page/"/>
      <url>/2019/01/12/use-anchor-jump-to-anywhere-in-page/</url>
      
        <content type="html"><![CDATA[<p>我们常常会碰到这样的需求：点击某个标题、某段话，跳转到页面对应的位置，并且浏览器不会刷新，相当于在页面进行内部导航，这在浏览文章、或者是内容比较多的长屏单页应用上有着迫切的需求。那么，如何实现这个简单的功能呢？</p><a id="more"></a><h1 id="利用a标签的href值"><a href="#利用a标签的href值" class="headerlink" title="利用a标签的href值"></a>利用a标签的href值</h1><p>我们知道，<code>&lt;a&gt;</code>标签的<code>href</code>属性支持绝对路径和相对路径，其实它还支持路由hash。打个比方，我们的浏览器地址是：<code>http://www.example.com</code>，HTML里有这样一个标签：<code>&lt;a href=&quot;#start&quot;&gt;click&lt;/a&gt;</code>，点击该标签后，浏览器的URL地址后面就会多出一个hash值：<code>http://www.example.com#start</code>，如果HTML里有id为<code>start</code>的元素，则浏览器窗口会自动滚动到该元素所在的位置，也就是使该元素滚动到视窗最上面。</p><p>那么，很简单的我们就可以利用这个属性实现跳转到页面任何位置，只要在想要跳转的地方设置<code>id</code>值，再通过设置<code>a</code>标签的<code>href</code>为<code>#id</code>，我们就可以实现跳转。</p><p>为什么我们可以使用<code>#id</code>实现跳转呢？我们先来看看MDN的定义：</p><blockquote><p><strong>href</strong></p><p>Contains a URL or a URL fragment that the hyperlink points to.</p><p>A URL fragment is a name preceded by a hash mark (<code>#</code>), which specifies an internal target location (an <code>id</code> of an HTML element) within the current document.</p></blockquote><p>什么意思呢？其实<code>href</code>就是给定一个超链接，它的值指向的其实是一个URL或者URL片段，而一个URL片段通常是以<code>#name</code>的形式，代表着当前文档页面内部target的位置（也就是一个HTML元素的id），所以我们就可以利用<code>id</code>来进行页面内部元素之间的跳转。</p><p>那么如果要跳转到页面顶部呢？有的人可能会说：用JS设置<code>scrollTop</code>的值不就好了，这当然可以，之前我也写过跳转到顶部的<a href="https://xmflyrk.com/2017/08/22/scroll-to-top-btn/">文章</a>。但是，如果不用JS呢？很简单，我们直接这样设置：<code>&lt;a href=&quot;#&quot;&gt;click to top&lt;/a&gt;</code>，点击就能直接跳转到页面顶部了！</p><p>这是为什么呢？我们知道<code>#</code>后面的name值代表的是某个元素的<code>id</code>，但如果没有这个name，那就代表所有元素，也就是整个页面，所以就把页面移动到视窗的最顶部了，是不是很方便呢。但是这样有一点不好，就是没有滚动动画，跳转比较生硬，对于UI动画要求不高的页面用这个非常合适。</p><h1 id="Input和Label的妙用"><a href="#Input和Label的妙用" class="headerlink" title="Input和Label的妙用"></a>Input和Label的妙用</h1><p>那么除了利用<code>a</code>标签，还有其他方法可以在不用JS的情况下实现跳转吗？答案就是利用<code>input</code>和<code>label</code>标签！</p><p>我们先在想要跳转的地方增加一个<code>input</code>标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"anchor"</span>&gt;</span>// 这是我们要跳转的位置</span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        // 假设文章很长...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后设置<code>CSS</code>令其不可见：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#anchor</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anchor</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来做什么呢？我们知道<code>label</code>标签有一个<code>for</code>属性，它的值代表着对应<code>input</code>的<code>id</code>，当设置了<code>for</code>值为某个<code>input</code>的<code>id</code>，我们点击<code>label</code>，则会令对应的<code>&lt;input&gt;</code>变为<code>focus</code>状态，而当某个元素为focus状态时，浏览器窗口会自动使其滚动到视窗内，这样我们就实现了点击跳转功能！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"anchor"</span>&gt;</span>// 这是我们要跳转的位置</span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        // 假设文章很长...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"anchor"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里我们用到了两种方法实现页面元素跳转，都没有用到JavaScript，在对滚动动画要求不高的条件下，用这两种方法能简单有效的实现跳转需求，值得一试！</p>]]></content>
      
      
      <categories>
          
          <category> JS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anchor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迟来的2018总结</title>
      <link href="/2019/01/09/2018-road-to-grow-up/"/>
      <url>/2019/01/09/2018-road-to-grow-up/</url>
      
        <content type="html"><![CDATA[<p>已经2019年了，由于最近一大堆事情，没有时间更博，现在终于有时间好好坐下来总结一下自己的2018了。</p><a id="more"></a><p>要是问我生命中最重要的年份有哪些，2018年肯定是其中之一。</p><p>这一年，我结束了学生生涯，正式踏上了工作岗位，成为了社会人。</p><p>这一年，我从成都只身一人来到杭州，没有听父母的意见去传统行业寻求稳定的工作，而是投入到互联网的浪潮当中。</p><p>这一年，我找到了我爱的那个她，希望可以和她一起走下去，我们的路，才刚刚开始。</p><p>这一年…</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>这一年最大的改变，就是我脱离了学生这个群体，走向了社会这个大熔炉。说实话，6月底刚刚毕业离开校园，心里面还是充满了对未来未知的恐惧。从小到大，生活都是按部就班，小学、中学、到大学，你可以清晰地看到前面的路，要做的就是好好学习，往前走就行了。但是，现在不同了，工作以后，前面的路一切都是未知的，走得怎么样，全取决于自己，没有人替我安排。</p><p>工作半年，其实挺困惑的，因为很多时候自己还停留在学生思维，学生时代做事，都有人推着你走，老师会帮你监督，做的好不好，更多的时候取决于你考的好不好，得到的反馈简单又明了。但是工作后才发现，所有的事情都变的不一样了。没有人帮你设定目标，没有人推着你走，即使你什么都不做也不会有人来管你，领导只看最后的结果，用数据说话，只有主动出击，才能收获成果，被动地等待，永远只能在原地打转。</p><p>所以说，作为职场新人，我还有很长的路要走，首先需要改变的就是自己的思维模式，做一个主动出击的人。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>作为一个刚入门的前端工程师，2018年也是我技术提升最快的一年。这里用一张思维导图记录下自己的前端学习之路。</p><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/front-end-learning.jpg" alt="frontend-learning"></p><p>这只是我总结的一个大概版本，之后还会不断补充。其实里面很多知识我都只是刚刚了解，还需要不断深入。</p><p>2018，对于我来说算是正式入了前端的大门，对整个前端的大架构也有了初步的了解，但是这还只是刚开始，前端要学的东西太多了，我不能停止学习的步伐，虽然工作后可能学习的时间变少了，但不管怎样都要抽时间出来自学，时刻保持好奇心和学习力。而且，前端工程师也是程序员，算法、数据结构、计算机网络等基本知识也需要巩固了解，技术的路上，学无止境。</p><p>2019我需要在巩固基础知识的同时，不断扩展自己的知识面，多写代码，多实践，只有在实践中才能真正学会运用相关知识。talk is cheap, just show the code.</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>2018最幸福的事，就是终于脱离了单身狗的队伍！撒狗粮的事就不多说了，一切才刚刚开始，我希望未来能和她一起携手度过每一天，成为我们彼此眼中那个更好的自己。</p><p>工作后，离开了父母的怀抱，生活中某种意义上成为了真正独立的个体，很多事情都需要自己来操作，我需要慢慢适应新生活的节奏，承担起更多的责任，平衡好工作与生活的时间点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>碎碎念了这么多，新的一年，新的开始，我希望未来的一年在工作、技术、生活方面都能不断成长蜕变，不停下自己的脚步。</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现基于codemirror的markdown编辑器(二)</title>
      <link href="/2018/12/20/codemirror-markdown-editor-chapter2/"/>
      <url>/2018/12/20/codemirror-markdown-editor-chapter2/</url>
      
        <content type="html"><![CDATA[<p>前面我们提到了如何加载<code>codemirror</code>组件和一些基本配置，以及如何实现实时预览。接下来才是重头戏，我们需要实现同屏滚动和添加自定义按钮。<br><a id="more"></a></p><p>这篇我们先来着重讲讲同屏滚动。</p><h1 id="同屏滚动"><a href="#同屏滚动" class="headerlink" title="同屏滚动"></a>同屏滚动</h1><p>我们写文档时，除了想要实时预览，还想要能同步滚动，这样写到哪预览页面就滚动到哪，不用鼠标移来移去，方便不少。但是如何实现呢？我们一步一步来。</p><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>首先，要想滚动，肯定得监听滚动事件<code>onscroll</code>，但是这里我没有直接监听<code>scroll</code>事件，因为我们有两个区域，左边是输入文本框，右边是预览区，我想实现这样的功能：当鼠标移到左边使滚动条滚动时，这个时候先监听左边的滚动事件计算出相应的滚动高度后再修改右边的滚动高度，这样右边是跟着左边的高度滚动而滚动的。相应的，当鼠标移到右边区域使滚动条滚动时，先监听右边的滚动事件计算出滚动高度后再修改左边的滚动高度。这样滚动才能实现对应关系，但是如果直接监听滚动事件，则会出现一个问题，当右边滚动时，左边滚动事件没有移除，则又会触发，计算高度后引发右边滚动，形成一个一直滚动的死循环，最后整个页面滚动位置都是乱的。<br>所以，这里我先监听<code>mouseover</code>和<code>mouseleave</code>事件，话不多说看代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">codemirrorScroll = <span class="function">(<span class="params">doc</span>) =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.onScroll &amp;&amp; <span class="keyword">this</span>.props.onScroll(doc, <span class="keyword">this</span>.editRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">codemirrorScrollHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.on(<span class="string">'scroll'</span>, <span class="keyword">this</span>.codemirrorScroll(<span class="keyword">this</span>.codeMirror.doc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">codemirrorRemoveScroll = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.off(<span class="string">'scroll'</span>, <span class="keyword">this</span>.codemirrorScroll(<span class="keyword">this</span>.codeMirror.doc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">this</span>.editRoot.addEventListener(<span class="string">'mouseover'</span>, <span class="keyword">this</span>.codemirrorScrollHandler);</span><br><span class="line">  <span class="keyword">this</span>.editRoot.addEventListener(<span class="string">'mouseleave'</span>, <span class="keyword">this</span>.codemirrorRemoveScroll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到，我在<code>mouseover</code>的时候开始监听<code>scroll</code>事件，<code>mouseleave</code>的时候移除之前的<code>scroll</code>事件，所以这里要用<code>codemirrorScroll</code>函数封装，以便移除时是同一个函数。<br>这里我把<code>scroll</code>事件的处理通过props抛给父组件，我们来看看父组件是怎么实现<code>scroll</code>事件的。</p><p>首先考虑到性能和滚动流畅度问题，使用<code>debounce</code>函数包装一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debounceContentScroll = debounce(<span class="keyword">this</span>.handleScrollContent);</span><br></pre></td></tr></table></figure></p><p>接下来就是如何去计算当前滚动的位置并使另一边的内容自动滚动到对应高度，这里我用一幅图解释一下：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/markdown-scroll.png" alt="markdown-scroll"><br>我们主要获取的就是这三个值：<code>child.offsetHeight</code>、<code>parent.offsetHeight</code>、<code>child.scrollTop</code>。所以我们需要在展示内容外面都用<code>div</code>包一层，代表<code>parent</code>元素。先看代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">calcScrollScale = <span class="function">(<span class="params">scrollTopMax1, scrollTopMax2</span>) =&gt;</span> (scrollTopMax1 / scrollTopMax2);</span><br><span class="line"></span><br><span class="line">calcScrollTopMax = <span class="function">(<span class="params">parent, child</span>) =&gt;</span> <span class="built_in">Math</span>.abs((child.offsetHeight || child.height) - parent.offsetHeight)</span><br><span class="line"></span><br><span class="line">updateScroll = <span class="function">(<span class="params">scrollTop, target, scrollTopMax1, scrollTopMax2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> scale = <span class="keyword">this</span>.calcScrollScale(scrollTopMax1, scrollTopMax2);</span><br><span class="line">  target.scrollTop = scrollTop / scale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleScrollContent = <span class="function">(<span class="params">doc, docParent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mdPreview = <span class="keyword">this</span>.mdPreview.current;</span><br><span class="line">  <span class="keyword">const</span> previewContent = <span class="keyword">this</span>.previewContent.current;</span><br><span class="line">  <span class="keyword">const</span> scrollTopMaxFrom = <span class="keyword">this</span>.calcScrollTopMax(docParent, doc);</span><br><span class="line">  <span class="keyword">const</span> scrollTopMaxTo = <span class="keyword">this</span>.calcScrollTopMax(mdPreview, previewContent);</span><br><span class="line">  <span class="keyword">this</span>.updateScroll(doc.scrollTop, mdPreview, scrollTopMaxFrom, scrollTopMaxTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个很重要的参数：<code>scrollTopMax</code>。<br><code>scrollTopMax = |(child.offsetHeight || child.height) - parent.offsetHeight|</code>。使用<code>child.height</code>是因为codemirror的<code>doc</code>对象内容高度可以直接通过<code>height</code>属性获得。为什么要这样计算？<br>我们算的是当前内容可滚动的最大高度，为什么要计算这个？因为我们知道因为渲染的原因，左边输入的时候是单纯的文本，右边渲染出来有标题、图片等等，实际高度会比左边高得多，通过计算两边相对父容器可滚动的最大高度，再计算这两个的比值：<code>calcScrollScale = (scrollTopMax1, scrollTopMax2) =&gt; (scrollTopMax1 / scrollTopMax2);</code>，可以得到一个<code>scrollScale</code>。<br>我们有这样一个公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>，那么我们很容易得出右边的滚动高度：<code>right.scrollTop = left.scrollTop / scrollScale</code>。于是就可以使右边滚动到对应内容的高度了！</p><p>有了左边的范例，对右边预览的container同样使用一样的监听事件，这样就可以实现双向同步滚动绑定了！！！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现同步滚动的关键点其实有两个：一个是注意监听事件的变化，先监听<code>mouseover</code>和<code>mouseleave</code>，这样不会出现滚动死循环。另一个是理解公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>。理解了这两个关键点，其实同步滚动就很容易了。<br>但要注意的是，这里的<code>debounce</code>设置延迟时间可能还需要好好斟酌，我默认使用20毫秒，实际滚动时还是会有点卡顿，可以适当改变一下数值。<br>还有就是，因为markdown语法原因，段落之间都必须有一个空行，不然渲染出来文本没换行，导致段落不一致。<br>下一篇，我将介绍如何添加操作按钮使其能自动生成对应的markdown语法。</p><blockquote><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop">scrollTop</a></li><li><a href="https://juejin.im/post/5a3bb40e5188252b145b38e3">原生JS控制多个滚动条同步跟随滚动</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> codemirror </tag>
            
            <tag> Editor </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现基于codemirror的markdown编辑器(一)</title>
      <link href="/2018/12/15/codemirror-markdown-editor-chapter1/"/>
      <url>/2018/12/15/codemirror-markdown-editor-chapter1/</url>
      
        <content type="html"><![CDATA[<p>我们知道，要实现一个Markdown编辑器，一般会想要实现这样的功能：实时预览、同步滚动、支持标签按钮添加、markdown语法高亮等等。那么如何去实现一个功能比较完整的markdown编辑器呢？</p><p>首先这里我们只讨论web端，其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，很多都可以拿来直接用，满足基本需求足够了。但是作为前端程序员来说，当然想要实现一个自己定制化的markdown编辑器比较有意思，不过通过查阅资料文档和各种框架比较，发现也不是那么容易的事。<br><a id="more"></a></p><h1 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h1><p>要实现一个markdown编辑器，首先得找到一个合适的框架，目前市面上优秀的markdown框架五花八门。由于现在自己写的项目一般都使用React，所以理所当然能找到一个比较契合React的Markdown框架是更好的。</p><p>经过前期调研，发现有几款基于React的Markdown框架还不错，<a href="https://zenoamaro.github.io/react-quill/">react-quill</a>、facebook的<a href="https://draftjs.org/docs/getting-started.html">draft</a>、<a href="https://github.com/scniro/react-codemirror2">react-codemirror2</a>，但它们其实都是富文本编辑器，定制的东西已经很完善了，我想要的框架是可支持自定义扩展，定制化自己想要的功能，找来找去，最后决定基于<a href="https://codemirror.net/doc/manual.html#api">CodeMirror</a>来自己实现一个定制化的markdown编辑器。因为CodeMirror其实相当于一个基础的框架，它有很多可配置项，可以自己添加工具栏，添加各种实用功能，这正好满足了我的需求，于是就决定用它了！</p><h1 id="CodeMirror"><a href="#CodeMirror" class="headerlink" title="CodeMirror"></a>CodeMirror</h1><p>现代很多编辑器其实都基于<code>codemirror</code>，为什么要选择它呢？这都得益于它强大的API和配置项，在不失基本功能的同时给予了开发者极大的定制空间，开发者可以基于它开发出各种功能的markdown编辑器。这里我先简单介绍一下codemirror的一些基本操作。想要了解更多有关codemirror，可以去看<a href="https://codemirror.net/doc/manual.html">官方文档</a>。</p><h2 id="如何加载codemirror"><a href="#如何加载codemirror" class="headerlink" title="如何加载codemirror"></a>如何加载codemirror</h2><p>一般我们在项目里npm下载完codemirror包后，在代码里引入<code>codemirror.js</code>，而且还会根据需要引入想要的语言模式包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> CM <span class="keyword">from</span> <span class="string">'codemirror'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'codemirror/mode/xml/xml'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'codemirror/mode/markdown/markdown'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'codemirror/addon/edit/continuelist'</span>;</span><br></pre></td></tr></table></figure></p><p>当然，我们还得在html里引入<code>codemirror.css</code>样式，也可以自己修改成想要的样式。</p><p>然后，在需要加载的地方写html标签，id为<code>codemirror</code>，这里我们用的是JSX：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"editor-root"</span> ref=&#123;(elem) =&gt; &#123; <span class="keyword">this</span>.editRoot = elem; &#125;&#125;&gt;</span><br><span class="line">  &lt;textarea id=<span class="string">"codemirror"</span> name=&#123;<span class="keyword">this</span>.props.path&#125; autoComplete=<span class="string">"off"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>我在<code>textarea</code>外面用div包了一层，是为了方便之后的滚动效果。这样，我们就已经可以使用codemirror写一个markdown编辑器了。</p><h2 id="options-可以使用的参数"><a href="#options-可以使用的参数" class="headerlink" title="options 可以使用的参数"></a>options 可以使用的参数</h2><p>  CodeMirror函数和它的fromTextArea方法都可以使用一个配置对象作为第二个参数。这个options极为重要，基本就决定了你的编辑器主要的输入语言、样式、内容。这里列一下它几个常用的可选的参数：</p><ul><li>value: string | CodeMirror.Doc<br>编辑器的初始值（文本），可以是字符串或者CodeMirror文档对象(不同于HTML文档对象)。</li><li>mode: string | object<br>通用的或者在CodeMirror中使用的与mode相关联的mime，当不设置这个值的时候，会默认使用第一个载入的mode定义文件。一般地，会使用关联的mime类型来设置这个值；除此之外，也可以使用一个带有name属性的对象来作为值（如：{name: “javascript”, json: true}）。可以通过访问CodeMirror.modes和CodeMirror.mimeModes获取定义的mode和MIME。</li><li>lineSeparator: string|null<br>明确指定编辑器使用的行分割符（换行符）。默认（值为null）情况下，文档会被 CRLF(以及单独的CR, LF)分割，单独的LF会在所有的输出中用作换行符（如：getValue）。当指定了换行字符串，行就只会被指定的串分割。</li><li>theme: string<br>配置编辑器的主题样式。要使用主题，必须保证名称为 .cm-s-[name] (name是设置的theme的值)的样式是加载上了的。当然，你也可以一次加载多个主题样式，使用方法和html和使用类一样，如： theme: foo bar，那么此时需要cm-s-foo cm-s-bar这两个样式都已经被加载上了。</li><li>indentUnit: integer<br>缩进单位，值为空格数，默认为2 。</li><li>smartIndent: boolean<br>自动缩进，设置是否根据上下文自动缩进（和上一行相同的缩进量）。默认为true。</li><li>tabSize: integer<br>tab字符的宽度，默认为4 。</li><li>indentWithTabs: boolean<br>在缩进时，是否需要把 n*tab宽度个空格替换成n个tab字符，默认为false 。</li><li>electricChars: boolean<br>在输入可能改变当前的缩进时，是否重新缩进，默认为true （仅在mode支持缩进时有效）。</li><li>keyMap: string<br>配置快捷键。默认值为default，即 codemorrir.js 内部定义。其它在key map目录下。</li><li>extraKeys: object<br>给编辑器绑定与前面keyMap配置不同的快捷键。</li><li>lineWrapping: boolean<br>在长行时文字是换行(wrap)还是滚动(scroll)，默认为滚动(scroll)。</li><li>lineNumbers: boolean<br>是否在编辑器左侧显示行号。</li><li>firstLineNumber: integer<br>行号从哪个数开始计数，默认为1 。</li><li>lineNumberFormatter: function(line: integer) → string<br>使用一个函数设置行号。</li><li>scrollbarStyle: string<br>设置滚动条。默认为”native”，显示原生的滚动条。核心库还提供了”null”样式，此样式会完全隐藏滚动条。Addons可以设置更多的滚动条模式。</li><li>inputStyle: string<br>选择CodeMirror处理输入和焦点的方式。核心库定义了textarea和contenteditable输入模式。在移动浏览器上，默认是contenteditable，在桌面浏览器上，默认是textarea。在contenteditable模式下对IME和屏幕阅读器支持更好。</li><li>readOnly: boolean|string<br>编辑器是否只读。如果设置为预设的值 “nocursor”，那么除了设置只读外，编辑区域还不能获得焦点。</li><li>showCursorWhenSelecting: boolean<br>在选择时是否显示光标，默认为false。</li><li>autofocus: boolean<br>是否在初始化时自动获取焦点。默认情况是关闭的。但是，在使用textarea并且没有明确指定值的时候会被自动设置为true。</li></ul><p>更多的配置请查看<a href="https://codemirror.net/doc/manual.html#config">相关文档</a>。</p><h1 id="实时预览"><a href="#实时预览" class="headerlink" title="实时预览"></a>实时预览</h1><p>这个需求可以说是现代markdown编辑器的基本需求，因为markdown写起来本身是没有任何样式的，纯文本的话对于有些人来说不能看到最终效果就很不习惯，自己写的效果怎么样都不知道，写的心里就会很没底（当然再花哨的样式最后还是要看内容好不好）。说白了，实时预览更多是写作时一个心理上的满足，这对于写作体验的提升来说是必不可少的。</p><p>这里的markdown渲染引擎我直接用了比较受欢迎的<a href="https://marked.js.org/#/README.md#README.md"><code>marked</code></a>库，其实markdown渲染是很考验技术的一门活，绝大部分都是用正则匹配来进行标签的替换，但由于markdown的语法相对还是较多的，要自己写一个markdown渲染引擎还是有点难度的，考虑到时间因素所以一般都会用现成的库，当然以后有时间的话我也会考虑写一个markdown渲染引擎玩玩。</p><p>这里我因为是用<code>React</code>写的markdown组件，下面我就简单的介绍下如何实现实时预览。</p><p>首先在组件渲染完后，我们在<code>componentDidMount</code>函数里对codemirror进行事件监听：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="comment">// 因为需要使用fromTextArea获取options，所以采用document.getElementById</span></span><br><span class="line">  <span class="keyword">this</span>.codeMirror = CM.fromTextArea(ReactDOM.findDOMNode(<span class="built_in">document</span>.getElementById(<span class="string">'codemirror'</span>)), <span class="keyword">this</span>.getOptions());</span><br><span class="line">  <span class="keyword">this</span>.props.init(<span class="keyword">this</span>.editRoot, <span class="keyword">this</span>.codeMirror);</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.setValue(<span class="keyword">this</span>.props.defaultValue);</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.on(<span class="string">'change'</span>, <span class="keyword">this</span>.codemirrorValueChanged);</span><br><span class="line">  <span class="keyword">this</span>._currentCodemirrorValue = <span class="keyword">this</span>.props.defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们使用<code>fromTextArea</code>获取codemirror的dom节点，它支持两个参数，第一个是codemirror所挂载的dom节点，第二个是配置的options。</p><p>之后调用init函数，这里之后会讲。然后就是初始值设置<code>codemirror.setValue(defaultValue)</code>，因为是编辑器，如果想对之前的文档进行修改，肯定需要传入初始值。</p><p>然后就是关键的监听事件<code>change</code>，当输入变化时调用<code>this.codemirrorValueChanged</code>事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">codemirrorValueChanged = <span class="function">(<span class="params">cm</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newValue = cm.getValue();</span><br><span class="line">  <span class="keyword">this</span>._currentCodemirrorValue = cm.getValue();</span><br><span class="line">  <span class="keyword">this</span>.props.onChange &amp;&amp; <span class="keyword">this</span>.props.onChange(newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里说下，我们通过<code>cm.getValue()</code>获取当前输入的值，然后通过调用<code>props.onChange(newValue)</code>将值抛给父组件处理。因为这里我想把编辑部分和预览部分分开来做成两个公共组件，这样组件复用性更强，有的可能只需要编辑功能，有的只需要预览展示功能。<br>那么在父组件里，我们需要对<code>onChange</code>事件传入的值进行处理，将其渲染成html然后展示出来，其实很简单：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkdownEditor</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  handleEditChange = <span class="function">(<span class="params">newCode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.renderMarkdown &amp;&amp; <span class="keyword">this</span>.props.renderMarkdown(newCode);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      code: newCode,</span><br><span class="line">      hasChanged: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  debounceEditChange = debounce(<span class="keyword">this</span>.handleEditChange, <span class="number">500</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> preview = marked(<span class="keyword">this</span>.state.code);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;MyEditor</span><br><span class="line">          defaultValue=&#123;<span class="keyword">this</span>.state.code&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.debounceEditChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"md-preview-container"</span>&gt;</span><br><span class="line">          &lt;div className=<span class="string">"preview-content"</span> dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: preview&#125;&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是，我用到了<code>debounce</code>函数进行延迟处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay = <span class="number">20</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.call(self, ...args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为考虑到性能原因，如果输入过快的话，<code>change</code>事件频繁触发，预览页面不断重绘，性能损耗十分严重，所以我用到了<code>debounce</code>，并设置延迟时间500毫秒，当然可以更短，这里我觉得设置500毫秒已经足够了。这样就达到了实时预览的效果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于codemirror的markdown编辑器实现起来其实还有很多坑，本篇先介绍了<code>codemirror</code>的一些基本配置和如何实现markdown实时预览，接下来我将进一步介绍如何实现同屏滚动和自定义标签按钮等其他功能。</p>]]></content>
      
      
      <categories>
          
          <category> JS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> codemirror </tag>
            
            <tag> Editor </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点击按钮粘贴所选内容到剪贴板</title>
      <link href="/2018/12/04/copy-to-clipboard/"/>
      <url>/2018/12/04/copy-to-clipboard/</url>
      
        <content type="html"><![CDATA[<p>我们经常可以看到这样的功能，点击某个按钮可以自动复制想要的内容到剪贴板。比如说某个图片、视频的地址，某个输入的内容，我们有的时候懒得去用键盘鼠标选中某个区域，希望只用点击一下，就能复制想要的内容。<br><a id="more"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>其实这个用原生JS实现难度不大，主要用到的是<code>document.execCommand()</code>。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> transfer = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(transfer);</span><br><span class="line">    transfer.value = target.value;  <span class="comment">// 这里表示想要复制的内容</span></span><br><span class="line">    transfer.focus();</span><br><span class="line">    transfer.select();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)) &#123;</span><br><span class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    transfer.blur();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'复制成功'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(transfer);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#copyBtn'</span>).addEventListener(<span class="string">'click'</span>, copy);</span><br></pre></td></tr></table></figure><p>这里我们其实就是新创建了一个<code>input</code>DOM元素，然后选中该元素，把要复制的内容赋给<code>input.value</code>，这个时候执行<code>document.execCommand(&#39;copy&#39;)</code>，会把当前页面所有选中的内容复制到剪贴板，也就实现了复制的操作，最后再把新建的DOM元素移除，在不影响DOM树的情况下达到复制的目的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>document.execCommand()</code> 方法可以使当前选中的可编辑内容实现一些常用的操作，如copy、cut、paste、delete、contentReadOnly等等，具体请看<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand">document.execCommand</a>，但个人感觉一般最好不要去用里面的一些操作，因为这样可能会和用户的交互操作产生冲突，发生意想不到的结果。但是<code>document.execCommand</code>在富文本编辑器里又是个神器，值得之后慢慢研究。</p>]]></content>
      
      
      <categories>
          
          <category> JS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> execCommand </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯CSS绘制不同的图形</title>
      <link href="/2018/12/03/draw-different-shapes-with-css/"/>
      <url>/2018/12/03/draw-different-shapes-with-css/</url>
      
        <content type="html"><![CDATA[<p>为什么要用CSS绘制图形？我们知道，一般表示图案可以用<code>img</code>标签，直接用切好的图片，或者用<code>background</code>加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。<br><a id="more"></a></p><p>这里我列举一些比较感兴趣的图形。</p><h1 id="基本图案"><a href="#基本图案" class="headerlink" title="基本图案"></a>基本图案</h1><h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><p>圆形可以说是除了方形以外最容易表达的图形了，多亏了CSS3的<code>border-radius</code>属性：</p><h3 id="基本圆形"><a href="#基本圆形" class="headerlink" title="基本圆形"></a>基本圆形</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/circle.jpg" alt="circle"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="椭圆形"><a href="#椭圆形" class="headerlink" title="椭圆形"></a>椭圆形</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/oval.jpg" alt="oval"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.oval</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50px</span> / <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p>三角形其实利用的是<code>border</code>属性，利用不同方向的<code>border</code>宽度和颜色可以展现不同的三角形。</p><h3 id="triangle-top："><a href="#triangle-top：" class="headerlink" title="triangle-top："></a>triangle-top：</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-top.jpg" alt="triangle-top"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.top-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-bottom"><a href="#triangle-bottom" class="headerlink" title="triangle-bottom"></a>triangle-bottom</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-bottom.jpg" alt="triangle-bottom"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-left"><a href="#triangle-left" class="headerlink" title="triangle-left"></a>triangle-left</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-left.jpg" alt="triangle-left"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-right"><a href="#triangle-right" class="headerlink" title="triangle-right"></a>triangle-right</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-right.jpg" alt="triangle-right"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他的三角形也就是利用border属性进行的变形。</p><h1 id="特殊图案"><a href="#特殊图案" class="headerlink" title="特殊图案"></a>特殊图案</h1><h2 id="跳转图标"><a href="#跳转图标" class="headerlink" title="跳转图标"></a>跳转图标</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/border-top-left-radius.png" alt="border-top-left-radius"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.curvedarrow</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">26px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">26px</span> solid red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(10deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.curvedarrow</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">6px</span> solid red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要利用的属性有两个，一个是<code>border-radius: 20px 0 0 0;</code>。为什么要这样用呢？其实<code>border-radius</code>最多支持四个值：<code>border-top-left-radius</code>, <code>border-top-right-radius</code>,<code>border-bottom-right-radius</code>, and <code>border-bottom-left-radius</code>。这里我们把<code>border-top-left-radius</code>设为20px，其他的都设为0，再加上只设<code>border-top</code>的宽度，最后出来是一个尾部有弧度的长条。</p><p>第二个属性则是<code>rotate(deg)</code>，将两个图形经过不同的角度旋转后再移动长条的位置进行组合，最后达到跳转箭头的图标效果。</p><h2 id="等腰梯形"><a href="#等腰梯形" class="headerlink" title="等腰梯形"></a>等腰梯形</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/trapezoid.png" alt="trapezoid"><br>梯形其实很好理解，通过设置border的宽度和透明度就可以形成梯形：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.trapezoid</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/parallel.png" alt="parallel"><br>很简单，直接利用<code>transform: skew(deg)</code>就可以得到任意角度的平行四边形：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parallel</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五角星"><a href="#五角星" class="headerlink" title="五角星"></a>五角星</h2><p>其原理是利用三个三角形通过旋转不同的角度和绝对定位拼接而成。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-five.png" alt="star-five"><br>具体代码如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star-five</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(35deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-five</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">80px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">45px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">65px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-35deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-five</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">105px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-70deg);</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="六角星"><a href="#六角星" class="headerlink" title="六角星"></a>六角星</h2><p>利用两个三角形拼接而成。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-six.png" alt="star-six"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star-six</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-six</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="心形"><a href="#心形" class="headerlink" title="心形"></a>心形</h2><p>利用两个半圆长条形状旋转一定角度后拼装成心形。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/heart.png" alt="heart"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="月亮"><a href="#月亮" class="headerlink" title="月亮"></a>月亮</h2><p>非常简单，利用了<code>box-shadow</code>属性，<code>box-shadow</code>一般支持四个值：<code>offset-x</code>、<code>offset-y</code>、<code>blur-radius</code>、<code>spread-radius</code>、<code>color</code>。还有一个值<code>inset</code>表示shadow是否内嵌。这里我们通过设置<code>border-radius</code>使其为圆形然后令<code>box-shadow</code>便宜一定值得到月亮形状。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/moon.png" alt="moon"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">15px</span> <span class="number">15px</span> <span class="number">0</span> <span class="number">0</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="阴阳图案"><a href="#阴阳图案" class="headerlink" title="阴阳图案"></a>阴阳图案</h2><p>刚一看到这个图案感觉很神奇，不知道怎么实现的，但其实很简单，分三步：</p><p>首先，利用<code>border-width</code>画出一个一半深、一半浅的圆形：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang1.png" alt="yin-yang1"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yin-yang</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">96px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: black;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">50px</span> <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，利用伪元素的<code>content</code>和<code>border</code>，生成一个小铜钱然后定位到适合的位置：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang2.png" alt="yin-yang2"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yin-yang</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">18px</span> solid black;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，在对称的位置上在生成一个小铜钱，颜色与之前的相反。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang3.png" alt="yin-yang3"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yin-yang</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">18px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个一拼接，就形成了想要的阴阳图案：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang.png" alt="yin-yang"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用CSS，我们可以实现很多简单甚至是较复杂的图案，这样省去了切图的烦恼，还减少了http请求，资源加载速度变快，唯一不足的可能就是基本上都是用的CSS3属性，有兼容性问题。但是，既然能直接用CSS画出图案，当然是用起来！</p><blockquote><p>更多图案参见<a href="https://css-tricks.com/the-shapes-of-css/">参考资料</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shapes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是堆排序</title>
      <link href="/2017/09/05/what-is-heapSort/"/>
      <url>/2017/09/05/what-is-heapSort/</url>
      
        <content type="html"><![CDATA[<p>堆排序是一种常见的排序算法，时间复杂度是O(nlgn)，与归并排序一样，但它又与插入排序一样具有<em>空间原址性</em> ：任何时候都只需要常数个额外的元素空间存储临时数据。<br><a id="more"></a></p><h1 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h1><p>  一般堆用数组存储，表现出近似完全二叉树形式，树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的且从左至右填充。</p><h1 id="最大堆和最小堆"><a href="#最大堆和最小堆" class="headerlink" title="最大堆和最小堆"></a>最大堆和最小堆</h1><ul><li>最大堆：除了根以外的所有节点i都要满足A[parent(i)]&gt;=A[i]，即堆中最大元素是根节点。</li><li>最小堆：除了根以外的所有节点i都要满足A[parent(i)]&lt;=A[i]，即堆中最小元素是根节点。   </li></ul><h1 id="堆中节点的高度"><a href="#堆中节点的高度" class="headerlink" title="堆中节点的高度"></a>堆中节点的高度</h1><p>  与二叉树的高度相同，定义为该节点到叶节点最长简单路径上边的数目。则包含n个元素的堆其高度为lgn。</p><h1 id="维护堆的性质与方法（数组下标都从1开始）"><a href="#维护堆的性质与方法（数组下标都从1开始）" class="headerlink" title="维护堆的性质与方法（数组下标都从1开始）"></a>维护堆的性质与方法（数组下标都从1开始）</h1><h2 id="maxHeapify"><a href="#maxHeapify" class="headerlink" title="maxHeapify"></a>maxHeapify</h2><p>  时间复杂度为O(lgn)。通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆性质。代码如下:<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">arr, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> largest;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span>; <span class="comment">// leftChild</span></span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// rightChild</span></span><br><span class="line">  <span class="keyword">if</span>( left &lt;= arr.length &amp;&amp; arr[i] &lt; arr[left] ) &#123;</span><br><span class="line">    largest = left;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    largest = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>( right &lt;= arr.length &amp;&amp; arr[largest] &lt; arr[right] ) &#123;</span><br><span class="line">    largest = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( largest !== i ) &#123; <span class="comment">// 把左右子节点中最大的元素与当前节点i交换</span></span><br><span class="line">    arr[i] = arr[i] + arr[largest];</span><br><span class="line">    arr[largest] = arr[i] - arr[largest];</span><br><span class="line">    arr[i] = arr[i] - arr[largest];</span><br><span class="line">    maxHeapify(arr, largest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="buildMaxHeap"><a href="#buildMaxHeap" class="headerlink" title="buildMaxHeap"></a>buildMaxHeap</h2><p>  时间复杂度为O(n)。用<em>自底向上</em>的方法利用maxHeapify把大小为n的数组转换为最大堆。因为最后一个叶节点序号为n，则其父节点序号为n/2,所以子数组[n/2+1,….,n]都是堆的叶节点，所以循环从n/2开始递减到1，每一次都保证节点i+1,i+2…,n都是一个最大堆的根节点的性质。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    maxHeapify(arr,i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="heapSort-堆排序算法。"><a href="#heapSort-堆排序算法。" class="headerlink" title="heapSort:堆排序算法。"></a>heapSort:堆排序算法。</h1><p>  有了上述两个函数方法，我们就可以实现堆排序。</p><p>  先将数组arr建为一个最大堆，因为最大堆的根节点总是最大的，通过把它与arr[n]互换可以得到正确位置，保证arr[n]总是当前堆中最大元素，然后将arr[n]存储到新的数组中。可以算出时间复杂度为O(nlgn)。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arrSort = [];</span><br><span class="line">  buildMaxHeap(arr);  <span class="comment">// 先建一个最大堆</span></span><br><span class="line">  <span class="keyword">let</span> length = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">    arr[<span class="number">1</span>] = arr[i];</span><br><span class="line">    arrSort.push(arr[i]);</span><br><span class="line">    maxHeapify(arr, <span class="number">1</span>); <span class="comment">// 每次交换后重新维护最大堆，复杂度为O(lgn)</span></span><br><span class="line">  &#125;</span><br><span class="line">  arrSort.push(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> arrSort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  通过堆排序的实现，我们可以在时间复杂度为O(nlgn)的情况下对数组进行排序。而且当我们只需要找出数组中最大的几个元素，则可以用堆排序来实现，因为每次最大的元素总是当前最后一个，这样就不需要将数组全排序。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HeapSort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用原生JS写轮播图</title>
      <link href="/2017/08/27/how-to-write-js-marquee/"/>
      <url>/2017/08/27/how-to-write-js-marquee/</url>
      
        <content type="html"><![CDATA[<p>我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。<br><a id="more"></a></p><h1 id="要实现的功能"><a href="#要实现的功能" class="headerlink" title="要实现的功能"></a>要实现的功能</h1><p>首先我们来看看要实现这么一个轮播图需要哪些功能，这里我把我想到的都列出来了。</p><ol><li>页面加载后轮播图自动开始播放，每张图片停几秒钟。</li><li>图片与图片之间实现平滑过渡动画效果，不显突兀。</li><li>鼠标悬停到当前图片时轮播动画停止，鼠标离开图片后继续开始轮播。</li><li>图片上有左右翻页功能按钮，点击左边按钮图片往左滑动，点击右边按钮图片右滑。</li><li>图片下端有显示图片个数的小圆点，当前图片是第几个，则第几个小圆点“点亮”。</li><li>离开当前页面后轮播动画停止，回到当前页面后轮播动画继续。</li></ol><p>我能想到的要实现的功能就这么多，接下来就一步步开始实现。</p><h1 id="HTMl结构"><a href="#HTMl结构" class="headerlink" title="HTMl结构"></a>HTMl结构</h1><p>先不管JS、CSS部分，我们先把整体结构定下来。这里直接贴上主体部分代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loop-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat5.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat1.jpg"</span> <span class="attr">alt</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat2.jpg"</span> <span class="attr">alt</span>=<span class="string">"2"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat3.jpg"</span> <span class="attr">alt</span>=<span class="string">"3"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat4.jpg"</span> <span class="attr">alt</span>=<span class="string">"4"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat5.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat1.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"buttons"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"on"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow arrow-left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pt-inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow arrow-right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pt-inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里要强调的一点就是，虽然最后显示只有5张图片，但我插入了7个<code>img</code>标签，其中第一个和最后一张图一样，最后一个和第一个图一样。为什么要这么做呢？是因为要实现平滑的动画过渡效果，后面JS部分会提到。</p><h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><p>接下来就是CSS设置：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.loop-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">700%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation</span>: left .<span class="number">6s</span> ease-out;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span><span class="selector-pseudo">:hover</span> &gt; <span class="selector-class">.arrow</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loop-container</span> <span class="selector-class">.loop-image</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我没有把全部的CSS代码贴出来，完整的代码我会在最后给出。</p><p>我只说几个要注意的地方：</p><ul><li>首先外部容器要设置<code>overflow:hidden</code>，这样才能把多余的图片遮住；</li><li>其次由于img默认是inline元素，显示出来的特性是inline-block，所以img之间会有4px的空隙，即使设置了margin和padding为0也不能消除。为此我困惑了很久。。。后来上网找资料才发现解决方案。一般有几种解决方案，这里我用的是设置父元素的font-size为0，然后img的font-size设不设置根据需要，这样就可以消除空隙。更详尽的解决方案可以参考张大神的<a href="http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">博客</a></li></ul><p>其他css设置就根据样式慢慢调整了。</p><h1 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h1><p>接下来就是重头戏，JS的实现了。我们一步一步来看。</p><p>我先创建了一个整体的“类”，里面有一些所需要用到的方法和属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Marquee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>; <span class="comment">// 保存当前是第几张图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.animate = <span class="function"><span class="keyword">function</span> (<span class="params">aimLeft</span>) </span>&#123;  <span class="comment">// 具体的动画实现</span></span><br><span class="line">  <span class="keyword">var</span> curLeft = <span class="built_in">parseInt</span>(loopContainer.style.left) || <span class="number">-600</span>, <span class="comment">// 获取当前图片的left值</span></span><br><span class="line">      speed = (aimLeft - curLeft) / <span class="number">20</span>, <span class="comment">// 每次left移动的距离</span></span><br><span class="line">      delay = <span class="number">20</span>,</span><br><span class="line">      self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> time = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 利用循环定时实现平滑移动的动画效果</span></span><br><span class="line">    curLeft += speed;</span><br><span class="line">    loopContainer.style.left = curLeft + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">if</span> (curLeft === aimLeft) &#123;  <span class="comment">// 如果移动到了下一张图片的位置，则此次移动动画结束</span></span><br><span class="line">      clearInterval(time);</span><br><span class="line">      <span class="keyword">if</span> (aimLeft &lt;= <span class="number">-3600</span>) &#123;  <span class="comment">// 特殊设置，如果是从最后一张图到第一张图，中间加一张图片实现动画过渡，当到达最后一张图后，立即设置left为第二个img的left。 </span></span><br><span class="line">        loopContainer.style.left = <span class="string">'-600px'</span>;  <span class="comment">// 第一张图实际的left为-600px，因为html里left为0的位置是最后一张图</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (aimLeft &gt;= <span class="number">0</span>) &#123; <span class="comment">// 同理，当从第一张图过渡到最后一张图，先实现动画效果，当left为实际第一张图的位置0时，设置left为倒数第二个img的位置。</span></span><br><span class="line">        loopContainer.style.left = <span class="string">'-3000px'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      self.showCurrentDot();  <span class="comment">// 动画结束后再改变小圆点的外观</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">Marquee.prototype.showCurrentDot = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 设置代表当前图片位置的小圆点class</span></span><br><span class="line">  <span class="keyword">var</span> dots = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = dots.length; i &lt; len; i++) &#123;</span><br><span class="line">    dots[i].className = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dots[<span class="keyword">this</span>.index].className = <span class="string">'on'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.changePhoto = <span class="function"><span class="keyword">function</span> (<span class="params">offset</span>) </span>&#123; <span class="comment">// 自动改变图片的函数</span></span><br><span class="line">  <span class="keyword">var</span> left = loopContainer.style.left,</span><br><span class="line">    newleft = left ? <span class="built_in">parseInt</span>(left) + offset : offset - <span class="number">600</span>;  <span class="comment">// 新的位置</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.index = offset &gt; <span class="number">0</span> ? <span class="keyword">this</span>.index - <span class="number">1</span> : <span class="keyword">this</span>.index + <span class="number">1</span>;  <span class="comment">// 判断向左还是向右滑动</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.index &gt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(left);</span></span><br><span class="line">  <span class="comment">// console.log(newleft);</span></span><br><span class="line">  <span class="comment">// console.log('------');</span></span><br><span class="line">  <span class="keyword">this</span>.animate(newleft);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.gotoPhoto = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;  <span class="comment">// 跳转到第count个图片的函数</span></span><br><span class="line">  <span class="keyword">var</span> newleft = count * <span class="number">-600</span>;</span><br><span class="line">  <span class="comment">// console.log(newleft);</span></span><br><span class="line">  <span class="keyword">this</span>.index = count - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.animate(newleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maq = <span class="keyword">new</span> Marquee();</span><br></pre></td></tr></table></figure></p><h2 id="自动播放图片"><a href="#自动播放图片" class="headerlink" title="自动播放图片"></a>自动播放图片</h2><p>轮播图，顾名思义就是轮流播放图片，所以首先要实现的功能就是自动轮流循环播放图片。 有了之前的类，我们要做的就是当页面加载完毕后开始循环播放：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'arrow-left'</span>)[<span class="number">0</span>],</span><br><span class="line">      nextBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'arrow-right'</span>)[<span class="number">0</span>],</span><br><span class="line">      loopContainer = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'loop-container'</span>)[<span class="number">0</span>],</span><br><span class="line">      btns = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'buttons'</span>)[<span class="number">0</span>],</span><br><span class="line">      wrap = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'wrap'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> stopFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">startInterval</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 开始循环动画</span></span><br><span class="line">    maq.timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// console.log(stopFlag);</span></span><br><span class="line">      <span class="keyword">if</span> (!stopFlag) &#123;</span><br><span class="line">        maq.changePhoto(<span class="number">-600</span>);</span><br><span class="line">        startInterval();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearTimeout(maq.timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">4500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  startInterval();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我循环动画没有用setInterval函数，而是用的setTimeout。因为setInterval的机制是每隔一段时间就把事件加入到队列中去，但如果之前的事件还没执行完，就会容易造成队列堵塞。比如说setInterval里的函数执行时间要4秒，如果setInterval的间隔时间少于4秒，则会造成队列里的事件越来越多，而之前的事件却没执行完，这样可能就会使队列里的事件堵塞，最后一次性全部执行，而没有达到预期的间隔效果。</p><p>所以我用setTimeout来代替setInterval，每次要加入新的事件之前都先判断一下<code>stopFlag</code>是否为0。<code>stopFlag</code>的作用就是记录是否要停止动画，为0则不停止，为1则停止。</p><p>这里记住要clearTimeout，目的是把已经在队列里但还没有执行的事件清除，这样可以达到立即停止动画的效果。</p><h2 id="鼠标悬停停止轮播动画，离开后开始动画"><a href="#鼠标悬停停止轮播动画，离开后开始动画" class="headerlink" title="鼠标悬停停止轮播动画，离开后开始动画"></a>鼠标悬停停止轮播动画，离开后开始动画</h2><p>监听mouseover和mouseout事件来达到目的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wrap.addEventListener(<span class="string">'mouseover'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  stopFlag = <span class="number">1</span>;</span><br><span class="line">  clearTimeout(maq.timer);</span><br><span class="line">&#125;);</span><br><span class="line">wrap.addEventListener(<span class="string">'mouseout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  stopFlag = <span class="number">0</span>;</span><br><span class="line">  startInterval();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="左右切换图片"><a href="#左右切换图片" class="headerlink" title="左右切换图片"></a>左右切换图片</h2><p>通过点击左右箭头按钮实现图片之间的滚动切换：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prevBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    maq.changePhoto(<span class="number">600</span>); <span class="comment">// 向左滑</span></span><br><span class="line">&#125;);</span><br><span class="line">nextBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  maq.changePhoto(<span class="number">-600</span>);  <span class="comment">// 向右滑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="点击小圆点跳转到对应图片"><a href="#点击小圆点跳转到对应图片" class="headerlink" title="点击小圆点跳转到对应图片"></a>点击小圆点跳转到对应图片</h2><p>这里我用了事件代理，不用在每个小圆点上绑定click事件，提高dom性能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btns.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="built_in">parseInt</span>(event.target.innerText);</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    maq.gotoPhoto(count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="离开当前页面动画停止"><a href="#离开当前页面动画停止" class="headerlink" title="离开当前页面动画停止"></a>离开当前页面动画停止</h2><p>这里我开始没有想到，后来是当我每次切换到别的页面后再回到当前页面，发现动画效果出现问题了。经过一番debug才发现是因为chrome浏览器设置了离开当前页面后setInterval继续执行，如果setInterval的间隔时间小于100ms，则按100ms来执行，于是回来时动画的时间就发生错误了。</p><p>所以我们需要设置离开页面时动画停止，这样也节省了不少性能。这里利用的是<code>onvisibilitychange</code>事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 离开当前页面后动画停止</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    stopFlag = <span class="number">1</span>;</span><br><span class="line">    clearTimeout(maq.timer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stopFlag = <span class="number">0</span>;</span><br><span class="line">    startInterval();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里可以直接调用<code>document.hidden</code>API判断当前页面是否被隐藏，如果document.hidden为true则代表已经切换到别的页面，于是设置<code>stopFlag</code>为1，使动画停止。也可以用<code>document.visibilityState</code>,如果不为’visible’，则代表离开了当前页面。</p><p>这里其实可以不用setTimeout、setInterval来实现动画，而是用<code>requestAnimationFrame</code>，后者的优点是自动以浏览器支持的最小刷新间隔来实现重绘，使性能得到最大化提升，而且实现了离开页面重绘停止，大大节省性能。这里我就没有实现了，要想了解requestAnimationFrame，可参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">资料</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述方法，最后实现了一个比较完善的轮播图，全部的动画效果都是用JS来实现的。其实要想实现自动轮播，也可以用CSS3的animation来实现，而且实现起来更快，这里我就不阐述了。</p><p>最后贴出实现的<a href="https://codepen.io/flyrk/full/brxQBm/">demo</a>。</p>]]></content>
      
      
      <categories>
          
          <category> JS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> setTimeout </tag>
            
            <tag> setInterval </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生JS实现回到顶部的效果</title>
      <link href="/2017/08/22/scroll-to-top-btn/"/>
      <url>/2017/08/22/scroll-to-top-btn/</url>
      
        <content type="html"><![CDATA[<p>我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？<br><a id="more"></a></p><h1 id="JS实现滚动"><a href="#JS实现滚动" class="headerlink" title="JS实现滚动"></a>JS实现滚动</h1><p>其实很简单，利用下列函数就可以实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * func: 实现页面滚动到顶部的效果，</span></span><br><span class="line"><span class="comment"> * 离顶部越近滚动速度越慢</span></span><br><span class="line"><span class="comment"> * @acceleration: 滑动的加速度</span></span><br><span class="line"><span class="comment"> * @time: 延迟时间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goTop</span>(<span class="params">acceleration, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xScroll = <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="built_in">window</span>.scrollLeft || <span class="number">0</span>,   <span class="comment">// 获取水平滚动坐标</span></span><br><span class="line">      yScroll = <span class="built_in">document</span>.documentElement.scrollTop ||<span class="built_in">document</span>.body.scrollTop || <span class="built_in">window</span>.scrollTop || <span class="number">0</span>,  <span class="comment">// 获取垂直滚动坐标</span></span><br><span class="line">      speed = <span class="number">1</span> + acceleration; <span class="comment">// 滚动速度</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="built_in">Math</span>.floor(xScroll / speed), <span class="built_in">Math</span>.floor(yScroll / speed)); <span class="comment">// 屏幕滚动到某个坐标，因为speed大于1，所以x、y轴的坐标越来越小</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (xScroll &gt; <span class="number">0</span> || yScroll &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果没有滚动到顶部就设置延迟time后继续滚动</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          goTop(acceleration, time);</span><br><span class="line">      &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <em>返回顶部</em> 的按钮上绑定<code>onClick=&quot;goTop();&quot;</code>就可以实现返回顶部操作。</p><p>这里用到了<code>xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0;</code>，其实这三个值的效果都差不多，都代表滚动条水平移动的像素，只是浏览器兼容性可能有所不同，所以这样写兼容性更好。</p><p>然后就是<code>window.scrollTo(x, y)</code>方法。该方法使当前窗口滚动到指定的x、y像素坐标。之所以除以speed，这样就以一定的速度慢慢减小，达到缓慢的动画效果。</p><p>之后判断如果滚动条距离顶部还有一段距离的话，就继续循环调用该函数，并设置一定的延迟时间，以达到平滑滚动的动画效果。这里的<code>time</code>值要设置的比较小，超过100就显得比较不自然了。</p><h1 id="按钮的样式设置"><a href="#按钮的样式设置" class="headerlink" title="按钮的样式设置"></a>按钮的样式设置</h1><p>滚动特效实现了，但一般我们只有当页面发生滚动并且滚动到一定距离时才想要回到顶部，我们希望回到顶部的按钮在一定情况下才出现，于是我们需要设置按钮何时出现。通过在<code>scroll</code>事件上绑定函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'scroll2Top-btn'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123; <span class="comment">// 这里用了ES6语法</span></span><br><span class="line">    <span class="keyword">let</span> contentTop = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">window</span>.innerHeight, <span class="comment">// 获取当前可视窗口的高度</span></span><br><span class="line">      scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;  <span class="comment">// 获取垂直滚动条距离页面顶部的距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (contentTop &lt; scrollTop) &#123; <span class="comment">// 如果可视窗口的高度小于垂直滚动的距离，说明已经向下滚动超过一个可视窗口的距离，也就是说看不到顶部了，于是就设置按钮可见</span></span><br><span class="line">      scrollBtn.style.display = <span class="string">"block"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      scrollBtn.style.display = <span class="string">"none"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><hr><p>通过这两个简单的函数，实现了回到顶部的滚动效果，全部用原生JS编写，简单又实用。</p>]]></content>
      
      
      <categories>
          
          <category> JS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scroll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Atom转战VSCode</title>
      <link href="/2017/08/20/changing-IDE-to-VSCODE/"/>
      <url>/2017/08/20/changing-IDE-to-VSCODE/</url>
      
        <content type="html"><![CDATA[<p>最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。<br><a id="more"></a></p><p>刚开始用Atom感觉的确很清爽，各种插件用得飞起。然后随着插件的增多，和项目大小的提升，感觉Atom越来越卡，打开一个文件也要很久，那种流畅感没有了。于是有了换编辑器的想法。毕竟“工欲善其事，必先利其器”，写代码还是想要一个用起来顺手的编辑器，写的时候心情都会舒畅点（可能这是个人癖好。。。真正重要的当然还是代码本身）。</p><p>正好最近半年来VSCode越来越火，许多人都开始用它，群里一些大佬也在用VSCode，于是我就下了一个瞧瞧。</p><p>说实话，打开速度比Atom快的真不是一点半点，即使装了一些插件后打开速度也还是很快。而且VSCode由于逐渐发展起来，插件也越来越丰富，一点也不输给Sublime和Atom，常用的插件应有尽有。</p><p>用了VSCode后最大感受就是写代码变得舒服了。VSCode的代码高亮和Git操作真的很赞！鼠标悬停在某个函数或者属性上时还会有相应的说明，Git的操作也比Atom更可视化，一目了然。</p><p>总之，转战VSCode后并没有什么不适应，反而更加得心应手。当然不是说Atom不好了，一切都只是个人习惯问题罢了。但不得不说，VSCode绝对是编程利器。</p><p>最后，推荐一些常用的插件：</p><ul><li>Beautify</li><li>ESLint</li><li>One Dark Pro</li><li>vscode-icons</li><li>IntelliSense for CSS</li><li>Git Lens</li><li>ES7 React/Redux/React-Native/JS snippets</li><li>Path Intellisense</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS如何设置Cookies</title>
      <link href="/2017/08/12/how-to-set-cookie-in-js/"/>
      <url>/2017/08/12/how-to-set-cookie-in-js/</url>
      
        <content type="html"><![CDATA[<p>Cookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。<br><a id="more"></a></p><h1 id="调用浏览器的CookiesAPI"><a href="#调用浏览器的CookiesAPI" class="headerlink" title="调用浏览器的CookiesAPI"></a>调用浏览器的CookiesAPI</h1><p>为了使用浏览器的CookieAPI，我们首先要在<a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json">manifest.json</a>里设置Cookie<code>permission</code>，还要设置<code>host-permission</code>确定能获取Cookie的网址。</p><p>接下来就是调用CookieAPI方法。</p><h2 id="Cookie-set"><a href="#Cookie-set" class="headerlink" title="Cookie.set"></a>Cookie.set</h2><p>使用<code>set()</code>方法添加新的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setting = browser.cookies.set(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>是一个对象，其中有可选的几个参数：</p><ul><li><code>url</code>: 请求Cookie的url</li><li><code>name</code>: Cookie的名字</li><li><code>value</code>: Cookie的值</li><li><code>domin</code>: Cookie的作用域名</li><li><code>path</code>: Cookie的路径</li><li><code>secure</code>: Cookie是否安全（true／false）</li><li><code>httpOnly</code>: Cookie是否只能在http上（true／false）</li><li><code>expirationDate</code>: Cookie的截止时间，如果没有设置，则Cookie变为Session Cookie</li><li><code>storeId</code>: 代表Cookie的存储ID</li></ul><h2 id="Cookie-get"><a href="#Cookie-get" class="headerlink" title="Cookie.get"></a>Cookie.get</h2><p>使用<code>get()</code>方法获取已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getting = browser.cookies.get(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p><h2 id="Cookie-getAll"><a href="#Cookie-getAll" class="headerlink" title="Cookie.getAll"></a>Cookie.getAll</h2><p>使用<code>getAll()</code>方法获取Cookie集合中所有匹配details的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getting = browser.cookies.getAll(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>session</code>、<code>storeId</code>。其中<code>session</code>是bool值，代表是否要从cookies中过滤掉session cookie。</p><h2 id="Cookie-remove"><a href="#Cookie-remove" class="headerlink" title="Cookie.remove"></a>Cookie.remove</h2><p>使用<code>remove()</code>方法移除已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removing = browser.cookies.remove(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p><h2 id="Cookie-getAllCookieStores"><a href="#Cookie-getAllCookieStores" class="headerlink" title="Cookie.getAllCookieStores"></a>Cookie.getAllCookieStores</h2><p>使用<code>getAllCookieStores()</code>方法获取所有的Cookie集合，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gettingStores = browser.cookies.getAllCookieStores();</span><br></pre></td></tr></table></figure></p><p>返回的<code>Promise</code>对象中包含的数据是包括所有cookiestore对象的数组。举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logStores</span>(<span class="params">cookieStores</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(store <span class="keyword">of</span> cookieStores) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Cookie store: <span class="subst">$&#123;store.id&#125;</span>\n Tab IDs: <span class="subst">$&#123;store.tabIds&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getting = browser.cookies.getAllCookieStores();</span><br><span class="line">getting.then(logStores);</span><br></pre></td></tr></table></figure></p><h2 id="Cookie-onChanged事件"><a href="#Cookie-onChanged事件" class="headerlink" title="Cookie.onChanged事件"></a>Cookie.onChanged事件</h2><p>当Cookie改变时，我们可以为它设置onChanged事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser.cookies.onChanged.addListener(callback)</span><br><span class="line">browser.cookies.onChanged.removeListener(listener)</span><br><span class="line">browser.cookies.onChanged.hasListener(listener)</span><br></pre></td></tr></table></figure></p><p>其中 <code>addListener</code>接受一个callback，callback有一个参数<code>changeInfo</code>，<code>changeInfo</code>有三个属性：</p><ul><li>removed：bool值，代表cookie是否移除</li><li>cookie：包含添加或移除信息的cookie对象</li><li>cause：Cookie改变的原因</li></ul><hr><h1 id="使用document-cookie"><a href="#使用document-cookie" class="headerlink" title="使用document.cookie"></a>使用document.cookie</h1><p>Cookie的结构很简单，就是键-值对，一般是以<code>key-value;expiration_date;path;domain;</code>的顺序。</p><p>最简单的设置当前页面Cookie的方法就是直接给<code>document.cookie</code>赋值，例如：<code>document.cookie = &quot;username=Simon, 12 Aug 2017 19:36:00 GMT; expires=Wed, 31 Oct 2017 11:00:00 GMT;&quot;;</code>，这样就设置了Cookie。但每次都这样设置很麻烦，我们可以用函数封装赋值方法。这里借鉴了网上的一些方法：</p><h2 id="setCookie"><a href="#setCookie" class="headerlink" title="setCookie()"></a>setCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cookie = name + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value) + <span class="string">";"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expires) &#123;</span><br><span class="line">    <span class="comment">// If it's a date</span></span><br><span class="line">    <span class="keyword">if</span>(expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">      <span class="comment">// If it isn't a valid date</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isNaN</span>(expires.getTime()))</span><br><span class="line">       expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="built_in">parseInt</span>(expires) * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cookie += <span class="string">"expires="</span> + expires.toGMTString() + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    cookie += <span class="string">"path="</span> + path + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">    cookie += <span class="string">"domain="</span> + domain + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>expires</code>可以是<code>Date</code>对象，也可以是代表天数的数字。</p><p>要创建新的Cookie，可以这样：<code>setCookie(&quot;website&quot;, &quot;xmflyrk.com&quot;, new Date(new Date().getTime() + 10000));</code> 或者 <code>setCookie(&quot;author&quot;, &quot;flyrk&quot;, 30);</code></p><h2 id="getCookie"><a href="#getCookie" class="headerlink" title="getCookie()"></a>getCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cok = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>),</span><br><span class="line">        length = cok.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> pairs = cok[i].trim();</span><br><span class="line">    <span class="keyword">if</span> (~pairs.indexOf(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> pairs.substring(pairs.indexOf(name) + name.length + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getCookie()</code>的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getCookie(<span class="string">'author'</span>); <span class="comment">// "flyrk"</span></span><br><span class="line">getCookie(<span class="string">'Something'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><h2 id="removeCookie"><a href="#removeCookie" class="headerlink" title="removeCookie()"></a>removeCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">name, path, domin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getCookie(name)) &#123;</span><br><span class="line">    setCookie(name, <span class="string">""</span>, <span class="number">-1</span>, path, domin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除某个Cookie我们就可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">removeCookie(<span class="string">"author"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(getCookie(<span class="string">"author"</span>)); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了这些API和自己封装的函数，我们就能对Cookie进行操作，方便地设置Cookie数据。</p><blockquote><p>参考资料：<br><a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies">cookies</a><br><a href="https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/">How to deal with cookie</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookies </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中&quot;类&quot;的构造与继承</title>
      <link href="/2017/08/10/javascript-class-constructor/"/>
      <url>/2017/08/10/javascript-class-constructor/</url>
      
        <content type="html"><![CDATA[<p>有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>undefined</code>、<code>Symbol</code>。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。<br><a id="more"></a></p><p>我们知道，JS里没有类似于C++、Java一样的<code>class</code>类，于是也就没有私有、公有之说。但这并不代表我们不能模拟一个类，因为类的思想在面向对象编程里是很重要的一点，对于对象的继承与方法的引用和代码的重构等等都有极大好处。所以很多人就在JS里模拟类的用法，ES6甚至官方定义了一个<code>class</code>语法，但这也不是真正的类，只是<code>class</code>的语法糖。</p><p>说了这么多，JS里到底怎么实现类呢？利用函数的特性：所有的函数默认都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，也就是原型。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>什么是构造函数？我们知道<code>function</code>也是对象的一种，而当我们想要声明一个构造函数，可以使用下列形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConstructor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Simon'</span>;</span><br><span class="line">  <span class="keyword">var</span> car = <span class="string">'BMW'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(car);</span><br><span class="line">  &#125;</span><br><span class="line">  getCar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> myConstructor();</span><br></pre></td></tr></table></figure></p><p>使用上述方法我们就声明了一个构造函数<code>myConstructor</code>，但其实构造函数也是普通的对象，它和java里类的构造函数完全不一样。当我们使用<code>new</code>创建一个对象，实际上是把myObj的[[Prototype]]链接关联到myConstructor.prototype指向的对象。</p><p>我们知道，真正的面向类的语言中，类可以被复制或者实例化很多次，每创建一个实例相当于把类的方法属性复制到新实例中。但javascript没有类似的复制机制，要想让新对象与构造的“类”对象有关系，就必须把两个对象的prototype关联起来。</p><p>实际上并不存在所谓的“构造函数”，我们只是对函数的“构造调用”。</p><p>当使用new来进行构造函数调用时，会执行以下四个步骤：</p><ol><li>创建一个全新的对象</li><li>新对象会执行[[Prototype]]链接到constructor对象的prototype</li><li>新对象会绑定到函数调用的this</li><li>如果构造函数没有返回其他对象，那么new的函数调用会返回这个新对象</li></ol><p>这样一来，我们就把新对象与构造函数对象关联起来了。所以说函数不是构造函数，只是当且仅当使用new时，函数调用会变成“构造函数调用”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">a.constructor === Foo; <span class="comment">// true</span></span><br><span class="line">Foo.prototype.constructor === Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>当我们创建了Foo函数，Foo.prototype默认有一个公有且不可枚举的属性constructor，这个属性引用的是对象关联的函数（也就是Foo）。而调用a.constructor，实际上只是通过[[Prototype]]委托给了Foo.prototype，所以指向了Foo。</p><p>如果我们创建了新的原型对象，那么新对象并不会自动获得constructor属性，比如说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123; <span class="comment">/*....*/</span> &#125;; <span class="comment">// 创建了新的原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo; <span class="comment">// false</span></span><br><span class="line">a.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但问题来了，运行以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myObj.name; <span class="comment">// "Simon"</span></span><br><span class="line">myObj.car; <span class="comment">// undefined</span></span><br><span class="line">myObj.getCar(); <span class="comment">// Uncaught TypeError: myObj.getCar is not a function</span></span><br></pre></td></tr></table></figure></p><p>为什么会这样呢？原因就是构造函数有作用域。<code>this.name = &#39;Simon&#39;</code>相当于给构造函数这个对象的<code>name</code>属性赋值<code>&quot;Simon&quot;</code>，这里的<code>this</code>指代构造函数对象原型。而在构造函数里使用<code>var</code>、<code>function</code>创建的变量和函数都相当于 <em>局部变量</em>，也就是“私有方法”，因为作用域的问题，这些变量和属性在构造函数之外是不能访问的，“私有方法”中的函数可以访问其他的私有变量，构造函数的实例却不能访问这些方法。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>那么，如果我们想要实例能继承构造函数的属性或者方法怎么办呢？JS使用的机制为 <em>原型继承</em>，请看以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myConstructor.prototype.car = <span class="string">"Farrari"</span>;</span><br><span class="line">myConstructor.prototype.getCar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.car);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.car; <span class="comment">// "Farrari"</span></span><br><span class="line">myObj.getCar(); <span class="comment">// "Farrari"</span></span><br></pre></td></tr></table></figure></p><p>一旦我们在构造函数的原型上添加了属性car，当新对象myObj调用car属性时，它本身没有这个属性，于是就通过委托，在原型链上找，最后在myConsrtuctor.prototype上找到。</p><p>但使用原型继承来实现子类继承父类更好的方法是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo,prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name, type</span>) </span>&#123;</span><br><span class="line">  Foo.call(<span class="keyword">this</span>, name); <span class="comment">// 相当于ES6的super(name);</span></span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype); <span class="comment">// 相当于ES6的extends</span></span><br><span class="line">Bar.prototype.constructor = Bar; <span class="comment">// 这里需要修复consructor</span></span><br><span class="line"></span><br><span class="line">Bar.prototype.getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.type);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>, <span class="string">'obj a'</span>);</span><br><span class="line">a.getName(); <span class="comment">// 'a'</span></span><br><span class="line">a.getType(); <span class="comment">// 'obj a'</span></span><br></pre></td></tr></table></figure></p><p>这里用到的核心语句就是<code>Bar.prototype = Object.create(Foo.prototype);</code>，调用Object.create(obj)会凭空创建一个新对象并把新对象的[[Prototype]]关联到obj上。</p><p>我们来看看Object.create()的polyfill:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">proto, propsObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(proto === <span class="literal">null</span> || <span class="keyword">typeof</span> proto === <span class="string">'object'</span> || <span class="keyword">typeof</span> proto === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Arguments must be object, or Null'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    temp.__proto__ = proto;</span><br><span class="line">    <span class="keyword">if</span> (propsObj) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(temp, propsObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有的人可能会说，为什么不能直接<code>Bar.prototype = Foo.prototype;</code>呢？这样并不会创建一个关联到Foo.prototype的新对象，只是让Bar.prototype引用Foo.prototype对象，我们执行<code>Bar.prototype.getType = ....</code>也会在Foo.prototype上修改，跟预料的结果不一样。那这样根本不需要Bar，还不如直接在Foo上修改就好了。</p><p>而之前介绍的<code>Bar.prototype = new Foo()</code>虽然也能实现原型继承，但它会有一些副作用。比如Foo如果有（写日志、修改状态、注册到其他对象、给this添加属性等等）的行为，就会影响到Bar的子类，造成无法预料的结果。</p><p>所以，要创建一个关联的“子类”对象，我们必须使用Object.create()，但这样有一个缺点是要创建一个新对象而把旧对象抛弃。</p><p>好在ES6添加了<code>Object.setPrototypeOf(...)</code>方法，可以修改关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype); <span class="comment">// ES6之前需要抛弃默认对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype, Foo.prototype); <span class="comment">// ES6可以直接修改Bar.prototype对象</span></span><br></pre></td></tr></table></figure></p><h1 id="检查“类”的关系"><a href="#检查“类”的关系" class="headerlink" title="检查“类”的关系"></a>检查“类”的关系</h1><p>考虑以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.blah = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p>我们如果想要判断a的原型是否与Foo关联起来了，我们可以有以下几种方法：</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但这样有个缺点是只能处理对象和函数之间的关系。如果我们想判断两个对象之间是否通过[[Prototype]]关联。可以用下列方法：</p><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.isPrototypeOf(a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要判断两个对象之间的关系，更直接：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.isPrototypeOf(c); <span class="comment">// 判断b是否出现在c的原型链中</span></span><br></pre></td></tr></table></figure></p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>我们可以直接用非标准的<code>__proto__</code>属性，<code>__proto__</code>实际上存在于内置的Object.prototype中，且不可枚举。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要想创建类似于“类”的对象，可以使用构造函数调用，给构造函数添加公有方法，在构造函数的<code>prototype</code>上添加属性。新对象想要继承构造函数，使用Javascript的原型继承机制。</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object </tag>
            
            <tag> 原型与继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这些天的感想</title>
      <link href="/2017/08/09/thought-of-today/"/>
      <url>/2017/08/09/thought-of-today/</url>
      
        <content type="html"><![CDATA[<p>最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。<br><a id="more"></a></p><p>暑假以来，一直在找实习，然而很多公司基本人都招满了，而投的几个也了无音讯，说实话，我感受到了强烈的失落感。<br>我到底适不适合做前端？为什么没有公司要我呢？我应该怎么做？我应该坚持下去吗？</p><p>每天我都陷入深深地自省中，我学前端真的对吗？我是真心想做前端开发吗？</p><p>经过这段时间的思考，我还是决定了，继续走下去。既然选择了前端这条路，就不该放弃，即使没有公司实习，没关系，自己在家自学，写项目，看书，反正不让自己闲着。前端基础不好，补！静下心来看书、静下心来写代码！边学边准备校招。</p><p>我知道，自己严格来说前端只学了不到一年的时间，比不上别人已经学了好几年，进工作室、公司实习过的大佬，但我相信，现在仍然为时不晚。我只不过是比别人起步晚，那就比别人花的时间长呗！我以前都只是听说勤能补拙，这次，我要自己实践下去。</p><p>为什么选择前端？</p><p>一开始是在知乎看到前端的介绍，那个时候第一次听到前端这个名词，之前完全不知道它是干什么的。后来慢慢去了解，发现前端看似很简单，用HTML、CSS、JavaScript稍加组合就能写出一个网页，不像后台开发那么没头绪、可视化不强，前端是即写即见的。后来一步步去W3SCHOOL上跟着教程走，上网找各种资料，图书馆借书看，发现前端并没有想象中的那么简单，要学的东西多而杂，光学好HTML、CSS还不行，还得会响应式开发，会用<code>Sass</code>、<code>Less</code>预处理，会<code>CSS3</code>动画…光会原生JS也不行，写项目时效率太低，得学会使用各种库，比如伟大的<code>JQuery</code>、<code>underscore</code>等等，后来发现还得了解工程化，因为前端的逻辑越来越复杂，所包含的内容越来越多，需要框架的帮助和自动化工具来提高开发效率，比如三大框架：<code>React</code>、<code>Vue</code>、<code>Angular</code>，还有打包工具<code>Webpack</code>、<code>gulp</code>、<code>grunt</code>等等。这里面每一个知识都值得去深挖，去研究。这还不够，你不能光会前端写页面，你还得会移动端开发，随着页面的复杂度提高，资源的增多，你还得会性能优化，缓存处理，HTTP协议相关。因为前端既要和用户进行交互，还要与后端进行交接，所以服务器方面的知识也得略知一二，比如<code>NodeJS</code>。</p><p>当我刚了解这些我发现我头都大了一圈，前端要学的东西太多了吧！不光这样，每天关注技术博客、新闻、知乎等论坛时还会发现层出不穷的新名词，都是别人新写的库，宣传得多么多么厉害。让我这个前端小白看得眼花缭乱，不知道该不该去学。</p><p>三四月份的时候真是我陷入迷茫期的时候，感觉自己什么都想学，但又觉得学不过来，不知道先学哪一个。经历了春招实习生的挫败后，我终于发现了，我学的太浮躁了。</p><p>因为急于想要找到实习，希望学点新东西，新框架来显示自己的能力，但却忽略了最重要的一点：基础。基础不牢，学什么都白谈。基础没学好，去学那些花里胡哨的库却不能理解其中的源码、思想，只是机械地使用工具来码代码，那和最基本的劳动力有什么区别？别人凭什么招你呢？你的活完全可以找别人来替代，为什么要选你呢？</p><p>于是，我开始重新翻阅书籍，静下心来去看，看到有意思的地方、值得记忆的地方就写下来，以后随时翻阅。但同时光看书也不行，实践能力差别人一大截，于是我又使用React+Node写了一个<a href="https://github.com/flyrk/myblog">博客系统</a>，每天持续完善中。就这样，暑假过去了一个月。</p><p>这一个月来，我虽然没有找到实习，但我找到了自己的学习方向。我知道我要先打好基础，同时动手能力也不能落下。</p><p>我不知道即将到来的秋招会是怎样，但我唯有坚持下去，坚守自己的初心，不让自己后悔。</p><hr><p>说了这么多关于前端的思考和自己的打算，再说说前端之外的吧。最近身体不好，去医院做了检查，索性无大碍。但是今天又有点感冒头晕，让我很是烦躁。不管怎样，身体一定要养好，有了好身体才有好力气干活。</p><p>虽说自己没有出去找事做，但每天学习学习，码码代码，也还是过的挺充实的。加油吧，少年！</p>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取浏览器窗口大小</title>
      <link href="/2017/08/08/get-browser-size/"/>
      <url>/2017/08/08/get-browser-size/</url>
      
        <content type="html"><![CDATA[<p>我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？</p><p>先来看这样一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBrowserSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> de = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">'width'</span>: (</span><br><span class="line">      <span class="built_in">window</span>.innerWidth</span><br><span class="line">      || de &amp;&amp; de.clientWidth</span><br><span class="line">      || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'height'</span>: (</span><br><span class="line">      <span class="built_in">window</span>.innerHeight</span><br><span class="line">      || de &amp;&amp; de.clientHeight</span><br><span class="line">      || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。<br><a id="more"></a></p><ul><li><code>documentElement</code>:<code>document.documentElement</code>获取的是页面中的<code>&lt;html&gt;</code>元素，也就相当于整个页面。</li><li><code>innerWidth&amp;&amp;innerHeight</code>: innerWidth获取的是可视区域的宽度，但包括垂直滚动条；innerHeight则只包括可视区域高度，不包括功能框之类的。相比较之下，outerWidth和outerHeight则包含整个窗口的高度，包括功能框、滚动条之类的。</li><li><code>document.body</code>:获取页面中body元素。</li><li><code>Element.clientWidth</code>:获取元素的可视宽度（高度），它包括<code>padding</code>但不包括滚动条、<code>border</code>和<code>margin</code>。</li></ul><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>话不多说，直接上图：<br><img src="http://ou5mz529o.bkt.clouddn.com/browser-size-test.png" alt="browser-size-test"></p><p>我们可以得出结论：</p><ul><li><code>window.innerWidth</code>和<code>window.outerWidth</code>基本是一样的，因为innerWidth也包括了滚动条，但如果侧面有功能栏的话，innerWidth就会比outerWidth小；<code>window.innerHeight</code>和<code>window.outerHeight</code>差别较大，因为下面有调试栏。</li><li><code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>获取的就是页面的可视窗口宽高，不包括滚动条和功能栏之类的。</li><li><code>document.body.clientWidth</code>和<code>document.body.clientHeight</code>获取的是<code>body</code>元素的宽高，不包括滚动条，但因为<code>body</code>的内容高度有639px，所以比<code>document.documentElement.clientHeight</code>要高。</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><code>document.documentElement</code>几乎每个浏览器都兼容；<code>window.outerWidth</code>和<code>window.innerWidth</code>IE8及以下都不支持；<code>document.body</code>和<code>clientWidth</code>IE6之前不支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>获取浏览器当前窗口大小，一般用<code>window.innerWidth</code>和<code>window.innerHeight</code>就好了，但如果不兼容，则次之用<code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>，再不行就只能用<code>document.body</code>获取了。</p><p>前面提到的<code>getBrowserSize()</code>方法就是使用了这种理念。</p><blockquote><p>参考资料:<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement">documentElement</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth">innerWidth</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/outerWidth">outerWidth</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/body">document.body</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth">clientWidth</a><br>《JavaScriptDOM高级程序设计》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clientWidth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解JavaScript对象</title>
      <link href="/2017/08/05/javascript-object/"/>
      <url>/2017/08/05/javascript-object/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。</p><a id="more"></a><h1 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h1><h2 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h2><p>对于 可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象来说，有一种巧妙的复制方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( someObj ));</span><br></pre></td></tr></table></figure></p><p>这种方法的好处是实现了 <strong>深复制</strong>，但必须要求原对象可以被解析成JSON字符串。</p><h2 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a><code>Object.assign()</code>方法</h2><p>ES6定义了<code>Object.assign()</code>方法实现 <strong>浅复制</strong>。该方法第一个参数是目标对象，之后可以跟若干个源对象。它会遍历源对象的所有可枚举的自有键并把它们复制到目标对象，比如说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  a: <span class="number">12</span></span><br><span class="line">  b: anotherObj,</span><br><span class="line">  c: anotherArray,</span><br><span class="line">  d: anotherFunction</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject);</span><br><span class="line">newObj.a; <span class="comment">// 12</span></span><br><span class="line">newObj.b === anotherObj; <span class="comment">// true</span></span><br><span class="line">newObj.c === anotherArray; <span class="comment">// true</span></span><br><span class="line">newObj.d === anotherFunction; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但要注意的是，浅复制只是简单的使用<code>=</code>操作符赋值，对于引用类型值来说，指向的是同一个对象。也就是说，<code>newObj.b === myObject.b</code>。</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>ES5开始，所有的属性都有属性描述符。通过<code>Object.getOwnPropertyDesciptor(obj, prop)</code>可以获取对象的某个属性的属性描述符。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObj, <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//Object &#123;</span></span><br><span class="line"><span class="comment">//  value: 12,</span></span><br><span class="line"><span class="comment">//  writable: true,</span></span><br><span class="line"><span class="comment">//  enumerable: true,</span></span><br><span class="line"><span class="comment">//  configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></p><p>一般默认值<code>writable</code>、<code>enumerable</code>、<code>configurable</code>都为<code>true</code>，我们也可以用<code>Object.defineProperty()</code>来添加一个新属性或者修改一个已有属性（如果它是<code>configurable</code>）。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><h2 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们修改<code>writable</code>为false，则该属性不可写了。</p><h2 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可配置</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a = <span class="number">5</span>;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">delete</span> myObject.a;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>一旦我们修改<code>configurable</code>为false，就无法撤销，并且不能重新配置属性，也无法删除该属性。</p><h2 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h2><p>这个属性描述符代表属性是否会出现在对象的属性枚举中，比如<code>for ..in</code>循环。如果设置<code>enumerable: false</code>，则该属性不会出现在枚举中。</p><h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>JavaScript不像其他语言，它是动态的，也就是可变的。但如果我们想属性或者对象是不可改变的，该怎么实现呢？</p><h2 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h2><p>结合<code>writable: false</code>和<code>configurable: false</code>可以创建一个常量属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"CONST_VARIABLE"</span>, &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h2><p>如果想保留对象已有的属性并禁止向对象添加新的属性，则可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions( myObject );</span><br><span class="line"></span><br><span class="line">myObject.b = <span class="number">13</span>;</span><br><span class="line">myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h2 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h2><p>使用<code>Object.seal(...)</code>会创建一个“密封”对象，相当于在对象上调用<code>Object.preventExtensions()</code>并且设置所有属性为<code>configurable: false</code>。</p><p>所以，密封之后的对象只能修改已有属性的值，而不能添加新属性，也不能重新配置或删除已有属性。</p><h2 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h2><p>使用<code>Object.freeze(...)</code>会创建一个冻结对象，相当于在对象上调用<code>Object.seal()</code>并且设置所有属性为<code>writable: false</code>。</p><p>这个方法完全使对象不可变，会禁止对于对象本身及其任意直接属性的修改。</p><blockquote><p>需要注意的是，之前所有的方法创建的都是浅不可变，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的。</p></blockquote><h1 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h1><p>当访问某个对象属性时，实际上实现了<code>[[Get]]</code>操作，对象默认的内置<code>[[Get]]</code>操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，则会遍历原型链，如果还是没找到，则返回<code>undefined</code>。</p><p>当设置某个对象属性的值，则有<code>[[Put]]</code>操作。<code>[[Put]]</code>会检查以下内容：</p><ol><li>属性是否存在setter，存在则调用setter</li><li>属性的<code>writable</code>是否是<code>false</code>，是的话则赋值失败</li><li>如果都不是，则对属性进行赋值</li></ol><p>我们可以给对象一个属性定义getter、setter，当访问或赋值对象的属性时，会忽略属性的<code>value</code>和<code>writable</code>特性，而关注<code>get</code>和<code>set</code>特性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  get a() &#123; <span class="comment">// 给属性a定义一个getter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span>; &#125;, <span class="comment">// 给属性b设置一个getter</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 11</span></span><br><span class="line">myObject.b; <span class="comment">// 22</span></span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 11</span></span><br></pre></td></tr></table></figure></p><p>当访问属性时会自动调用<code>get</code>函数，其返回值会被当作属性访问的返回值；注意的是，由于我们没有设置<code>set</code>，所以赋值操作被忽略了。而由于我们定义的<code>get</code>始终返回2，即使设置了<code>set</code>也没有意义。</p><p>我们可以这样设置<code>getter</code>和<code>setter</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  get a() &#123; <span class="comment">// 给属性a定义一个getter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a;</span><br><span class="line">  &#125;,</span><br><span class="line">  set a(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._a = val * <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span>;</span><br><span class="line">myObject.a; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><h1 id="属性的存在性"><a href="#属性的存在性" class="headerlink" title="属性的存在性"></a>属性的存在性</h1><p>当我们访问<code>object.a</code>返回的是<code>undefined</code>，可能是属性中本来存储的就是<code>undefined</code>，也可能是属性不存在，那么怎么判断属性是否存在呢？</p><p>我们可以用<code>in</code>或者<code>Object.hasOwnProperty()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">(<span class="string">"a"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"a"</span>); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"b"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>这里要注意的是，<code>in</code>会检查属性是否在对象及其原型链中，而<code>hasOwnProperty</code>只会检查属性是否在对象中，不会检查原型链。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>要检查某个属性是否可枚举，通常有两种方法：<br>第一种方法，使用<code>for...in</code>循环：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObject.b; <span class="comment">// 2</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"b"</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> myObject) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;k&#125;</span>:<span class="subst">$&#123;myObject[k]&#125;</span>`</span>); <span class="comment">// a:1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObject.propertyIsEnumerable(<span class="string">"a"</span>); <span class="comment">// true</span></span><br><span class="line">myObject.propertyIsEnumerable(<span class="string">"b"</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(myObject); <span class="comment">// ["a"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(myObject); <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure></p><p><code>propertyIsEnumerable()</code>可以判断给定的属性名是否直接存在于对象中且<code>enumerable: true</code>；<code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code>会返回一个数组，包含所有属性，无论它们是否可枚举。</p><p>要注意的是，<code>Object.keys(..)</code>和<code>hasOwnProperty()</code>和<code>Object.getOwnPropertyNames(..)</code>不会查找原型链，而<code>in</code>和<code>for...in</code>会查找原型链。</p><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>对于数组来说，最常用的遍历就是<code>for</code>循环。然而javascript内置了一些数组的迭代器，包括<code>forEach(..)</code>、<code>every(..)</code>、<code>some(..)</code>、<code>map(..)</code>。它们都接受一个回调函数并把它应用到每个元素上，区别就是它们对回调函数返回值的处理方式不同。</p><p><code>forEach(..)</code>遍历所有元素并忽略返回值；<code>every(..)</code>会一直运行直到返回值为<code>false</code>；<code>some(..)</code>会一直运行直到返回值为<code>true</code>；<code>map(..)</code>遍历所有元素并且用返回值代替当前元素。</p><p>ES6还新增了遍历数组的<code>for...of</code>循环语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p><code>for..of</code>循环首先会向被访问对象请求一个 <strong>迭代器</strong> 对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。由于数组有内置的<code>@@iterator</code>，所以<code>for..of</code>可以直接应用在数组上，如果想让对象也使用<code>for..of</code>循环，则需要自定义<code>@@iterator</code>，这里就不多展开了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JavaScript对象是引用类型，我们可以给对象添加属性并修改属性描述符来控制属性的特征，还可以用<code>get</code>和<code>set</code>来修改属性的访问和赋值操作，对象的属性还可以枚举和遍历。</p><blockquote><p>参考资料：<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch3.md">You-Dont-Know-JS</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中如何更新state</title>
      <link href="/2017/08/04/react-setState-update/"/>
      <url>/2017/08/04/react-setState-update/</url>
      
        <content type="html"><![CDATA[<p>我们知道，React中最重要的概念就是<code>state</code>和<code>props</code>，我们在写每一个组件时，都可以为该组件创建一个<code>state</code>，用以保存当前组件的数据。那么如何去更新<code>state</code>就是一个重要的问题了。<br><a id="more"></a></p><h1 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h1><p>首先我们来看一个<code>React Component</code>初始化的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'flyrk'</span>,</span><br><span class="line">      sex: <span class="string">'male'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而当我们要更新<code>state</code>，不能直接赋值修改<code>this.state</code>，而是应该使用<code>this.setState()</code>方法。</p><p>但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新<code>state</code>，更新的<code>state</code>再进行处理，同步显示在某个<code>div</code>中。当我这样写的时候，发现视图层迟迟没有更新：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">''</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.getName().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;  <span class="comment">// 从服务器获取数据</span></span><br><span class="line">      <span class="keyword">const</span> name = res.data.name;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; name &#125;);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>后来上网查阅官方文档，才发现React的<code>setState()</code>可能是异步的。也就是说，当我们用<code>this.setState()</code>更新<code>state</code>时，<code>state</code>可能不会立即更新，React会将多个<code>setState()</code>合并在一起最后调用来提高性能，如果我们想立即使用更新后的<code>state</code>，有两种方法：</p><ul><li><p><code>setState()</code>接受函数参数，我们可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  name: prevState.name + props.name</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>这样我们就可以获取之前的<code>state</code>。</p></li><li><p>还有一种方法，<code>setState()</code>第二个参数接受一个<code>callback</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123; name &#125;, callback);</span><br></pre></td></tr></table></figure><p>在<code>callback</code>里我们可以对修改后的<code>state</code>进行操作。</p></li></ul><p>这两种方法，都可以保证操作的<code>state</code>是最新值，并且能在<code>render()</code>里展现出来。</p>]]></content>
      
      
      <categories>
          
          <category> 框架学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript类型转换</title>
      <link href="/2017/08/02/javascript-value-coercions/"/>
      <url>/2017/08/02/javascript-value-coercions/</url>
      
        <content type="html"><![CDATA[<p>JavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。<br><a id="more"></a></p><h1 id="JavaScript类型"><a href="#JavaScript类型" class="headerlink" title="JavaScript类型"></a>JavaScript类型</h1><p>在JS中，有6种基本类型和一种引用类型，分别是：</p><ul><li>基本类型：<ul><li>null</li><li>undefined</li><li>boolean</li><li>number</li><li>string</li><li>symbol(ES6新增)</li></ul></li><li>引用类型：object</li></ul><p>一般来说，我们可以用<code>typeof</code>来检测某个值的数据类型，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          === <span class="string">"boolean"</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">24</span>            === <span class="string">"number"</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"24"</span>          === <span class="string">"string"</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">age</span>: <span class="number">24</span> &#125;  === <span class="string">"object"</span>;    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// added in ES6!</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()      === <span class="string">"symbol"</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但是有一个例外: null,这也是一个bug<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">"object"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>如果想检测某个值是否是null，则可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，function和array其实也是object，但它们有所区别：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* .. */</span> &#125; === <span class="string">"function"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] === <span class="string">"object"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>如果要检测a是否是数组，可以用<code>instanceof</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">123</span>];</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="类型转换抽象操作"><a href="#类型转换抽象操作" class="headerlink" title="类型转换抽象操作"></a>类型转换抽象操作</h1><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><p>当一个非String类型的值要转换为String，我们可以用ToString操作。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>对于基本类型来说，它们有自然的转换关系。如：<code>null</code>变成<code>&quot;null&quot;</code>,<code>undefined</code>变成<code>&quot;undefined&quot;</code>,<code>true</code>变成<code>&quot;true&quot;</code>,<code>number</code>自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。</p><p>对于<code>object</code>来说，<code>toString()</code>(代表着<code>Object.prototype.toString()</code>)将会返回<code>[[class]]</code>原型，比如说<code>&quot;object Object&quot;</code>;但如果是数组，则重写了<code>toString()</code>方法，会返回一个以逗号分隔数组值的字符串。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.toString(); <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure></p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><p>另一种转换为字符串的方法就是<code>JSON.stringify</code>，对大多数基本类型，它的转换方法和<code>toString</code>是一样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify( <span class="number">42</span> );<span class="comment">// "42"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="string">"42"</span> );<span class="comment">// ""42"" (外面多加一层引号)</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">null</span> );<span class="comment">// "null"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">true</span> );<span class="comment">// "true"</span></span><br></pre></td></tr></table></figure></p><p>但不同的是，<code>JSON.stringify</code>会忽略掉<code>undefined</code>、<code>function</code>和<code>symbol</code>。请看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">undefined</span> );<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; );<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( [<span class="number">1</span>,<span class="literal">undefined</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="number">4</span>] );<span class="comment">// "[1,null,null,4]"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( &#123; <span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; );<span class="comment">// "&#123;"a":2&#125;"</span></span><br></pre></td></tr></table></figure></p><p>如果<code>JSON.stringify</code>调用了循环引用的<code>object</code>，则会抛出Error。如果<code>JSON.stringify</code>调用的对象有<code>toJSON()</code>方法，则会对<code>toJSON()</code>的返回值再进行stringify。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: <span class="number">111</span></span><br><span class="line">&#125;;</span><br><span class="line">a.toJSON = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="keyword">this</span>.b &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a ); <span class="comment">// "&#123;"b":111&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">val: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.val.slice( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify( c ); <span class="comment">// "[2,3]"</span></span><br></pre></td></tr></table></figure></p><h2 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h2><p>转换为number，我们可以用ToNumber操作。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>对于基本类型，转换规则为：<code>true -&gt; 1</code>,<code>false -&gt; 0</code>,<code>undefined -&gt; NaN</code>,<code>null -&gt; 0</code>，字符串如果包含字母则转换为<code>NaN</code>。</p><p>对于将某值转换为基本数据类型，通常会调用<code>ToPrimitive</code>操作，首先看该值有没有<code>valueof()</code>方法，如果没有则调用<code>toString()</code>方法，如果二者都没有，则抛出<code>TypeError</code>。</p><p>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"12"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"12"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">c.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.join( <span class="string">""</span> );<span class="comment">// "12"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>( a );<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>( b );<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>( c );<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>( <span class="string">""</span> );<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>( [] );<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>( [ <span class="string">"abc"</span> ] );<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><h2 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h2><p>将一个值转换为Boolean值，我们先看一个false表：</p><ul><li>undefined</li><li>null</li><li>false</li><li>+0, -0, and NaN</li><li>“”</li></ul><p>任何不在这个表上的值都为<code>true</code>。<br>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">0</span> );</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">""</span> );</span><br><span class="line"><span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class="comment">// true</span></span><br><span class="line"><span class="comment">/***************/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"false"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"''"</span>;</span><br><span class="line"><span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class="comment">// true</span></span><br><span class="line"><span class="comment">/***************/</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h1><p>之前提到过一些显式转换，但其实还有以下几种：</p><h2 id="字符串与数字的转换"><a href="#字符串与数字的转换" class="headerlink" title="字符串与数字的转换"></a>字符串与数字的转换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"3.14"</span>;</span><br><span class="line"><span class="keyword">var</span> d = +c;</span><br><span class="line"></span><br><span class="line">b; <span class="comment">// "42"</span></span><br><span class="line">d; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h2 id="日期转换为数字"><a href="#日期转换为数字" class="headerlink" title="日期转换为数字"></a>日期转换为数字</h2><p>Date转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="string">"Wed, 2 Aug 2017 08:53:06 CDT"</span> );</span><br><span class="line"></span><br><span class="line">+d; <span class="comment">// 1501681986000</span></span><br></pre></td></tr></table></figure></p><p><code>Date.now()</code>方法就是用的这种转换：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Date</span>.now) &#123;</span><br><span class="line"><span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="~操作符"></a><code>~</code>操作符</h2><p>Js里有<code>~</code>操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，<code>~x</code>相当于<code>-(x+1)</code>。</p><p>于是，<code>~</code>有一个用处就是判断<code>-1</code>，比如我们对字符串使用<code>indexOf()</code>时如果找不到则返回<code>-1</code>，我们可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">"lo"</span> );<span class="comment">// -4   &lt;-- truthy!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (~a.indexOf( <span class="string">"lo"</span> )) &#123;<span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 找到了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">"ol"</span> );<span class="comment">// 0    &lt;-- falsy!</span></span><br><span class="line">!~a.indexOf( <span class="string">"ol"</span> );<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!~a.indexOf( <span class="string">"ol"</span> )) &#123;<span class="comment">// true</span></span><br><span class="line"><span class="comment">// 没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，<code>~~</code>可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于<code>Math.ceil()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor( <span class="number">-49.6</span> );<span class="comment">// -50</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">-49.6</span>);  <span class="comment">// -49</span></span><br><span class="line">~~<span class="number">-49.6</span>;<span class="comment">// -49</span></span><br></pre></td></tr></table></figure></p><h2 id="parseInt-方法"><a href="#parseInt-方法" class="headerlink" title="parseInt()方法"></a><code>parseInt()</code>方法</h2><p>该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.000008</span> );<span class="comment">// 0   ("0" from "0.000008")</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.0000008</span> );<span class="comment">// 8   ("8" from "8e-7")</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="literal">false</span>, <span class="number">16</span> );<span class="comment">// 250 ("fa" from "false")</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="built_in">parseInt</span>, <span class="number">16</span> );<span class="comment">// 15  ("f" from "function..")</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">"0x10"</span> );<span class="comment">// 16</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">"103"</span>, <span class="number">2</span> );<span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>所以，要谨慎使用<code>parseInt</code>。</p><h2 id="转换为Boolean"><a href="#转换为Boolean" class="headerlink" title="转换为Boolean"></a>转换为Boolean</h2><p>我们已经知道<code>Boolean()</code>方法可以将值转换为<code>Boolean</code>，但还有一个更快的方法，就是使用<code>!!</code>操作符：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> g;</span><br><span class="line"></span><br><span class="line">!!a;<span class="comment">// true</span></span><br><span class="line">!!b;<span class="comment">// true</span></span><br><span class="line">!!c;<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!!d;<span class="comment">// false</span></span><br><span class="line">!!e;<span class="comment">// false</span></span><br><span class="line">!!f;<span class="comment">// false</span></span><br><span class="line">!!g;<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><h2 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h2><p>因为字符串可以用<code>+</code>连接，所以当我们把数字和字符串用<code>+</code>连接时，数字会强制转换为字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">122</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">''</span>;  </span><br><span class="line">b;  <span class="comment">// "122"</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串转换为数字"><a href="#字符串转换为数字" class="headerlink" title="字符串转换为数字"></a>字符串转换为数字</h2><p>因为<code>-</code>只在数字运算符中才有定义，所以对字符串使用<code>-</code>会被强制转换为数字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"122"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a - <span class="number">0</span>;  </span><br><span class="line">b;  <span class="comment">// 122</span></span><br></pre></td></tr></table></figure></p><h2 id="数组转换为数字"><a href="#数组转换为数字" class="headerlink" title="数组转换为数字"></a>数组转换为数字</h2><p>同样的，如果数组中只有一个值，使用<code>-</code>时，会先把数组转换为字符串，再转换为数字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>];</span><br><span class="line">a - b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><h1 id="操作符-和-amp-amp-的妙用"><a href="#操作符-和-amp-amp-的妙用" class="headerlink" title="操作符||和&amp;&amp;的妙用"></a>操作符<code>||</code>和<code>&amp;&amp;</code>的妙用</h1><p>我们都知道<code>||</code>代表‘或’，<code>&amp;&amp;</code>代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a || b;<span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b;<span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line">c || b;<span class="comment">// "abc"</span></span><br><span class="line">c &amp;&amp; b;<span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>于是我们就可以利用这两个操作符进行一些赋值操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a || b;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">a ? a : b;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">a ? b : a;</span><br></pre></td></tr></table></figure></p><h1 id="与-的运用"><a href="#与-的运用" class="headerlink" title="==与===的运用"></a><code>==</code>与<code>===</code>的运用</h1><p>这两个符号我们应该很熟悉了，<code>==</code>代表值的比较，如果二者类型不同，会进行强制转换；<code>===</code>则是二者值与类型都相同才为true。这里需要注意一些问题：</p><ul><li><code>NaN</code>不等于它本身</li><li><code>+0</code>等于<code>-0</code></li></ul><h2 id="字符串与数字比较"><a href="#字符串与数字比较" class="headerlink" title="字符串与数字比较"></a>字符串与数字比较</h2><p>二者比较时，使用<code>===</code>结果肯定为false，因为二者类型不同，但如果使用<code>==</code>，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"22"</span>;</span><br><span class="line"></span><br><span class="line">a === b;<span class="comment">// false</span></span><br><span class="line">a == b;<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h2 id="任何值与Boolean比较"><a href="#任何值与Boolean比较" class="headerlink" title="任何值与Boolean比较"></a>任何值与Boolean比较</h2><p>当任何值与<code>Boolean</code>使用<code>==</code>比较时，首先会把<code>Boolean</code>转换为数字，然后再进行比较。也就是说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">"42"</span>;</span><br><span class="line"></span><br><span class="line">x == y; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>所以，在任何时候，都不要使用<code>== true</code>或者<code>== false</code>这样的语句。</p><h2 id="null与undefined比较"><a href="#null与undefined比较" class="headerlink" title="null与undefined比较"></a><code>null</code>与<code>undefined</code>比较</h2><p>当使用<code>==</code>比较<code>null</code>和<code>undefined</code>时，结果总为true。</p><h2 id="Object与非Object比较"><a href="#Object与非Object比较" class="headerlink" title="Object与非Object比较"></a><code>Object</code>与非<code>Object</code>比较</h2><p>当<code>object</code>/<code>function</code>/<code>array</code>与<code>String</code>或者<code>Number</code>进行<code>==</code>比较时，会先把<code>Object</code>转换为<code>String</code>或<code>Number</code>，然后再对值进行比较，而<code>Boolean</code>值会被转换为<code>Number</code>再进行比较。</p><h3 id="一些值得注意的比较"><a href="#一些值得注意的比较" class="headerlink" title="一些值得注意的比较"></a>一些值得注意的比较</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span> == [<span class="literal">null</span>];<span class="comment">// true</span></span><br><span class="line">[] == ![]; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">"\n"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">"0"</span> == <span class="literal">false</span>;<span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>;<span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">""</span>;<span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == [];<span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span>;<span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == [];<span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == [];<span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用<code>valueOf()</code>方法，没有才调用<code>toString()</code>方法，如果我们给自定义的对象添加<code>valueOf()</code>方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用<code>===</code>比较安全。</p><hr><blockquote><p>参考资料：<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md">You-Dont-Know-JS</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> type-coercion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS外边距合并效应</title>
      <link href="/2017/07/27/css-margin-collapse/"/>
      <url>/2017/07/27/css-margin-collapse/</url>
      
        <content type="html"><![CDATA[<p>大部分人都知道CSS布局时有外边距合并，也就是说如果给两个块元素设置margin-top或者margin-bottom值，它们上下之间的margin值会发生合并，但具体是根据什么来合并呢？我查了一下，大部分的解释都是<strong>叠加后的margin值取两者之间的最大值</strong>，也就是说，如果给上面的元素设置margin-bottom: 40px, 下面的元素设置margin-top: 50px,则最终两者之间的外边距为50px。但如果设置的值是负值呢？<br><a id="more"></a></p><h1 id="一个为负值，一个为正值"><a href="#一个为负值，一个为正值" class="headerlink" title="一个为负值，一个为正值"></a>一个为负值，一个为正值</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tops</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(94, 195, 27);</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bottoms</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(29, 141, 213);</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ou5mz529o.bkt.clouddn.com/imagemargin-top-bottom1.png" alt="margin"></p><p>可以看到，结果两者之间的外边距值为正负值相加，为10px。</p><h1 id="两个都为负值"><a href="#两个都为负值" class="headerlink" title="两个都为负值"></a>两个都为负值</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tops</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(94, 195, 27);</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bottoms</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(29, 141, 213);</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ou5mz529o.bkt.clouddn.com/imagemargin-top-bottom2.png" alt="margin"></p><p>最后两者之间外边距为-20px，也就是两个负值绝对值更大的那个。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以说，外边距合并一般有三种情况：</p><ul><li>两者都是正值，取最大的；</li><li>两者一正一负，取二者相加的结果；</li><li>两者都是负值，取二者绝对值更大的；</li></ul><blockquote><p>但要注意的是，外边距合并只发生在块元素之间。一般有三种情况：</p><ul><li>相邻的兄弟姐妹元素：毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。</li><li>块级父元素与其第一个/最后一个子元素：如果块级父元素中，不存在上边框、上内边距、内联元素、 清除浮动 这四条属性（也可以说，当上边框宽度及上内边距距离为0时），那么这个块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。</li><li>空块元素：如果存在一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。</li></ul></blockquote><p><strong>参考文档</strong>：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">MDN-margin-collapsing</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> margin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS边框的应用</title>
      <link href="/2017/07/24/csssecrets-border/"/>
      <url>/2017/07/24/csssecrets-border/</url>
      
        <content type="html"><![CDATA[<p>CSS中盒模型里重要的一个部分就是<code>border</code>，常见的<code>border</code>方法就是设置一重边框：<code>border: 1px solid #494949</code>，但如果我们想实现其他效果，该怎么用呢？<br><a id="more"></a></p><h1 id="CSS实现多重边框"><a href="#CSS实现多重边框" class="headerlink" title="CSS实现多重边框"></a>CSS实现多重边框</h1><h2 id="一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。"><a href="#一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。" class="headerlink" title="一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。"></a>一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。</h2><h2 id="box-shadow方案"><a href="#box-shadow方案" class="headerlink" title="box-shadow方案"></a>box-shadow方案</h2><p>  我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：</p><blockquote><p>Specify a single box-shadow using:</p><ul><li>Two, three, or four <length> values.</length></li><li>If only two values are given, they are interpreted as <offset-x><offset-y> values.</offset-y></offset-x></li><li>If a third value is given, it is interpreted as a <blur-radius>.</blur-radius></li><li>If a fourth value is given, it is interpreted as a <spread-radius>.</spread-radius></li><li>Optionally, the inset keyword.</li><li>Optionally, a <color> value.</color></li></ul></blockquote><p>  我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#533</span>;</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ou5mz529o.bkt.clouddn.com/imagebox-shadow.png" alt="one-shadow"></p><p>  当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#533</span>,</span><br><span class="line">                      0 0 0 15<span class="selector-tag">px</span> <span class="selector-id">#2f4</span>,</span><br><span class="line">                      0 2<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.6</span>);</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ou5mz529o.bkt.clouddn.com/imagebox-shadow2.png" alt="double-shadow"></p><p>  注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。</p><p>  需要注意的是：</p><blockquote><ul><li>投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。</li><li>box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。</li></ul></blockquote><h2 id="outline方案"><a href="#outline方案" class="headerlink" title="outline方案"></a>outline方案</h2><p>  某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#533</span>;</span><br><span class="line"><span class="selector-tag">outline</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#2f4</span>;</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ou5mz529o.bkt.clouddn.com/imagebox-shadow2.png" alt="double-shadow"></p><p>需要注意的是：</p><blockquote><p>它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。</p></blockquote><p><img src="http://ou5mz529o.bkt.clouddn.com/imageoutline-radius.png" alt="outline-radius"></p><hr><h1 id="边框内圆角实现"><a href="#边框内圆角实现" class="headerlink" title="边框内圆角实现"></a>边框内圆角实现</h1><p>有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'container'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>This is a box<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#655</span>;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: tan;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: .<span class="number">8em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果：<br><img src="http://ou5mz529o.bkt.clouddn.com/imageborder-inner-radius.png" alt="border-inner-radius"></p><p>但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: tan;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: .<span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span> <span class="number">#655</span></span><br><span class="line">  outline: .<span class="number">6em</span> solid <span class="number">#655</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的效果和之前一样。<br>因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。</p><p>注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于<code>(&amp;radic;2-1)*border-radius</code>，为了方便，一般取border-radius的一半。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> border </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近一段时间的总结</title>
      <link href="/2017/05/10/Summary/"/>
      <url>/2017/05/10/Summary/</url>
      
        <content type="html"><![CDATA[<p>最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。<br><a id="more"></a></p><h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><blockquote><p>自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。<br>不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：</p></blockquote><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><ul><li>继续阅读《You don’t know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图</li><li>完成FreeCodeCamp项目练习</li><li>练习百度前端学院有关项目</li></ul><h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><ul><li>阅读《CSS揭秘》</li><li>阅读图书馆借阅的设计方面相关书籍</li><li>在项目中模仿别人的页面设计</li><li>掌握bootstrap</li></ul><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><ul><li>掌握webpack的基本使用和配置</li><li>会用gulp</li><li>了解mocha测试工具</li><li>多了解前端性能优化</li><li>学会如何测试、发布上线项目</li><li>学会写文档</li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul><li>leetcode刷题</li><li>阅读算法导论</li><li>阅读http、tcp有关书籍</li></ul><h2 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h2><ul><li>通过阅读别人的React项目学习React基本结构和方法</li><li>自己开始用React+Redux+React-router模仿着写小组件</li><li>掌握React、Vue框架核心思想和区别</li><li>最好能阅读React源码分析</li></ul><h2 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h2><ul><li>阅读underscore源码</li><li>阅读jQuery源码</li><li>阅读Backbone源码</li></ul><hr><h1 id="规划生活"><a href="#规划生活" class="headerlink" title="规划生活"></a>规划生活</h1><p>感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。</p><ul><li>首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。</li><li>上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。</li><li>下午联系驾校练车，争取半个多月拿到证。</li><li>练完车后去锻炼锻炼，跑步或者打球。</li><li>晚上是码代码时间。</li><li>22：00后写博客总结一下当天的心得。</li><li>23：30上床</li></ul><blockquote><p>总之，让生活充实起来，做到学习娱乐两不误！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈函数节流与函数去抖</title>
      <link href="/2017/05/01/throttle-debounce/"/>
      <url>/2017/05/01/throttle-debounce/</url>
      
        <content type="html"><![CDATA[<p>函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。<br><a id="more"></a></p><h1 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流:throttle"></a>函数节流:throttle</h1><h2 id="函数节流的目的"><a href="#函数节流的目的" class="headerlink" title="函数节流的目的"></a>函数节流的目的</h2><p>有些函数不是由用户直接控制触发的，函数有可能被<strong>频繁地调用</strong>而导致性能问题。一些常见的函数被频繁调用场景：</p><ul><li>window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。</li><li>mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。</li><li>键盘keydown监听<blockquote><p>我们的目的就是减少函数触发的频率</p></blockquote></li></ul><h2 id="函数节流原理"><a href="#函数节流原理" class="headerlink" title="函数节流原理"></a>函数节流原理</h2><p>我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params"> fn, delay </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _self = fn,             <span class="comment">// 保存将要延迟执行的函数</span></span><br><span class="line">          timer,                    <span class="comment">// 定时器</span></span><br><span class="line">          first_time = <span class="literal">true</span>;  <span class="comment">// 是否第一次调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">              _me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> ( first_time ) &#123;     <span class="comment">// 如果第一次执行则直接调用</span></span><br><span class="line">            _self.apply( _me, args );</span><br><span class="line">            <span class="keyword">return</span> first_time = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( timer ) &#123;           <span class="comment">// 如果timer存在说明之前延迟的函数还没有执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout( timer );</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            _self.apply( _me, args );</span><br><span class="line">        &#125;, delay );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"has changed"</span>);</span><br><span class="line">&#125;, <span class="number">500</span> );</span><br></pre></td></tr></table></figure></p><h1 id="函数去抖-debounce"><a href="#函数去抖-debounce" class="headerlink" title="函数去抖:debounce"></a>函数去抖:debounce</h1><h2 id="函数去抖的目的"><a href="#函数去抖的目的" class="headerlink" title="函数去抖的目的"></a>函数去抖的目的</h2><p>函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：</p><ul><li>文字输入监听</li><li>onscroll事件</li><li>onresize事件。<h2 id="函数去抖原理"><a href="#函数去抖原理" class="headerlink" title="函数去抖原理"></a>函数去抖原理</h2>也是利用setTimeout和闭包的原理。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params"> fn, delay </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context,</span><br><span class="line">          args,</span><br><span class="line">          timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>, args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">if</span>( timer ) &#123;</span><br><span class="line">            clearTimeout( timer );</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply( context, args );</span><br><span class="line">        &#125;, delay );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize = debounce( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"has changed"</span>);</span><br><span class="line">&#125;, <span class="number">600</span> );</span><br></pre></td></tr></table></figure></li></ul><h1 id="underscore源码"><a href="#underscore源码" class="headerlink" title="underscore源码"></a>underscore源码</h1><p>underscore里对throttle和debounce有更完整的实现，这里把代码贴出来</p><ul><li><p>throttle</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, result;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> now = _.now();</span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>debounce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> last = _.now() - timestamp;       <span class="comment">// 上一次函数触发的时间</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class="number">0</span>) &#123;       <span class="comment">// 如果没有到达规定的wait时间则继续延迟，相当于计时器</span></span><br><span class="line">        timeout = setTimeout(later, wait - last);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">          result = func.apply(context, args);</span><br><span class="line">          <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      timestamp = _.now();</span><br><span class="line">      <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">      <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;        <span class="comment">// 如果是立即调用或者上一次函数已经调用完毕</span></span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> throttle </tag>
            
            <tag> debounce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http状态码记录</title>
      <link href="/2017/04/23/http-status-codes-marks/"/>
      <url>/2017/04/23/http-status-codes-marks/</url>
      
        <content type="html"><![CDATA[<p>近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。<br><a id="more"></a></p><h2 id="100～199：信息性状态码"><a href="#100～199：信息性状态码" class="headerlink" title="100～199：信息性状态码"></a>100～199：信息性状态码</h2><ul><li>100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。</li></ul><h2 id="200～299：成功状态码"><a href="#200～299：成功状态码" class="headerlink" title="200～299：成功状态码"></a>200～299：成功状态码</h2><ul><li>200 OK，代表请求没问题，返回的主体包含请求资源</li><li>202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。</li><li>204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面</li></ul><h2 id="300～399：重定向状态码"><a href="#300～399：重定向状态码" class="headerlink" title="300～399：重定向状态码"></a>300～399：重定向状态码</h2><ul><li>301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL</li><li>302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP/1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。</li><li>303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求</li><li>304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。</li><li>307 Temporary Redirect，HTTP1.1客户端用307状态码取代302</li></ul><h2 id="400～499：客户端错误状态码"><a href="#400～499：客户端错误状态码" class="headerlink" title="400～499：客户端错误状态码"></a>400～499：客户端错误状态码</h2><ul><li>400 Bad Request，客户端发送了错误请求</li><li>401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</li><li>403 Forbidden，说明请求被服务器拒绝了</li><li>404 Not Found，说明服务器无法找到所请求的URL</li><li>405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。</li><li>406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源</li><li>408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。</li></ul><h2 id="500～599：服务器错误状态码"><a href="#500～599：服务器错误状态码" class="headerlink" title="500～599：服务器错误状态码"></a>500～599：服务器错误状态码</h2><ul><li>500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误</li><li>501 Not Implemented，客户端发起的请求超出服务器的能力范围</li><li>502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误</li><li>503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈this和call、apply</title>
      <link href="/2017/04/19/GetToKnow-this-call-apply/"/>
      <url>/2017/04/19/GetToKnow-this-call-apply/</url>
      
        <content type="html"><![CDATA[<p>this的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考<br><a id="more"></a></p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p> 一般可分为四种情况：</p><ol><li><p>作为普通函数调用：此时this总是指向全局对象，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var func = &#123;</span><br><span class="line">    name: &apos;Simon&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var name = &apos;Yuk&apos;;</span><br><span class="line">var getMyName = func.getName;</span><br><span class="line">getMyName();  // 输出&apos;Yuk&apos;</span><br></pre></td></tr></table></figure></li><li><p>作为对象方法调用：此时this指向该对象，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var func = &#123;</span><br><span class="line">    name: &apos;Simon&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var name = &apos;Yuk&apos;;</span><br><span class="line">func.getName();  // 输出&apos;Simon&apos;</span><br></pre></td></tr></table></figure></li><li><p>构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。</p></li><li>bind、call、apply方法调用：此时this指向方法中指定的obj。</li></ol><hr><h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><ol><li>call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。</li><li>当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。</li><li><p>call和apply的用途：</p><ul><li>改变this的指向</li><li><p>Function.prototype.bind的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> _this = <span class="keyword">this</span>,   <span class="comment">// 保存原函数</span></span><br><span class="line">       context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 需要绑定的this的上下文</span></span><br><span class="line">       args = [].slice.call(<span class="built_in">arguments</span>);  <span class="comment">// 剩余的参数转成数组</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;     <span class="comment">// 返回一个新的函数</span></span><br><span class="line">       <span class="keyword">return</span> _this.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>) ) );</span><br><span class="line">           <span class="comment">//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span></span><br><span class="line">           <span class="comment">//并且组合两次分别传入的参数，作为新函数的参数</span></span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].slice.call(<span class="built_in">arguments</span>);   <span class="comment">// 将arguments转换为数组</span></span><br><span class="line">[].shift.call(<span class="built_in">arguments</span>);   <span class="comment">// 截去arguments列表中的头一个元素</span></span><br><span class="line">[].push.call(<span class="built_in">arguments</span>, item); <span class="comment">// 向arguments里添加新元素</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> call、apply </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVTE、阿里一面、去哪儿一面总结</title>
      <link href="/2017/04/16/Internship-interviews/"/>
      <url>/2017/04/16/Internship-interviews/</url>
      
        <content type="html"><![CDATA[<p>最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。<br><a id="more"></a></p><h2 id="CVTE一面、二面（3-28）"><a href="#CVTE一面、二面（3-28）" class="headerlink" title="CVTE一面、二面（3.28）"></a>CVTE一面、二面（3.28）</h2><blockquote><p>上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。<br>进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。</p></blockquote><blockquote><p>二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。</p></blockquote><blockquote><p>然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。</p></blockquote><h2 id="阿里电话一面（3-28）"><a href="#阿里电话一面（3-28）" class="headerlink" title="阿里电话一面（3.28）"></a>阿里电话一面（3.28）</h2><blockquote><p>没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。<br>电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。<br>然后又问了我一些问题：</p><pre><code>1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。</code></pre><p>然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。</p></blockquote><p>3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！<br>总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！</p><h2 id="去哪儿一面-4-14"><a href="#去哪儿一面-4-14" class="headerlink" title="去哪儿一面(4.14)"></a>去哪儿一面(4.14)</h2><blockquote><p>接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。<br>很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？<br>我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。<br>回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017腾讯前端实习生二面+HR面总结</title>
      <link href="/2017/04/16/Tecent-Interview-Second/"/>
      <url>/2017/04/16/Tecent-Interview-Second/</url>
      
        <content type="html"><![CDATA[<h2 id="二面（4-15）"><a href="#二面（4-15）" class="headerlink" title="二面（4.15）"></a>二面（4.15）</h2><blockquote><p>很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。<br><a id="more"></a><br>终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~<br>介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。接着面试官开始问我一些基础知识：</p><ol><li>了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对</li><li>操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。</li><li>递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。</li><li>了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。</li><li>了解TCP有什么延迟机制吗？我就说了TCP的慢启动。<br>问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。<br>回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。<br>希望自己能进入HR面吧！焦急等待中。。。</li></ol></blockquote><h2 id="HR面（4-16）"><a href="#HR面（4-16）" class="headerlink" title="HR面（4.16）"></a>HR面（4.16）</h2><blockquote><p>今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。<br>去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。<br>到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：</p><pre><code>1. 你是哪里人？2. 你最想去哪个城市工作？回答当然是深圳。3. 你是怎么学习前端的？4. 你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。5. 你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。6. 你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。7. 你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。8. 你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。9. 你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。10. 实习时间可以从什么时候开始？</code></pre><p>问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017腾讯前端实习生一面总结</title>
      <link href="/2017/04/13/Tecent-Interview-one/"/>
      <url>/2017/04/13/Tecent-Interview-one/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。<br>到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：<br><a id="more"></a><br>首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。<br>然后面试官又问我一些问题：</p><ol><li>前端路由怎么控制？</li><li>SPA如何管理内存</li><li>浏览器发送Cookie服务器接收不到什么原因？</li><li>了解过web性能优化有哪些吗？</li><li>web存储有哪些？</li><li>跨域方法有哪些？</li><li>了解哪些web安全问题？</li><li>如何防止恶意广告、脚本注入？</li><li>CORS方法跨域数据被劫持怎么办？</li><li>移动端适配怎么做？</li><li>了解哪些MVVM框架？</li><li>手机webApp如何与原生App通信？</li><li>Http状态码了解哪些？</li><li>浏览器缓存问题<br>中间还问了几个算法问题：</li><li>写出一个字符串反转函数</li><li>5分钟内手写二分查找</li><li>有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。</li></ol></blockquote><blockquote><p>问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。<br>之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。<br>最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。<br>与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。</p></blockquote><p>不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web性能优化方案</title>
      <link href="/2017/04/12/webpage-optimize/"/>
      <url>/2017/04/12/webpage-optimize/</url>
      
        <content type="html"><![CDATA[<p>最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：<br><a id="more"></a></p><ul><li>压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积</li><li><p>合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求</p></li><li><p>使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存<br>延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。</p></li><li>css放在页面头部，js放在页面底部</li><li>能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。</li><li>异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。</li><li>因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。</li><li>第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。</li><li>使用localStorage缓存一些静态数据，避免去服务器查询。</li><li>静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。</li><li>减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN </tag>
            
            <tag> storage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器跨域问题</title>
      <link href="/2017/04/10/cross-origin/"/>
      <url>/2017/04/10/cross-origin/</url>
      
        <content type="html"><![CDATA[<p>最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。<br>由于浏览器的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：<br><a id="more"></a></p><h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>我们可以在要传输数据的两个页面设置相同的document.domain=”<a href="http://www.example.com&quot;，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;，但&quot;a.com&quot;和&quot;b.com&quot;就不行。">www.example.com&quot;，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;，但&quot;a.com&quot;和&quot;b.com&quot;就不行。</a></p><h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>HTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：<em>则代表允许任何域连接，也可以设置为想要连接的域地址。</em></p><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。</p><h2 id="postMessage方法"><a href="#postMessage方法" class="headerlink" title="postMessage方法"></a>postMessage方法</h2><p>HTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。<br>接受端通过监听message事件，调用event.data来获取数据。</p>]]></content>
      
      
      <categories>
          
          <category> Web网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题ing</title>
      <link href="/2017/04/09/leetcode-week1/"/>
      <url>/2017/04/09/leetcode-week1/</url>
      
        <content type="html"><![CDATA[<p>前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。<br>其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，也当给自己复习～代码就不贴了。。。<br><a id="more"></a></p><h3 id="Longest-Uncommon-Subsequence-I"><a href="#Longest-Uncommon-Subsequence-I" class="headerlink" title="Longest Uncommon Subsequence I"></a><a href="https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description">Longest Uncommon Subsequence I</a></h3><blockquote><p>题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说”abcad”, “abcda”这两个字符串的最大不同子字符串就是它们自己任何一个。</p></blockquote><p>开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。</p><h3 id="Isomorphic-Strings"><a href="#Isomorphic-Strings" class="headerlink" title="Isomorphic Strings"></a><a href="https://leetcode.com/problems/isomorphic-strings/#/description">Isomorphic Strings</a></h3><blockquote><p>题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如”abba”和”cddc”就是同构，”abcde”和”abcdf”就不是同构。</p></blockquote><p>一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。</p><h3 id="Queue-Reconstruction-by-Height"><a href="#Queue-Reconstruction-by-Height" class="headerlink" title="Queue Reconstruction by Height"></a><a href="https://leetcode.com/problems/queue-reconstruction-by-height/#/description">Queue Reconstruction by Height</a></h3><blockquote><p>题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。</p></blockquote><p>其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。</p><h3 id="Assign-Cookies"><a href="#Assign-Cookies" class="headerlink" title="Assign Cookies"></a><a href="https://leetcode.com/problems/assign-cookies/#/description">Assign Cookies</a></h3><blockquote><p>题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。</p></blockquote><p>又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。</p><h3 id="Arithmetic-Slices"><a href="#Arithmetic-Slices" class="headerlink" title="Arithmetic Slices"></a><a href="https://leetcode.com/problems/arithmetic-slices/#/description">Arithmetic Slices</a></h3><blockquote><p>题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。</p></blockquote><p>简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)/2个等差数列，然后把结果累加就行了。</p><h3 id="Counting-Bits"><a href="#Counting-Bits" class="headerlink" title="Counting Bits"></a><a href="https://leetcode.com/problems/counting-bits/#/description">Counting Bits</a></h3><blockquote><p>给定一个数字n统计0～n里每个数字的二进制中1的个数。</p></blockquote><p>主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n) &#123;</span><br><span class="line">  count++;</span><br><span class="line">  n = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为n &amp; (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。</p><h3 id="Add-Digits"><a href="#Add-Digits" class="headerlink" title="Add Digits"></a><a href="https://leetcode.com/problems/add-digits/#/description">Add Digits</a></h3><blockquote><p>给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num = 38, 3 + 8 = 11, 1 + 1 = 2. 返回2。</p></blockquote><p>这里有一个数学公式，wiki上有<a href="https://en.wikipedia.org/wiki/Digital_root#Congruence_formula">digital_root</a>，具体我就没推了，直接用结论：dr(n) = 1 + (n - 1) % 9</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深刻理解闭包</title>
      <link href="/2017/04/06/Closures-learning/"/>
      <url>/2017/04/06/Closures-learning/</url>
      
        <content type="html"><![CDATA[<h3 id="变量的知识"><a href="#变量的知识" class="headerlink" title="变量的知识"></a>变量的知识</h3><hr><ul><li>变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。</li><li>变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。<a id="more"></a><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3></li></ul><hr><p>我们先来看个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = func();</span><br><span class="line">f();    <span class="comment">// 1</span></span><br><span class="line">f();    <span class="comment">// 2</span></span><br><span class="line">f();    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>当退出函数后，变量a并没有消失，因为调用var f = func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。<br>我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。</p><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><hr><ul><li>封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。</li><li>延长局部变量寿命：使其不会在退出函数时就立即销毁。</li><li>将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。</li></ul><h3 id="闭包与面向对象设计"><a href="#闭包与面向对象设计" class="headerlink" title="闭包与面向对象设计"></a>闭包与面向对象设计</h3><hr><ul><li>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。</li><li><p>闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createCommand = <span class="function"><span class="keyword">function</span>(<span class="params">receiver</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> excute = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver.open();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> undo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver.close();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        excute: excute,</span><br><span class="line">        undo: undo</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。</p></li></ul><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><hr><p>在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( message );</span><br><span class="line">    &#125;, <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(<span class="string">"This is a closure!"</span>);</span><br></pre></td></tr></table></figure></p><p>在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(…)作用域的闭包，因此包含对变量message的引用。wait(…)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(…)作用域的闭包。</p><h3 id="经典闭包问题"><a href="#经典闭包问题" class="headerlink" title="经典闭包问题"></a>经典闭包问题</h3><hr><p>考虑如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？<br>我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。<br>怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;, i * <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。<br>其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p><h3 id="闭包在模块中的应用"><a href="#闭包在模块中的应用" class="headerlink" title="闭包在模块中的应用"></a>闭包在模块中的应用</h3><hr><p>考虑以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(sth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">','</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSth: doSth,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line">foo.doSth();</span><br><span class="line">foo.doAnother();</span><br></pre></td></tr></table></figure></p><p>这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。<br>简单地说，模块模式需要具备两个必要条件：</p><pre><code>1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态</code></pre><p>当只需要一个实例时，我们可以用如下方法实现单例模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(sth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">','</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSth: doSth,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.doSth();</span><br><span class="line">foo.doAnother();</span><br></pre></td></tr></table></figure></p><p>我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入学习HTTP连接</title>
      <link href="/2017/04/04/http-learning-1/"/>
      <url>/2017/04/04/http-learning-1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是HTTP协议？"><a href="#什么是HTTP协议？" class="headerlink" title="什么是HTTP协议？"></a>什么是HTTP协议？</h2><hr><p>HTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。<br>只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。<br><a id="more"></a></p><h3 id="为什么说HTTP是无状态的？"><a href="#为什么说HTTP是无状态的？" class="headerlink" title="为什么说HTTP是无状态的？"></a>为什么说HTTP是无状态的？</h3><hr><p>无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。<br>缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。</p><h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP/IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：</p><ul><li>浏览器从URL中解析出服务器的主机名;</li><li>浏览器通过DNS将主机名转换成服务器的IP地址;</li><li>浏览器将端口号(默认80)从URL中解析出来;</li><li>浏览器建立一条与Web服务器的TCP连接;</li><li>浏览器向服务器发送一条HTTP请求报文;</li><li>服务器向浏览器回送一条HTTP响应报文;</li><li>关闭连接，浏览器渲染文档并显示;</li></ul><p>当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><hr><p>我们知道，HTTP协议依赖TCP/IP来进行通信。那么什么是TCP/IP呢？TCP/IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。</p><h4 id="TCP数据传输"><a href="#TCP数据传输" class="headerlink" title="TCP数据传输"></a>TCP数据传输</h4><ul><li>TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。</li><li>传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：<ul><li>一个IP分组首部（通常为20字节）;</li><li>一个TCP段首部（通常为20字节）;</li><li>一个TCP数据块（0个或多个字节）;<br><img src="http://ou5mz529o.bkt.clouddn.com/imageip-group.jpg" alt="ip分组" title="IP分组"></li></ul></li><li>TCP连接通过4个值来识别：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;，这4个值一起唯一地定义了一条连接。<h3 id="TCP性能考虑"><a href="#TCP性能考虑" class="headerlink" title="TCP性能考虑"></a>TCP性能考虑</h3></li><li><strong>HTTP事务的时延</strong>：一般影响HTTP事务的时延主要有以下几点原因：<ol><li>解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。</li><li>发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。</li><li>连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间<br>总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。</li></ol></li><li><strong>TCP握手时延</strong>：TCP连接需要经过三次握手，一般步骤如下：<ol><li>请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。</li><li>服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。</li><li>客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）</li></ol></li><li><strong>TCP延迟确认</strong>：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。</li><li><strong>TCP慢启动</strong>：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。<br>由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。</li><li><strong>Nagle算法问题</strong>：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。<br>Nagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。<br>所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。</li><li><strong>TIME_WAIT、端口耗尽</strong>：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树JavaScript实现</title>
      <link href="/2017/04/03/achieve-binary-search-tree/"/>
      <url>/2017/04/03/achieve-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树"></a>什么是二叉搜索树</h3><p>其形式就是二叉树，对于每个节点x，其左子树的值&lt;=x.value，右子树的值&gt;=x.value。<br><a id="more"></a></p><h3 id="二叉搜索树的遍历与查询"><a href="#二叉搜索树的遍历与查询" class="headerlink" title="二叉搜索树的遍历与查询"></a>二叉搜索树的遍历与查询</h3><p>对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inorderTreeWalk</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x!== <span class="literal">null</span>) &#123;</span><br><span class="line">    inorderTreeWalk(x.left);</span><br><span class="line">    print(x.key);</span><br><span class="line">    inorderTreeWalk(x.right);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeSearch</span>(<span class="params">x,k</span>) </span>&#123;  <span class="comment">//最开始x代表根节点</span></span><br><span class="line">  <span class="keyword">if</span>(x === <span class="literal">null</span> || x.key === k) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k &lt; x.key) &#123;</span><br><span class="line">    <span class="keyword">return</span> treeSearch(x.left, k);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> treeSearch(x.right, k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们还可以写出循环版本（一般比递归更高效）:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeSearch</span>(<span class="params">x, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x !== <span class="literal">null</span> || k !== x.key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; x.key) &#123;</span><br><span class="line">      x = x.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = x.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeMinimum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">    x = x.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeMaximum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(x.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">    x = x.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeSuccessor</span>(<span class="params">x</span>) </span>&#123;  <span class="comment">//后继查找</span></span><br><span class="line">  <span class="keyword">if</span>(x.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> treeMinimum(x.right);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> y = x.parent;</span><br><span class="line">    <span class="keyword">while</span>(y !== <span class="literal">null</span> &amp;&amp; x === y.right) &#123;</span><br><span class="line">      x = y;</span><br><span class="line">      y = y.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeSuccessor</span>(<span class="params">x</span>) </span>&#123;  <span class="comment">//前驱查找</span></span><br><span class="line">  <span class="keyword">if</span>(x.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> treeMaximum(x.left);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> y = x.parent;</span><br><span class="line">    <span class="keyword">while</span>(y !== <span class="literal">null</span> &amp;&amp; x === y.left) &#123;</span><br><span class="line">      x = y;</span><br><span class="line">      y = y.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉搜索树实现插入和删除操作。"><a href="#二叉搜索树实现插入和删除操作。" class="headerlink" title="二叉搜索树实现插入和删除操作。"></a>二叉搜索树实现插入和删除操作。</h3><p>　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。<br>　　<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeInsert</span>(<span class="params">tree, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(tree !== <span class="literal">null</span>) &#123;</span><br><span class="line">    y = tree;</span><br><span class="line">    <span class="keyword">if</span>(newNode.key &lt; tree.key) &#123;</span><br><span class="line">      tree = tree.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tree = tree.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  newNode.parent = y;</span><br><span class="line">  <span class="keyword">if</span>(y === <span class="literal">null</span>) &#123;  <span class="comment">// 树为空</span></span><br><span class="line">    tree.root = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(newNode.key &lt; y.key) &#123;</span><br><span class="line">      y.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      y.right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。<br>　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。<br>　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。<br>　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。<br>        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transplant</span>(<span class="params">tree, u, v</span>) </span>&#123;  <span class="comment">//子树替换父节点方法</span></span><br><span class="line">  <span class="keyword">if</span>(u.p === <span class="literal">null</span>) &#123;</span><br><span class="line">    tree.root = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(u === u.parent.left) &#123;</span><br><span class="line">    u.parent.left = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    u.parent.right = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(v !== <span class="literal">null</span>) &#123;</span><br><span class="line">    v.parent = u.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeDelete</span>(<span class="params">tree, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(z.left === <span class="literal">null</span>) &#123;</span><br><span class="line">    transplant(tree, z, z.right);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(z.right === <span class="literal">null</span>) &#123;</span><br><span class="line">    transplant(tree, z, z.left);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> y = treeMinimum(z.right);</span><br><span class="line">    <span class="keyword">if</span>(y.parent !== z) &#123;</span><br><span class="line">      transplant(tree, y, y.right);</span><br><span class="line">      y.right = z.right;</span><br><span class="line">      y.right.parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    transplant(tree, z, y);</span><br><span class="line">    y.left = z.left;</span><br><span class="line">    y.left.parent = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客终于搭好了！</title>
      <link href="/2017/04/03/thoughts/"/>
      <url>/2017/04/03/thoughts/</url>
      
        <content type="html"><![CDATA[<p><strong>花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。<br>希望能在记录自己的生活中成长吧！</strong></p><p>今天很晚了。。。就先写到这吧～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thoughts </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
