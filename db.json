{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/images/WechatQR.png","path":"images/WechatQR.png","modified":1,"renderable":0},{"_id":"source/images/ip-group.jpg","path":"images/ip-group.jpg","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/copycode.css","path":"css/copycode.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/copyright.css","path":"css/copyright.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/search.css","path":"css/search.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/copycode.js","path":"js/copycode.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/copyright.js","path":"js/copyright.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/love.js","path":"js/love.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/favicon.ico","hash":"f92d0773e9634ed052f9934e48aed4a362bdc746","modified":1646898272628},{"_id":"source/_posts/2017-04-03-achieve-binary-search-tree.md","hash":"0d0367e850fb69ff86453cd4c102a6b727092cf9","modified":1646898272624},{"_id":"source/_posts/2017-04-04-http-learning-1.md","hash":"29f5e0b2e5eb24b49975586982de53f8adbb7a65","modified":1646898272624},{"_id":"source/_posts/2017-04-06-Closures-learning.md","hash":"9707daa6a6b650ee57f7eac7ea65c064f06ad669","modified":1646898272624},{"_id":"source/_posts/2017-04-09-leetcode-week1.md","hash":"abe0442c3174d3e028cd0f9d226747f4592bb6e9","modified":1646898272624},{"_id":"source/_posts/2017-04-10-cross-origin.md","hash":"268fcd7a5e54a11c3bd12a72745a4a947d1c1dbd","modified":1646898272624},{"_id":"source/_posts/2017-04-12-webpage-optimize.md","hash":"f6c980da22d27fd8058420c19de28a55a19c6dbc","modified":1646898272624},{"_id":"source/_posts/2017-04-13-Tecent-Interview-one.md","hash":"35f05a55a3b735b1fbe3dda0cc1fea1b6ced3b8e","modified":1646898272624},{"_id":"source/_posts/2017-04-16-Internship-interviews.md","hash":"ca877d2963273506b8aa3fdcaf4d38e324df7e41","modified":1646898272624},{"_id":"source/_posts/2017-04-16-Tecent-Interview-Second.md","hash":"765d647352c73679e50d78d7e3ab312b5c813ca3","modified":1646898272624},{"_id":"source/_posts/2017-04-19-GetToKnow-this-call-apply.md","hash":"fdfff7f05a8fdc181aee896b99ee07ca1240ec52","modified":1646898272624},{"_id":"source/_posts/2017-04-23-http-status-codes-marks.md","hash":"4f8dc82997197919d560b8b31321349d8dfb09a4","modified":1646898272624},{"_id":"source/_posts/2017-05-01-throttle-debounce.md","hash":"d4dd6f30ed6a5edacdac2d9d87e20f0e4c76f6f1","modified":1646898272624},{"_id":"source/_posts/2017-05-10-Summary.md","hash":"12f3999d26136fa6baffe26053c86ec50c34697b","modified":1646898272624},{"_id":"source/_posts/2017-07-24-csssecrets-border.md","hash":"0d057099f38368ae9210fdaa2b68e36d1cf3b278","modified":1646898272624},{"_id":"source/_posts/2017-07-27-css-margin-collapse.md","hash":"2922344d6a3f8f9540d305166ed892e2edbe2abf","modified":1646898272624},{"_id":"source/_posts/2017-08-02-js-value-coercions.md","hash":"9e8c7eeb78edf256e8233bd6c5289d0a8c222307","modified":1646898272624},{"_id":"source/_posts/2017-08-04-react-setState-update.md","hash":"8acd7f5e02773aaff5e609eafd1e71dd23b1f5d0","modified":1646898272624},{"_id":"source/_posts/2017-08-05-javascript-object.md","hash":"ffe5c71b3b79c572d32e1f4807d2805d5fc1a7d4","modified":1646898272624},{"_id":"source/_posts/2017-08-08-get-browser-size.md","hash":"8d765b5f0e1abbb8d41971f093e58a5fca5874dc","modified":1646898272624},{"_id":"source/_posts/2017-08-09-thought-of-today.md","hash":"805d876eb76890aa1a4b483ce40608d60afe73b9","modified":1646898272624},{"_id":"source/_posts/2017-08-10-javascript-class-constructor.md","hash":"52ba727d16baab0873f00f450b088121644b2f1f","modified":1646898272624},{"_id":"source/_posts/2017-08-12-how-to-set-cookie-in-js.md","hash":"566ac687d9248bf096b7bcafb9298347e83b227f","modified":1646898272628},{"_id":"source/_posts/2017-08-20-changing-IDE-to-VSCODE.md","hash":"dbd9133bc47cc3940e87faf4d76e77e13c6d20ef","modified":1646898272628},{"_id":"source/_posts/2017-08-22-scroll-to-top-btn.md","hash":"8b797b503bcf86391dc32e976cb53f2475117742","modified":1646898272628},{"_id":"source/_posts/2017-08-27-how-to-write-js-marquee.md","hash":"eb9cdaadab2b5f7c6236fb5b310e91006122b874","modified":1646898272628},{"_id":"source/_posts/2017-09-05-what-is-heapSort.md","hash":"12d6270eaf5163b9a74d9f4d3e869c67ec6d1838","modified":1646898272628},{"_id":"source/_posts/2018-12-03-draw-different-shapes-with-css.md","hash":"7fd107e02093f2eef36be6177f3889c66ad7471f","modified":1646898272628},{"_id":"source/_posts/2018-12-04-copy-to-clipboard.md","hash":"6736a356297061ab5645419baeaa4e3e2d6c9d71","modified":1646898272628},{"_id":"source/_posts/2018-12-15-codemirror-markdown-editor-chapter1.md","hash":"6eb792c61adad4cf60d8f9baac7c0299c9f61548","modified":1646898272628},{"_id":"source/_posts/2018-12-20-codemirror-markdown-editor-chapter2.md","hash":"70306b2cdbf5130f8c33ad62c8287b60e1175a47","modified":1646898272628},{"_id":"source/_posts/2019-01-09-2018-road-to-grow-up.md","hash":"0a3753bbf4c501af9376b06abd2587959c93c9de","modified":1646898272628},{"_id":"source/_posts/2019-01-12-use-anchor-jump-to-anywhere-in-page.md","hash":"48fa506c2a4c1e9142f7f6582bcb82ab6da00e8a","modified":1646898272628},{"_id":"source/_posts/2019-01-23-how-to-achieve-typewriter-effect.md","hash":"56699d82b2ac4b54d4a36d7faf462e99fe6a6a48","modified":1646898272628},{"_id":"source/_posts/2019-01-29-nodeJS-file-system-operation.md","hash":"c2bc9e2f408e17e09b2ac1723c82d36c756d6d1e","modified":1646898272628},{"_id":"source/_posts/2019-02-15-fast-achieve-tabpane-effect.md","hash":"544af74d4cd0e5277f69723222634bea00cc740c","modified":1646898272628},{"_id":"source/_posts/2019-02-27-leetcode-sum-of-even-numbers-after-queries-solution.md","hash":"f753cf083b8e466699526d502aecbf9e0a70ff9c","modified":1646898272628},{"_id":"source/_posts/2019-08-11-half-year-summary.md","hash":"547c88e7c54a4673dbbcf5a00673b4b82d7f3d22","modified":1646898272628},{"_id":"source/_posts/2019-08-18-how-can-i-be-a-programmer-1.md","hash":"f361cdedd4672a0c842f3d3416152da86d89ed9d","modified":1646898272628},{"_id":"source/_posts/2019-08-25-how-can-i-be-a-programmer-2.md","hash":"0f3cde0ccb95b117eb9d73bb7338dacf48b9d6e7","modified":1646898272628},{"_id":"source/_posts/2020-01-25-git-commend-list.md","hash":"a8a70dc187f80194c1d68909df26554d76d63800","modified":1646898272628},{"_id":"source/_posts/2022-02-24-clarity-source-analysis-1.md","hash":"ab3dd9567403b0ca7b64d985386fc000a7378dee","modified":1646898272628},{"_id":"source/_posts/2022-02-26-clarity-source-analysis-2.md","hash":"ef35aff9ee33948fa478693cc27edd536d597ae3","modified":1646898272628},{"_id":"source/_posts/thoughts.md","hash":"ec72748f6b7faca5219a18729d7d833d2ca04ed1","modified":1646898272628},{"_id":"source/about/index.md","hash":"c438685c1330ba9c3afa8c033738f42ee4429958","modified":1646898272628},{"_id":"source/categories/index.md","hash":"980902f8d2ca46760a46087064985ffe123c6086","modified":1646898272628},{"_id":"source/guestbook/index.md","hash":"df0bfeca43614c65ea414cd4e3290e2210aafc1c","modified":1646898272628},{"_id":"source/images/ip-group.jpg","hash":"6d6fbafa1d5ed8893df83b63248a44a5529152dc","modified":1646898272628},{"_id":"source/tags/index.md","hash":"a7824afd531d0a50aaaf28da2d8665818f27a70e","modified":1646898272628},{"_id":"source/images/WechatQR.png","hash":"c3c9f25958413a4652e98d98413deb1b0382865c","modified":1646898272628},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1646898272632},{"_id":"themes/maupassant/README.md","hash":"8cc8e522e7b0b9bf41bfe54f447213737134370b","modified":1646898272636},{"_id":"themes/maupassant/_config.yml","hash":"d1a5c0a70c162506428c9b37353ac97281679d94","modified":1646898705232},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1646898272636},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1646898272636},{"_id":"themes/maupassant/languages/en.yml","hash":"9c979a2f107536399bbe2be572c2d0bebcdd9d95","modified":1646898272636},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1646898272636},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1646898272636},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1646898272636},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1646898272636},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"78cc1794a3ce3e186c462c1a70f097d0c05cd210","modified":1646898272636},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"e9747f9b3ec1314a3cae44a9a90e7649af739633","modified":1646898272636},{"_id":"themes/maupassant/layout/about.pug","hash":"b3b3b8c1c73361fab8fe8df3f103ecad37aded0a","modified":1646898272636},{"_id":"themes/maupassant/layout/archive.pug","hash":"749028e57a2eaad8c92ce2a2426c98605ab746a7","modified":1646898272636},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"80995eadfd89ee9aa36f4672f8d405e03f13af15","modified":1646898272636},{"_id":"themes/maupassant/layout/base.pug","hash":"bf8c6eda72f9190dd2d46065924840958c57619e","modified":1646898272636},{"_id":"themes/maupassant/layout/index.pug","hash":"162fe3fa695e8bea5a77916aefbb7ce98cd227bf","modified":1646898272636},{"_id":"themes/maupassant/layout/page.pug","hash":"a285a76950bb1b91f482ef9c473472bd0ede601d","modified":1646898272636},{"_id":"themes/maupassant/layout/post.pug","hash":"9fbbc4ca1394f99dccdd972c3db9105d3cf5066e","modified":1646898272636},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1646898272636},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"4aa57b41e919a12b6d7691cd4a36d3a531b55fcb","modified":1646898272636},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"aefb67bac8fcef9cb3027f8622923b392f79f51e","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"b49f4e2cd9f77456230a5508d0bbe9a362668712","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/darkmode.pug","hash":"82567449d68025cc7fee5259d4769f5ee015aa26","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"20eb3d4746956b661775e84d91d36c09119bb820","modified":1646898382248},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"53d721ea4c93564cb0bdde065572ff6128574d36","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1646898272636},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"b3c846a2e0ac79933e32c343029b769f2865a27f","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/copyright.pug","hash":"32701dcba9c52d4bc73badaf8afe91af3f87b6a0","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/donate.pug","hash":"50855ce17af4298ce0f15236e2308c4a1760e7e3","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"1ef7a333ab9bfa169276d0ad48aecf5166ab63cb","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1646898272636},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1646898272636},{"_id":"themes/maupassant/source/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1646898272636},{"_id":"themes/maupassant/source/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1646898272636},{"_id":"themes/maupassant/source/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1646898272636},{"_id":"themes/maupassant/source/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1646898272636},{"_id":"themes/maupassant/source/css/style.scss","hash":"e6d1b74b620b27b480f76a4998a6cb279dc01772","modified":1646898272636},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1646898272636},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1646898272636},{"_id":"themes/maupassant/source/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1646898272636},{"_id":"themes/maupassant/source/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1646898272636},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1646898272636},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1646898272636},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1646898272636},{"_id":"themes/maupassant/source/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1646898272636},{"_id":"themes/maupassant/source/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1646898272636},{"_id":"themes/maupassant/source/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1646898272636},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1646898272636},{"_id":"themes/maupassant/source/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1646898272636},{"_id":"themes/maupassant/source/js/search.js","hash":"6fdfd143646d12b8dbef9b5809cea768192f08aa","modified":1646898272636},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1646898272636},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1646898272636},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1646898272636},{"_id":"public/rss2.xml","hash":"0a5774d6cf2f5433a806e8daba922feb8f4f5576","modified":1646898766261},{"_id":"public/search.xml","hash":"95aa51c98bcf49eff359ee2f712a33ba71002224","modified":1646898766261},{"_id":"public/about/index.html","hash":"8e27951902f868d02c70e1463283c329320872ca","modified":1646898766261},{"_id":"public/categories/index.html","hash":"8785b49b52511a3eaa6ceab59fb64f204e0db70a","modified":1646898766261},{"_id":"public/guestbook/index.html","hash":"4b30216d47ed7f97d1d7ab2556d1599896d8e159","modified":1646898766261},{"_id":"public/tags/index.html","hash":"8ae1311934ebbe4ea1c2eb9995aef1b5d49c0a02","modified":1646898766261},{"_id":"public/2022/02/26/clarity-source-analysis-2/index.html","hash":"8de1f90689dcd1d90fd7b4aef62042e297b0886e","modified":1646898766261},{"_id":"public/2022/02/24/clarity-source-analysis-1/index.html","hash":"c0cf7f86d8bf3e13cc96339272f0247a2ebef472","modified":1646898766261},{"_id":"public/2020/01/25/git-commend-list/index.html","hash":"cf7616ce28ae6c82d3bf7631af99a6f3ab0de7d9","modified":1646898766261},{"_id":"public/2019/08/25/how-can-i-be-a-programmer-2/index.html","hash":"7f4e27fe3d8a5028ffb0fc9ea3dc5cb89799449e","modified":1646898766261},{"_id":"public/2019/08/18/how-can-i-be-a-programmer-1/index.html","hash":"13f1ac5afb2a4e15d17e68667d700a68f5d12fef","modified":1646898766261},{"_id":"public/2019/08/11/half-year-summary/index.html","hash":"20601d5497f0a2e79ec51145cda5cbe050f3910c","modified":1646898766261},{"_id":"public/2019/02/27/leetcode-sum-of-even-numbers-after-queries-solution/index.html","hash":"6cd34616e5b9d17b3392bea4bcb907abb3c916fc","modified":1646898766261},{"_id":"public/2019/02/15/fast-achieve-tabpane-effect/index.html","hash":"30144ff28c9f6962ac56f3d898a43b7dcf2ecf4d","modified":1646898766261},{"_id":"public/2019/01/29/nodeJS-file-system-operation/index.html","hash":"2668ac6d2ddfa76a13dd82f55ceb973416153e0f","modified":1646898766261},{"_id":"public/2019/01/23/how-to-achieve-typewriter-effect/index.html","hash":"8e2613c6e0cc3277740a87cbd4e1f6fd55e6a24f","modified":1646898766261},{"_id":"public/2019/01/12/use-anchor-jump-to-anywhere-in-page/index.html","hash":"34380bf093bd34f393c32b2a5e061d7ce2f452f1","modified":1646898766261},{"_id":"public/2019/01/09/2018-road-to-grow-up/index.html","hash":"8c4855f5a9d47f1d6bd428548d7c4cf5bbebd80d","modified":1646898766261},{"_id":"public/2018/12/20/codemirror-markdown-editor-chapter2/index.html","hash":"f4de18fa2d308809e4fb1a84e9d74ca75989132f","modified":1646898766261},{"_id":"public/2018/12/15/codemirror-markdown-editor-chapter1/index.html","hash":"598c06f5407ef0da4f30a53710828e426b849098","modified":1646898766261},{"_id":"public/2018/12/04/copy-to-clipboard/index.html","hash":"1f01eac92df9b8c74d41ea74cb35dfb918cae262","modified":1646898766261},{"_id":"public/2018/12/03/draw-different-shapes-with-css/index.html","hash":"68cabc8a182b0ca07becd36724c808110c18b5c1","modified":1646898766261},{"_id":"public/2017/09/05/what-is-heapSort/index.html","hash":"09b7eeef51427144e3e2c5bca218b479fc06661c","modified":1646898766261},{"_id":"public/2017/08/27/how-to-write-js-marquee/index.html","hash":"ebcdd38fbf881711f5569247baf8220c25f51e7d","modified":1646898766261},{"_id":"public/2017/08/22/scroll-to-top-btn/index.html","hash":"737938de42e61ed9eeb5553125566fd7f38ddecc","modified":1646898766261},{"_id":"public/2017/08/20/changing-IDE-to-VSCODE/index.html","hash":"def464fcae80484cb5de551b8c30dccf4ab24392","modified":1646898766261},{"_id":"public/2017/08/12/how-to-set-cookie-in-js/index.html","hash":"c9097a7076493e3341d3bd33f57d069e976d5ab3","modified":1646898766261},{"_id":"public/2017/08/10/javascript-class-constructor/index.html","hash":"6df8edbf450574cfbd8c74afbcf461c44ba325f4","modified":1646898766261},{"_id":"public/2017/08/09/thought-of-today/index.html","hash":"e50a708c2dd613af69b8e75d3c04a19abaea42f9","modified":1646898766261},{"_id":"public/2017/08/08/get-browser-size/index.html","hash":"9bc3a8fd965974b67acd0604ecb3ef9d4d98c770","modified":1646898766261},{"_id":"public/2017/08/05/javascript-object/index.html","hash":"1ba278b06c33df910aa86a3f14da41bb0351f18f","modified":1646898766261},{"_id":"public/2017/08/04/react-setState-update/index.html","hash":"55c3f7457c12c4f6996c19666f11b655e294bfd4","modified":1646898766261},{"_id":"public/2017/08/02/js-value-coercions/index.html","hash":"56fbe97582b64a9396caefc7688c681131dc2ef1","modified":1646898766261},{"_id":"public/2017/07/27/css-margin-collapse/index.html","hash":"c663f25e339c94b5698315cf5528b4c9b9c4bb7c","modified":1646898766261},{"_id":"public/2017/07/24/csssecrets-border/index.html","hash":"efd99b140e339f79df6946d06ecf3149179d78b1","modified":1646898766261},{"_id":"public/2017/05/10/Summary/index.html","hash":"6cb97556b2f97c5e417d1e191eec2e58a623bf2f","modified":1646898766261},{"_id":"public/2017/05/01/throttle-debounce/index.html","hash":"52ce2597ccdc41d83444d656759aa2ec24d1dd2c","modified":1646898766261},{"_id":"public/2017/04/23/http-status-codes-marks/index.html","hash":"c0e837f587bfb5470e29befa7845d214f50c5c19","modified":1646898766261},{"_id":"public/2017/04/19/GetToKnow-this-call-apply/index.html","hash":"e7207b3cce39d620000881c351e94d346b7087e6","modified":1646898766261},{"_id":"public/2017/04/16/Internship-interviews/index.html","hash":"e6d2dc66da6b90fdb02ec977656c63c6068e8fc7","modified":1646898766261},{"_id":"public/2017/04/16/Tecent-Interview-Second/index.html","hash":"5715f09f68187e51b325f56198d98f339086e521","modified":1646898766261},{"_id":"public/2017/04/13/Tecent-Interview-one/index.html","hash":"6c652422a08be051c5b6c05a9ff2118d0425d4dd","modified":1646898766261},{"_id":"public/2017/04/12/webpage-optimize/index.html","hash":"3ed3167ad1cae6057b9c2ba66e7f948eaaeb37ca","modified":1646898766261},{"_id":"public/2017/04/10/cross-origin/index.html","hash":"4fa9f4324148ecc49133f328b154fc53bc4ea430","modified":1646898766261},{"_id":"public/2017/04/09/leetcode-week1/index.html","hash":"38b0f6493f88d5331f9adc485f79efb3d03b6a9a","modified":1646898766261},{"_id":"public/2017/04/06/Closures-learning/index.html","hash":"f7cbb2aa63e0e9d570fd95ab4d6806fddd84d21a","modified":1646898766261},{"_id":"public/2017/04/04/http-learning-1/index.html","hash":"7ff69994b22b592c50c3ba6a92bf447468799f2a","modified":1646898766261},{"_id":"public/2017/04/03/achieve-binary-search-tree/index.html","hash":"703361dc6a40240994c9e9d26586a04ea24dd90c","modified":1646898766261},{"_id":"public/2017/04/03/thoughts/index.html","hash":"f7f9714e5121a5dd0482d18da4240b0bd0e96e23","modified":1646898766261},{"_id":"public/archives/index.html","hash":"9ca4e54a968a8fe87963599b68d060a21a8fa1c1","modified":1646898766261},{"_id":"public/archives/page/2/index.html","hash":"8c5822597333497ab896b32baba330bf09a3371f","modified":1646898766261},{"_id":"public/archives/page/3/index.html","hash":"64821a564c2d5f367ec080681c19ddf1eba560fe","modified":1646898766261},{"_id":"public/archives/page/4/index.html","hash":"4fc4cb7a9c27c163ea0d3ff955171175bfc3aa07","modified":1646898766261},{"_id":"public/archives/page/5/index.html","hash":"7936c9097a78f0c6f1bd1da83cf8b2fff693e58a","modified":1646898766261},{"_id":"public/archives/2017/index.html","hash":"641e45e2e1271dd8ae67ac08ede7da3e55878715","modified":1646898766261},{"_id":"public/archives/2017/page/2/index.html","hash":"58d98461b0de87b2793f234cb715331f801a94b6","modified":1646898766261},{"_id":"public/archives/2017/page/3/index.html","hash":"173e5a7b74fc4264e04f5725af4e5c359edf7279","modified":1646898766261},{"_id":"public/archives/2017/04/index.html","hash":"a88cce714c7ebc6939eae44025846a0ec0b849a4","modified":1646898766261},{"_id":"public/archives/2017/04/page/2/index.html","hash":"f55390fdc719e7366ebbd17387f38dc1151bc4db","modified":1646898766261},{"_id":"public/archives/2017/05/index.html","hash":"2caf9b458c96528a7fdbd00f2d26d1220972f0ed","modified":1646898766261},{"_id":"public/archives/2017/07/index.html","hash":"9fc6e396b382f6b548774ad33f1423b85c07d91d","modified":1646898766261},{"_id":"public/archives/2017/08/index.html","hash":"185a40b60717f88283ef9a4cbb23003e555fead2","modified":1646898766261},{"_id":"public/archives/2017/09/index.html","hash":"1efba5ad851264f362e52dd1ac8db6df002f0551","modified":1646898766261},{"_id":"public/archives/2018/index.html","hash":"6bd61e70dcada7000a07b9f89d4cafdfa354cee5","modified":1646898766261},{"_id":"public/archives/2018/12/index.html","hash":"6bd61e70dcada7000a07b9f89d4cafdfa354cee5","modified":1646898766261},{"_id":"public/archives/2019/index.html","hash":"5b45efdf21a5f3a6964426f1f8de54b072bea43d","modified":1646898766261},{"_id":"public/archives/2019/01/index.html","hash":"0db95b80a436145d1953f55ed3c323ace3a47262","modified":1646898766261},{"_id":"public/archives/2019/02/index.html","hash":"c56bea7c118d18bc18d3b05271465de51285696f","modified":1646898766261},{"_id":"public/archives/2019/08/index.html","hash":"1788b4a619ebd23576ef03c64118267c3caa7928","modified":1646898766261},{"_id":"public/archives/2020/index.html","hash":"a5f0dad8b476f08d009df7eacc81dd3e3a50214e","modified":1646898766261},{"_id":"public/archives/2020/01/index.html","hash":"a5f0dad8b476f08d009df7eacc81dd3e3a50214e","modified":1646898766261},{"_id":"public/archives/2022/index.html","hash":"89fd0f627211822fc9a14fd6eef8f93bc7624a1f","modified":1646898766261},{"_id":"public/archives/2022/02/index.html","hash":"89fd0f627211822fc9a14fd6eef8f93bc7624a1f","modified":1646898766261},{"_id":"public/categories/算法/index.html","hash":"1ecefc990de7e9c8ee9c46ca598305cc4b855646","modified":1646898766261},{"_id":"public/categories/网络/index.html","hash":"f03232b24e0e525847fbcaf33882b9a27766ecc9","modified":1646898766261},{"_id":"public/categories/JS相关/index.html","hash":"3417e13683621ead67321347027044acd0e0ccf8","modified":1646898766261},{"_id":"public/categories/JS相关/page/2/index.html","hash":"bb0f66de0fcba3ddac4a748c19c89867876569ce","modified":1646898766261},{"_id":"public/categories/Web相关/index.html","hash":"f6bc71bbc3c65cd0861cc4f99fa19622d23229b0","modified":1646898766261},{"_id":"public/categories/经验分享/index.html","hash":"1b53ef4155158d7f59920b941aaf9273c620325b","modified":1646898766261},{"_id":"public/categories/随笔/index.html","hash":"fb68c9044fbf5186162936f1b55d039ba06353a3","modified":1646898766261},{"_id":"public/categories/CSS相关/index.html","hash":"be3a41e6d75f63c683728f0ebe618147becb69a5","modified":1646898766261},{"_id":"public/categories/工具/index.html","hash":"1523aa223a98bd71a2d9f4bdfa5256e47fcfeff4","modified":1646898766261},{"_id":"public/index.html","hash":"b1504abd3103e224de6575356f1c1b4665035e47","modified":1646898766261},{"_id":"public/page/2/index.html","hash":"a870c705db87c3052e3655d89f9523860a36a5da","modified":1646898766261},{"_id":"public/page/3/index.html","hash":"5accdf4d94185e75de3607bda0ebfa0a7338d9a5","modified":1646898766261},{"_id":"public/page/4/index.html","hash":"0864dd72553d92d3262ffb137a648f8987646255","modified":1646898766261},{"_id":"public/page/5/index.html","hash":"298a293ead12a54e24464d1bd41ab27e5860827a","modified":1646898766261},{"_id":"public/page/6/index.html","hash":"a314ce2f2ca895bcdf5535c361dad601df98c963","modified":1646898766261},{"_id":"public/page/7/index.html","hash":"9041a44c98939b905bceafebfb3b7f05a0b0d15d","modified":1646898766261},{"_id":"public/page/8/index.html","hash":"e1657318286cd6de1945404b684b62fa81e73b2a","modified":1646898766261},{"_id":"public/page/9/index.html","hash":"5fdf9ea8320c67375daecc4eb12643a3ff3b4ea1","modified":1646898766261},{"_id":"public/tags/二叉树/index.html","hash":"bfc921881838dacfd27ad049db2665004427a254","modified":1646898766261},{"_id":"public/tags/http/index.html","hash":"5cf96747e196a9a361cd268e663252b351cce3ce","modified":1646898766261},{"_id":"public/tags/闭包/index.html","hash":"3e51f3f6a73664c3c3b211bbfd224854e5aadde5","modified":1646898766261},{"_id":"public/tags/leetcode/index.html","hash":"45b5f5bd1917f965dacd2d38ebb7569c9704afce","modified":1646898766261},{"_id":"public/tags/跨域/index.html","hash":"1da49befd50cd2f289c0182a7162b94be5d24d8c","modified":1646898766261},{"_id":"public/tags/性能优化/index.html","hash":"432dbf50b2b98183f4fb9778206698248b5caa83","modified":1646898766261},{"_id":"public/tags/实习面试/index.html","hash":"df2b76bab05a9b06e77be795d2c4958bb816b060","modified":1646898766261},{"_id":"public/tags/JS原理/index.html","hash":"2357d98112a7a06a8532c823782e11477acbb066","modified":1646898766261},{"_id":"public/tags/状态码/index.html","hash":"185ad576c12f81539e504c131493f0a50e1485ca","modified":1646898766261},{"_id":"public/tags/throttle/index.html","hash":"1aeae1936c5565319694431c10a488218df1a21c","modified":1646898766261},{"_id":"public/tags/debounce/index.html","hash":"5cd36f81657aae96d273ad62b2e6fc046dbc7598","modified":1646898766261},{"_id":"public/tags/思考感悟/index.html","hash":"a245f7ac0fcfaeb04bc2221e41197b39129129ce","modified":1646898766261},{"_id":"public/tags/CSS技巧/index.html","hash":"df1aa4c4adbce0bace2b1bed4a39dfa8a007fbe0","modified":1646898766261},{"_id":"public/tags/React/index.html","hash":"da9e8becb6f9bdcd27a1fbe47b891f075d078aaf","modified":1646898766261},{"_id":"public/tags/前端框架/index.html","hash":"7423a17866eca2c049dcaeb6ee878a2fc96a761e","modified":1646898766261},{"_id":"public/tags/state/index.html","hash":"6031815d03496db9d1a0f655026ea6c9daa7abb5","modified":1646898766261},{"_id":"public/tags/对象/index.html","hash":"b6b2c371e03c49f73da946a3f71a2071f2cee382","modified":1646898766261},{"_id":"public/tags/JS技巧/index.html","hash":"76d26af80a654c77daf5646ee66ad8e650d28908","modified":1646898766261},{"_id":"public/tags/类/index.html","hash":"931f4c7f50f33c3ceda8ef2f7589c3cbf0531303","modified":1646898766261},{"_id":"public/tags/Cookies/index.html","hash":"ec4ad78060fdd41ddabffe9b30c6ec1669ccc596","modified":1646898766261},{"_id":"public/tags/VSCode/index.html","hash":"4894af7e787de6e1fa06914069c88a7b64e3d92a","modified":1646898766261},{"_id":"public/tags/排序/index.html","hash":"a81e2bc987b74206ee1b091fa72a95569ecfb1cb","modified":1646898766261},{"_id":"public/tags/编辑器/index.html","hash":"f85ac87e46f0531b8c83c73ab1d54384ed97a2b8","modified":1646898766261},{"_id":"public/tags/markdown/index.html","hash":"66e5e3cedd51e2e524f16a0368ad19e2bb8f5f12","modified":1646898766261},{"_id":"public/tags/nodejs/index.html","hash":"b669e4cf493d589dcd26622c10ebe5a4a563c676","modified":1646898766261},{"_id":"public/tags/职业规划/index.html","hash":"29e3557666f61202cd74113dfb399cdabd098400","modified":1646898766261},{"_id":"public/tags/git/index.html","hash":"7c0a80e6666dcf217ae7e9e458fafb71db09b483","modified":1646898766261},{"_id":"public/tags/源码分析/index.html","hash":"441469a7a89679ae9fb334330536b067b87774c6","modified":1646898766261},{"_id":"public/tags/前端监控/index.html","hash":"c5002f67a5d9e5654bfd57053fbd38d21fb2a4c5","modified":1646898766261},{"_id":"public/tags/录制回放/index.html","hash":"393b67308729afb3632e3bb84df0f85af7655f55","modified":1646898766261},{"_id":"public/tags/thoughts/index.html","hash":"e5a11f8ef5b583c556d5a61a2f83c25f39fcbbe7","modified":1646898766261},{"_id":"public/favicon.ico","hash":"f92d0773e9634ed052f9934e48aed4a362bdc746","modified":1646898766261},{"_id":"public/images/ip-group.jpg","hash":"6d6fbafa1d5ed8893df83b63248a44a5529152dc","modified":1646898766261},{"_id":"public/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1646898766261},{"_id":"public/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1646898766261},{"_id":"public/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1646898766261},{"_id":"public/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1646898766261},{"_id":"public/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1646898766261},{"_id":"public/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1646898766261},{"_id":"public/images/WechatQR.png","hash":"c3c9f25958413a4652e98d98413deb1b0382865c","modified":1646898766261},{"_id":"public/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1646898766261},{"_id":"public/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1646898766261},{"_id":"public/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1646898766261},{"_id":"public/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1646898766261},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1646898766261},{"_id":"public/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1646898766261},{"_id":"public/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1646898766261},{"_id":"public/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1646898766261},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1646898766261},{"_id":"public/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1646898766261},{"_id":"public/js/search.js","hash":"6fdfd143646d12b8dbef9b5809cea768192f08aa","modified":1646898766261},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1646898766261},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1646898766261},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1646898766261},{"_id":"public/css/style.css","hash":"a9be1af00cdbd2d164fdf67c75db3c752c1dea4a","modified":1646898766261}],"Category":[{"name":"算法","_id":"cl0kp05by0004ra4kf88u16vn"},{"name":"网络","_id":"cl0kp05c3000bra4k4di03ky5"},{"name":"JS相关","_id":"cl0kp05c7000hra4k4qls3fc0"},{"name":"Web相关","_id":"cl0kp05ca000ora4ke0edek3h"},{"name":"经验分享","_id":"cl0kp05ci0010ra4kcod3ev1d"},{"name":"随笔","_id":"cl0kp05ct001mra4kh20qfor7"},{"name":"CSS相关","_id":"cl0kp05cw001ura4kb14wftj7"},{"name":"工具","_id":"cl0kp05d10028ra4k1kh33s3b"}],"Data":[],"Page":[{"title":"关于","date":"2022-02-24T07:49:24.000Z","layout":"about","_content":"\n欢迎来到西蒙的实验室！\n\n本人目前居住于广州，是一枚前端工程师，爱好看书、编程、玩游戏。\n\n在这里我会分享技术上的一些学习感悟，也会分享生活的趣事，不定时更新。\n\n欢迎留言讨论，不管是技术上还是生活上，期待与您一起分享～\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2022-02-24 15:49:24\nlayout: about\n---\n\n欢迎来到西蒙的实验室！\n\n本人目前居住于广州，是一枚前端工程师，爱好看书、编程、玩游戏。\n\n在这里我会分享技术上的一些学习感悟，也会分享生活的趣事，不定时更新。\n\n欢迎留言讨论，不管是技术上还是生活上，期待与您一起分享～\n","updated":"2022-03-10T07:44:32.628Z","path":"about/index.html","comments":1,"_id":"cl0kp05bq0000ra4khhju0x6w","content":"<p>欢迎来到西蒙的实验室！</p>\n<p>本人目前居住于广州，是一枚前端工程师，爱好看书、编程、玩游戏。</p>\n<p>在这里我会分享技术上的一些学习感悟，也会分享生活的趣事，不定时更新。</p>\n<p>欢迎留言讨论，不管是技术上还是生活上，期待与您一起分享～</p>\n","site":{"data":{}},"excerpt":"","more":"<p>欢迎来到西蒙的实验室！</p>\n<p>本人目前居住于广州，是一枚前端工程师，爱好看书、编程、玩游戏。</p>\n<p>在这里我会分享技术上的一些学习感悟，也会分享生活的趣事，不定时更新。</p>\n<p>欢迎留言讨论，不管是技术上还是生活上，期待与您一起分享～</p>\n"},{"title":"categories","date":"2017-04-06T15:24:58.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-04-06 23:24:58\ntype: categories\ncomments: false\n---\n","updated":"2022-03-10T07:44:32.628Z","path":"categories/index.html","layout":"page","_id":"cl0kp05bv0002ra4k4dav17nz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"guestbook","date":"2017-04-03T05:46:52.000Z","_content":"","source":"guestbook/index.md","raw":"---\ntitle: guestbook\ndate: 2017-04-03 13:46:52\n---\n","updated":"2022-03-10T07:44:32.628Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"cl0kp05bz0006ra4khhaohki9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-04-06T15:32:50.000Z","type":"tags","layout":"tagcloud","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-04-06 23:32:50\ntype: tags\nlayout: tagcloud\ncomments: false\n---\n","updated":"2022-03-10T07:44:32.628Z","path":"tags/index.html","_id":"cl0kp05c10008ra4kdmtnfayd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"二叉搜索树JavaScript实现","date":"2017-04-03T06:24:32.000Z","_content":"\n### 什么是二叉搜索树\n其形式就是二叉树，对于每个节点x，其左子树的值<=x.value，右子树的值>=x.value。\n<!--more-->\n### 二叉搜索树的遍历与查询\n\n对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。\n```\nfunction inorderTreeWalk(x) {\n  if(x!== null) {\n    inorderTreeWalk(x.left);\n    print(x.key);\n    inorderTreeWalk(x.right);\n  }  \n}\n```\n\n当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：\n```\nfunction treeSearch(x,k) {  //最开始x代表根节点\n  if(x === null || x.key === k) {\n    return x;\n  }\n  if(k < x.key) {\n    return treeSearch(x.left, k);\n  } else {\n    return treeSearch(x.right, k);\n  }\n}\n```\n我们还可以写出循环版本（一般比递归更高效）:\n```\nfunction treeSearch(x, k) {\n  while(x !== null || k !== x.key) {\n    if(k < x.key) {\n      x = x.left;\n    } else {\n      x = x.right;\n    }\n  }\n  return x;\n}\n```\n我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：\n```\nfunction treeMinimum(x) {\n  while(x.left !== null) {\n    x = x.left;\n  }\n  return x;\n}\n\nfunction treeMaximum(x) {\n  while(x.right !== null) {\n    x = x.right;\n  }\n  return x;\n}\n```\n有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：\n```\nfunction treeSuccessor(x) {  //后继查找\n  if(x.right !== null) {\n    return treeMinimum(x.right);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.right) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n\nfunction treeSuccessor(x) {  //前驱查找\n  if(x.left !== null) {\n    return treeMaximum(x.left);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.left) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n```\n### 二叉搜索树实现插入和删除操作。\n　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。\n　　```\n        function treeInsert(tree, newNode) {\n          let y = null;\n          while(tree !== null) {\n            y = tree;\n            if(newNode.key < tree.key) {\n              tree = tree.left;\n            } else {\n              tree = tree.right;\n            }\n          }\n          newNode.parent = y;\n          if(y === null) {  // 树为空\n            tree.root = newNode;\n          } else {\n            if(newNode.key < y.key) {\n              y.left = newNode;\n            } else {\n              y.right = newNode;\n            }\n          }\n        }\n        ```\n　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。\n　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。\n　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。\n　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。\n        ```\n        function transplant(tree, u, v) {  //子树替换父节点方法\n          if(u.p === null) {\n            tree.root = v;\n          } else if(u === u.parent.left) {\n            u.parent.left = v;\n          } else {\n            u.parent.right = v;\n          }\n          if(v !== null) {\n            v.parent = u.parent;\n          }\n        }\n\n        function treeDelete(tree, z) {\n          if(z.left === null) {\n            transplant(tree, z, z.right);\n          } else if(z.right === null) {\n            transplant(tree, z, z.left);\n          } else {\n            let y = treeMinimum(z.right);\n            if(y.parent !== z) {\n              transplant(tree, y, y.right);\n              y.right = z.right;\n              y.right.parent = y;\n            }\n            transplant(tree, z, y);\n            y.left = z.left;\n            y.left.parent = y;\n          }\n        }\n        ```\n**至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》**\n","source":"_posts/2017-04-03-achieve-binary-search-tree.md","raw":"---\ntitle: 二叉搜索树JavaScript实现\ndate: 2017-04-03 14:24:32\ntags: \n- 二叉树\ncategories: 算法\n---\n\n### 什么是二叉搜索树\n其形式就是二叉树，对于每个节点x，其左子树的值<=x.value，右子树的值>=x.value。\n<!--more-->\n### 二叉搜索树的遍历与查询\n\n对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。\n```\nfunction inorderTreeWalk(x) {\n  if(x!== null) {\n    inorderTreeWalk(x.left);\n    print(x.key);\n    inorderTreeWalk(x.right);\n  }  \n}\n```\n\n当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：\n```\nfunction treeSearch(x,k) {  //最开始x代表根节点\n  if(x === null || x.key === k) {\n    return x;\n  }\n  if(k < x.key) {\n    return treeSearch(x.left, k);\n  } else {\n    return treeSearch(x.right, k);\n  }\n}\n```\n我们还可以写出循环版本（一般比递归更高效）:\n```\nfunction treeSearch(x, k) {\n  while(x !== null || k !== x.key) {\n    if(k < x.key) {\n      x = x.left;\n    } else {\n      x = x.right;\n    }\n  }\n  return x;\n}\n```\n我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：\n```\nfunction treeMinimum(x) {\n  while(x.left !== null) {\n    x = x.left;\n  }\n  return x;\n}\n\nfunction treeMaximum(x) {\n  while(x.right !== null) {\n    x = x.right;\n  }\n  return x;\n}\n```\n有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：\n```\nfunction treeSuccessor(x) {  //后继查找\n  if(x.right !== null) {\n    return treeMinimum(x.right);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.right) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n\nfunction treeSuccessor(x) {  //前驱查找\n  if(x.left !== null) {\n    return treeMaximum(x.left);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.left) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n```\n### 二叉搜索树实现插入和删除操作。\n　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。\n　　```\n        function treeInsert(tree, newNode) {\n          let y = null;\n          while(tree !== null) {\n            y = tree;\n            if(newNode.key < tree.key) {\n              tree = tree.left;\n            } else {\n              tree = tree.right;\n            }\n          }\n          newNode.parent = y;\n          if(y === null) {  // 树为空\n            tree.root = newNode;\n          } else {\n            if(newNode.key < y.key) {\n              y.left = newNode;\n            } else {\n              y.right = newNode;\n            }\n          }\n        }\n        ```\n　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。\n　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。\n　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。\n　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。\n        ```\n        function transplant(tree, u, v) {  //子树替换父节点方法\n          if(u.p === null) {\n            tree.root = v;\n          } else if(u === u.parent.left) {\n            u.parent.left = v;\n          } else {\n            u.parent.right = v;\n          }\n          if(v !== null) {\n            v.parent = u.parent;\n          }\n        }\n\n        function treeDelete(tree, z) {\n          if(z.left === null) {\n            transplant(tree, z, z.right);\n          } else if(z.right === null) {\n            transplant(tree, z, z.left);\n          } else {\n            let y = treeMinimum(z.right);\n            if(y.parent !== z) {\n              transplant(tree, y, y.right);\n              y.right = z.right;\n              y.right.parent = y;\n            }\n            transplant(tree, z, y);\n            y.left = z.left;\n            y.left.parent = y;\n          }\n        }\n        ```\n**至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》**\n","slug":"achieve-binary-search-tree","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05bs0001ra4k5hnja2li","content":"<h3 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h3><p>其形式就是二叉树，对于每个节点x，其左子树的值&lt;&#x3D;x.value，右子树的值&gt;&#x3D;x.value。</p>\n<span id=\"more\"></span>\n<h3 id=\"二叉搜索树的遍历与查询\"><a href=\"#二叉搜索树的遍历与查询\" class=\"headerlink\" title=\"二叉搜索树的遍历与查询\"></a>二叉搜索树的遍历与查询</h3><p>对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inorderTreeWalk(x) &#123;</span><br><span class=\"line\">  if(x!== null) &#123;</span><br><span class=\"line\">    inorderTreeWalk(x.left);</span><br><span class=\"line\">    print(x.key);</span><br><span class=\"line\">    inorderTreeWalk(x.right);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x,k) &#123;  //最开始x代表根节点</span><br><span class=\"line\">  if(x === null || x.key === k) &#123;</span><br><span class=\"line\">    return x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(k &lt; x.key) &#123;</span><br><span class=\"line\">    return treeSearch(x.left, k);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return treeSearch(x.right, k);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以写出循环版本（一般比递归更高效）:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x, k) &#123;</span><br><span class=\"line\">  while(x !== null || k !== x.key) &#123;</span><br><span class=\"line\">    if(k &lt; x.key) &#123;</span><br><span class=\"line\">      x = x.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      x = x.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeMinimum(x) &#123;</span><br><span class=\"line\">  while(x.left !== null) &#123;</span><br><span class=\"line\">    x = x.left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeMaximum(x) &#123;</span><br><span class=\"line\">  while(x.right !== null) &#123;</span><br><span class=\"line\">    x = x.right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSuccessor(x) &#123;  //后继查找</span><br><span class=\"line\">  if(x.right !== null) &#123;</span><br><span class=\"line\">    return treeMinimum(x.right);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.right) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeSuccessor(x) &#123;  //前驱查找</span><br><span class=\"line\">  if(x.left !== null) &#123;</span><br><span class=\"line\">    return treeMaximum(x.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.left) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉搜索树实现插入和删除操作。\"><a href=\"#二叉搜索树实现插入和删除操作。\" class=\"headerlink\" title=\"二叉搜索树实现插入和删除操作。\"></a>二叉搜索树实现插入和删除操作。</h3><p>　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。<br>　　<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeInsert(tree, newNode) &#123;</span><br><span class=\"line\">  let y = null;</span><br><span class=\"line\">  while(tree !== null) &#123;</span><br><span class=\"line\">    y = tree;</span><br><span class=\"line\">    if(newNode.key &lt; tree.key) &#123;</span><br><span class=\"line\">      tree = tree.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      tree = tree.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  newNode.parent = y;</span><br><span class=\"line\">  if(y === null) &#123;  // 树为空</span><br><span class=\"line\">    tree.root = newNode;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    if(newNode.key &lt; y.key) &#123;</span><br><span class=\"line\">      y.left = newNode;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      y.right = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。<br>　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。<br>　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。<br>　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。<br>        <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transplant(tree, u, v) &#123;  //子树替换父节点方法</span><br><span class=\"line\">  if(u.p === null) &#123;</span><br><span class=\"line\">    tree.root = v;</span><br><span class=\"line\">  &#125; else if(u === u.parent.left) &#123;</span><br><span class=\"line\">    u.parent.left = v;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    u.parent.right = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(v !== null) &#123;</span><br><span class=\"line\">    v.parent = u.parent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeDelete(tree, z) &#123;</span><br><span class=\"line\">  if(z.left === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.right);</span><br><span class=\"line\">  &#125; else if(z.right === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = treeMinimum(z.right);</span><br><span class=\"line\">    if(y.parent !== z) &#123;</span><br><span class=\"line\">      transplant(tree, y, y.right);</span><br><span class=\"line\">      y.right = z.right;</span><br><span class=\"line\">      y.right.parent = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    transplant(tree, z, y);</span><br><span class=\"line\">    y.left = z.left;</span><br><span class=\"line\">    y.left.parent = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》</strong></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h3><p>其形式就是二叉树，对于每个节点x，其左子树的值&lt;&#x3D;x.value，右子树的值&gt;&#x3D;x.value。</p>","more":"<h3 id=\"二叉搜索树的遍历与查询\"><a href=\"#二叉搜索树的遍历与查询\" class=\"headerlink\" title=\"二叉搜索树的遍历与查询\"></a>二叉搜索树的遍历与查询</h3><p>对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inorderTreeWalk(x) &#123;</span><br><span class=\"line\">  if(x!== null) &#123;</span><br><span class=\"line\">    inorderTreeWalk(x.left);</span><br><span class=\"line\">    print(x.key);</span><br><span class=\"line\">    inorderTreeWalk(x.right);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x,k) &#123;  //最开始x代表根节点</span><br><span class=\"line\">  if(x === null || x.key === k) &#123;</span><br><span class=\"line\">    return x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(k &lt; x.key) &#123;</span><br><span class=\"line\">    return treeSearch(x.left, k);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return treeSearch(x.right, k);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以写出循环版本（一般比递归更高效）:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x, k) &#123;</span><br><span class=\"line\">  while(x !== null || k !== x.key) &#123;</span><br><span class=\"line\">    if(k &lt; x.key) &#123;</span><br><span class=\"line\">      x = x.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      x = x.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeMinimum(x) &#123;</span><br><span class=\"line\">  while(x.left !== null) &#123;</span><br><span class=\"line\">    x = x.left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeMaximum(x) &#123;</span><br><span class=\"line\">  while(x.right !== null) &#123;</span><br><span class=\"line\">    x = x.right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSuccessor(x) &#123;  //后继查找</span><br><span class=\"line\">  if(x.right !== null) &#123;</span><br><span class=\"line\">    return treeMinimum(x.right);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.right) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeSuccessor(x) &#123;  //前驱查找</span><br><span class=\"line\">  if(x.left !== null) &#123;</span><br><span class=\"line\">    return treeMaximum(x.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.left) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉搜索树实现插入和删除操作。\"><a href=\"#二叉搜索树实现插入和删除操作。\" class=\"headerlink\" title=\"二叉搜索树实现插入和删除操作。\"></a>二叉搜索树实现插入和删除操作。</h3><p>　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。<br>　　<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeInsert(tree, newNode) &#123;</span><br><span class=\"line\">  let y = null;</span><br><span class=\"line\">  while(tree !== null) &#123;</span><br><span class=\"line\">    y = tree;</span><br><span class=\"line\">    if(newNode.key &lt; tree.key) &#123;</span><br><span class=\"line\">      tree = tree.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      tree = tree.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  newNode.parent = y;</span><br><span class=\"line\">  if(y === null) &#123;  // 树为空</span><br><span class=\"line\">    tree.root = newNode;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    if(newNode.key &lt; y.key) &#123;</span><br><span class=\"line\">      y.left = newNode;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      y.right = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。<br>　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。<br>　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。<br>　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。<br>        <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transplant(tree, u, v) &#123;  //子树替换父节点方法</span><br><span class=\"line\">  if(u.p === null) &#123;</span><br><span class=\"line\">    tree.root = v;</span><br><span class=\"line\">  &#125; else if(u === u.parent.left) &#123;</span><br><span class=\"line\">    u.parent.left = v;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    u.parent.right = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(v !== null) &#123;</span><br><span class=\"line\">    v.parent = u.parent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeDelete(tree, z) &#123;</span><br><span class=\"line\">  if(z.left === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.right);</span><br><span class=\"line\">  &#125; else if(z.right === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = treeMinimum(z.right);</span><br><span class=\"line\">    if(y.parent !== z) &#123;</span><br><span class=\"line\">      transplant(tree, y, y.right);</span><br><span class=\"line\">      y.right = z.right;</span><br><span class=\"line\">      y.right.parent = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    transplant(tree, z, y);</span><br><span class=\"line\">    y.left = z.left;</span><br><span class=\"line\">    y.left.parent = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》</strong></p>"},{"title":"深入学习HTTP连接","date":"2017-04-04T12:43:32.000Z","_content":"\n## 什么是HTTP协议？\n---\nHTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。\n只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。\n<!--more-->\n### 为什么说HTTP是无状态的？\n---\n无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。\n缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。\n\n## HTTP连接\n在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP/IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：\n\n - 浏览器从URL中解析出服务器的主机名;\n - 浏览器通过DNS将主机名转换成服务器的IP地址;\n - 浏览器将端口号(默认80)从URL中解析出来;\n - 浏览器建立一条与Web服务器的TCP连接;\n - 浏览器向服务器发送一条HTTP请求报文;\n - 服务器向浏览器回送一条HTTP响应报文;\n - 关闭连接，浏览器渲染文档并显示;\n\n当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。\n\n### TCP连接\n---\n我们知道，HTTP协议依赖TCP/IP来进行通信。那么什么是TCP/IP呢？TCP/IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。\n#### TCP数据传输\n- TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。\n- 传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：\n    * 一个IP分组首部（通常为20字节）;\n    * 一个TCP段首部（通常为20字节）;\n    * 一个TCP数据块（0个或多个字节）;\n    ![ip分组](/images/ip-group.jpg \"IP分组\")\n- TCP连接通过4个值来识别：<源IP地址、源端口号、目的IP地址、目的端口号>，这4个值一起唯一地定义了一条连接。\n### TCP性能考虑\n- **HTTP事务的时延**：一般影响HTTP事务的时延主要有以下几点原因：\n    1. 解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。\n    2. 发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。\n    3. 连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间\n    总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。\n- **TCP握手时延**：TCP连接需要经过三次握手，一般步骤如下：\n    1. 请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。\n    2. 服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。\n    3. 客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）\n- **TCP延迟确认**：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。\n- **TCP慢启动**：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。\n由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。\n- **Nagle算法问题**：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。\nNagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。\n所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。\n- **TIME_WAIT、端口耗尽**：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。\n","source":"_posts/2017-04-04-http-learning-1.md","raw":"---\ntitle: 深入学习HTTP连接\ndate: 2017-04-04 20:43:32\ntags: http\ncategories: 网络\n---\n\n## 什么是HTTP协议？\n---\nHTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。\n只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。\n<!--more-->\n### 为什么说HTTP是无状态的？\n---\n无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。\n缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。\n\n## HTTP连接\n在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP/IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：\n\n - 浏览器从URL中解析出服务器的主机名;\n - 浏览器通过DNS将主机名转换成服务器的IP地址;\n - 浏览器将端口号(默认80)从URL中解析出来;\n - 浏览器建立一条与Web服务器的TCP连接;\n - 浏览器向服务器发送一条HTTP请求报文;\n - 服务器向浏览器回送一条HTTP响应报文;\n - 关闭连接，浏览器渲染文档并显示;\n\n当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。\n\n### TCP连接\n---\n我们知道，HTTP协议依赖TCP/IP来进行通信。那么什么是TCP/IP呢？TCP/IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。\n#### TCP数据传输\n- TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。\n- 传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：\n    * 一个IP分组首部（通常为20字节）;\n    * 一个TCP段首部（通常为20字节）;\n    * 一个TCP数据块（0个或多个字节）;\n    ![ip分组](/images/ip-group.jpg \"IP分组\")\n- TCP连接通过4个值来识别：<源IP地址、源端口号、目的IP地址、目的端口号>，这4个值一起唯一地定义了一条连接。\n### TCP性能考虑\n- **HTTP事务的时延**：一般影响HTTP事务的时延主要有以下几点原因：\n    1. 解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。\n    2. 发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。\n    3. 连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间\n    总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。\n- **TCP握手时延**：TCP连接需要经过三次握手，一般步骤如下：\n    1. 请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。\n    2. 服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。\n    3. 客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）\n- **TCP延迟确认**：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。\n- **TCP慢启动**：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。\n由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。\n- **Nagle算法问题**：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。\nNagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。\n所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。\n- **TIME_WAIT、端口耗尽**：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。\n","slug":"http-learning-1","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05bw0003ra4k9kluhwxm","content":"<h2 id=\"什么是HTTP协议？\"><a href=\"#什么是HTTP协议？\" class=\"headerlink\" title=\"什么是HTTP协议？\"></a>什么是HTTP协议？</h2><hr>\n<p>HTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP&#x2F;IP。<br>只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。</p>\n<span id=\"more\"></span>\n<h3 id=\"为什么说HTTP是无状态的？\"><a href=\"#为什么说HTTP是无状态的？\" class=\"headerlink\" title=\"为什么说HTTP是无状态的？\"></a>为什么说HTTP是无状态的？</h3><hr>\n<p>无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。<br>缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。</p>\n<h2 id=\"HTTP连接\"><a href=\"#HTTP连接\" class=\"headerlink\" title=\"HTTP连接\"></a>HTTP连接</h2><p>在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP&#x2F;IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：</p>\n<ul>\n<li>浏览器从URL中解析出服务器的主机名;</li>\n<li>浏览器通过DNS将主机名转换成服务器的IP地址;</li>\n<li>浏览器将端口号(默认80)从URL中解析出来;</li>\n<li>浏览器建立一条与Web服务器的TCP连接;</li>\n<li>浏览器向服务器发送一条HTTP请求报文;</li>\n<li>服务器向浏览器回送一条HTTP响应报文;</li>\n<li>关闭连接，浏览器渲染文档并显示;</li>\n</ul>\n<p>当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。</p>\n<h3 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h3><hr>\n<p>我们知道，HTTP协议依赖TCP&#x2F;IP来进行通信。那么什么是TCP&#x2F;IP呢？TCP&#x2F;IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。</p>\n<h4 id=\"TCP数据传输\"><a href=\"#TCP数据传输\" class=\"headerlink\" title=\"TCP数据传输\"></a>TCP数据传输</h4><ul>\n<li>TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。</li>\n<li>传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：<ul>\n<li>一个IP分组首部（通常为20字节）;</li>\n<li>一个TCP段首部（通常为20字节）;</li>\n<li>一个TCP数据块（0个或多个字节）;<br>  <img src=\"/images/ip-group.jpg\" alt=\"ip分组\" title=\"IP分组\"></li>\n</ul>\n</li>\n<li>TCP连接通过4个值来识别：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;，这4个值一起唯一地定义了一条连接。<h3 id=\"TCP性能考虑\"><a href=\"#TCP性能考虑\" class=\"headerlink\" title=\"TCP性能考虑\"></a>TCP性能考虑</h3></li>\n<li><strong>HTTP事务的时延</strong>：一般影响HTTP事务的时延主要有以下几点原因：<ol>\n<li>解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。</li>\n<li>发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。</li>\n<li>连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间<br>  总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。</li>\n</ol>\n</li>\n<li><strong>TCP握手时延</strong>：TCP连接需要经过三次握手，一般步骤如下：<ol>\n<li>请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。</li>\n<li>服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。</li>\n<li>客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）</li>\n</ol>\n</li>\n<li><strong>TCP延迟确认</strong>：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。</li>\n<li><strong>TCP慢启动</strong>：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。<br>由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。</li>\n<li><strong>Nagle算法问题</strong>：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。<br>Nagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。<br>所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。</li>\n<li><strong>TIME_WAIT、端口耗尽</strong>：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是HTTP协议？\"><a href=\"#什么是HTTP协议？\" class=\"headerlink\" title=\"什么是HTTP协议？\"></a>什么是HTTP协议？</h2><hr>\n<p>HTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP&#x2F;IP。<br>只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。</p>","more":"<h3 id=\"为什么说HTTP是无状态的？\"><a href=\"#为什么说HTTP是无状态的？\" class=\"headerlink\" title=\"为什么说HTTP是无状态的？\"></a>为什么说HTTP是无状态的？</h3><hr>\n<p>无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。<br>缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。</p>\n<h2 id=\"HTTP连接\"><a href=\"#HTTP连接\" class=\"headerlink\" title=\"HTTP连接\"></a>HTTP连接</h2><p>在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP&#x2F;IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：</p>\n<ul>\n<li>浏览器从URL中解析出服务器的主机名;</li>\n<li>浏览器通过DNS将主机名转换成服务器的IP地址;</li>\n<li>浏览器将端口号(默认80)从URL中解析出来;</li>\n<li>浏览器建立一条与Web服务器的TCP连接;</li>\n<li>浏览器向服务器发送一条HTTP请求报文;</li>\n<li>服务器向浏览器回送一条HTTP响应报文;</li>\n<li>关闭连接，浏览器渲染文档并显示;</li>\n</ul>\n<p>当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。</p>\n<h3 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h3><hr>\n<p>我们知道，HTTP协议依赖TCP&#x2F;IP来进行通信。那么什么是TCP&#x2F;IP呢？TCP&#x2F;IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。</p>\n<h4 id=\"TCP数据传输\"><a href=\"#TCP数据传输\" class=\"headerlink\" title=\"TCP数据传输\"></a>TCP数据传输</h4><ul>\n<li>TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。</li>\n<li>传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：<ul>\n<li>一个IP分组首部（通常为20字节）;</li>\n<li>一个TCP段首部（通常为20字节）;</li>\n<li>一个TCP数据块（0个或多个字节）;<br>  <img src=\"/images/ip-group.jpg\" alt=\"ip分组\" title=\"IP分组\"></li>\n</ul>\n</li>\n<li>TCP连接通过4个值来识别：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;，这4个值一起唯一地定义了一条连接。<h3 id=\"TCP性能考虑\"><a href=\"#TCP性能考虑\" class=\"headerlink\" title=\"TCP性能考虑\"></a>TCP性能考虑</h3></li>\n<li><strong>HTTP事务的时延</strong>：一般影响HTTP事务的时延主要有以下几点原因：<ol>\n<li>解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。</li>\n<li>发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。</li>\n<li>连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间<br>  总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。</li>\n</ol>\n</li>\n<li><strong>TCP握手时延</strong>：TCP连接需要经过三次握手，一般步骤如下：<ol>\n<li>请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。</li>\n<li>服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。</li>\n<li>客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）</li>\n</ol>\n</li>\n<li><strong>TCP延迟确认</strong>：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。</li>\n<li><strong>TCP慢启动</strong>：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。<br>由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。</li>\n<li><strong>Nagle算法问题</strong>：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。<br>Nagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。<br>所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。</li>\n<li><strong>TIME_WAIT、端口耗尽</strong>：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</li>\n</ul>"},{"title":"深刻理解闭包","date":"2017-04-06T12:45:59.000Z","toc":true,"_content":"\n# 变量的知识\n- 变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。\n- 变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。\n<!--more-->\n\n# 什么是闭包？\n我们先来看个例子\n```javascript\nvar func = function() {\n    var a = 0;\n    return function() {\n        a++;\n        console.log(a);\n    };\n};\nvar f = func();\nf();    // 1\nf();    // 2\nf();    // 3\n```\n当退出函数后，变量a并没有消失，因为调用var f = func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。\n我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。\n\n# 闭包的作用\n- 封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。\n- 延长局部变量寿命：使其不会在退出函数时就立即销毁。\n- 将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。\n\n# 闭包与面向对象设计\n- 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。\n- 闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:\n```javascript\nvar createCommand = function(receiver){\n    var excute = function(){\n        return receiver.open();\n    };\n    var undo = function(){\n        return receiver.close();\n    };\n    return {\n        excute: excute,\n        undo: undo\n    };\n};\n```\n- 闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。\n\n# 闭包的应用\n在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：\n```javascript\nfunction wait(message) {\n    setTimeout( function timer() {\n        console.log( message );\n    }, 1000 );\n}\n\nwait(\"This is a closure!\");\n```\n在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(...)作用域的闭包，因此包含对变量message的引用。wait(...)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(...)作用域的闭包。\n\n# 经典闭包问题\n考虑如下代码：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？\n我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。\n怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i * 1000);\n    })(i);\n}\n```\n这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。\n其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：\n```javascript\nfor(let i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n\n# 闭包在模块中的应用\n考虑以下代码：\n```javascript\nfunction CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n}\n\nvar foo = CoolModule();\nfoo.doSth();\nfoo.doAnother();\n```\n这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。\n简单地说，模块模式需要具备两个必要条件：\n    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）\n    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态\n当只需要一个实例时，我们可以用如下方法实现单例模式：\n```javascript\nvar foo = (function CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n})();\n\nfoo.doSth();\nfoo.doAnother();\n```\n我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。\n","source":"_posts/2017-04-06-Closures-learning.md","raw":"---\ntitle: 深刻理解闭包\ndate: 2017-04-06 20:45:59\ntoc: true\ncategories: \n- JS相关\ntags: \n- 闭包\n---\n\n# 变量的知识\n- 变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。\n- 变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。\n<!--more-->\n\n# 什么是闭包？\n我们先来看个例子\n```javascript\nvar func = function() {\n    var a = 0;\n    return function() {\n        a++;\n        console.log(a);\n    };\n};\nvar f = func();\nf();    // 1\nf();    // 2\nf();    // 3\n```\n当退出函数后，变量a并没有消失，因为调用var f = func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。\n我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。\n\n# 闭包的作用\n- 封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。\n- 延长局部变量寿命：使其不会在退出函数时就立即销毁。\n- 将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。\n\n# 闭包与面向对象设计\n- 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。\n- 闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:\n```javascript\nvar createCommand = function(receiver){\n    var excute = function(){\n        return receiver.open();\n    };\n    var undo = function(){\n        return receiver.close();\n    };\n    return {\n        excute: excute,\n        undo: undo\n    };\n};\n```\n- 闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。\n\n# 闭包的应用\n在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：\n```javascript\nfunction wait(message) {\n    setTimeout( function timer() {\n        console.log( message );\n    }, 1000 );\n}\n\nwait(\"This is a closure!\");\n```\n在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(...)作用域的闭包，因此包含对变量message的引用。wait(...)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(...)作用域的闭包。\n\n# 经典闭包问题\n考虑如下代码：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？\n我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。\n怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i * 1000);\n    })(i);\n}\n```\n这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。\n其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：\n```javascript\nfor(let i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n\n# 闭包在模块中的应用\n考虑以下代码：\n```javascript\nfunction CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n}\n\nvar foo = CoolModule();\nfoo.doSth();\nfoo.doAnother();\n```\n这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。\n简单地说，模块模式需要具备两个必要条件：\n    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）\n    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态\n当只需要一个实例时，我们可以用如下方法实现单例模式：\n```javascript\nvar foo = (function CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n})();\n\nfoo.doSth();\nfoo.doAnother();\n```\n我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。\n","slug":"Closures-learning","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05c00007ra4k3df914cl","content":"<h1 id=\"变量的知识\"><a href=\"#变量的知识\" class=\"headerlink\" title=\"变量的知识\"></a>变量的知识</h1><ul>\n<li>变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。</li>\n<li>变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。<span id=\"more\"></span></li>\n</ul>\n<h1 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h1><p>我们先来看个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"title function_\">func</span>();</span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当退出函数后，变量a并没有消失，因为调用var f &#x3D; func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。<br>我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。</p>\n<h1 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h1><ul>\n<li>封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。</li>\n<li>延长局部变量寿命：使其不会在退出函数时就立即销毁。</li>\n<li>将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。</li>\n</ul>\n<h1 id=\"闭包与面向对象设计\"><a href=\"#闭包与面向对象设计\" class=\"headerlink\" title=\"闭包与面向对象设计\"></a>闭包与面向对象设计</h1><ul>\n<li>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。</li>\n<li>闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCommand = <span class=\"keyword\">function</span>(<span class=\"params\">receiver</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> excute = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">open</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> undo = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">excute</span>: excute,</span><br><span class=\"line\">        <span class=\"attr\">undo</span>: undo</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。</li>\n</ul>\n<h1 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h1><p>在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">wait</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( message );</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">wait</span>(<span class=\"string\">&quot;This is a closure!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(…)作用域的闭包，因此包含对变量message的引用。wait(…)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(…)作用域的闭包。</p>\n<h1 id=\"经典闭包问题\"><a href=\"#经典闭包问题\" class=\"headerlink\" title=\"经典闭包问题\"></a>经典闭包问题</h1><p>考虑如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？<br>我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。<br>怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"keyword\">function</span>(<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">        &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。<br>其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>\n<h1 id=\"闭包在模块中的应用\"><a href=\"#闭包在模块中的应用\" class=\"headerlink\" title=\"闭包在模块中的应用\"></a>闭包在模块中的应用</h1><p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"title class_\">CoolModule</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。<br>简单地说，模块模式需要具备两个必要条件：<br>    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）<br>    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态<br>当只需要一个实例时，我们可以用如下方法实现单例模式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"变量的知识\"><a href=\"#变量的知识\" class=\"headerlink\" title=\"变量的知识\"></a>变量的知识</h1><ul>\n<li>变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。</li>\n<li>变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。","more":"</li>\n</ul>\n<h1 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h1><p>我们先来看个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"title function_\">func</span>();</span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当退出函数后，变量a并没有消失，因为调用var f &#x3D; func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。<br>我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。</p>\n<h1 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h1><ul>\n<li>封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。</li>\n<li>延长局部变量寿命：使其不会在退出函数时就立即销毁。</li>\n<li>将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。</li>\n</ul>\n<h1 id=\"闭包与面向对象设计\"><a href=\"#闭包与面向对象设计\" class=\"headerlink\" title=\"闭包与面向对象设计\"></a>闭包与面向对象设计</h1><ul>\n<li>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。</li>\n<li>闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCommand = <span class=\"keyword\">function</span>(<span class=\"params\">receiver</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> excute = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">open</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> undo = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">excute</span>: excute,</span><br><span class=\"line\">        <span class=\"attr\">undo</span>: undo</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。</li>\n</ul>\n<h1 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h1><p>在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">wait</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( message );</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">wait</span>(<span class=\"string\">&quot;This is a closure!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(…)作用域的闭包，因此包含对变量message的引用。wait(…)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(…)作用域的闭包。</p>\n<h1 id=\"经典闭包问题\"><a href=\"#经典闭包问题\" class=\"headerlink\" title=\"经典闭包问题\"></a>经典闭包问题</h1><p>考虑如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？<br>我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。<br>怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"keyword\">function</span>(<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">        &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。<br>其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>\n<h1 id=\"闭包在模块中的应用\"><a href=\"#闭包在模块中的应用\" class=\"headerlink\" title=\"闭包在模块中的应用\"></a>闭包在模块中的应用</h1><p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"title class_\">CoolModule</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。<br>简单地说，模块模式需要具备两个必要条件：<br>    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）<br>    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态<br>当只需要一个实例时，我们可以用如下方法实现单例模式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>"},{"title":"leetcode刷题ing(week-one)","date":"2017-04-09T12:58:30.000Z","_content":"\n前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。\n其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。\n<!--more-->\n### [Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description)\n> 题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说\"abcad\", \"abcda\"这两个字符串的最大不同子字符串就是它们自己任何一个。\n\n开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。\n\n### [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/#/description)\n> 题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如\"abba\"和\"cddc\"就是同构，\"abcde\"和\"abcdf\"就不是同构。\n\n一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。\n\n### [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/#/description)\n> 题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。\n\n其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。\n\n### [Assign Cookies](https://leetcode.com/problems/assign-cookies/#/description)\n> 题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。\n\n又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。\n\n### [Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/#/description)\n> 题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。\n\n简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)/2个等差数列，然后把结果累加就行了。\n\n### [Counting Bits](https://leetcode.com/problems/counting-bits/#/description)\n> 给定一个数字n统计0～n里每个数字的二进制中1的个数。\n\n主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：\n```javascript\nvar count = 0;\nwhile(n) {\n  count++;\n  n = n & (n-1);\n}\n```\n因为n & (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。\n\n### [Add Digits](https://leetcode.com/problems/add-digits/#/description)\n> 给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num = 38, 3 + 8 = 11, 1 + 1 = 2. 返回2。\n\n这里有一个数学公式，wiki上有[digital_root](https://en.wikipedia.org/wiki/Digital_root#Congruence_formula)，具体我就没推了，直接用结论：dr(n) = 1 + (n - 1) % 9\n","source":"_posts/2017-04-09-leetcode-week1.md","raw":"---\ntitle: leetcode刷题ing(week-one)\ndate: 2017-04-09 20:58:30\ncategories: \n- 算法\ntags: \n- leetcode\n---\n\n前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。\n其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。\n<!--more-->\n### [Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description)\n> 题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说\"abcad\", \"abcda\"这两个字符串的最大不同子字符串就是它们自己任何一个。\n\n开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。\n\n### [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/#/description)\n> 题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如\"abba\"和\"cddc\"就是同构，\"abcde\"和\"abcdf\"就不是同构。\n\n一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。\n\n### [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/#/description)\n> 题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。\n\n其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。\n\n### [Assign Cookies](https://leetcode.com/problems/assign-cookies/#/description)\n> 题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。\n\n又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。\n\n### [Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/#/description)\n> 题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。\n\n简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)/2个等差数列，然后把结果累加就行了。\n\n### [Counting Bits](https://leetcode.com/problems/counting-bits/#/description)\n> 给定一个数字n统计0～n里每个数字的二进制中1的个数。\n\n主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：\n```javascript\nvar count = 0;\nwhile(n) {\n  count++;\n  n = n & (n-1);\n}\n```\n因为n & (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。\n\n### [Add Digits](https://leetcode.com/problems/add-digits/#/description)\n> 给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num = 38, 3 + 8 = 11, 1 + 1 = 2. 返回2。\n\n这里有一个数学公式，wiki上有[digital_root](https://en.wikipedia.org/wiki/Digital_root#Congruence_formula)，具体我就没推了，直接用结论：dr(n) = 1 + (n - 1) % 9\n","slug":"leetcode-week1","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05c20009ra4kg7mr9uca","content":"<p>前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。<br>其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。</p>\n<span id=\"more\"></span>\n<h3 id=\"Longest-Uncommon-Subsequence-I\"><a href=\"#Longest-Uncommon-Subsequence-I\" class=\"headerlink\" title=\"Longest Uncommon Subsequence I\"></a><a href=\"https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description\">Longest Uncommon Subsequence I</a></h3><blockquote>\n<p>题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说”abcad”, “abcda”这两个字符串的最大不同子字符串就是它们自己任何一个。</p>\n</blockquote>\n<p>开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。</p>\n<h3 id=\"Isomorphic-Strings\"><a href=\"#Isomorphic-Strings\" class=\"headerlink\" title=\"Isomorphic Strings\"></a><a href=\"https://leetcode.com/problems/isomorphic-strings/#/description\">Isomorphic Strings</a></h3><blockquote>\n<p>题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如”abba”和”cddc”就是同构，”abcde”和”abcdf”就不是同构。</p>\n</blockquote>\n<p>一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。</p>\n<h3 id=\"Queue-Reconstruction-by-Height\"><a href=\"#Queue-Reconstruction-by-Height\" class=\"headerlink\" title=\"Queue Reconstruction by Height\"></a><a href=\"https://leetcode.com/problems/queue-reconstruction-by-height/#/description\">Queue Reconstruction by Height</a></h3><blockquote>\n<p>题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。</p>\n</blockquote>\n<p>其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。</p>\n<h3 id=\"Assign-Cookies\"><a href=\"#Assign-Cookies\" class=\"headerlink\" title=\"Assign Cookies\"></a><a href=\"https://leetcode.com/problems/assign-cookies/#/description\">Assign Cookies</a></h3><blockquote>\n<p>题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。</p>\n</blockquote>\n<p>又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。</p>\n<h3 id=\"Arithmetic-Slices\"><a href=\"#Arithmetic-Slices\" class=\"headerlink\" title=\"Arithmetic Slices\"></a><a href=\"https://leetcode.com/problems/arithmetic-slices/#/description\">Arithmetic Slices</a></h3><blockquote>\n<p>题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。</p>\n</blockquote>\n<p>简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)&#x2F;2个等差数列，然后把结果累加就行了。</p>\n<h3 id=\"Counting-Bits\"><a href=\"#Counting-Bits\" class=\"headerlink\" title=\"Counting Bits\"></a><a href=\"https://leetcode.com/problems/counting-bits/#/description\">Counting Bits</a></h3><blockquote>\n<p>给定一个数字n统计0～n里每个数字的二进制中1的个数。</p>\n</blockquote>\n<p>主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">  count++;</span><br><span class=\"line\">  n = n &amp; (n-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为n &amp; (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。</p>\n<h3 id=\"Add-Digits\"><a href=\"#Add-Digits\" class=\"headerlink\" title=\"Add Digits\"></a><a href=\"https://leetcode.com/problems/add-digits/#/description\">Add Digits</a></h3><blockquote>\n<p>给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num &#x3D; 38, 3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2. 返回2。</p>\n</blockquote>\n<p>这里有一个数学公式，wiki上有<a href=\"https://en.wikipedia.org/wiki/Digital_root#Congruence_formula\">digital_root</a>，具体我就没推了，直接用结论：dr(n) &#x3D; 1 + (n - 1) % 9</p>\n","site":{"data":{}},"excerpt":"<p>前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。<br>其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。</p>","more":"<h3 id=\"Longest-Uncommon-Subsequence-I\"><a href=\"#Longest-Uncommon-Subsequence-I\" class=\"headerlink\" title=\"Longest Uncommon Subsequence I\"></a><a href=\"https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description\">Longest Uncommon Subsequence I</a></h3><blockquote>\n<p>题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说”abcad”, “abcda”这两个字符串的最大不同子字符串就是它们自己任何一个。</p>\n</blockquote>\n<p>开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。</p>\n<h3 id=\"Isomorphic-Strings\"><a href=\"#Isomorphic-Strings\" class=\"headerlink\" title=\"Isomorphic Strings\"></a><a href=\"https://leetcode.com/problems/isomorphic-strings/#/description\">Isomorphic Strings</a></h3><blockquote>\n<p>题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如”abba”和”cddc”就是同构，”abcde”和”abcdf”就不是同构。</p>\n</blockquote>\n<p>一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。</p>\n<h3 id=\"Queue-Reconstruction-by-Height\"><a href=\"#Queue-Reconstruction-by-Height\" class=\"headerlink\" title=\"Queue Reconstruction by Height\"></a><a href=\"https://leetcode.com/problems/queue-reconstruction-by-height/#/description\">Queue Reconstruction by Height</a></h3><blockquote>\n<p>题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。</p>\n</blockquote>\n<p>其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。</p>\n<h3 id=\"Assign-Cookies\"><a href=\"#Assign-Cookies\" class=\"headerlink\" title=\"Assign Cookies\"></a><a href=\"https://leetcode.com/problems/assign-cookies/#/description\">Assign Cookies</a></h3><blockquote>\n<p>题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。</p>\n</blockquote>\n<p>又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。</p>\n<h3 id=\"Arithmetic-Slices\"><a href=\"#Arithmetic-Slices\" class=\"headerlink\" title=\"Arithmetic Slices\"></a><a href=\"https://leetcode.com/problems/arithmetic-slices/#/description\">Arithmetic Slices</a></h3><blockquote>\n<p>题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。</p>\n</blockquote>\n<p>简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)&#x2F;2个等差数列，然后把结果累加就行了。</p>\n<h3 id=\"Counting-Bits\"><a href=\"#Counting-Bits\" class=\"headerlink\" title=\"Counting Bits\"></a><a href=\"https://leetcode.com/problems/counting-bits/#/description\">Counting Bits</a></h3><blockquote>\n<p>给定一个数字n统计0～n里每个数字的二进制中1的个数。</p>\n</blockquote>\n<p>主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">  count++;</span><br><span class=\"line\">  n = n &amp; (n-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为n &amp; (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。</p>\n<h3 id=\"Add-Digits\"><a href=\"#Add-Digits\" class=\"headerlink\" title=\"Add Digits\"></a><a href=\"https://leetcode.com/problems/add-digits/#/description\">Add Digits</a></h3><blockquote>\n<p>给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num &#x3D; 38, 3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2. 返回2。</p>\n</blockquote>\n<p>这里有一个数学公式，wiki上有<a href=\"https://en.wikipedia.org/wiki/Digital_root#Congruence_formula\">digital_root</a>，具体我就没推了，直接用结论：dr(n) &#x3D; 1 + (n - 1) % 9</p>"},{"title":"浏览器跨域问题","date":"2017-04-10T15:05:26.000Z","_content":"\n最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。\n由于浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：\n<!--more-->\n## document.domain\n我们可以在要传输数据的两个页面设置相同的document.domain=\"www.example.com\"，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如\"www.a.com\"和\"bt.a.com\"，但\"a.com\"和\"b.com\"就不行。\n\n## window.name\n因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。\n\n## CORS\nHTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。\n\n## JSONP\n利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。\n\n## postMessage方法\nHTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。\n接受端通过监听message事件，调用event.data来获取数据。\n","source":"_posts/2017-04-10-cross-origin.md","raw":"---\ntitle: 浏览器跨域问题\ndate: 2017-04-10 23:05:26\ncategories:\n- Web相关\ntags:\n- 跨域\n---\n\n最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。\n由于浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：\n<!--more-->\n## document.domain\n我们可以在要传输数据的两个页面设置相同的document.domain=\"www.example.com\"，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如\"www.a.com\"和\"bt.a.com\"，但\"a.com\"和\"b.com\"就不行。\n\n## window.name\n因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。\n\n## CORS\nHTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。\n\n## JSONP\n利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。\n\n## postMessage方法\nHTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。\n接受端通过监听message事件，调用event.data来获取数据。\n","slug":"cross-origin","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05c3000ara4k4cgf54fc","content":"<p>最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。<br>由于浏览器的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a>，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：</p>\n<span id=\"more\"></span>\n<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>我们可以在要传输数据的两个页面设置相同的document.domain&#x3D;”<a href=\"http://www.example.com&quot;,使其主域相同.但这只有当两个页面的主域相同时才能设置.比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;,但&quot;a.com&quot;和&quot;b.com&quot;就不行./\">www.example.com&quot;，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;，但&quot;a.com&quot;和&quot;b.com&quot;就不行。</a></p>\n<h2 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a>window.name</h2><p>因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。</p>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>HTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。</p>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p>利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。</p>\n<h2 id=\"postMessage方法\"><a href=\"#postMessage方法\" class=\"headerlink\" title=\"postMessage方法\"></a>postMessage方法</h2><p>HTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。<br>接受端通过监听message事件，调用event.data来获取数据。</p>\n","site":{"data":{}},"excerpt":"<p>最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。<br>由于浏览器的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a>，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：</p>","more":"<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>我们可以在要传输数据的两个页面设置相同的document.domain&#x3D;”<a href=\"http://www.example.com&quot;,使其主域相同.但这只有当两个页面的主域相同时才能设置.比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;,但&quot;a.com&quot;和&quot;b.com&quot;就不行./\">www.example.com&quot;，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;，但&quot;a.com&quot;和&quot;b.com&quot;就不行。</a></p>\n<h2 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a>window.name</h2><p>因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。</p>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>HTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。</p>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p>利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。</p>\n<h2 id=\"postMessage方法\"><a href=\"#postMessage方法\" class=\"headerlink\" title=\"postMessage方法\"></a>postMessage方法</h2><p>HTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。<br>接受端通过监听message事件，调用event.data来获取数据。</p>"},{"title":"Web性能优化方案","date":"2017-04-12T15:05:47.000Z","_content":"\n最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：\n<!--more-->\n* 压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积\n* 合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求\n\n* 使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存\n延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。\n* css放在页面头部，js放在页面底部\n* 能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。\n* 异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。\n* 因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。\n* 第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。\n* 使用localStorage缓存一些静态数据，避免去服务器查询。\n* 静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。\n* 减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。\n","source":"_posts/2017-04-12-webpage-optimize.md","raw":"---\ntitle: Web性能优化方案\ndate: 2017-04-12 23:05:47\ncategories:\n- Web相关\ntags:\n- 性能优化\n---\n\n最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：\n<!--more-->\n* 压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积\n* 合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求\n\n* 使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存\n延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。\n* css放在页面头部，js放在页面底部\n* 能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。\n* 异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。\n* 因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。\n* 第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。\n* 使用localStorage缓存一些静态数据，避免去服务器查询。\n* 静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。\n* 减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。\n","slug":"webpage-optimize","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05c5000era4keq5y4m62","content":"<p>最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：</p>\n<span id=\"more\"></span>\n<ul>\n<li><p>压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积</p>\n</li>\n<li><p>合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求</p>\n</li>\n<li><p>使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存<br>延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。</p>\n</li>\n<li><p>css放在页面头部，js放在页面底部</p>\n</li>\n<li><p>能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。</p>\n</li>\n<li><p>异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。</p>\n</li>\n<li><p>因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。</p>\n</li>\n<li><p>第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。</p>\n</li>\n<li><p>使用localStorage缓存一些静态数据，避免去服务器查询。</p>\n</li>\n<li><p>静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。</p>\n</li>\n<li><p>减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：</p>","more":"<ul>\n<li><p>压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积</p>\n</li>\n<li><p>合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求</p>\n</li>\n<li><p>使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存<br>延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。</p>\n</li>\n<li><p>css放在页面头部，js放在页面底部</p>\n</li>\n<li><p>能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。</p>\n</li>\n<li><p>异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。</p>\n</li>\n<li><p>因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。</p>\n</li>\n<li><p>第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。</p>\n</li>\n<li><p>使用localStorage缓存一些静态数据，避免去服务器查询。</p>\n</li>\n<li><p>静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。</p>\n</li>\n<li><p>减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。</p>\n</li>\n</ul>"},{"title":"2017腾讯前端实习生一面总结","date":"2017-04-13T13:56:46.000Z","_content":"\n今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。\n\n到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：\n<!--more-->\n\n首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。\n\n然后面试官又问我一些问题：\n  1. 前端路由怎么控制？\n  2. SPA如何管理内存\n  3. 浏览器发送Cookie服务器接收不到什么原因？\n  4. 了解过web性能优化有哪些吗？\n  5. web存储有哪些？\n  6. 跨域方法有哪些？\n  7. 了解哪些web安全问题？\n  8. 如何防止恶意广告、脚本注入？\n  9. CORS方法跨域数据被劫持怎么办？\n  10. 移动端适配怎么做？\n  11. 了解哪些MVVM框架？\n  12. 手机webApp如何与原生App通信？\n  13. Http状态码了解哪些？\n  14. 浏览器缓存问题     \n  中间还问了几个算法问题：\n  1. 写出一个字符串反转函数\n  2. 5分钟内手写二分查找\n  3. 有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。\n\n\n问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。\n\n之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。\n\n最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。\n\n与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。\n\n不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！\n","source":"_posts/2017-04-13-Tecent-Interview-one.md","raw":"---\ntitle: 2017腾讯前端实习生一面总结\ndate: 2017-04-13 21:56:46\ncategories:\n- 经验分享\ntags:\n- 实习面试\n---\n\n今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。\n\n到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：\n<!--more-->\n\n首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。\n\n然后面试官又问我一些问题：\n  1. 前端路由怎么控制？\n  2. SPA如何管理内存\n  3. 浏览器发送Cookie服务器接收不到什么原因？\n  4. 了解过web性能优化有哪些吗？\n  5. web存储有哪些？\n  6. 跨域方法有哪些？\n  7. 了解哪些web安全问题？\n  8. 如何防止恶意广告、脚本注入？\n  9. CORS方法跨域数据被劫持怎么办？\n  10. 移动端适配怎么做？\n  11. 了解哪些MVVM框架？\n  12. 手机webApp如何与原生App通信？\n  13. Http状态码了解哪些？\n  14. 浏览器缓存问题     \n  中间还问了几个算法问题：\n  1. 写出一个字符串反转函数\n  2. 5分钟内手写二分查找\n  3. 有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。\n\n\n问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。\n\n之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。\n\n最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。\n\n与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。\n\n不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！\n","slug":"Tecent-Interview-one","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05c6000fra4ke30p4m6t","content":"<p>今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。</p>\n<p>到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：</p>\n<span id=\"more\"></span>\n\n<p>首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。</p>\n<p>然后面试官又问我一些问题：</p>\n<ol>\n<li>前端路由怎么控制？</li>\n<li>SPA如何管理内存</li>\n<li>浏览器发送Cookie服务器接收不到什么原因？</li>\n<li>了解过web性能优化有哪些吗？</li>\n<li>web存储有哪些？</li>\n<li>跨域方法有哪些？</li>\n<li>了解哪些web安全问题？</li>\n<li>如何防止恶意广告、脚本注入？</li>\n<li>CORS方法跨域数据被劫持怎么办？</li>\n<li>移动端适配怎么做？</li>\n<li>了解哪些MVVM框架？</li>\n<li>手机webApp如何与原生App通信？</li>\n<li>Http状态码了解哪些？</li>\n<li>浏览器缓存问题<br>  中间还问了几个算法问题：</li>\n<li>写出一个字符串反转函数</li>\n<li>5分钟内手写二分查找</li>\n<li>有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。</li>\n</ol>\n<p>问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。</p>\n<p>之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。</p>\n<p>最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。</p>\n<p>与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。</p>\n<p>不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！</p>\n","site":{"data":{}},"excerpt":"<p>今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。</p>\n<p>到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：</p>","more":"<p>首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。</p>\n<p>然后面试官又问我一些问题：</p>\n<ol>\n<li>前端路由怎么控制？</li>\n<li>SPA如何管理内存</li>\n<li>浏览器发送Cookie服务器接收不到什么原因？</li>\n<li>了解过web性能优化有哪些吗？</li>\n<li>web存储有哪些？</li>\n<li>跨域方法有哪些？</li>\n<li>了解哪些web安全问题？</li>\n<li>如何防止恶意广告、脚本注入？</li>\n<li>CORS方法跨域数据被劫持怎么办？</li>\n<li>移动端适配怎么做？</li>\n<li>了解哪些MVVM框架？</li>\n<li>手机webApp如何与原生App通信？</li>\n<li>Http状态码了解哪些？</li>\n<li>浏览器缓存问题<br>  中间还问了几个算法问题：</li>\n<li>写出一个字符串反转函数</li>\n<li>5分钟内手写二分查找</li>\n<li>有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。</li>\n</ol>\n<p>问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。</p>\n<p>之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。</p>\n<p>最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。</p>\n<p>与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。</p>\n<p>不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！</p>"},{"title":"CVTE、阿里一面、去哪儿一面总结","date":"2017-04-16T12:47:22.000Z","toc":true,"_content":"\n最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。\n<!--more-->\n# CVTE一面、二面（3.28）\n上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。\n\n进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。\n\n我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。\n\n二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。\n\n我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。\n\n然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。\n\n# 阿里电话一面（3.28）\n没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。\n\n电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。\n\n然后又问了我一些问题：\n    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。\n    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。\n    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。\n    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。\n    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。\n    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。\n    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。\n    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。\n\n然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。\n\n3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！\n总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！\n\n# 去哪儿一面(4.14)\n接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。\n\n很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？\n\n我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。\n\n回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。\n","source":"_posts/2017-04-16-Internship-interviews.md","raw":"---\ntitle: CVTE、阿里一面、去哪儿一面总结\ndate: 2017-04-16 20:47:22\ntoc: true\ncategories:\n- 经验分享\ntags:\n- 实习面试\n---\n\n最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。\n<!--more-->\n# CVTE一面、二面（3.28）\n上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。\n\n进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。\n\n我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。\n\n二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。\n\n我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。\n\n然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。\n\n# 阿里电话一面（3.28）\n没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。\n\n电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。\n\n然后又问了我一些问题：\n    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。\n    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。\n    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。\n    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。\n    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。\n    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。\n    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。\n    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。\n\n然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。\n\n3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！\n总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！\n\n# 去哪儿一面(4.14)\n接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。\n\n很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？\n\n我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。\n\n回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。\n","slug":"Internship-interviews","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05c7000jra4k2s924e91","content":"<p>最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。</p>\n<span id=\"more\"></span>\n<h1 id=\"CVTE一面、二面（3-28）\"><a href=\"#CVTE一面、二面（3-28）\" class=\"headerlink\" title=\"CVTE一面、二面（3.28）\"></a>CVTE一面、二面（3.28）</h1><p>上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。</p>\n<p>进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。</p>\n<p>我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。</p>\n<p>二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。</p>\n<p>我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。</p>\n<p>然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。</p>\n<h1 id=\"阿里电话一面（3-28）\"><a href=\"#阿里电话一面（3-28）\" class=\"headerlink\" title=\"阿里电话一面（3.28）\"></a>阿里电话一面（3.28）</h1><p>没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。</p>\n<p>电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。</p>\n<p>然后又问了我一些问题：<br>    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。<br>    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。<br>    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。<br>    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。<br>    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。<br>    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。<br>    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。<br>    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。</p>\n<p>然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。</p>\n<p>3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！<br>总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！</p>\n<h1 id=\"去哪儿一面-4-14\"><a href=\"#去哪儿一面-4-14\" class=\"headerlink\" title=\"去哪儿一面(4.14)\"></a>去哪儿一面(4.14)</h1><p>接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。</p>\n<p>很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？</p>\n<p>我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。</p>\n<p>回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。</p>\n","site":{"data":{}},"excerpt":"<p>最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。</p>","more":"<h1 id=\"CVTE一面、二面（3-28）\"><a href=\"#CVTE一面、二面（3-28）\" class=\"headerlink\" title=\"CVTE一面、二面（3.28）\"></a>CVTE一面、二面（3.28）</h1><p>上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。</p>\n<p>进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。</p>\n<p>我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。</p>\n<p>二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。</p>\n<p>我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。</p>\n<p>然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。</p>\n<h1 id=\"阿里电话一面（3-28）\"><a href=\"#阿里电话一面（3-28）\" class=\"headerlink\" title=\"阿里电话一面（3.28）\"></a>阿里电话一面（3.28）</h1><p>没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。</p>\n<p>电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。</p>\n<p>然后又问了我一些问题：<br>    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。<br>    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。<br>    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。<br>    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。<br>    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。<br>    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。<br>    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。<br>    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。</p>\n<p>然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。</p>\n<p>3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！<br>总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！</p>\n<h1 id=\"去哪儿一面-4-14\"><a href=\"#去哪儿一面-4-14\" class=\"headerlink\" title=\"去哪儿一面(4.14)\"></a>去哪儿一面(4.14)</h1><p>接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。</p>\n<p>很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？</p>\n<p>我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。</p>\n<p>回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。</p>"},{"title":"2017腾讯前端实习生二面+HR面总结","date":"2017-04-16T11:16:23.000Z","toc":true,"_content":"# 二面（4.15）\n很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。\n<!--more-->\n终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~\n\n介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。\n\n他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。\n\n接着面试官开始问我一些基础知识：\n  \n  1. 了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对\n  2. 操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。\n  3. 递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。\n  4. 了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。\n  5. 了解TCP有什么延迟机制吗？我就说了TCP的慢启动。\n\n问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。\n\n回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。\n\n希望自己能进入HR面吧！焦急等待中。。。\n\n# HR面（4.16）\n今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。\n\n去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。\n\n到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：\n    \n 1. 你是哪里人？\n 2. 你最想去哪个城市工作？回答当然是深圳。\n 3. 你是怎么学习前端的？\n 4. 你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。\n 5. 你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。\n 6. 你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。\n 7. 你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。\n 8. 你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。\n 9. 你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。\n 10. 实习时间可以从什么时候开始？\n\n问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。\n\n# 总结\n经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！\n","source":"_posts/2017-04-16-Tecent-Interview-Second.md","raw":"---\ntitle: 2017腾讯前端实习生二面+HR面总结\ndate: 2017-04-16 19:16:23\ntoc: true\ncategories:\n- 经验分享\ntags:\n- 实习面试\n---\n# 二面（4.15）\n很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。\n<!--more-->\n终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~\n\n介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。\n\n他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。\n\n接着面试官开始问我一些基础知识：\n  \n  1. 了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对\n  2. 操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。\n  3. 递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。\n  4. 了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。\n  5. 了解TCP有什么延迟机制吗？我就说了TCP的慢启动。\n\n问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。\n\n回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。\n\n希望自己能进入HR面吧！焦急等待中。。。\n\n# HR面（4.16）\n今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。\n\n去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。\n\n到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：\n    \n 1. 你是哪里人？\n 2. 你最想去哪个城市工作？回答当然是深圳。\n 3. 你是怎么学习前端的？\n 4. 你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。\n 5. 你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。\n 6. 你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。\n 7. 你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。\n 8. 你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。\n 9. 你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。\n 10. 实习时间可以从什么时候开始？\n\n问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。\n\n# 总结\n经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！\n","slug":"Tecent-Interview-Second","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05c9000mra4k53vb9tm3","content":"<h1 id=\"二面（4-15）\"><a href=\"#二面（4-15）\" class=\"headerlink\" title=\"二面（4.15）\"></a>二面（4.15）</h1><p>很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。</p>\n<span id=\"more\"></span>\n<p>终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~</p>\n<p>介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。</p>\n<p>他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。</p>\n<p>接着面试官开始问我一些基础知识：</p>\n<ol>\n<li>了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对</li>\n<li>操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。</li>\n<li>递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。</li>\n<li>了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。</li>\n<li>了解TCP有什么延迟机制吗？我就说了TCP的慢启动。</li>\n</ol>\n<p>问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。</p>\n<p>回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。</p>\n<p>希望自己能进入HR面吧！焦急等待中。。。</p>\n<h1 id=\"HR面（4-16）\"><a href=\"#HR面（4-16）\" class=\"headerlink\" title=\"HR面（4.16）\"></a>HR面（4.16）</h1><p>今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。</p>\n<p>去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。</p>\n<p>到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：</p>\n<ol>\n<li>你是哪里人？</li>\n<li>你最想去哪个城市工作？回答当然是深圳。</li>\n<li>你是怎么学习前端的？</li>\n<li>你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。</li>\n<li>你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。</li>\n<li>你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。</li>\n<li>你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。</li>\n<li>你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。</li>\n<li>你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。</li>\n<li>实习时间可以从什么时候开始？</li>\n</ol>\n<p>问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"二面（4-15）\"><a href=\"#二面（4-15）\" class=\"headerlink\" title=\"二面（4.15）\"></a>二面（4.15）</h1><p>很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。</p>","more":"<p>终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~</p>\n<p>介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。</p>\n<p>他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。</p>\n<p>接着面试官开始问我一些基础知识：</p>\n<ol>\n<li>了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对</li>\n<li>操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。</li>\n<li>递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。</li>\n<li>了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。</li>\n<li>了解TCP有什么延迟机制吗？我就说了TCP的慢启动。</li>\n</ol>\n<p>问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。</p>\n<p>回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。</p>\n<p>希望自己能进入HR面吧！焦急等待中。。。</p>\n<h1 id=\"HR面（4-16）\"><a href=\"#HR面（4-16）\" class=\"headerlink\" title=\"HR面（4.16）\"></a>HR面（4.16）</h1><p>今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。</p>\n<p>去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。</p>\n<p>到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：</p>\n<ol>\n<li>你是哪里人？</li>\n<li>你最想去哪个城市工作？回答当然是深圳。</li>\n<li>你是怎么学习前端的？</li>\n<li>你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。</li>\n<li>你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。</li>\n<li>你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。</li>\n<li>你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。</li>\n<li>你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。</li>\n<li>你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。</li>\n<li>实习时间可以从什么时候开始？</li>\n</ol>\n<p>问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！</p>"},{"title":"浅谈this和call、apply","date":"2017-04-19T13:46:45.000Z","_content":"\nthis的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考\n<!--more-->\n## this的指向\n 一般可分为四种情况：\n   1. 作为普通函数调用：此时this总是指向全局对象，比如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    var getMyName = func.getName;\n    getMyName();  // 输出'Yuk'\n    ```\n   2. 作为对象方法调用：此时this指向该对象，如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    func.getName();  // 输出'Simon'\n    ```\n   3. 构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。\n   4. bind、call、apply方法调用：此时this指向方法中指定的obj。\n\n---\n## call和apply\n  1. call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。\n  2. 当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。\n  3. call和apply的用途：\n   * 改变this的指向\n   * Function.prototype.bind的实现：\n```javascript\nFunction.prototype.bind = function() {\n   var _this = this,   // 保存原函数\n       context = [].shift.call(arguments), // 需要绑定的this的上下文\n       args = [].slice.call(arguments);  // 剩余的参数转成数组\n   return function() {     // 返回一个新的函数\n       return _this.apply(context, [].concat.call(args, [].slice.call(arguments) ) );\n           //执行新的函数的时候，会把之前传入的context当做新函数体内的this\n           //并且组合两次分别传入的参数，作为新函数的参数 \n   };\n};\n```\n   * 借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。\n```javascript\n[].slice.call(arguments);   // 将arguments转换为数组\n[].shift.call(arguments);   // 截去arguments列表中的头一个元素\n[].push.call(arguments, item); // 向arguments里添加新元素\n```\n\n\n","source":"_posts/2017-04-19-GetToKnow-this-call-apply.md","raw":"---\ntitle: 浅谈this和call、apply\ndate: 2017-04-19 21:46:45\ncategories:\n- JS相关\ntags:\n- JS原理\n---\n\nthis的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考\n<!--more-->\n## this的指向\n 一般可分为四种情况：\n   1. 作为普通函数调用：此时this总是指向全局对象，比如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    var getMyName = func.getName;\n    getMyName();  // 输出'Yuk'\n    ```\n   2. 作为对象方法调用：此时this指向该对象，如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    func.getName();  // 输出'Simon'\n    ```\n   3. 构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。\n   4. bind、call、apply方法调用：此时this指向方法中指定的obj。\n\n---\n## call和apply\n  1. call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。\n  2. 当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。\n  3. call和apply的用途：\n   * 改变this的指向\n   * Function.prototype.bind的实现：\n```javascript\nFunction.prototype.bind = function() {\n   var _this = this,   // 保存原函数\n       context = [].shift.call(arguments), // 需要绑定的this的上下文\n       args = [].slice.call(arguments);  // 剩余的参数转成数组\n   return function() {     // 返回一个新的函数\n       return _this.apply(context, [].concat.call(args, [].slice.call(arguments) ) );\n           //执行新的函数的时候，会把之前传入的context当做新函数体内的this\n           //并且组合两次分别传入的参数，作为新函数的参数 \n   };\n};\n```\n   * 借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。\n```javascript\n[].slice.call(arguments);   // 将arguments转换为数组\n[].shift.call(arguments);   // 截去arguments列表中的头一个元素\n[].push.call(arguments, item); // 向arguments里添加新元素\n```\n\n\n","slug":"GetToKnow-this-call-apply","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cb000qra4khw8n6hsc","content":"<p>this的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考</p>\n<span id=\"more\"></span>\n<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p> 一般可分为四种情况：</p>\n<ol>\n<li>作为普通函数调用：此时this总是指向全局对象，比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">var getMyName = func.getName;</span><br><span class=\"line\">getMyName();  // 输出&#x27;Yuk&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>作为对象方法调用：此时this指向该对象，如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">func.getName();  // 输出&#x27;Simon&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。</li>\n<li>bind、call、apply方法调用：此时this指向方法中指定的obj。</li>\n</ol>\n<hr>\n<h2 id=\"call和apply\"><a href=\"#call和apply\" class=\"headerlink\" title=\"call和apply\"></a>call和apply</h2><ol>\n<li>call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。</li>\n<li>当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。</li>\n<li>call和apply的用途：</li>\n</ol>\n<ul>\n<li>改变this的指向</li>\n<li>Function.prototype.bind的实现：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bind</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> _this = <span class=\"variable language_\">this</span>,   <span class=\"comment\">// 保存原函数</span></span><br><span class=\"line\">       context = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>), <span class=\"comment\">// 需要绑定的this的上下文</span></span><br><span class=\"line\">       args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);  <span class=\"comment\">// 剩余的参数转成数组</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;     <span class=\"comment\">// 返回一个新的函数</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> _this.<span class=\"title function_\">apply</span>(context, [].<span class=\"property\">concat</span>.<span class=\"title function_\">call</span>(args, [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>) ) );</span><br><span class=\"line\">           <span class=\"comment\">//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span></span><br><span class=\"line\">           <span class=\"comment\">//并且组合两次分别传入的参数，作为新函数的参数 </span></span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 将arguments转换为数组</span></span><br><span class=\"line\">[].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 截去arguments列表中的头一个元素</span></span><br><span class=\"line\">[].<span class=\"property\">push</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, item); <span class=\"comment\">// 向arguments里添加新元素</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>this的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考</p>","more":"<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p> 一般可分为四种情况：</p>\n<ol>\n<li>作为普通函数调用：此时this总是指向全局对象，比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">var getMyName = func.getName;</span><br><span class=\"line\">getMyName();  // 输出&#x27;Yuk&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>作为对象方法调用：此时this指向该对象，如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">func.getName();  // 输出&#x27;Simon&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。</li>\n<li>bind、call、apply方法调用：此时this指向方法中指定的obj。</li>\n</ol>\n<hr>\n<h2 id=\"call和apply\"><a href=\"#call和apply\" class=\"headerlink\" title=\"call和apply\"></a>call和apply</h2><ol>\n<li>call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。</li>\n<li>当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。</li>\n<li>call和apply的用途：</li>\n</ol>\n<ul>\n<li>改变this的指向</li>\n<li>Function.prototype.bind的实现：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bind</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> _this = <span class=\"variable language_\">this</span>,   <span class=\"comment\">// 保存原函数</span></span><br><span class=\"line\">       context = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>), <span class=\"comment\">// 需要绑定的this的上下文</span></span><br><span class=\"line\">       args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);  <span class=\"comment\">// 剩余的参数转成数组</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;     <span class=\"comment\">// 返回一个新的函数</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> _this.<span class=\"title function_\">apply</span>(context, [].<span class=\"property\">concat</span>.<span class=\"title function_\">call</span>(args, [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>) ) );</span><br><span class=\"line\">           <span class=\"comment\">//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span></span><br><span class=\"line\">           <span class=\"comment\">//并且组合两次分别传入的参数，作为新函数的参数 </span></span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 将arguments转换为数组</span></span><br><span class=\"line\">[].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 截去arguments列表中的头一个元素</span></span><br><span class=\"line\">[].<span class=\"property\">push</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, item); <span class=\"comment\">// 向arguments里添加新元素</span></span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"http状态码记录","date":"2017-04-23T09:57:31.000Z","_content":"\n近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。\n<!--more-->\n## 100～199：信息性状态码\n* 100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。\n\n## 200～299：成功状态码\n* 200 OK，代表请求没问题，返回的主体包含请求资源\n* 202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。\n* 204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面\n\n## 300～399：重定向状态码\n* 301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL\n* 302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP/1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。\n* 303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求\n* 304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。\n* 307 Temporary Redirect，HTTP1.1客户端用307状态码取代302\n\n## 400～499：客户端错误状态码\n* 400 Bad Request，客户端发送了错误请求\n* 401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。\n* 403 Forbidden，说明请求被服务器拒绝了\n* 404 Not Found，说明服务器无法找到所请求的URL\n* 405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。\n* 406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源\n* 408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。\n\n## 500～599：服务器错误状态码\n* 500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误\n* 501 Not Implemented，客户端发起的请求超出服务器的能力范围\n* 502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误\n* 503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务\n","source":"_posts/2017-04-23-http-status-codes-marks.md","raw":"---\ntitle: http状态码记录\ndate: 2017-04-23 17:57:31\ncategories:\n- 网络\ntags:\n- http\n- 状态码\n---\n\n近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。\n<!--more-->\n## 100～199：信息性状态码\n* 100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。\n\n## 200～299：成功状态码\n* 200 OK，代表请求没问题，返回的主体包含请求资源\n* 202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。\n* 204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面\n\n## 300～399：重定向状态码\n* 301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL\n* 302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP/1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。\n* 303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求\n* 304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。\n* 307 Temporary Redirect，HTTP1.1客户端用307状态码取代302\n\n## 400～499：客户端错误状态码\n* 400 Bad Request，客户端发送了错误请求\n* 401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。\n* 403 Forbidden，说明请求被服务器拒绝了\n* 404 Not Found，说明服务器无法找到所请求的URL\n* 405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。\n* 406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源\n* 408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。\n\n## 500～599：服务器错误状态码\n* 500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误\n* 501 Not Implemented，客户端发起的请求超出服务器的能力范围\n* 502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误\n* 503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务\n","slug":"http-status-codes-marks","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cc000sra4kfwqs9wpd","content":"<p>近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。</p>\n<span id=\"more\"></span>\n<h2 id=\"100～199：信息性状态码\"><a href=\"#100～199：信息性状态码\" class=\"headerlink\" title=\"100～199：信息性状态码\"></a>100～199：信息性状态码</h2><ul>\n<li>100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。</li>\n</ul>\n<h2 id=\"200～299：成功状态码\"><a href=\"#200～299：成功状态码\" class=\"headerlink\" title=\"200～299：成功状态码\"></a>200～299：成功状态码</h2><ul>\n<li>200 OK，代表请求没问题，返回的主体包含请求资源</li>\n<li>202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。</li>\n<li>204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面</li>\n</ul>\n<h2 id=\"300～399：重定向状态码\"><a href=\"#300～399：重定向状态码\" class=\"headerlink\" title=\"300～399：重定向状态码\"></a>300～399：重定向状态码</h2><ul>\n<li>301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL</li>\n<li>302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP&#x2F;1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。</li>\n<li>303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求</li>\n<li>304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。</li>\n<li>307 Temporary Redirect，HTTP1.1客户端用307状态码取代302</li>\n</ul>\n<h2 id=\"400～499：客户端错误状态码\"><a href=\"#400～499：客户端错误状态码\" class=\"headerlink\" title=\"400～499：客户端错误状态码\"></a>400～499：客户端错误状态码</h2><ul>\n<li>400 Bad Request，客户端发送了错误请求</li>\n<li>401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</li>\n<li>403 Forbidden，说明请求被服务器拒绝了</li>\n<li>404 Not Found，说明服务器无法找到所请求的URL</li>\n<li>405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。</li>\n<li>406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源</li>\n<li>408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。</li>\n</ul>\n<h2 id=\"500～599：服务器错误状态码\"><a href=\"#500～599：服务器错误状态码\" class=\"headerlink\" title=\"500～599：服务器错误状态码\"></a>500～599：服务器错误状态码</h2><ul>\n<li>500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误</li>\n<li>501 Not Implemented，客户端发起的请求超出服务器的能力范围</li>\n<li>502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误</li>\n<li>503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。</p>","more":"<h2 id=\"100～199：信息性状态码\"><a href=\"#100～199：信息性状态码\" class=\"headerlink\" title=\"100～199：信息性状态码\"></a>100～199：信息性状态码</h2><ul>\n<li>100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。</li>\n</ul>\n<h2 id=\"200～299：成功状态码\"><a href=\"#200～299：成功状态码\" class=\"headerlink\" title=\"200～299：成功状态码\"></a>200～299：成功状态码</h2><ul>\n<li>200 OK，代表请求没问题，返回的主体包含请求资源</li>\n<li>202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。</li>\n<li>204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面</li>\n</ul>\n<h2 id=\"300～399：重定向状态码\"><a href=\"#300～399：重定向状态码\" class=\"headerlink\" title=\"300～399：重定向状态码\"></a>300～399：重定向状态码</h2><ul>\n<li>301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL</li>\n<li>302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP&#x2F;1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。</li>\n<li>303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求</li>\n<li>304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。</li>\n<li>307 Temporary Redirect，HTTP1.1客户端用307状态码取代302</li>\n</ul>\n<h2 id=\"400～499：客户端错误状态码\"><a href=\"#400～499：客户端错误状态码\" class=\"headerlink\" title=\"400～499：客户端错误状态码\"></a>400～499：客户端错误状态码</h2><ul>\n<li>400 Bad Request，客户端发送了错误请求</li>\n<li>401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</li>\n<li>403 Forbidden，说明请求被服务器拒绝了</li>\n<li>404 Not Found，说明服务器无法找到所请求的URL</li>\n<li>405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。</li>\n<li>406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源</li>\n<li>408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。</li>\n</ul>\n<h2 id=\"500～599：服务器错误状态码\"><a href=\"#500～599：服务器错误状态码\" class=\"headerlink\" title=\"500～599：服务器错误状态码\"></a>500～599：服务器错误状态码</h2><ul>\n<li>500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误</li>\n<li>501 Not Implemented，客户端发起的请求超出服务器的能力范围</li>\n<li>502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误</li>\n<li>503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务</li>\n</ul>"},{"title":"浅谈函数节流与函数去抖","date":"2017-05-01T11:37:31.000Z","_content":"\n函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\n---\n<!--more-->\n# 函数节流:throttle\n## 函数节流的目的\n有些函数不是由用户直接控制触发的，函数有可能被**频繁地调用**而导致性能问题。一些常见的函数被频繁调用场景：\n- window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。\n- mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。\n- 键盘keydown监听\n> 我们的目的就是减少函数触发的频率\n\n## 函数节流原理\n我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。\n```javascript\nvar throttle = function ( fn, delay ) {\n    var _self = fn,             // 保存将要延迟执行的函数\n          timer,                    // 定时器\n          first_time = true;  // 是否第一次调用\n\n    return function () {\n        var args = [].slice.call(arguments),\n              _me = this;\n        if ( first_time ) {     // 如果第一次执行则直接调用\n            _self.apply( _me, args );\n            return first_time = false;\n        }\n        if( timer ) {           // 如果timer存在说明之前延迟的函数还没有执行\n            return false;\n        }\n        timer = setTimeout( function () {\n            clearTimeout( timer );\n            timer = null;\n            _self.apply( _me, args );\n        }, delay );\n    };\n};\n\nwindow.onscroll = throttle( function () {\n    console.log(\"has changed\");\n}, 500 );\n```\n\n# 函数去抖:debounce\n## 函数去抖的目的\n函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：\n- 文字输入监听\n- onscroll事件\n- onresize事件。\n## 函数去抖原理\n也是利用setTimeout和闭包的原理。\n```javascript\nvar debounce = function ( fn, delay ) {\n    var context,\n          args,\n          timer;\n    return function () {\n        context = this, args = [].slice.call(arguments);\n        if( timer ) {\n            clearTimeout( timer );\n        }\n        timer = setTimeout( function () {\n            fn.apply( context, args );\n        }, delay );\n    };\n};\n\nwindow.onresize = debounce( function () {\n    console.log(\"has changed\");\n}, 600 );\n```\n# underscore源码\nunderscore里对throttle和debounce有更完整的实现，这里把代码贴出来\n- throttle\n```javascript\n_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n };\n```\n\n- debounce\n```javascript\n_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;       // 上一次函数触发的时间\n\n      if (last < wait && last >= 0) {       // 如果没有到达规定的wait时间则继续延迟，相当于计时器\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {        // 如果是立即调用或者上一次函数已经调用完毕\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n };\n```\n","source":"_posts/2017-05-01-throttle-debounce.md","raw":"---\ntitle: 浅谈函数节流与函数去抖\ndate: 2017-05-01 19:37:31\ncategories:\n- JS相关\ntags:\n- throttle\n- debounce\n---\n\n函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\n---\n<!--more-->\n# 函数节流:throttle\n## 函数节流的目的\n有些函数不是由用户直接控制触发的，函数有可能被**频繁地调用**而导致性能问题。一些常见的函数被频繁调用场景：\n- window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。\n- mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。\n- 键盘keydown监听\n> 我们的目的就是减少函数触发的频率\n\n## 函数节流原理\n我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。\n```javascript\nvar throttle = function ( fn, delay ) {\n    var _self = fn,             // 保存将要延迟执行的函数\n          timer,                    // 定时器\n          first_time = true;  // 是否第一次调用\n\n    return function () {\n        var args = [].slice.call(arguments),\n              _me = this;\n        if ( first_time ) {     // 如果第一次执行则直接调用\n            _self.apply( _me, args );\n            return first_time = false;\n        }\n        if( timer ) {           // 如果timer存在说明之前延迟的函数还没有执行\n            return false;\n        }\n        timer = setTimeout( function () {\n            clearTimeout( timer );\n            timer = null;\n            _self.apply( _me, args );\n        }, delay );\n    };\n};\n\nwindow.onscroll = throttle( function () {\n    console.log(\"has changed\");\n}, 500 );\n```\n\n# 函数去抖:debounce\n## 函数去抖的目的\n函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：\n- 文字输入监听\n- onscroll事件\n- onresize事件。\n## 函数去抖原理\n也是利用setTimeout和闭包的原理。\n```javascript\nvar debounce = function ( fn, delay ) {\n    var context,\n          args,\n          timer;\n    return function () {\n        context = this, args = [].slice.call(arguments);\n        if( timer ) {\n            clearTimeout( timer );\n        }\n        timer = setTimeout( function () {\n            fn.apply( context, args );\n        }, delay );\n    };\n};\n\nwindow.onresize = debounce( function () {\n    console.log(\"has changed\");\n}, 600 );\n```\n# underscore源码\nunderscore里对throttle和debounce有更完整的实现，这里把代码贴出来\n- throttle\n```javascript\n_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n };\n```\n\n- debounce\n```javascript\n_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;       // 上一次函数触发的时间\n\n      if (last < wait && last >= 0) {       // 如果没有到达规定的wait时间则继续延迟，相当于计时器\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {        // 如果是立即调用或者上一次函数已经调用完毕\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n };\n```\n","slug":"throttle-debounce","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05ce000wra4ka8m3c69p","content":"<h2 id=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"><a href=\"#函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\" class=\"headerlink\" title=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"></a>函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。</h2><span id=\"more\"></span>\n<h1 id=\"函数节流-throttle\"><a href=\"#函数节流-throttle\" class=\"headerlink\" title=\"函数节流:throttle\"></a>函数节流:throttle</h1><h2 id=\"函数节流的目的\"><a href=\"#函数节流的目的\" class=\"headerlink\" title=\"函数节流的目的\"></a>函数节流的目的</h2><p>有些函数不是由用户直接控制触发的，函数有可能被<strong>频繁地调用</strong>而导致性能问题。一些常见的函数被频繁调用场景：</p>\n<ul>\n<li>window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。</li>\n<li>mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。</li>\n<li>键盘keydown监听<blockquote>\n<p>我们的目的就是减少函数触发的频率</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"函数节流原理\"><a href=\"#函数节流原理\" class=\"headerlink\" title=\"函数节流原理\"></a>函数节流原理</h2><p>我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _self = fn,             <span class=\"comment\">// 保存将要延迟执行的函数</span></span><br><span class=\"line\">          timer,                    <span class=\"comment\">// 定时器</span></span><br><span class=\"line\">          first_time = <span class=\"literal\">true</span>;  <span class=\"comment\">// 是否第一次调用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>),</span><br><span class=\"line\">              _me = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( first_time ) &#123;     <span class=\"comment\">// 如果第一次执行则直接调用</span></span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_time = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;           <span class=\"comment\">// 如果timer存在说明之前延迟的函数还没有执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"title function_\">throttle</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span> );</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数去抖-debounce\"><a href=\"#函数去抖-debounce\" class=\"headerlink\" title=\"函数去抖:debounce\"></a>函数去抖:debounce</h1><h2 id=\"函数去抖的目的\"><a href=\"#函数去抖的目的\" class=\"headerlink\" title=\"函数去抖的目的\"></a>函数去抖的目的</h2><p>函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：</p>\n<ul>\n<li><p>文字输入监听</p>\n</li>\n<li><p>onscroll事件</p>\n</li>\n<li><p>onresize事件。</p>\n<h2 id=\"函数去抖原理\"><a href=\"#函数去抖原理\" class=\"headerlink\" title=\"函数去抖原理\"></a>函数去抖原理</h2><p>也是利用setTimeout和闭包的原理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context,</span><br><span class=\"line\">          args,</span><br><span class=\"line\">          timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        context = <span class=\"variable language_\">this</span>, args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>( context, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onresize</span> = <span class=\"title function_\">debounce</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">600</span> );</span><br></pre></td></tr></table></figure>\n<h1 id=\"underscore源码\"><a href=\"#underscore源码\" class=\"headerlink\" title=\"underscore源码\"></a>underscore源码</h1><p>underscore里对throttle和debounce有更完整的实现，这里把代码贴出来</p>\n</li>\n<li><p>throttle</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">throttle</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context, args, result;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      previous = options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> now = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!previous &amp;&amp; options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">          timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = now;</span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.<span class=\"property\">trailing</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>debounce</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">debounce</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> last = _.<span class=\"title function_\">now</span>() - timestamp;       <span class=\"comment\">// 上一次函数触发的时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class=\"number\">0</span>) &#123;       <span class=\"comment\">// 如果没有到达规定的wait时间则继续延迟，相当于计时器</span></span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, wait - last);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">          result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      timestamp = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) &#123;        <span class=\"comment\">// 如果是立即调用或者上一次函数已经调用完毕</span></span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"><a href=\"#函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\" class=\"headerlink\" title=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"></a>函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。</h2>","more":"<h1 id=\"函数节流-throttle\"><a href=\"#函数节流-throttle\" class=\"headerlink\" title=\"函数节流:throttle\"></a>函数节流:throttle</h1><h2 id=\"函数节流的目的\"><a href=\"#函数节流的目的\" class=\"headerlink\" title=\"函数节流的目的\"></a>函数节流的目的</h2><p>有些函数不是由用户直接控制触发的，函数有可能被<strong>频繁地调用</strong>而导致性能问题。一些常见的函数被频繁调用场景：</p>\n<ul>\n<li>window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。</li>\n<li>mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。</li>\n<li>键盘keydown监听<blockquote>\n<p>我们的目的就是减少函数触发的频率</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"函数节流原理\"><a href=\"#函数节流原理\" class=\"headerlink\" title=\"函数节流原理\"></a>函数节流原理</h2><p>我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _self = fn,             <span class=\"comment\">// 保存将要延迟执行的函数</span></span><br><span class=\"line\">          timer,                    <span class=\"comment\">// 定时器</span></span><br><span class=\"line\">          first_time = <span class=\"literal\">true</span>;  <span class=\"comment\">// 是否第一次调用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>),</span><br><span class=\"line\">              _me = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( first_time ) &#123;     <span class=\"comment\">// 如果第一次执行则直接调用</span></span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_time = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;           <span class=\"comment\">// 如果timer存在说明之前延迟的函数还没有执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"title function_\">throttle</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span> );</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数去抖-debounce\"><a href=\"#函数去抖-debounce\" class=\"headerlink\" title=\"函数去抖:debounce\"></a>函数去抖:debounce</h1><h2 id=\"函数去抖的目的\"><a href=\"#函数去抖的目的\" class=\"headerlink\" title=\"函数去抖的目的\"></a>函数去抖的目的</h2><p>函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：</p>\n<ul>\n<li><p>文字输入监听</p>\n</li>\n<li><p>onscroll事件</p>\n</li>\n<li><p>onresize事件。</p>\n<h2 id=\"函数去抖原理\"><a href=\"#函数去抖原理\" class=\"headerlink\" title=\"函数去抖原理\"></a>函数去抖原理</h2><p>也是利用setTimeout和闭包的原理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context,</span><br><span class=\"line\">          args,</span><br><span class=\"line\">          timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        context = <span class=\"variable language_\">this</span>, args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>( context, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onresize</span> = <span class=\"title function_\">debounce</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">600</span> );</span><br></pre></td></tr></table></figure>\n<h1 id=\"underscore源码\"><a href=\"#underscore源码\" class=\"headerlink\" title=\"underscore源码\"></a>underscore源码</h1><p>underscore里对throttle和debounce有更完整的实现，这里把代码贴出来</p>\n</li>\n<li><p>throttle</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">throttle</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context, args, result;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      previous = options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> now = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!previous &amp;&amp; options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">          timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = now;</span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.<span class=\"property\">trailing</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>debounce</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">debounce</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> last = _.<span class=\"title function_\">now</span>() - timestamp;       <span class=\"comment\">// 上一次函数触发的时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class=\"number\">0</span>) &#123;       <span class=\"comment\">// 如果没有到达规定的wait时间则继续延迟，相当于计时器</span></span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, wait - last);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">          result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      timestamp = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) &#123;        <span class=\"comment\">// 如果是立即调用或者上一次函数已经调用完毕</span></span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"最近一段时间的总结","date":"2017-05-10T12:53:14.000Z","_content":"\n最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。\n<!--more-->\n\n# 前端学习\n> 自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。\n> 不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：\n\n## JS基础\n- 继续阅读《You don't know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图\n- 完成FreeCodeCamp项目练习\n- 练习百度前端学院有关项目\n\n## CSS基础\n- 阅读《CSS揭秘》\n- 阅读图书馆借阅的设计方面相关书籍\n- 在项目中模仿别人的页面设计\n- 掌握bootstrap\n\n## 工程化\n- 掌握webpack的基本使用和配置\n- 会用gulp\n- 了解mocha测试工具\n- 多了解前端性能优化\n- 学会如何测试、发布上线项目\n- 学会写文档\n\n## 计算机基础\n- leetcode刷题\n- 阅读算法导论\n- 阅读http、tcp有关书籍\n\n## 框架学习\n- 通过阅读别人的React项目学习React基本结构和方法\n- 自己开始用React+Redux+React-router模仿着写小组件\n- 掌握React、Vue框架核心思想和区别\n- 最好能阅读React源码分析\n\n## 阅读源码\n- 阅读underscore源码\n- 阅读jQuery源码\n- 阅读Backbone源码\n---\n\n# 规划生活\n感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。\n- 首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。\n- 上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。\n- 下午联系驾校练车，争取半个多月拿到证。\n- 练完车后去锻炼锻炼，跑步或者打球。\n- 晚上是码代码时间。\n- 22：00后写博客总结一下当天的心得。\n- 23：30上床\n\n> 总之，让生活充实起来，做到学习娱乐两不误！\n","source":"_posts/2017-05-10-Summary.md","raw":"---\ntitle: 最近一段时间的总结\ndate: 2017-05-10 20:53:14\ncategories:\n- 随笔\ntags:\n- 思考感悟\n---\n\n最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。\n<!--more-->\n\n# 前端学习\n> 自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。\n> 不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：\n\n## JS基础\n- 继续阅读《You don't know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图\n- 完成FreeCodeCamp项目练习\n- 练习百度前端学院有关项目\n\n## CSS基础\n- 阅读《CSS揭秘》\n- 阅读图书馆借阅的设计方面相关书籍\n- 在项目中模仿别人的页面设计\n- 掌握bootstrap\n\n## 工程化\n- 掌握webpack的基本使用和配置\n- 会用gulp\n- 了解mocha测试工具\n- 多了解前端性能优化\n- 学会如何测试、发布上线项目\n- 学会写文档\n\n## 计算机基础\n- leetcode刷题\n- 阅读算法导论\n- 阅读http、tcp有关书籍\n\n## 框架学习\n- 通过阅读别人的React项目学习React基本结构和方法\n- 自己开始用React+Redux+React-router模仿着写小组件\n- 掌握React、Vue框架核心思想和区别\n- 最好能阅读React源码分析\n\n## 阅读源码\n- 阅读underscore源码\n- 阅读jQuery源码\n- 阅读Backbone源码\n---\n\n# 规划生活\n感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。\n- 首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。\n- 上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。\n- 下午联系驾校练车，争取半个多月拿到证。\n- 练完车后去锻炼锻炼，跑步或者打球。\n- 晚上是码代码时间。\n- 22：00后写博客总结一下当天的心得。\n- 23：30上床\n\n> 总之，让生活充实起来，做到学习娱乐两不误！\n","slug":"Summary","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05ch000yra4k7b0q89fv","content":"<p>最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"前端学习\"><a href=\"#前端学习\" class=\"headerlink\" title=\"前端学习\"></a>前端学习</h1><blockquote>\n<p>自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。<br>不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：</p>\n</blockquote>\n<h2 id=\"JS基础\"><a href=\"#JS基础\" class=\"headerlink\" title=\"JS基础\"></a>JS基础</h2><ul>\n<li>继续阅读《You don’t know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图</li>\n<li>完成FreeCodeCamp项目练习</li>\n<li>练习百度前端学院有关项目</li>\n</ul>\n<h2 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h2><ul>\n<li>阅读《CSS揭秘》</li>\n<li>阅读图书馆借阅的设计方面相关书籍</li>\n<li>在项目中模仿别人的页面设计</li>\n<li>掌握bootstrap</li>\n</ul>\n<h2 id=\"工程化\"><a href=\"#工程化\" class=\"headerlink\" title=\"工程化\"></a>工程化</h2><ul>\n<li>掌握webpack的基本使用和配置</li>\n<li>会用gulp</li>\n<li>了解mocha测试工具</li>\n<li>多了解前端性能优化</li>\n<li>学会如何测试、发布上线项目</li>\n<li>学会写文档</li>\n</ul>\n<h2 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h2><ul>\n<li>leetcode刷题</li>\n<li>阅读算法导论</li>\n<li>阅读http、tcp有关书籍</li>\n</ul>\n<h2 id=\"框架学习\"><a href=\"#框架学习\" class=\"headerlink\" title=\"框架学习\"></a>框架学习</h2><ul>\n<li>通过阅读别人的React项目学习React基本结构和方法</li>\n<li>自己开始用React+Redux+React-router模仿着写小组件</li>\n<li>掌握React、Vue框架核心思想和区别</li>\n<li>最好能阅读React源码分析</li>\n</ul>\n<h2 id=\"阅读源码\"><a href=\"#阅读源码\" class=\"headerlink\" title=\"阅读源码\"></a>阅读源码</h2><ul>\n<li>阅读underscore源码</li>\n<li>阅读jQuery源码</li>\n<li>阅读Backbone源码</li>\n</ul>\n<hr>\n<h1 id=\"规划生活\"><a href=\"#规划生活\" class=\"headerlink\" title=\"规划生活\"></a>规划生活</h1><p>感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。</p>\n<ul>\n<li>首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。</li>\n<li>上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。</li>\n<li>下午联系驾校练车，争取半个多月拿到证。</li>\n<li>练完车后去锻炼锻炼，跑步或者打球。</li>\n<li>晚上是码代码时间。</li>\n<li>22：00后写博客总结一下当天的心得。</li>\n<li>23：30上床</li>\n</ul>\n<blockquote>\n<p>总之，让生活充实起来，做到学习娱乐两不误！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。</p>","more":"<h1 id=\"前端学习\"><a href=\"#前端学习\" class=\"headerlink\" title=\"前端学习\"></a>前端学习</h1><blockquote>\n<p>自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。<br>不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：</p>\n</blockquote>\n<h2 id=\"JS基础\"><a href=\"#JS基础\" class=\"headerlink\" title=\"JS基础\"></a>JS基础</h2><ul>\n<li>继续阅读《You don’t know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图</li>\n<li>完成FreeCodeCamp项目练习</li>\n<li>练习百度前端学院有关项目</li>\n</ul>\n<h2 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h2><ul>\n<li>阅读《CSS揭秘》</li>\n<li>阅读图书馆借阅的设计方面相关书籍</li>\n<li>在项目中模仿别人的页面设计</li>\n<li>掌握bootstrap</li>\n</ul>\n<h2 id=\"工程化\"><a href=\"#工程化\" class=\"headerlink\" title=\"工程化\"></a>工程化</h2><ul>\n<li>掌握webpack的基本使用和配置</li>\n<li>会用gulp</li>\n<li>了解mocha测试工具</li>\n<li>多了解前端性能优化</li>\n<li>学会如何测试、发布上线项目</li>\n<li>学会写文档</li>\n</ul>\n<h2 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h2><ul>\n<li>leetcode刷题</li>\n<li>阅读算法导论</li>\n<li>阅读http、tcp有关书籍</li>\n</ul>\n<h2 id=\"框架学习\"><a href=\"#框架学习\" class=\"headerlink\" title=\"框架学习\"></a>框架学习</h2><ul>\n<li>通过阅读别人的React项目学习React基本结构和方法</li>\n<li>自己开始用React+Redux+React-router模仿着写小组件</li>\n<li>掌握React、Vue框架核心思想和区别</li>\n<li>最好能阅读React源码分析</li>\n</ul>\n<h2 id=\"阅读源码\"><a href=\"#阅读源码\" class=\"headerlink\" title=\"阅读源码\"></a>阅读源码</h2><ul>\n<li>阅读underscore源码</li>\n<li>阅读jQuery源码</li>\n<li>阅读Backbone源码</li>\n</ul>\n<hr>\n<h1 id=\"规划生活\"><a href=\"#规划生活\" class=\"headerlink\" title=\"规划生活\"></a>规划生活</h1><p>感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。</p>\n<ul>\n<li>首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。</li>\n<li>上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。</li>\n<li>下午联系驾校练车，争取半个多月拿到证。</li>\n<li>练完车后去锻炼锻炼，跑步或者打球。</li>\n<li>晚上是码代码时间。</li>\n<li>22：00后写博客总结一下当天的心得。</li>\n<li>23：30上床</li>\n</ul>\n<blockquote>\n<p>总之，让生活充实起来，做到学习娱乐两不误！</p>\n</blockquote>"},{"title":"CSS边框的应用","date":"2017-07-24T05:34:47.000Z","toc":true,"_content":"\nCSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？\n\n<!--more-->\n# CSS实现多重边框\n一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。\n\n## box-shadow方案\n我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：\n\n> Specify a single box-shadow using:\n> - Two, three, or four values.\n> - If only two values are given, they are interpreted as values.\n> - If a third value is given, it is interpreted as a .\n> - If a fourth value is given, it is interpreted as a .\n> - Optionally, the inset keyword.\n> - Optionally, a value.\n\n我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533;\n```\n\n当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533, 0 0 0 15px #2f4, 0 2px 5px 15px rgba(0, 0, 0, .6);\n```\n\n注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。\n\n需要注意的是：\n\n- 投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。\n- box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。\n\n## outline方案\n某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。\n\n```css\nbackground: lightblue;\nborder: 10px solid #533;\noutline: 5px solid #2f4;\n```\n\n需要注意的是：\n\n它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。\n\n# 边框内圆角实现\n有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。\n\n```html\n<div class='container'>\n  <div>This is a box</div>\n</div>\n```\n\n```css\n.container {\n  background: #655;\n  padding: .6em;\n}\n\n.container > div {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n}\n```\n\n但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。\n\n```css\n.container {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n  box-shadow: 0 0 0 .5em #655\n  outline: .6em solid #655;\n}\n```\n实现的效果和之前一样。\n\n因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。\n\n注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&radic;2-1)*border-radius，为了方便，一般取border-radius的一半。","source":"_posts/2017-07-24-csssecrets-border.md","raw":"---\ntitle: CSS边框的应用\ndate: 2017-07-24 13:34:47\ntoc: true\ncategories:\n- CSS相关\ntags:\n- CSS技巧\n---\n\nCSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？\n\n<!--more-->\n# CSS实现多重边框\n一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。\n\n## box-shadow方案\n我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：\n\n> Specify a single box-shadow using:\n> - Two, three, or four values.\n> - If only two values are given, they are interpreted as values.\n> - If a third value is given, it is interpreted as a .\n> - If a fourth value is given, it is interpreted as a .\n> - Optionally, the inset keyword.\n> - Optionally, a value.\n\n我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533;\n```\n\n当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533, 0 0 0 15px #2f4, 0 2px 5px 15px rgba(0, 0, 0, .6);\n```\n\n注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。\n\n需要注意的是：\n\n- 投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。\n- box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。\n\n## outline方案\n某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。\n\n```css\nbackground: lightblue;\nborder: 10px solid #533;\noutline: 5px solid #2f4;\n```\n\n需要注意的是：\n\n它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。\n\n# 边框内圆角实现\n有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。\n\n```html\n<div class='container'>\n  <div>This is a box</div>\n</div>\n```\n\n```css\n.container {\n  background: #655;\n  padding: .6em;\n}\n\n.container > div {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n}\n```\n\n但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。\n\n```css\n.container {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n  box-shadow: 0 0 0 .5em #655\n  outline: .6em solid #655;\n}\n```\n实现的效果和之前一样。\n\n因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。\n\n注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&radic;2-1)*border-radius，为了方便，一般取border-radius的一半。","slug":"csssecrets-border","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cj0011ra4k38uva625","content":"<p>CSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？</p>\n<span id=\"more\"></span>\n<h1 id=\"CSS实现多重边框\"><a href=\"#CSS实现多重边框\" class=\"headerlink\" title=\"CSS实现多重边框\"></a>CSS实现多重边框</h1><p>一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。</p>\n<h2 id=\"box-shadow方案\"><a href=\"#box-shadow方案\" class=\"headerlink\" title=\"box-shadow方案\"></a>box-shadow方案</h2><p>我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：</p>\n<blockquote>\n<p>Specify a single box-shadow using:</p>\n<ul>\n<li>Two, three, or four values.</li>\n<li>If only two values are given, they are interpreted as values.</li>\n<li>If a third value is given, it is interpreted as a .</li>\n<li>If a fourth value is given, it is interpreted as a .</li>\n<li>Optionally, the inset keyword.</li>\n<li>Optionally, a value.</li>\n</ul>\n</blockquote>\n<p>我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>, <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> <span class=\"number\">#2f4</span>, <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">5px</span> <span class=\"number\">15px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, .<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。</p>\n<p>需要注意的是：</p>\n<ul>\n<li>投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。</li>\n<li>box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。</li>\n</ul>\n<h2 id=\"outline方案\"><a href=\"#outline方案\" class=\"headerlink\" title=\"outline方案\"></a>outline方案</h2><p>某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid <span class=\"number\">#533</span>;</span><br><span class=\"line\"><span class=\"attribute\">outline</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#2f4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：</p>\n<p>它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。</p>\n<h1 id=\"边框内圆角实现\"><a href=\"#边框内圆角实现\" class=\"headerlink\" title=\"边框内圆角实现\"></a>边框内圆角实现</h1><p>有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;container&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>This is a box<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#655</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: .<span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &gt; <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> .<span class=\"number\">5em</span> <span class=\"number\">#655</span></span><br><span class=\"line\">  outline: .<span class=\"number\">6em</span> solid <span class=\"number\">#655</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的效果和之前一样。</p>\n<p>因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。</p>\n<p>注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&amp;radic;2-1)*border-radius，为了方便，一般取border-radius的一半。</p>\n","site":{"data":{}},"excerpt":"<p>CSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？</p>","more":"<h1 id=\"CSS实现多重边框\"><a href=\"#CSS实现多重边框\" class=\"headerlink\" title=\"CSS实现多重边框\"></a>CSS实现多重边框</h1><p>一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。</p>\n<h2 id=\"box-shadow方案\"><a href=\"#box-shadow方案\" class=\"headerlink\" title=\"box-shadow方案\"></a>box-shadow方案</h2><p>我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：</p>\n<blockquote>\n<p>Specify a single box-shadow using:</p>\n<ul>\n<li>Two, three, or four values.</li>\n<li>If only two values are given, they are interpreted as values.</li>\n<li>If a third value is given, it is interpreted as a .</li>\n<li>If a fourth value is given, it is interpreted as a .</li>\n<li>Optionally, the inset keyword.</li>\n<li>Optionally, a value.</li>\n</ul>\n</blockquote>\n<p>我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>, <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> <span class=\"number\">#2f4</span>, <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">5px</span> <span class=\"number\">15px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, .<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。</p>\n<p>需要注意的是：</p>\n<ul>\n<li>投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。</li>\n<li>box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。</li>\n</ul>\n<h2 id=\"outline方案\"><a href=\"#outline方案\" class=\"headerlink\" title=\"outline方案\"></a>outline方案</h2><p>某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid <span class=\"number\">#533</span>;</span><br><span class=\"line\"><span class=\"attribute\">outline</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#2f4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：</p>\n<p>它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。</p>\n<h1 id=\"边框内圆角实现\"><a href=\"#边框内圆角实现\" class=\"headerlink\" title=\"边框内圆角实现\"></a>边框内圆角实现</h1><p>有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;container&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>This is a box<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#655</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: .<span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &gt; <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> .<span class=\"number\">5em</span> <span class=\"number\">#655</span></span><br><span class=\"line\">  outline: .<span class=\"number\">6em</span> solid <span class=\"number\">#655</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的效果和之前一样。</p>\n<p>因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。</p>\n<p>注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&amp;radic;2-1)*border-radius，为了方便，一般取border-radius的一半。</p>"},{"title":"CSS外边距合并效应","date":"2017-07-27T14:44:05.000Z","_content":"\n大部分人都知道CSS布局时有外边距合并，也就是说如果给两个块元素设置margin-top或者margin-bottom值，它们上下之间的margin值会发生合并，但具体是根据什么来合并呢？我查了一下，大部分的解释都是**叠加后的margin值取两者之间的最大值**，也就是说，如果给上面的元素设置margin-bottom: 40px, 下面的元素设置margin-top: 50px,则最终两者之间的外边距为50px。但如果设置的值是负值呢？\n<!--more-->\n\n# 一个为负值，一个为正值\n\n```CSS\n.tops {\n  width: 20px;\n  height: 20px;\n  background: rgb(94, 195, 27);\n  margin-bottom: -50px;\n}\n\n.bottoms {\n  width: 20px;\n  height: 20px;\n  background: rgb(29, 141, 213);\n  margin-top: 60px;\n}\n```\n\n![margin](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-10.jpg)\n\n可以看到，结果两者之间的外边距值为正负值相加，为10px。\n\n# 两个都为负值\n\n```CSS\n.tops {\n  width: 20px;\n  height: 30px;\n  background: rgb(94, 195, 27);\n  margin-bottom: -10px;\n}\n\n.bottoms {\n  width: 20px;\n  height: 20px;\n  background: rgb(29, 141, 213);\n  margin-top: -20px;\n}\n```\n\n![margin](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-20.jpg)\n\n最后两者之间外边距为-20px，也就是两个负值绝对值更大的那个。\n\n# 总结\n\n所以说，外边距合并一般有三种情况：\n- 两者都是正值，取最大的；\n- 两者一正一负，取二者相加的结果；\n- 两者都是负值，取二者绝对值更大的；\n\n> 但要注意的是，外边距合并只发生在块元素之间。一般有三种情况：\n> - 相邻的兄弟姐妹元素：毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。\n> - 块级父元素与其第一个/最后一个子元素：如果块级父元素中，不存在上边框、上内边距、内联元素、 清除浮动 这四条属性（也可以说，当上边框宽度及上内边距距离为0时），那么这个块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。\n> - 空块元素：如果存在一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。\n\n**参考文档**：[MDN-margin-collapsing](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing)\n","source":"_posts/2017-07-27-css-margin-collapse.md","raw":"---\ntitle: CSS外边距合并效应\ndate: 2017-07-27 22:44:05\ncategories:\n- CSS相关\ntags:\n- CSS技巧\n---\n\n大部分人都知道CSS布局时有外边距合并，也就是说如果给两个块元素设置margin-top或者margin-bottom值，它们上下之间的margin值会发生合并，但具体是根据什么来合并呢？我查了一下，大部分的解释都是**叠加后的margin值取两者之间的最大值**，也就是说，如果给上面的元素设置margin-bottom: 40px, 下面的元素设置margin-top: 50px,则最终两者之间的外边距为50px。但如果设置的值是负值呢？\n<!--more-->\n\n# 一个为负值，一个为正值\n\n```CSS\n.tops {\n  width: 20px;\n  height: 20px;\n  background: rgb(94, 195, 27);\n  margin-bottom: -50px;\n}\n\n.bottoms {\n  width: 20px;\n  height: 20px;\n  background: rgb(29, 141, 213);\n  margin-top: 60px;\n}\n```\n\n![margin](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-10.jpg)\n\n可以看到，结果两者之间的外边距值为正负值相加，为10px。\n\n# 两个都为负值\n\n```CSS\n.tops {\n  width: 20px;\n  height: 30px;\n  background: rgb(94, 195, 27);\n  margin-bottom: -10px;\n}\n\n.bottoms {\n  width: 20px;\n  height: 20px;\n  background: rgb(29, 141, 213);\n  margin-top: -20px;\n}\n```\n\n![margin](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-20.jpg)\n\n最后两者之间外边距为-20px，也就是两个负值绝对值更大的那个。\n\n# 总结\n\n所以说，外边距合并一般有三种情况：\n- 两者都是正值，取最大的；\n- 两者一正一负，取二者相加的结果；\n- 两者都是负值，取二者绝对值更大的；\n\n> 但要注意的是，外边距合并只发生在块元素之间。一般有三种情况：\n> - 相邻的兄弟姐妹元素：毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。\n> - 块级父元素与其第一个/最后一个子元素：如果块级父元素中，不存在上边框、上内边距、内联元素、 清除浮动 这四条属性（也可以说，当上边框宽度及上内边距距离为0时），那么这个块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。\n> - 空块元素：如果存在一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。\n\n**参考文档**：[MDN-margin-collapsing](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing)\n","slug":"css-margin-collapse","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05ck0015ra4k399t7n3n","content":"<p>大部分人都知道CSS布局时有外边距合并，也就是说如果给两个块元素设置margin-top或者margin-bottom值，它们上下之间的margin值会发生合并，但具体是根据什么来合并呢？我查了一下，大部分的解释都是<strong>叠加后的margin值取两者之间的最大值</strong>，也就是说，如果给上面的元素设置margin-bottom: 40px, 下面的元素设置margin-top: 50px,则最终两者之间的外边距为50px。但如果设置的值是负值呢？</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一个为负值，一个为正值\"><a href=\"#一个为负值，一个为正值\" class=\"headerlink\" title=\"一个为负值，一个为正值\"></a>一个为负值，一个为正值</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tops</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">94</span>, <span class=\"number\">195</span>, <span class=\"number\">27</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.bottoms</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">29</span>, <span class=\"number\">141</span>, <span class=\"number\">213</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-10.jpg\" alt=\"margin\"></p>\n<p>可以看到，结果两者之间的外边距值为正负值相加，为10px。</p>\n<h1 id=\"两个都为负值\"><a href=\"#两个都为负值\" class=\"headerlink\" title=\"两个都为负值\"></a>两个都为负值</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tops</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">94</span>, <span class=\"number\">195</span>, <span class=\"number\">27</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: -<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.bottoms</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">29</span>, <span class=\"number\">141</span>, <span class=\"number\">213</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-20.jpg\" alt=\"margin\"></p>\n<p>最后两者之间外边距为-20px，也就是两个负值绝对值更大的那个。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>所以说，外边距合并一般有三种情况：</p>\n<ul>\n<li>两者都是正值，取最大的；</li>\n<li>两者一正一负，取二者相加的结果；</li>\n<li>两者都是负值，取二者绝对值更大的；</li>\n</ul>\n<blockquote>\n<p>但要注意的是，外边距合并只发生在块元素之间。一般有三种情况：</p>\n<ul>\n<li>相邻的兄弟姐妹元素：毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。</li>\n<li>块级父元素与其第一个&#x2F;最后一个子元素：如果块级父元素中，不存在上边框、上内边距、内联元素、 清除浮动 这四条属性（也可以说，当上边框宽度及上内边距距离为0时），那么这个块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。</li>\n<li>空块元素：如果存在一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。</li>\n</ul>\n</blockquote>\n<p><strong>参考文档</strong>：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\">MDN-margin-collapsing</a></p>\n","site":{"data":{}},"excerpt":"<p>大部分人都知道CSS布局时有外边距合并，也就是说如果给两个块元素设置margin-top或者margin-bottom值，它们上下之间的margin值会发生合并，但具体是根据什么来合并呢？我查了一下，大部分的解释都是<strong>叠加后的margin值取两者之间的最大值</strong>，也就是说，如果给上面的元素设置margin-bottom: 40px, 下面的元素设置margin-top: 50px,则最终两者之间的外边距为50px。但如果设置的值是负值呢？</p>","more":"<h1 id=\"一个为负值，一个为正值\"><a href=\"#一个为负值，一个为正值\" class=\"headerlink\" title=\"一个为负值，一个为正值\"></a>一个为负值，一个为正值</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tops</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">94</span>, <span class=\"number\">195</span>, <span class=\"number\">27</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.bottoms</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">29</span>, <span class=\"number\">141</span>, <span class=\"number\">213</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-10.jpg\" alt=\"margin\"></p>\n<p>可以看到，结果两者之间的外边距值为正负值相加，为10px。</p>\n<h1 id=\"两个都为负值\"><a href=\"#两个都为负值\" class=\"headerlink\" title=\"两个都为负值\"></a>两个都为负值</h1><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.tops</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">94</span>, <span class=\"number\">195</span>, <span class=\"number\">27</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-bottom</span>: -<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.bottoms</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">rgb</span>(<span class=\"number\">29</span>, <span class=\"number\">141</span>, <span class=\"number\">213</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/margin-20.jpg\" alt=\"margin\"></p>\n<p>最后两者之间外边距为-20px，也就是两个负值绝对值更大的那个。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>所以说，外边距合并一般有三种情况：</p>\n<ul>\n<li>两者都是正值，取最大的；</li>\n<li>两者一正一负，取二者相加的结果；</li>\n<li>两者都是负值，取二者绝对值更大的；</li>\n</ul>\n<blockquote>\n<p>但要注意的是，外边距合并只发生在块元素之间。一般有三种情况：</p>\n<ul>\n<li>相邻的兄弟姐妹元素：毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。</li>\n<li>块级父元素与其第一个&#x2F;最后一个子元素：如果块级父元素中，不存在上边框、上内边距、内联元素、 清除浮动 这四条属性（也可以说，当上边框宽度及上内边距距离为0时），那么这个块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。</li>\n<li>空块元素：如果存在一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。</li>\n</ul>\n</blockquote>\n<p><strong>参考文档</strong>：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing\">MDN-margin-collapsing</a></p>"},{"title":"javascript类型转换","date":"2017-08-02T05:55:02.000Z","toc":true,"_content":"\nJavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。\n<!--more-->\n\n# JavaScript类型\n## 类型种类\n在JS中，有6种基本类型和一种引用类型，分别是：\n\n基本类型：\n\n- null\n- undefined\n- boolean\n- number\n- string\n- symbol(ES6新增)\n\n引用类型：\n\nobject\n\n## 类型检测\n一般来说，我们可以用typeof来检测某个值的数据类型，比如：\n\n```javascript\ntypeof undefined     === \"undefined\"; // true\ntypeof true          === \"boolean\";   // true\ntypeof 24            === \"number\";    // true\ntypeof \"24\"          === \"string\";    // true\ntypeof { age: 24 }  === \"object\";    // true\n\n// added in ES6!\ntypeof Symbol()      === \"symbol\";    // true\n```\n\n但是有一个例外: null,这也是一个bug\n\n```javascript\ntypeof null === \"object\"; // true\n```\n\n如果想检测某个值是否是null，则可以这样：\n\n```javascript\nvar a = null;\n(!a && typeof a === \"object\"); // true\n```\n\n需要注意的是，function和array其实也是object，但它们有所区别：\n\n```javascript\ntypeof function a(){ /* .. */ } === \"function\"; // true\ntypeof [1,2,3] === \"object\"; // true\n```\n\n如果要检测a是否是数组，可以用instanceof\n\n```javascript\nvar a = [123];\na instanceof Array; // true\n```\n\n# 类型转换抽象操作\n## ToString\n当一个非String类型的值要转换为String，我们可以用`ToString`操作。\n\n### toString()\n对于基本类型来说，它们有自然的转换关系。如：null变成\"null\",undefined变成\"undefined\",true变成\"true\",number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。\n\n对于object来说，`toString()`(代表着`Object.prototype.toString()`)将会返回`[[class]]`原型，比如说\"object Object\";但如果是数组，则重写了`toString()`方法，会返回一个以逗号分隔数组值的字符串。比如：\n\n```javascript\nvar a = [1,2,3];\na.toString(); // \"1,2,3\"\n```\n### JSON.stringify()\n另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：\n\n1\n2\n3\n4\n```javascript\nJSON.stringify( 42 );\t// \"42\"\nJSON.stringify( \"42\" );\t// \"\"42\"\" (外面多加一层引号)\nJSON.stringify( null );\t// \"null\"\nJSON.stringify( true );\t// \"true\"\n```\n\n但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：\n\n```javascript\nJSON.stringify( undefined );\t// undefined\nJSON.stringify( function(){} );\t// undefined\n\nJSON.stringify( [1,undefined,function(){},4] );\t// \"[1,null,null,4]\"\nJSON.stringify( { a:2, b:function(){} } );\t// \"{\"a\":2}\"\n```\n\n如果JSON.stringify调用了循环引用的object，则会抛出`Error`。如果JSON.stringify调用的对象有`toJSON()`方法，则会对toJSON()的返回值再进行stringify。\n\n```javascript\nvar a = {\n  b: 111\n};\na.toJSON = function() {\n\treturn { b: this.b };\n};\n\nJSON.stringify( a ); // \"{\"b\":111}\"\n\nvar c = {\n\tval: [1,2,3],\n\n\ttoJSON: function(){\n\t\treturn this.val.slice( 1 );\n\t}\n};\nJSON.stringify( c ); // \"[2,3]\"\n```\n\n## ToNumber\n转换为number，我们可以用ToNumber操作。\n\n### Number()\n对于基本类型，转换规则为：true -> 1,false -> 0,undefined -> NaN,null -> 0，字符串如果包含字母则转换为NaN。\n\n对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。\n\n比如：\n\n```javascript\nvar a = {\n\tvalueOf: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar b = {\n\ttoString: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar c = [1,2];\nc.toString = function(){\n\treturn this.join( \"\" );\t// \"12\"\n};\n\nNumber( a );\t\t\t// 12\nNumber( b );\t\t\t// 12\nNumber( c );\t\t\t// 12\nNumber( \"\" );\t\t\t// 0\nNumber( [] );\t\t\t// 0\nNumber( [ \"abc\" ] );\t// NaN\n```\n\n## ToBoolean\n将一个值转换为Boolean值，我们先看一个false表：\n\n```\nundefined\nnull\nfalse\n+0, -0, and NaN\n“”\n```\n\n任何不在这个表上的值都为true。\n比如：\n\n```javascript\nvar a = new Boolean( false );\nvar b = new Number( 0 );\nvar c = new String( \"\" );\nBoolean( a && b && c );  // true\n/***************/\nvar a = \"false\";\nvar b = \"0\";\nvar c = \"''\";\nBoolean( a && b && c );  // true\n/***************/\nvar a = [];\t\t\nvar b = {};\t\t\t\nvar c = function(){};\nBoolean( a && b && c );  // true\n```\n\n# 显式转换\n之前提到过一些显式转换，但其实还有以下几种：\n\n## 字符串与数字的转换\n\n```javascript\nvar a = 42;\nvar b = a.toString();\n\nvar c = \"3.14\";\nvar d = +c;\n\nb; // \"42\"\nd; // 3.14\n```\n\n## 日期转换为数字\nDate转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。\n\n```javascript\nvar d = new Date( \"Wed, 2 Aug 2017 08:53:06 CDT\" );\n\n+d; // 1501681986000\n```\n\nDate.now()方法就是用的这种转换：\n\n```javascript\nif (!Date.now) {\n\tDate.now = function() {\n\t\treturn +new Date();\n\t};\n}\n```\n\n## ~操作符\nJs里有\"\\~\"操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，\"\\~x\"相当于\"-(x+1)\"。\n\n于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：\n\n```javascript\nvar a = \"Hello World\";\n\n~a.indexOf( \"lo\" );\t\t\t// -4   <-- truthy!\n\nif (~a.indexOf( \"lo\" )) {\t// true\n  // 找到了\n}\n\n~a.indexOf( \"ol\" );\t\t\t// 0    <-- falsy!\n!~a.indexOf( \"ol\" );\t\t// true\n\nif (!~a.indexOf( \"ol\" )) {\t// true\n\t// 没有找到\n}\n```\n\n除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：\n\n```javascript\nMath.floor( -49.6 );\t// -50\nMath.ceil(-49.6);  // -49\n~~-49.6;\t\t   // -49\n```\n## parseInt()方法\n该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：\n\n```javascript\nparseInt( 0.000008 );\t\t// 0   (\"0\" from \"0.000008\")\nparseInt( 0.0000008 );\t\t// 8   (\"8\" from \"8e-7\")\nparseInt( false, 16 );\t\t// 250 (\"fa\" from \"false\")\nparseInt( parseInt, 16 );\t// 15  (\"f\" from \"function..\")\n\nparseInt( \"0x10\" );\t\t\t// 16\nparseInt( \"103\", 2 );\t\t// 2\n```\n\n所以，要谨慎使用parseInt。\n\n## 转换为Boolean\n我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：\n\n```javascript\nvar a = \"0\";\nvar b = [];\nvar c = {};\n\nvar d = \"\";\nvar e = 0;\nvar f = null;\nvar g;\n\n!!a;\t// true\n!!b;\t// true\n!!c;\t// true\n\n!!d;\t// false\n!!e;\t// false\n!!f;\t// false\n!!g;\t// false\n```\n\n# 隐式转换\n## 数字转换为字符串\n因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：\n\n```javascript\nvar a = 122;\nvar b = a + '';  \nb;  // \"122\"\n```\n\n## 字符串转换为数字\n因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：\n\n```javascript\nvar a = \"122\";\nvar b = a - 0;  \nb;  // 122\n```\n\n## 数组转换为数字\n同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：\n\n```javascript\nvar a = [3];\nvar b = [1];\na - b; // 2\n```\n\n# 操作符的妙用\n## 操作符||和&&\n我们都知道||代表‘或’，&&代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：\n\n```javascript\nvar a = 42;\nvar b = \"abc\";\nvar c = null;\n\na || b;\t\t// 42\na && b;\t\t// \"abc\"\n\nc || b;\t\t// \"abc\"\nc && b;\t\t// null\n```\n\n于是我们就可以利用这两个操作符进行一些赋值操作：\n\n```javascript\na || b;\n// 等价于：\na ? a : b;\n\na && b;\n// 等价于：\na ? b : a;\n```\n\n## 操作符==与===\n这两个符号我们应该很熟悉了，==代表值的比较，如果二者类型不同，会进行强制转换；===则是二者值与类型都相同才为true。这里需要注意一些问题：\n\n> NaN不等于它本身\n> +0等于-0\n\n### 字符串与数字比较\n二者比较时，使用===结果肯定为false，因为二者类型不同，但如果使用==，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：\n\n```javascript\nvar a = 22;\nvar b = \"22\";\n\na === b;\t// false\na == b;\t\t// true\n```\n### 任何值与Boolean比较\n当任何值与Boolean使用==比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：\n\n```javascript\nvar x = true;\nvar y = \"42\";\n\nx == y; // false\n```\n\n所以，在任何时候，都不要使用== true或者== false这样的语句。\n\n### null与undefined比较\n当使用==比较null和undefined时，结果总为true。\n\n### Object与非Object比较\n当object/function/array与String或者Number进行==比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。\n\n### 一些值得注意的比较\n\n```javascript\n\"\" == [null];\t// true\n[] == ![]; // true\n0 == \"\\n\"; // true\n\"0\" == false;\t// true\nfalse == 0;\t\t// true\nfalse == \"\";\t// true\nfalse == [];\t// true\n\"\" == 0;\t\t// true\n\"\" == [];\t\t// true\n0 == [];\t\t// true\n```\n\n# 总结\n需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用`valueOf()`方法，没有才调用`toString()`方法，如果我们给自定义的对象添加`valueOf()`方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用===比较安全。\n\n> 参考资料： [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS/)","source":"_posts/2017-08-02-js-value-coercions.md","raw":"---\ntitle: javascript类型转换\ndate: 2017-08-02 13:55:02\ntoc: true\ncategories:\n- JS相关\ntags:\n- JS原理\n---\n\nJavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。\n<!--more-->\n\n# JavaScript类型\n## 类型种类\n在JS中，有6种基本类型和一种引用类型，分别是：\n\n基本类型：\n\n- null\n- undefined\n- boolean\n- number\n- string\n- symbol(ES6新增)\n\n引用类型：\n\nobject\n\n## 类型检测\n一般来说，我们可以用typeof来检测某个值的数据类型，比如：\n\n```javascript\ntypeof undefined     === \"undefined\"; // true\ntypeof true          === \"boolean\";   // true\ntypeof 24            === \"number\";    // true\ntypeof \"24\"          === \"string\";    // true\ntypeof { age: 24 }  === \"object\";    // true\n\n// added in ES6!\ntypeof Symbol()      === \"symbol\";    // true\n```\n\n但是有一个例外: null,这也是一个bug\n\n```javascript\ntypeof null === \"object\"; // true\n```\n\n如果想检测某个值是否是null，则可以这样：\n\n```javascript\nvar a = null;\n(!a && typeof a === \"object\"); // true\n```\n\n需要注意的是，function和array其实也是object，但它们有所区别：\n\n```javascript\ntypeof function a(){ /* .. */ } === \"function\"; // true\ntypeof [1,2,3] === \"object\"; // true\n```\n\n如果要检测a是否是数组，可以用instanceof\n\n```javascript\nvar a = [123];\na instanceof Array; // true\n```\n\n# 类型转换抽象操作\n## ToString\n当一个非String类型的值要转换为String，我们可以用`ToString`操作。\n\n### toString()\n对于基本类型来说，它们有自然的转换关系。如：null变成\"null\",undefined变成\"undefined\",true变成\"true\",number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。\n\n对于object来说，`toString()`(代表着`Object.prototype.toString()`)将会返回`[[class]]`原型，比如说\"object Object\";但如果是数组，则重写了`toString()`方法，会返回一个以逗号分隔数组值的字符串。比如：\n\n```javascript\nvar a = [1,2,3];\na.toString(); // \"1,2,3\"\n```\n### JSON.stringify()\n另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：\n\n1\n2\n3\n4\n```javascript\nJSON.stringify( 42 );\t// \"42\"\nJSON.stringify( \"42\" );\t// \"\"42\"\" (外面多加一层引号)\nJSON.stringify( null );\t// \"null\"\nJSON.stringify( true );\t// \"true\"\n```\n\n但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：\n\n```javascript\nJSON.stringify( undefined );\t// undefined\nJSON.stringify( function(){} );\t// undefined\n\nJSON.stringify( [1,undefined,function(){},4] );\t// \"[1,null,null,4]\"\nJSON.stringify( { a:2, b:function(){} } );\t// \"{\"a\":2}\"\n```\n\n如果JSON.stringify调用了循环引用的object，则会抛出`Error`。如果JSON.stringify调用的对象有`toJSON()`方法，则会对toJSON()的返回值再进行stringify。\n\n```javascript\nvar a = {\n  b: 111\n};\na.toJSON = function() {\n\treturn { b: this.b };\n};\n\nJSON.stringify( a ); // \"{\"b\":111}\"\n\nvar c = {\n\tval: [1,2,3],\n\n\ttoJSON: function(){\n\t\treturn this.val.slice( 1 );\n\t}\n};\nJSON.stringify( c ); // \"[2,3]\"\n```\n\n## ToNumber\n转换为number，我们可以用ToNumber操作。\n\n### Number()\n对于基本类型，转换规则为：true -> 1,false -> 0,undefined -> NaN,null -> 0，字符串如果包含字母则转换为NaN。\n\n对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。\n\n比如：\n\n```javascript\nvar a = {\n\tvalueOf: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar b = {\n\ttoString: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar c = [1,2];\nc.toString = function(){\n\treturn this.join( \"\" );\t// \"12\"\n};\n\nNumber( a );\t\t\t// 12\nNumber( b );\t\t\t// 12\nNumber( c );\t\t\t// 12\nNumber( \"\" );\t\t\t// 0\nNumber( [] );\t\t\t// 0\nNumber( [ \"abc\" ] );\t// NaN\n```\n\n## ToBoolean\n将一个值转换为Boolean值，我们先看一个false表：\n\n```\nundefined\nnull\nfalse\n+0, -0, and NaN\n“”\n```\n\n任何不在这个表上的值都为true。\n比如：\n\n```javascript\nvar a = new Boolean( false );\nvar b = new Number( 0 );\nvar c = new String( \"\" );\nBoolean( a && b && c );  // true\n/***************/\nvar a = \"false\";\nvar b = \"0\";\nvar c = \"''\";\nBoolean( a && b && c );  // true\n/***************/\nvar a = [];\t\t\nvar b = {};\t\t\t\nvar c = function(){};\nBoolean( a && b && c );  // true\n```\n\n# 显式转换\n之前提到过一些显式转换，但其实还有以下几种：\n\n## 字符串与数字的转换\n\n```javascript\nvar a = 42;\nvar b = a.toString();\n\nvar c = \"3.14\";\nvar d = +c;\n\nb; // \"42\"\nd; // 3.14\n```\n\n## 日期转换为数字\nDate转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。\n\n```javascript\nvar d = new Date( \"Wed, 2 Aug 2017 08:53:06 CDT\" );\n\n+d; // 1501681986000\n```\n\nDate.now()方法就是用的这种转换：\n\n```javascript\nif (!Date.now) {\n\tDate.now = function() {\n\t\treturn +new Date();\n\t};\n}\n```\n\n## ~操作符\nJs里有\"\\~\"操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，\"\\~x\"相当于\"-(x+1)\"。\n\n于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：\n\n```javascript\nvar a = \"Hello World\";\n\n~a.indexOf( \"lo\" );\t\t\t// -4   <-- truthy!\n\nif (~a.indexOf( \"lo\" )) {\t// true\n  // 找到了\n}\n\n~a.indexOf( \"ol\" );\t\t\t// 0    <-- falsy!\n!~a.indexOf( \"ol\" );\t\t// true\n\nif (!~a.indexOf( \"ol\" )) {\t// true\n\t// 没有找到\n}\n```\n\n除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：\n\n```javascript\nMath.floor( -49.6 );\t// -50\nMath.ceil(-49.6);  // -49\n~~-49.6;\t\t   // -49\n```\n## parseInt()方法\n该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：\n\n```javascript\nparseInt( 0.000008 );\t\t// 0   (\"0\" from \"0.000008\")\nparseInt( 0.0000008 );\t\t// 8   (\"8\" from \"8e-7\")\nparseInt( false, 16 );\t\t// 250 (\"fa\" from \"false\")\nparseInt( parseInt, 16 );\t// 15  (\"f\" from \"function..\")\n\nparseInt( \"0x10\" );\t\t\t// 16\nparseInt( \"103\", 2 );\t\t// 2\n```\n\n所以，要谨慎使用parseInt。\n\n## 转换为Boolean\n我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：\n\n```javascript\nvar a = \"0\";\nvar b = [];\nvar c = {};\n\nvar d = \"\";\nvar e = 0;\nvar f = null;\nvar g;\n\n!!a;\t// true\n!!b;\t// true\n!!c;\t// true\n\n!!d;\t// false\n!!e;\t// false\n!!f;\t// false\n!!g;\t// false\n```\n\n# 隐式转换\n## 数字转换为字符串\n因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：\n\n```javascript\nvar a = 122;\nvar b = a + '';  \nb;  // \"122\"\n```\n\n## 字符串转换为数字\n因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：\n\n```javascript\nvar a = \"122\";\nvar b = a - 0;  \nb;  // 122\n```\n\n## 数组转换为数字\n同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：\n\n```javascript\nvar a = [3];\nvar b = [1];\na - b; // 2\n```\n\n# 操作符的妙用\n## 操作符||和&&\n我们都知道||代表‘或’，&&代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：\n\n```javascript\nvar a = 42;\nvar b = \"abc\";\nvar c = null;\n\na || b;\t\t// 42\na && b;\t\t// \"abc\"\n\nc || b;\t\t// \"abc\"\nc && b;\t\t// null\n```\n\n于是我们就可以利用这两个操作符进行一些赋值操作：\n\n```javascript\na || b;\n// 等价于：\na ? a : b;\n\na && b;\n// 等价于：\na ? b : a;\n```\n\n## 操作符==与===\n这两个符号我们应该很熟悉了，==代表值的比较，如果二者类型不同，会进行强制转换；===则是二者值与类型都相同才为true。这里需要注意一些问题：\n\n> NaN不等于它本身\n> +0等于-0\n\n### 字符串与数字比较\n二者比较时，使用===结果肯定为false，因为二者类型不同，但如果使用==，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：\n\n```javascript\nvar a = 22;\nvar b = \"22\";\n\na === b;\t// false\na == b;\t\t// true\n```\n### 任何值与Boolean比较\n当任何值与Boolean使用==比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：\n\n```javascript\nvar x = true;\nvar y = \"42\";\n\nx == y; // false\n```\n\n所以，在任何时候，都不要使用== true或者== false这样的语句。\n\n### null与undefined比较\n当使用==比较null和undefined时，结果总为true。\n\n### Object与非Object比较\n当object/function/array与String或者Number进行==比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。\n\n### 一些值得注意的比较\n\n```javascript\n\"\" == [null];\t// true\n[] == ![]; // true\n0 == \"\\n\"; // true\n\"0\" == false;\t// true\nfalse == 0;\t\t// true\nfalse == \"\";\t// true\nfalse == [];\t// true\n\"\" == 0;\t\t// true\n\"\" == [];\t\t// true\n0 == [];\t\t// true\n```\n\n# 总结\n需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用`valueOf()`方法，没有才调用`toString()`方法，如果我们给自定义的对象添加`valueOf()`方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用===比较安全。\n\n> 参考资料： [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS/)","slug":"js-value-coercions","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cl0017ra4kefykhb91","content":"<p>JavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"JavaScript类型\"><a href=\"#JavaScript类型\" class=\"headerlink\" title=\"JavaScript类型\"></a>JavaScript类型</h1><h2 id=\"类型种类\"><a href=\"#类型种类\" class=\"headerlink\" title=\"类型种类\"></a>类型种类</h2><p>在JS中，有6种基本类型和一种引用类型，分别是：</p>\n<p>基本类型：</p>\n<ul>\n<li>null</li>\n<li>undefined</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>symbol(ES6新增)</li>\n</ul>\n<p>引用类型：</p>\n<p>object</p>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><p>一般来说，我们可以用typeof来检测某个值的数据类型，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>     === <span class=\"string\">&quot;undefined&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>          === <span class=\"string\">&quot;boolean&quot;</span>;   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">24</span>            === <span class=\"string\">&quot;number&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;24&quot;</span>          === <span class=\"string\">&quot;string&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123; <span class=\"attr\">age</span>: <span class=\"number\">24</span> &#125;  === <span class=\"string\">&quot;object&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// added in ES6!</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>()      === <span class=\"string\">&quot;symbol&quot;</span>;    <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但是有一个例外: null,这也是一个bug</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果想检测某个值是否是null，则可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(!a &amp;&amp; <span class=\"keyword\">typeof</span> a === <span class=\"string\">&quot;object&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，function和array其实也是object，但它们有所区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123; <span class=\"comment\">/* .. */</span> &#125; === <span class=\"string\">&quot;function&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要检测a是否是数组，可以用instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">123</span>];</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类型转换抽象操作\"><a href=\"#类型转换抽象操作\" class=\"headerlink\" title=\"类型转换抽象操作\"></a>类型转换抽象操作</h1><h2 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString\"></a>ToString</h2><p>当一个非String类型的值要转换为String，我们可以用<code>ToString</code>操作。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>对于基本类型来说，它们有自然的转换关系。如：null变成”null”,undefined变成”undefined”,true变成”true”,number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。</p>\n<p>对于object来说，<code>toString()</code>(代表着<code>Object.prototype.toString()</code>)将会返回<code>[[class]]</code>原型，比如说”object Object”;但如果是数组，则重写了<code>toString()</code>方法，会返回一个以逗号分隔数组值的字符串。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">a.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify()\"></a>JSON.stringify()</h3><p>另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：</p>\n<p>1<br>2<br>3<br>4</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"number\">42</span> );\t<span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"string\">&quot;42&quot;</span> );\t<span class=\"comment\">// &quot;&quot;42&quot;&quot; (外面多加一层引号)</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">null</span> );\t<span class=\"comment\">// &quot;null&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">true</span> );\t<span class=\"comment\">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">undefined</span> );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( [<span class=\"number\">1</span>,<span class=\"literal\">undefined</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;,<span class=\"number\">4</span>] );\t<span class=\"comment\">// &quot;[1,null,null,4]&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( &#123; <span class=\"attr\">a</span>:<span class=\"number\">2</span>, <span class=\"attr\">b</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; &#125; );\t<span class=\"comment\">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果JSON.stringify调用了循环引用的object，则会抛出<code>Error</code>。如果JSON.stringify调用的对象有<code>toJSON()</code>方法，则会对toJSON()的返回值再进行stringify。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">111</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a.<span class=\"property\">toJSON</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123; <span class=\"attr\">b</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( a ); <span class=\"comment\">// &quot;&#123;&quot;b&quot;:111&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">val</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">toJSON</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">val</span>.<span class=\"title function_\">slice</span>( <span class=\"number\">1</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( c ); <span class=\"comment\">// &quot;[2,3]&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h2><p>转换为number，我们可以用ToNumber操作。</p>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number()\"></a>Number()</h3><p>对于基本类型，转换规则为：true -&gt; 1,false -&gt; 0,undefined -&gt; NaN,null -&gt; 0，字符串如果包含字母则转换为NaN。</p>\n<p>对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。</p>\n<p>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">valueOf</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">c.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">join</span>( <span class=\"string\">&quot;&quot;</span> );\t<span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( a );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( b );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( c );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( <span class=\"string\">&quot;&quot;</span> );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [] );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [ <span class=\"string\">&quot;abc&quot;</span> ] );\t<span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h2><p>将一个值转换为Boolean值，我们先看一个false表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undefined</span><br><span class=\"line\">null</span><br><span class=\"line\">false</span><br><span class=\"line\">+0, -0, and NaN</span><br><span class=\"line\">“”</span><br></pre></td></tr></table></figure>\n\n<p>任何不在这个表上的值都为true。<br>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>( <span class=\"literal\">false</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>( <span class=\"number\">0</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>( <span class=\"string\">&quot;&quot;</span> );</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;false&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;&#x27;&#x27;&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h1><p>之前提到过一些显式转换，但其实还有以下几种：</p>\n<h2 id=\"字符串与数字的转换\"><a href=\"#字符串与数字的转换\" class=\"headerlink\" title=\"字符串与数字的转换\"></a>字符串与数字的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;3.14&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = +c;</span><br><span class=\"line\"></span><br><span class=\"line\">b; <span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\">d; <span class=\"comment\">// 3.14</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期转换为数字\"><a href=\"#日期转换为数字\" class=\"headerlink\" title=\"日期转换为数字\"></a>日期转换为数字</h2><p>Date转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>( <span class=\"string\">&quot;Wed, 2 Aug 2017 08:53:06 CDT&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">+d; <span class=\"comment\">// 1501681986000</span></span><br></pre></td></tr></table></figure>\n\n<p>Date.now()方法就是用的这种转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Date</span>.<span class=\"property\">now</span>) &#123;</span><br><span class=\"line\">\t<span class=\"title class_\">Date</span>.<span class=\"property\">now</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> +<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"~操作符\"></a>~操作符</h2><p>Js里有”~“操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，”~x”相当于”-(x+1)”。</p>\n<p>于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> );\t\t\t<span class=\"comment\">// -4   &lt;-- truthy!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"comment\">// 找到了</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t\t<span class=\"comment\">// 0    &lt;-- falsy!</span></span><br><span class=\"line\">!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">\t<span class=\"comment\">// 没有找到</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>( -<span class=\"number\">49.6</span> );\t<span class=\"comment\">// -50</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(-<span class=\"number\">49.6</span>);  <span class=\"comment\">// -49</span></span><br><span class=\"line\">~~-<span class=\"number\">49.6</span>;\t\t   <span class=\"comment\">// -49</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"parseInt-方法\"><a href=\"#parseInt-方法\" class=\"headerlink\" title=\"parseInt()方法\"></a>parseInt()方法</h2><p>该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.000008</span> );\t\t<span class=\"comment\">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.0000008</span> );\t\t<span class=\"comment\">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"literal\">false</span>, <span class=\"number\">16</span> );\t\t<span class=\"comment\">// 250 (&quot;fa&quot; from &quot;false&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"built_in\">parseInt</span>, <span class=\"number\">16</span> );\t<span class=\"comment\">// 15  (&quot;f&quot; from &quot;function..&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;0x10&quot;</span> );\t\t\t<span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;103&quot;</span>, <span class=\"number\">2</span> );\t\t<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，要谨慎使用parseInt。</p>\n<h2 id=\"转换为Boolean\"><a href=\"#转换为Boolean\" class=\"headerlink\" title=\"转换为Boolean\"></a>转换为Boolean</h2><p>我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g;</span><br><span class=\"line\"></span><br><span class=\"line\">!!a;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!b;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!c;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!!d;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!e;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!f;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!g;\t<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h1><h2 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h2><p>因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">122</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a + <span class=\"string\">&#x27;&#x27;</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// &quot;122&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串转换为数字\"><a href=\"#字符串转换为数字\" class=\"headerlink\" title=\"字符串转换为数字\"></a>字符串转换为数字</h2><p>因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;122&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a - <span class=\"number\">0</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// 122</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组转换为数字\"><a href=\"#数组转换为数字\" class=\"headerlink\" title=\"数组转换为数字\"></a>数组转换为数字</h2><p>同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>];</span><br><span class=\"line\">a - b; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"操作符的妙用\"><a href=\"#操作符的妙用\" class=\"headerlink\" title=\"操作符的妙用\"></a>操作符的妙用</h1><h2 id=\"操作符-和-amp-amp\"><a href=\"#操作符-和-amp-amp\" class=\"headerlink\" title=\"操作符||和&amp;&amp;\"></a>操作符||和&amp;&amp;</h2><p>我们都知道||代表‘或’，&amp;&amp;代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a || b;\t\t<span class=\"comment\">// 42</span></span><br><span class=\"line\">a &amp;&amp; b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">c || b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\">c &amp;&amp; b;\t\t<span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以利用这两个操作符进行一些赋值操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a || b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? a : b;</span><br><span class=\"line\"></span><br><span class=\"line\">a &amp;&amp; b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? b : a;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符-x3D-x3D-与-x3D-x3D-x3D\"><a href=\"#操作符-x3D-x3D-与-x3D-x3D-x3D\" class=\"headerlink\" title=\"操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;\"></a>操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</h2><p>这两个符号我们应该很熟悉了，&#x3D;&#x3D;代表值的比较，如果二者类型不同，会进行强制转换；&#x3D;&#x3D;&#x3D;则是二者值与类型都相同才为true。这里需要注意一些问题：</p>\n<blockquote>\n<p>NaN不等于它本身<br>+0等于-0</p>\n</blockquote>\n<h3 id=\"字符串与数字比较\"><a href=\"#字符串与数字比较\" class=\"headerlink\" title=\"字符串与数字比较\"></a>字符串与数字比较</h3><p>二者比较时，使用&#x3D;&#x3D;&#x3D;结果肯定为false，因为二者类型不同，但如果使用&#x3D;&#x3D;，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;22&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a === b;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">a == b;\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"任何值与Boolean比较\"><a href=\"#任何值与Boolean比较\" class=\"headerlink\" title=\"任何值与Boolean比较\"></a>任何值与Boolean比较</h3><p>当任何值与Boolean使用&#x3D;&#x3D;比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"string\">&quot;42&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x == y; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，在任何时候，都不要使用&#x3D;&#x3D; true或者&#x3D;&#x3D; false这样的语句。</p>\n<h3 id=\"null与undefined比较\"><a href=\"#null与undefined比较\" class=\"headerlink\" title=\"null与undefined比较\"></a>null与undefined比较</h3><p>当使用&#x3D;&#x3D;比较null和undefined时，结果总为true。</p>\n<h3 id=\"Object与非Object比较\"><a href=\"#Object与非Object比较\" class=\"headerlink\" title=\"Object与非Object比较\"></a>Object与非Object比较</h3><p>当object&#x2F;function&#x2F;array与String或者Number进行&#x3D;&#x3D;比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。</p>\n<h3 id=\"一些值得注意的比较\"><a href=\"#一些值得注意的比较\" class=\"headerlink\" title=\"一些值得注意的比较\"></a>一些值得注意的比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [<span class=\"literal\">null</span>];\t<span class=\"comment\">// true</span></span><br><span class=\"line\">[] == ![]; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">&quot;\\n&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;0&quot;</span> == <span class=\"literal\">false</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"string\">&quot;&quot;</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == [];\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [];\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == [];\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用<code>valueOf()</code>方法，没有才调用<code>toString()</code>方法，如果我们给自定义的对象添加<code>valueOf()</code>方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用&#x3D;&#x3D;&#x3D;比较安全。</p>\n<blockquote>\n<p>参考资料： <a href=\"https://github.com/getify/You-Dont-Know-JS/\">You-Dont-Know-JS</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>JavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。</p>","more":"<h1 id=\"JavaScript类型\"><a href=\"#JavaScript类型\" class=\"headerlink\" title=\"JavaScript类型\"></a>JavaScript类型</h1><h2 id=\"类型种类\"><a href=\"#类型种类\" class=\"headerlink\" title=\"类型种类\"></a>类型种类</h2><p>在JS中，有6种基本类型和一种引用类型，分别是：</p>\n<p>基本类型：</p>\n<ul>\n<li>null</li>\n<li>undefined</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>symbol(ES6新增)</li>\n</ul>\n<p>引用类型：</p>\n<p>object</p>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><p>一般来说，我们可以用typeof来检测某个值的数据类型，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>     === <span class=\"string\">&quot;undefined&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>          === <span class=\"string\">&quot;boolean&quot;</span>;   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">24</span>            === <span class=\"string\">&quot;number&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;24&quot;</span>          === <span class=\"string\">&quot;string&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123; <span class=\"attr\">age</span>: <span class=\"number\">24</span> &#125;  === <span class=\"string\">&quot;object&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// added in ES6!</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>()      === <span class=\"string\">&quot;symbol&quot;</span>;    <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但是有一个例外: null,这也是一个bug</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果想检测某个值是否是null，则可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(!a &amp;&amp; <span class=\"keyword\">typeof</span> a === <span class=\"string\">&quot;object&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，function和array其实也是object，但它们有所区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123; <span class=\"comment\">/* .. */</span> &#125; === <span class=\"string\">&quot;function&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要检测a是否是数组，可以用instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">123</span>];</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类型转换抽象操作\"><a href=\"#类型转换抽象操作\" class=\"headerlink\" title=\"类型转换抽象操作\"></a>类型转换抽象操作</h1><h2 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString\"></a>ToString</h2><p>当一个非String类型的值要转换为String，我们可以用<code>ToString</code>操作。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>对于基本类型来说，它们有自然的转换关系。如：null变成”null”,undefined变成”undefined”,true变成”true”,number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。</p>\n<p>对于object来说，<code>toString()</code>(代表着<code>Object.prototype.toString()</code>)将会返回<code>[[class]]</code>原型，比如说”object Object”;但如果是数组，则重写了<code>toString()</code>方法，会返回一个以逗号分隔数组值的字符串。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">a.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify()\"></a>JSON.stringify()</h3><p>另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：</p>\n<p>1<br>2<br>3<br>4</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"number\">42</span> );\t<span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"string\">&quot;42&quot;</span> );\t<span class=\"comment\">// &quot;&quot;42&quot;&quot; (外面多加一层引号)</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">null</span> );\t<span class=\"comment\">// &quot;null&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">true</span> );\t<span class=\"comment\">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">undefined</span> );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( [<span class=\"number\">1</span>,<span class=\"literal\">undefined</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;,<span class=\"number\">4</span>] );\t<span class=\"comment\">// &quot;[1,null,null,4]&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( &#123; <span class=\"attr\">a</span>:<span class=\"number\">2</span>, <span class=\"attr\">b</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; &#125; );\t<span class=\"comment\">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果JSON.stringify调用了循环引用的object，则会抛出<code>Error</code>。如果JSON.stringify调用的对象有<code>toJSON()</code>方法，则会对toJSON()的返回值再进行stringify。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">111</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a.<span class=\"property\">toJSON</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123; <span class=\"attr\">b</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( a ); <span class=\"comment\">// &quot;&#123;&quot;b&quot;:111&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">val</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">toJSON</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">val</span>.<span class=\"title function_\">slice</span>( <span class=\"number\">1</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( c ); <span class=\"comment\">// &quot;[2,3]&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h2><p>转换为number，我们可以用ToNumber操作。</p>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number()\"></a>Number()</h3><p>对于基本类型，转换规则为：true -&gt; 1,false -&gt; 0,undefined -&gt; NaN,null -&gt; 0，字符串如果包含字母则转换为NaN。</p>\n<p>对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。</p>\n<p>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">valueOf</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">c.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">join</span>( <span class=\"string\">&quot;&quot;</span> );\t<span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( a );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( b );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( c );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( <span class=\"string\">&quot;&quot;</span> );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [] );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [ <span class=\"string\">&quot;abc&quot;</span> ] );\t<span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h2><p>将一个值转换为Boolean值，我们先看一个false表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undefined</span><br><span class=\"line\">null</span><br><span class=\"line\">false</span><br><span class=\"line\">+0, -0, and NaN</span><br><span class=\"line\">“”</span><br></pre></td></tr></table></figure>\n\n<p>任何不在这个表上的值都为true。<br>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>( <span class=\"literal\">false</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>( <span class=\"number\">0</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>( <span class=\"string\">&quot;&quot;</span> );</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;false&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;&#x27;&#x27;&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h1><p>之前提到过一些显式转换，但其实还有以下几种：</p>\n<h2 id=\"字符串与数字的转换\"><a href=\"#字符串与数字的转换\" class=\"headerlink\" title=\"字符串与数字的转换\"></a>字符串与数字的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;3.14&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = +c;</span><br><span class=\"line\"></span><br><span class=\"line\">b; <span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\">d; <span class=\"comment\">// 3.14</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期转换为数字\"><a href=\"#日期转换为数字\" class=\"headerlink\" title=\"日期转换为数字\"></a>日期转换为数字</h2><p>Date转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>( <span class=\"string\">&quot;Wed, 2 Aug 2017 08:53:06 CDT&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">+d; <span class=\"comment\">// 1501681986000</span></span><br></pre></td></tr></table></figure>\n\n<p>Date.now()方法就是用的这种转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Date</span>.<span class=\"property\">now</span>) &#123;</span><br><span class=\"line\">\t<span class=\"title class_\">Date</span>.<span class=\"property\">now</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> +<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"~操作符\"></a>~操作符</h2><p>Js里有”~“操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，”~x”相当于”-(x+1)”。</p>\n<p>于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> );\t\t\t<span class=\"comment\">// -4   &lt;-- truthy!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"comment\">// 找到了</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t\t<span class=\"comment\">// 0    &lt;-- falsy!</span></span><br><span class=\"line\">!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">\t<span class=\"comment\">// 没有找到</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>( -<span class=\"number\">49.6</span> );\t<span class=\"comment\">// -50</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(-<span class=\"number\">49.6</span>);  <span class=\"comment\">// -49</span></span><br><span class=\"line\">~~-<span class=\"number\">49.6</span>;\t\t   <span class=\"comment\">// -49</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"parseInt-方法\"><a href=\"#parseInt-方法\" class=\"headerlink\" title=\"parseInt()方法\"></a>parseInt()方法</h2><p>该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.000008</span> );\t\t<span class=\"comment\">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.0000008</span> );\t\t<span class=\"comment\">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"literal\">false</span>, <span class=\"number\">16</span> );\t\t<span class=\"comment\">// 250 (&quot;fa&quot; from &quot;false&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"built_in\">parseInt</span>, <span class=\"number\">16</span> );\t<span class=\"comment\">// 15  (&quot;f&quot; from &quot;function..&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;0x10&quot;</span> );\t\t\t<span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;103&quot;</span>, <span class=\"number\">2</span> );\t\t<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，要谨慎使用parseInt。</p>\n<h2 id=\"转换为Boolean\"><a href=\"#转换为Boolean\" class=\"headerlink\" title=\"转换为Boolean\"></a>转换为Boolean</h2><p>我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g;</span><br><span class=\"line\"></span><br><span class=\"line\">!!a;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!b;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!c;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!!d;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!e;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!f;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!g;\t<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h1><h2 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h2><p>因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">122</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a + <span class=\"string\">&#x27;&#x27;</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// &quot;122&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串转换为数字\"><a href=\"#字符串转换为数字\" class=\"headerlink\" title=\"字符串转换为数字\"></a>字符串转换为数字</h2><p>因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;122&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a - <span class=\"number\">0</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// 122</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组转换为数字\"><a href=\"#数组转换为数字\" class=\"headerlink\" title=\"数组转换为数字\"></a>数组转换为数字</h2><p>同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>];</span><br><span class=\"line\">a - b; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"操作符的妙用\"><a href=\"#操作符的妙用\" class=\"headerlink\" title=\"操作符的妙用\"></a>操作符的妙用</h1><h2 id=\"操作符-和-amp-amp\"><a href=\"#操作符-和-amp-amp\" class=\"headerlink\" title=\"操作符||和&amp;&amp;\"></a>操作符||和&amp;&amp;</h2><p>我们都知道||代表‘或’，&amp;&amp;代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a || b;\t\t<span class=\"comment\">// 42</span></span><br><span class=\"line\">a &amp;&amp; b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">c || b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\">c &amp;&amp; b;\t\t<span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以利用这两个操作符进行一些赋值操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a || b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? a : b;</span><br><span class=\"line\"></span><br><span class=\"line\">a &amp;&amp; b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? b : a;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符-x3D-x3D-与-x3D-x3D-x3D\"><a href=\"#操作符-x3D-x3D-与-x3D-x3D-x3D\" class=\"headerlink\" title=\"操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;\"></a>操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</h2><p>这两个符号我们应该很熟悉了，&#x3D;&#x3D;代表值的比较，如果二者类型不同，会进行强制转换；&#x3D;&#x3D;&#x3D;则是二者值与类型都相同才为true。这里需要注意一些问题：</p>\n<blockquote>\n<p>NaN不等于它本身<br>+0等于-0</p>\n</blockquote>\n<h3 id=\"字符串与数字比较\"><a href=\"#字符串与数字比较\" class=\"headerlink\" title=\"字符串与数字比较\"></a>字符串与数字比较</h3><p>二者比较时，使用&#x3D;&#x3D;&#x3D;结果肯定为false，因为二者类型不同，但如果使用&#x3D;&#x3D;，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;22&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a === b;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">a == b;\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"任何值与Boolean比较\"><a href=\"#任何值与Boolean比较\" class=\"headerlink\" title=\"任何值与Boolean比较\"></a>任何值与Boolean比较</h3><p>当任何值与Boolean使用&#x3D;&#x3D;比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"string\">&quot;42&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x == y; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，在任何时候，都不要使用&#x3D;&#x3D; true或者&#x3D;&#x3D; false这样的语句。</p>\n<h3 id=\"null与undefined比较\"><a href=\"#null与undefined比较\" class=\"headerlink\" title=\"null与undefined比较\"></a>null与undefined比较</h3><p>当使用&#x3D;&#x3D;比较null和undefined时，结果总为true。</p>\n<h3 id=\"Object与非Object比较\"><a href=\"#Object与非Object比较\" class=\"headerlink\" title=\"Object与非Object比较\"></a>Object与非Object比较</h3><p>当object&#x2F;function&#x2F;array与String或者Number进行&#x3D;&#x3D;比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。</p>\n<h3 id=\"一些值得注意的比较\"><a href=\"#一些值得注意的比较\" class=\"headerlink\" title=\"一些值得注意的比较\"></a>一些值得注意的比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [<span class=\"literal\">null</span>];\t<span class=\"comment\">// true</span></span><br><span class=\"line\">[] == ![]; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">&quot;\\n&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;0&quot;</span> == <span class=\"literal\">false</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"string\">&quot;&quot;</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == [];\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [];\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == [];\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用<code>valueOf()</code>方法，没有才调用<code>toString()</code>方法，如果我们给自定义的对象添加<code>valueOf()</code>方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用&#x3D;&#x3D;&#x3D;比较安全。</p>\n<blockquote>\n<p>参考资料： <a href=\"https://github.com/getify/You-Dont-Know-JS/\">You-Dont-Know-JS</a></p>\n</blockquote>"},{"title":"React中如何更新state","date":"2017-08-04T12:49:46.000Z","_content":"\n我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。\n\n<!--more-->\n# setState\n首先我们来看一个React Component初始化的例子：\n```javascript\nimport React, { Component } from 'react';\n\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'flyrk',\n      sex: 'male'\n    };\n  }\n\n  render() {\n    return (\n      //....\n    );\n  }\n}\n```\n\n而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。\n\n但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：\n\n```javascript\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: ''\n    };\n  }\n\n  componentWillMount() {\n    this.props.getName().then(res => {  // 从服务器获取数据\n      const name = res.data.name;\n      this.setState({ name });\n      //...\n    });\n  }\n  render() {\n    return (\n      <div>\n        {this.state.name}\n      </div>\n    );\n  }\n}\n```\n\n后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：\n\nsetState()接受函数参数，我们可以这样写：\n\n```javascript\nthis.setState((prevState, props) => ({\n  name: prevState.name + props.name\n}));\n```\n\n这样我们就可以获取之前的state。\n\n还有一种方法，setState()第二个参数接受一个callback：\n\n```javascript\nthis.setState({ name }, callback);\n```\n\n在callback里我们可以对修改后的state进行操作。\n\n这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。\n\n","source":"_posts/2017-08-04-react-setState-update.md","raw":"---\ntitle: React中如何更新state\ndate: 2017-08-04 20:49:46\ncategories:\n- JS相关\ntags:\n- React\n- 前端框架\n- state\n---\n\n我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。\n\n<!--more-->\n# setState\n首先我们来看一个React Component初始化的例子：\n```javascript\nimport React, { Component } from 'react';\n\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'flyrk',\n      sex: 'male'\n    };\n  }\n\n  render() {\n    return (\n      //....\n    );\n  }\n}\n```\n\n而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。\n\n但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：\n\n```javascript\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: ''\n    };\n  }\n\n  componentWillMount() {\n    this.props.getName().then(res => {  // 从服务器获取数据\n      const name = res.data.name;\n      this.setState({ name });\n      //...\n    });\n  }\n  render() {\n    return (\n      <div>\n        {this.state.name}\n      </div>\n    );\n  }\n}\n```\n\n后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：\n\nsetState()接受函数参数，我们可以这样写：\n\n```javascript\nthis.setState((prevState, props) => ({\n  name: prevState.name + props.name\n}));\n```\n\n这样我们就可以获取之前的state。\n\n还有一种方法，setState()第二个参数接受一个callback：\n\n```javascript\nthis.setState({ name }, callback);\n```\n\n在callback里我们可以对修改后的state进行操作。\n\n这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。\n\n","slug":"react-setState-update","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05co001bra4k1hv605yz","content":"<p>我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。</p>\n<span id=\"more\"></span>\n<h1 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h1><p>首先我们来看一个React Component初始化的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyrk&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">//....</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。</p>\n<p>但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">componentWillMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">getName</span>().<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;  <span class=\"comment\">// 从服务器获取数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> name = res.<span class=\"property\">data</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;);</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;this.state.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：</p>\n<p>setState()接受函数参数，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(<span class=\"function\">(<span class=\"params\">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: prevState.<span class=\"property\">name</span> + props.<span class=\"property\">name</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以获取之前的state。</p>\n<p>还有一种方法，setState()第二个参数接受一个callback：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;, callback);</span><br></pre></td></tr></table></figure>\n\n<p>在callback里我们可以对修改后的state进行操作。</p>\n<p>这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。</p>\n","site":{"data":{}},"excerpt":"<p>我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。</p>","more":"<h1 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h1><p>首先我们来看一个React Component初始化的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyrk&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">//....</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。</p>\n<p>但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">componentWillMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">getName</span>().<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;  <span class=\"comment\">// 从服务器获取数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> name = res.<span class=\"property\">data</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;);</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;this.state.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：</p>\n<p>setState()接受函数参数，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(<span class=\"function\">(<span class=\"params\">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: prevState.<span class=\"property\">name</span> + props.<span class=\"property\">name</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以获取之前的state。</p>\n<p>还有一种方法，setState()第二个参数接受一个callback：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;, callback);</span><br></pre></td></tr></table></figure>\n\n<p>在callback里我们可以对修改后的state进行操作。</p>\n<p>这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。</p>"},{"title":"详解JavaScript对象","date":"2017-08-05T06:32:12.000Z","_content":"\nJavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。\n\n<!--more-->\n\n# 对象的复制\n\n## JSON方法\n对于 可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象来说，有一种巧妙的复制方法:\n```javascript\nvar newObj = JSON.parse(JSON.stringify( someObj ));\n```\n这种方法的好处是实现了 **深复制**，但必须要求原对象可以被解析成JSON字符串。\n## `Object.assign()`方法\nES6定义了`Object.assign()`方法实现 **浅复制**。该方法第一个参数是目标对象，之后可以跟若干个源对象。它会遍历源对象的所有可枚举的自有键并把它们复制到目标对象，比如说：\n```javascript\nvar myObj = {\n  a: 12\n  b: anotherObj,\n  c: anotherArray,\n  d: anotherFunction\n};\n\nvar newObj = Object.assign( {}, myObject);\nnewObj.a; // 12\nnewObj.b === anotherObj; // true\nnewObj.c === anotherArray; // true\nnewObj.d === anotherFunction; // true\n```\n但要注意的是，浅复制只是简单的使用`=`操作符赋值，对于引用类型值来说，指向的是同一个对象。也就是说，`newObj.b === myObject.b`。\n\n# 属性描述符\nES5开始，所有的属性都有属性描述符。通过`Object.getOwnPropertyDesciptor(obj, prop)`可以获取对象的某个属性的属性描述符。比如：\n```javascript\nObject.getOwnPropertyDescriptor(myObj, \"a\");\n//Object {\n//  value: 12,\n//  writable: true,\n//  enumerable: true,\n//  configurable: true\n//  }\n```\n一般默认值`writable`、`enumerable`、`configurable`都为`true`，我们也可以用`Object.defineProperty()`来添加一个新属性或者修改一个已有属性（如果它是`configurable`）。比如：\n```javascript\nvar myObject = {};\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: true,\n  configurable: true,\n  enumerable: true\n});\nmyObject.a; // 2\n```\n## writable\n```javascript\nvar myObject = {};\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: false,\n  configurable: true,\n  enumerable: true\n});\nmyObject.a = 3;\nmyObject.a; // 2\n```\n可以看到，当我们修改`writable`为false，则该属性不可写了。\n## configurable\n```javascript\nvar myObject = {};\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: true,\n  configurable: false, // 不可配置\n  enumerable: true\n});\nmyObject.a; // 2\nmyObject.a = 5;\nmyObject.a; // 5\ndelete myObject.a;\nmyObject.a; // 5\n\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: true,\n  configurable: true,\n  enumerable: true\n}); // TypeError\n```\n一旦我们修改`configurable`为false，就无法撤销，并且不能重新配置属性，也无法删除该属性。\n## enumerable\n这个属性描述符代表属性是否会出现在对象的属性枚举中，比如`for ..in`循环。如果设置`enumerable: false`，则该属性不会出现在枚举中。\n\n# 不变性\nJavaScript不像其他语言，它是动态的，也就是可变的。但如果我们想属性或者对象是不可改变的，该怎么实现呢？\n## 对象常量\n结合`writable: false`和`configurable: false`可以创建一个常量属性：\n```javascript\nvar myObject = {};\nObject.defineProperty(myObject, \"CONST_VARIABLE\", {\n  value: 100,\n  writable: false,\n  configurable: false\n});\n```\n## 禁止扩展\n如果想保留对象已有的属性并禁止向对象添加新的属性，则可以这样：\n```javascript\nvar myObject = { a: 12 };\nObject.preventExtensions( myObject );\n\nmyObject.b = 13;\nmyObject.b; // undefined\n```\n## 密封\n使用`Object.seal(...)`会创建一个“密封”对象，相当于在对象上调用`Object.preventExtensions()`并且设置所有属性为`configurable: false`。\n\n所以，密封之后的对象只能修改已有属性的值，而不能添加新属性，也不能重新配置或删除已有属性。\n## 冻结\n使用`Object.freeze(...)`会创建一个冻结对象，相当于在对象上调用`Object.seal()`并且设置所有属性为`writable: false`。\n\n这个方法完全使对象不可变，会禁止对于对象本身及其任意直接属性的修改。\n> 需要注意的是，之前所有的方法创建的都是浅不可变，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的。\n\n# Getter和Setter\n当访问某个对象属性时，实际上实现了`[[Get]]`操作，对象默认的内置`[[Get]]`操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，则会遍历原型链，如果还是没找到，则返回`undefined`。\n\n当设置某个对象属性的值，则有`[[Put]]`操作。`[[Put]]`会检查以下内容：\n  1. 属性是否存在setter，存在则调用setter\n  2. 属性的`writable`是否是`false`，是的话则赋值失败\n  3. 如果都不是，则对属性进行赋值\n\n我们可以给对象一个属性定义getter、setter，当访问或赋值对象的属性时，会忽略属性的`value`和`writable`特性，而关注`get`和`set`特性：\n```javascript\nvar myObject = {\n  get a() { // 给属性a定义一个getter\n    return 11;\n  }\n};\n\nObject.defineProperty( myObject, \"b\", {\n  get: function() { return this.a * 2; }, // 给属性b设置一个getter\n  enumerable: true\n});\nmyObject.a; // 11\nmyObject.b; // 22\nmyObject.a = 3;\nmyObject.a; // 11\n```\n当访问属性时会自动调用`get`函数，其返回值会被当作属性访问的返回值；注意的是，由于我们没有设置`set`，所以赋值操作被忽略了。而由于我们定义的`get`始终返回2，即使设置了`set`也没有意义。\n\n我们可以这样设置`getter`和`setter`：\n```javascript\nvar myObject = {\n  get a() { // 给属性a定义一个getter\n    return this._a;\n  },\n  set a(val) {\n    this._a = val * 5;\n  }\n};\n\nmyObject.a = 2;\nmyObject.a; // 10\n```\n\n# 属性的存在性\n当我们访问`object.a`返回的是`undefined`，可能是属性中本来存储的就是`undefined`，也可能是属性不存在，那么怎么判断属性是否存在呢？\n\n我们可以用`in`或者`Object.hasOwnProperty()`方法：\n```javascript\nvar myObject = { a: 1 };\n\n(\"a\" in myObject); // true\n(\"b\" in myObject); // false\n\nmyObject.hasOwnProperty(\"a\"); // true\nmyObject.hasOwnProperty(\"b\"); // false\n```\n这里要注意的是，`in`会检查属性是否在对象及其原型链中，而`hasOwnProperty`只会检查属性是否在对象中，不会检查原型链。\n\n# 枚举\n要检查某个属性是否可枚举，通常有两种方法：\n第一种方法，使用`for...in`循环：\n```javascript\nvar myObject = { a: 1 };\n\nObject.defineProperty(myObject, \"b\", {\n  value: 2,\n  enumerable: false\n});\n\nmyObject.b; // 2\n(\"b\" in myObject); // true\nmyObject.hasOwnProperty(\"b\"); // true\n\nfor (let k in myObject) {\n  console.log(`${k}:${myObject[k]}`); // a:1\n}\n```\n第二种方法：\n```javascript\nvar myObject = { a: 1 };\n\nObject.defineProperty(myObject, \"b\", {\n  value: 2,\n  enumerable: false\n});\n\nmyObject.propertyIsEnumerable(\"a\"); // true\nmyObject.propertyIsEnumerable(\"b\"); // false\n\nObject.keys(myObject); // [\"a\"]\nObject.getOwnPropertyNames(myObject); // [\"a\", \"b\"]\n```\n`propertyIsEnumerable()`可以判断给定的属性名是否直接存在于对象中且`enumerable: true`；`Object.keys(..)` 会返回一个数组，包含所有可枚举属性，`Object.getOwnPropertyNames(..)`会返回一个数组，包含所有属性，无论它们是否可枚举。\n\n要注意的是，`Object.keys(..)`和`hasOwnProperty()`和`Object.getOwnPropertyNames(..)`不会查找原型链，而`in`和`for...in`会查找原型链。\n\n# 遍历\n对于数组来说，最常用的遍历就是`for`循环。然而javascript内置了一些数组的迭代器，包括`forEach(..)`、`every(..)`、`some(..)`、`map(..)`。它们都接受一个回调函数并把它应用到每个元素上，区别就是它们对回调函数返回值的处理方式不同。\n\n`forEach(..)`遍历所有元素并忽略返回值；`every(..)`会一直运行直到返回值为`false`；`some(..)`会一直运行直到返回值为`true`；`map(..)`遍历所有元素并且用返回值代替当前元素。\n\nES6还新增了遍历数组的`for...of`循环语法：\n```javascript\nvar myArray = [1,2,3];\n\nfor (var v of myArray) {\n  console.log( v );\n}\n// 1\n// 2\n// 3\n```\n`for..of`循环首先会向被访问对象请求一个 **迭代器** 对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。由于数组有内置的`@@iterator`，所以`for..of`可以直接应用在数组上，如果想让对象也使用`for..of`循环，则需要自定义`@@iterator`，这里就不多展开了。\n\n# 总结\nJavaScript对象是引用类型，我们可以给对象添加属性并修改属性描述符来控制属性的特征，还可以用`get`和`set`来修改属性的访问和赋值操作，对象的属性还可以枚举和遍历。\n\n> 参考资料：[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch3.md)\n","source":"_posts/2017-08-05-javascript-object.md","raw":"---\ntitle: 详解JavaScript对象\ndate: 2017-08-05 14:32:12\ncategories:\n- JS相关\ntags:\n- 对象\n---\n\nJavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。\n\n<!--more-->\n\n# 对象的复制\n\n## JSON方法\n对于 可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象来说，有一种巧妙的复制方法:\n```javascript\nvar newObj = JSON.parse(JSON.stringify( someObj ));\n```\n这种方法的好处是实现了 **深复制**，但必须要求原对象可以被解析成JSON字符串。\n## `Object.assign()`方法\nES6定义了`Object.assign()`方法实现 **浅复制**。该方法第一个参数是目标对象，之后可以跟若干个源对象。它会遍历源对象的所有可枚举的自有键并把它们复制到目标对象，比如说：\n```javascript\nvar myObj = {\n  a: 12\n  b: anotherObj,\n  c: anotherArray,\n  d: anotherFunction\n};\n\nvar newObj = Object.assign( {}, myObject);\nnewObj.a; // 12\nnewObj.b === anotherObj; // true\nnewObj.c === anotherArray; // true\nnewObj.d === anotherFunction; // true\n```\n但要注意的是，浅复制只是简单的使用`=`操作符赋值，对于引用类型值来说，指向的是同一个对象。也就是说，`newObj.b === myObject.b`。\n\n# 属性描述符\nES5开始，所有的属性都有属性描述符。通过`Object.getOwnPropertyDesciptor(obj, prop)`可以获取对象的某个属性的属性描述符。比如：\n```javascript\nObject.getOwnPropertyDescriptor(myObj, \"a\");\n//Object {\n//  value: 12,\n//  writable: true,\n//  enumerable: true,\n//  configurable: true\n//  }\n```\n一般默认值`writable`、`enumerable`、`configurable`都为`true`，我们也可以用`Object.defineProperty()`来添加一个新属性或者修改一个已有属性（如果它是`configurable`）。比如：\n```javascript\nvar myObject = {};\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: true,\n  configurable: true,\n  enumerable: true\n});\nmyObject.a; // 2\n```\n## writable\n```javascript\nvar myObject = {};\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: false,\n  configurable: true,\n  enumerable: true\n});\nmyObject.a = 3;\nmyObject.a; // 2\n```\n可以看到，当我们修改`writable`为false，则该属性不可写了。\n## configurable\n```javascript\nvar myObject = {};\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: true,\n  configurable: false, // 不可配置\n  enumerable: true\n});\nmyObject.a; // 2\nmyObject.a = 5;\nmyObject.a; // 5\ndelete myObject.a;\nmyObject.a; // 5\n\nObject.defineProperty( myObject, \"a\", {\n  value: 2,\n  writable: true,\n  configurable: true,\n  enumerable: true\n}); // TypeError\n```\n一旦我们修改`configurable`为false，就无法撤销，并且不能重新配置属性，也无法删除该属性。\n## enumerable\n这个属性描述符代表属性是否会出现在对象的属性枚举中，比如`for ..in`循环。如果设置`enumerable: false`，则该属性不会出现在枚举中。\n\n# 不变性\nJavaScript不像其他语言，它是动态的，也就是可变的。但如果我们想属性或者对象是不可改变的，该怎么实现呢？\n## 对象常量\n结合`writable: false`和`configurable: false`可以创建一个常量属性：\n```javascript\nvar myObject = {};\nObject.defineProperty(myObject, \"CONST_VARIABLE\", {\n  value: 100,\n  writable: false,\n  configurable: false\n});\n```\n## 禁止扩展\n如果想保留对象已有的属性并禁止向对象添加新的属性，则可以这样：\n```javascript\nvar myObject = { a: 12 };\nObject.preventExtensions( myObject );\n\nmyObject.b = 13;\nmyObject.b; // undefined\n```\n## 密封\n使用`Object.seal(...)`会创建一个“密封”对象，相当于在对象上调用`Object.preventExtensions()`并且设置所有属性为`configurable: false`。\n\n所以，密封之后的对象只能修改已有属性的值，而不能添加新属性，也不能重新配置或删除已有属性。\n## 冻结\n使用`Object.freeze(...)`会创建一个冻结对象，相当于在对象上调用`Object.seal()`并且设置所有属性为`writable: false`。\n\n这个方法完全使对象不可变，会禁止对于对象本身及其任意直接属性的修改。\n> 需要注意的是，之前所有的方法创建的都是浅不可变，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的。\n\n# Getter和Setter\n当访问某个对象属性时，实际上实现了`[[Get]]`操作，对象默认的内置`[[Get]]`操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，则会遍历原型链，如果还是没找到，则返回`undefined`。\n\n当设置某个对象属性的值，则有`[[Put]]`操作。`[[Put]]`会检查以下内容：\n  1. 属性是否存在setter，存在则调用setter\n  2. 属性的`writable`是否是`false`，是的话则赋值失败\n  3. 如果都不是，则对属性进行赋值\n\n我们可以给对象一个属性定义getter、setter，当访问或赋值对象的属性时，会忽略属性的`value`和`writable`特性，而关注`get`和`set`特性：\n```javascript\nvar myObject = {\n  get a() { // 给属性a定义一个getter\n    return 11;\n  }\n};\n\nObject.defineProperty( myObject, \"b\", {\n  get: function() { return this.a * 2; }, // 给属性b设置一个getter\n  enumerable: true\n});\nmyObject.a; // 11\nmyObject.b; // 22\nmyObject.a = 3;\nmyObject.a; // 11\n```\n当访问属性时会自动调用`get`函数，其返回值会被当作属性访问的返回值；注意的是，由于我们没有设置`set`，所以赋值操作被忽略了。而由于我们定义的`get`始终返回2，即使设置了`set`也没有意义。\n\n我们可以这样设置`getter`和`setter`：\n```javascript\nvar myObject = {\n  get a() { // 给属性a定义一个getter\n    return this._a;\n  },\n  set a(val) {\n    this._a = val * 5;\n  }\n};\n\nmyObject.a = 2;\nmyObject.a; // 10\n```\n\n# 属性的存在性\n当我们访问`object.a`返回的是`undefined`，可能是属性中本来存储的就是`undefined`，也可能是属性不存在，那么怎么判断属性是否存在呢？\n\n我们可以用`in`或者`Object.hasOwnProperty()`方法：\n```javascript\nvar myObject = { a: 1 };\n\n(\"a\" in myObject); // true\n(\"b\" in myObject); // false\n\nmyObject.hasOwnProperty(\"a\"); // true\nmyObject.hasOwnProperty(\"b\"); // false\n```\n这里要注意的是，`in`会检查属性是否在对象及其原型链中，而`hasOwnProperty`只会检查属性是否在对象中，不会检查原型链。\n\n# 枚举\n要检查某个属性是否可枚举，通常有两种方法：\n第一种方法，使用`for...in`循环：\n```javascript\nvar myObject = { a: 1 };\n\nObject.defineProperty(myObject, \"b\", {\n  value: 2,\n  enumerable: false\n});\n\nmyObject.b; // 2\n(\"b\" in myObject); // true\nmyObject.hasOwnProperty(\"b\"); // true\n\nfor (let k in myObject) {\n  console.log(`${k}:${myObject[k]}`); // a:1\n}\n```\n第二种方法：\n```javascript\nvar myObject = { a: 1 };\n\nObject.defineProperty(myObject, \"b\", {\n  value: 2,\n  enumerable: false\n});\n\nmyObject.propertyIsEnumerable(\"a\"); // true\nmyObject.propertyIsEnumerable(\"b\"); // false\n\nObject.keys(myObject); // [\"a\"]\nObject.getOwnPropertyNames(myObject); // [\"a\", \"b\"]\n```\n`propertyIsEnumerable()`可以判断给定的属性名是否直接存在于对象中且`enumerable: true`；`Object.keys(..)` 会返回一个数组，包含所有可枚举属性，`Object.getOwnPropertyNames(..)`会返回一个数组，包含所有属性，无论它们是否可枚举。\n\n要注意的是，`Object.keys(..)`和`hasOwnProperty()`和`Object.getOwnPropertyNames(..)`不会查找原型链，而`in`和`for...in`会查找原型链。\n\n# 遍历\n对于数组来说，最常用的遍历就是`for`循环。然而javascript内置了一些数组的迭代器，包括`forEach(..)`、`every(..)`、`some(..)`、`map(..)`。它们都接受一个回调函数并把它应用到每个元素上，区别就是它们对回调函数返回值的处理方式不同。\n\n`forEach(..)`遍历所有元素并忽略返回值；`every(..)`会一直运行直到返回值为`false`；`some(..)`会一直运行直到返回值为`true`；`map(..)`遍历所有元素并且用返回值代替当前元素。\n\nES6还新增了遍历数组的`for...of`循环语法：\n```javascript\nvar myArray = [1,2,3];\n\nfor (var v of myArray) {\n  console.log( v );\n}\n// 1\n// 2\n// 3\n```\n`for..of`循环首先会向被访问对象请求一个 **迭代器** 对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。由于数组有内置的`@@iterator`，所以`for..of`可以直接应用在数组上，如果想让对象也使用`for..of`循环，则需要自定义`@@iterator`，这里就不多展开了。\n\n# 总结\nJavaScript对象是引用类型，我们可以给对象添加属性并修改属性描述符来控制属性的特征，还可以用`get`和`set`来修改属性的访问和赋值操作，对象的属性还可以枚举和遍历。\n\n> 参考资料：[You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch3.md)\n","slug":"javascript-object","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cp001era4k8sp2f050","content":"<p>JavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"对象的复制\"><a href=\"#对象的复制\" class=\"headerlink\" title=\"对象的复制\"></a>对象的复制</h1><h2 id=\"JSON方法\"><a href=\"#JSON方法\" class=\"headerlink\" title=\"JSON方法\"></a>JSON方法</h2><p>对于 可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象来说，有一种巧妙的复制方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( someObj ));</span><br></pre></td></tr></table></figure>\n<p>这种方法的好处是实现了 <strong>深复制</strong>，但必须要求原对象可以被解析成JSON字符串。</p>\n<h2 id=\"Object-assign-方法\"><a href=\"#Object-assign-方法\" class=\"headerlink\" title=\"Object.assign()方法\"></a><code>Object.assign()</code>方法</h2><p>ES6定义了<code>Object.assign()</code>方法实现 <strong>浅复制</strong>。该方法第一个参数是目标对象，之后可以跟若干个源对象。它会遍历源对象的所有可枚举的自有键并把它们复制到目标对象，比如说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">12</span></span><br><span class=\"line\">  <span class=\"attr\">b</span>: anotherObj,</span><br><span class=\"line\">  <span class=\"attr\">c</span>: anotherArray,</span><br><span class=\"line\">  <span class=\"attr\">d</span>: anotherFunction</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>( &#123;&#125;, myObject);</span><br><span class=\"line\">newObj.<span class=\"property\">a</span>; <span class=\"comment\">// 12</span></span><br><span class=\"line\">newObj.<span class=\"property\">b</span> === anotherObj; <span class=\"comment\">// true</span></span><br><span class=\"line\">newObj.<span class=\"property\">c</span> === anotherArray; <span class=\"comment\">// true</span></span><br><span class=\"line\">newObj.<span class=\"property\">d</span> === anotherFunction; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>但要注意的是，浅复制只是简单的使用<code>=</code>操作符赋值，对于引用类型值来说，指向的是同一个对象。也就是说，<code>newObj.b === myObject.b</code>。</p>\n<h1 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h1><p>ES5开始，所有的属性都有属性描述符。通过<code>Object.getOwnPropertyDesciptor(obj, prop)</code>可以获取对象的某个属性的属性描述符。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(myObj, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//Object &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  value: 12,</span></span><br><span class=\"line\"><span class=\"comment\">//  writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//  enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//  configurable: true</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br></pre></td></tr></table></figure>\n<p>一般默认值<code>writable</code>、<code>enumerable</code>、<code>configurable</code>都为<code>true</code>，我们也可以用<code>Object.defineProperty()</code>来添加一个新属性或者修改一个已有属性（如果它是<code>configurable</code>）。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"writable\"><a href=\"#writable\" class=\"headerlink\" title=\"writable\"></a>writable</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们修改<code>writable</code>为false，则该属性不可写了。</p>\n<h2 id=\"configurable\"><a href=\"#configurable\" class=\"headerlink\" title=\"configurable\"></a>configurable</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span>, <span class=\"comment\">// 不可配置</span></span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> myObject.<span class=\"property\">a</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;); <span class=\"comment\">// TypeError</span></span><br></pre></td></tr></table></figure>\n<p>一旦我们修改<code>configurable</code>为false，就无法撤销，并且不能重新配置属性，也无法删除该属性。</p>\n<h2 id=\"enumerable\"><a href=\"#enumerable\" class=\"headerlink\" title=\"enumerable\"></a>enumerable</h2><p>这个属性描述符代表属性是否会出现在对象的属性枚举中，比如<code>for ..in</code>循环。如果设置<code>enumerable: false</code>，则该属性不会出现在枚举中。</p>\n<h1 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h1><p>JavaScript不像其他语言，它是动态的，也就是可变的。但如果我们想属性或者对象是不可改变的，该怎么实现呢？</p>\n<h2 id=\"对象常量\"><a href=\"#对象常量\" class=\"headerlink\" title=\"对象常量\"></a>对象常量</h2><p>结合<code>writable: false</code>和<code>configurable: false</code>可以创建一个常量属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(myObject, <span class=\"string\">&quot;CONST_VARIABLE&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"禁止扩展\"><a href=\"#禁止扩展\" class=\"headerlink\" title=\"禁止扩展\"></a>禁止扩展</h2><p>如果想保留对象已有的属性并禁止向对象添加新的属性，则可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">12</span> &#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">preventExtensions</span>( myObject );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"property\">b</span> = <span class=\"number\">13</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">b</span>; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"密封\"><a href=\"#密封\" class=\"headerlink\" title=\"密封\"></a>密封</h2><p>使用<code>Object.seal(...)</code>会创建一个“密封”对象，相当于在对象上调用<code>Object.preventExtensions()</code>并且设置所有属性为<code>configurable: false</code>。</p>\n<p>所以，密封之后的对象只能修改已有属性的值，而不能添加新属性，也不能重新配置或删除已有属性。</p>\n<h2 id=\"冻结\"><a href=\"#冻结\" class=\"headerlink\" title=\"冻结\"></a>冻结</h2><p>使用<code>Object.freeze(...)</code>会创建一个冻结对象，相当于在对象上调用<code>Object.seal()</code>并且设置所有属性为<code>writable: false</code>。</p>\n<p>这个方法完全使对象不可变，会禁止对于对象本身及其任意直接属性的修改。</p>\n<blockquote>\n<p>需要注意的是，之前所有的方法创建的都是浅不可变，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的。</p>\n</blockquote>\n<h1 id=\"Getter和Setter\"><a href=\"#Getter和Setter\" class=\"headerlink\" title=\"Getter和Setter\"></a>Getter和Setter</h1><p>当访问某个对象属性时，实际上实现了<code>[[Get]]</code>操作，对象默认的内置<code>[[Get]]</code>操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，则会遍历原型链，如果还是没找到，则返回<code>undefined</code>。</p>\n<p>当设置某个对象属性的值，则有<code>[[Put]]</code>操作。<code>[[Put]]</code>会检查以下内容：</p>\n<ol>\n<li>属性是否存在setter，存在则调用setter</li>\n<li>属性的<code>writable</code>是否是<code>false</code>，是的话则赋值失败</li>\n<li>如果都不是，则对属性进行赋值</li>\n</ol>\n<p>我们可以给对象一个属性定义getter、setter，当访问或赋值对象的属性时，会忽略属性的<code>value</code>和<code>writable</code>特性，而关注<code>get</code>和<code>set</code>特性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">a</span>() &#123; <span class=\"comment\">// 给属性a定义一个getter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">11</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;b&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">get</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> * <span class=\"number\">2</span>; &#125;, <span class=\"comment\">// 给属性b设置一个getter</span></span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 11</span></span><br><span class=\"line\">myObject.<span class=\"property\">b</span>; <span class=\"comment\">// 22</span></span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n<p>当访问属性时会自动调用<code>get</code>函数，其返回值会被当作属性访问的返回值；注意的是，由于我们没有设置<code>set</code>，所以赋值操作被忽略了。而由于我们定义的<code>get</code>始终返回2，即使设置了<code>set</code>也没有意义。</p>\n<p>我们可以这样设置<code>getter</code>和<code>setter</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">a</span>() &#123; <span class=\"comment\">// 给属性a定义一个getter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_a</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">a</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_a</span> = val * <span class=\"number\">5</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">2</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"属性的存在性\"><a href=\"#属性的存在性\" class=\"headerlink\" title=\"属性的存在性\"></a>属性的存在性</h1><p>当我们访问<code>object.a</code>返回的是<code>undefined</code>，可能是属性中本来存储的就是<code>undefined</code>，也可能是属性不存在，那么怎么判断属性是否存在呢？</p>\n<p>我们可以用<code>in</code>或者<code>Object.hasOwnProperty()</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"string\">&quot;a&quot;</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"string\">&quot;b&quot;</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>这里要注意的是，<code>in</code>会检查属性是否在对象及其原型链中，而<code>hasOwnProperty</code>只会检查属性是否在对象中，不会检查原型链。</p>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><p>要检查某个属性是否可枚举，通常有两种方法：<br>第一种方法，使用<code>for...in</code>循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(myObject, <span class=\"string\">&quot;b&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"property\">b</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">(<span class=\"string\">&quot;b&quot;</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> myObject) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;k&#125;</span>:<span class=\"subst\">$&#123;myObject[k]&#125;</span>`</span>); <span class=\"comment\">// a:1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(myObject, <span class=\"string\">&quot;b&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"title function_\">propertyIsEnumerable</span>(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.<span class=\"title function_\">propertyIsEnumerable</span>(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(myObject); <span class=\"comment\">// [&quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyNames</span>(myObject); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>\n<p><code>propertyIsEnumerable()</code>可以判断给定的属性名是否直接存在于对象中且<code>enumerable: true</code>；<code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code>会返回一个数组，包含所有属性，无论它们是否可枚举。</p>\n<p>要注意的是，<code>Object.keys(..)</code>和<code>hasOwnProperty()</code>和<code>Object.getOwnPropertyNames(..)</code>不会查找原型链，而<code>in</code>和<code>for...in</code>会查找原型链。</p>\n<h1 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h1><p>对于数组来说，最常用的遍历就是<code>for</code>循环。然而javascript内置了一些数组的迭代器，包括<code>forEach(..)</code>、<code>every(..)</code>、<code>some(..)</code>、<code>map(..)</code>。它们都接受一个回调函数并把它应用到每个元素上，区别就是它们对回调函数返回值的处理方式不同。</p>\n<p><code>forEach(..)</code>遍历所有元素并忽略返回值；<code>every(..)</code>会一直运行直到返回值为<code>false</code>；<code>some(..)</code>会一直运行直到返回值为<code>true</code>；<code>map(..)</code>遍历所有元素并且用返回值代替当前元素。</p>\n<p>ES6还新增了遍历数组的<code>for...of</code>循环语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> v <span class=\"keyword\">of</span> myArray) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( v );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p><code>for..of</code>循环首先会向被访问对象请求一个 <strong>迭代器</strong> 对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。由于数组有内置的<code>@@iterator</code>，所以<code>for..of</code>可以直接应用在数组上，如果想让对象也使用<code>for..of</code>循环，则需要自定义<code>@@iterator</code>，这里就不多展开了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>JavaScript对象是引用类型，我们可以给对象添加属性并修改属性描述符来控制属性的特征，还可以用<code>get</code>和<code>set</code>来修改属性的访问和赋值操作，对象的属性还可以枚举和遍历。</p>\n<blockquote>\n<p>参考资料：<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch3.md\">You-Dont-Know-JS</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>JavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。</p>","more":"<h1 id=\"对象的复制\"><a href=\"#对象的复制\" class=\"headerlink\" title=\"对象的复制\"></a>对象的复制</h1><h2 id=\"JSON方法\"><a href=\"#JSON方法\" class=\"headerlink\" title=\"JSON方法\"></a>JSON方法</h2><p>对于 可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象来说，有一种巧妙的复制方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(<span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( someObj ));</span><br></pre></td></tr></table></figure>\n<p>这种方法的好处是实现了 <strong>深复制</strong>，但必须要求原对象可以被解析成JSON字符串。</p>\n<h2 id=\"Object-assign-方法\"><a href=\"#Object-assign-方法\" class=\"headerlink\" title=\"Object.assign()方法\"></a><code>Object.assign()</code>方法</h2><p>ES6定义了<code>Object.assign()</code>方法实现 <strong>浅复制</strong>。该方法第一个参数是目标对象，之后可以跟若干个源对象。它会遍历源对象的所有可枚举的自有键并把它们复制到目标对象，比如说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: <span class=\"number\">12</span></span><br><span class=\"line\">  <span class=\"attr\">b</span>: anotherObj,</span><br><span class=\"line\">  <span class=\"attr\">c</span>: anotherArray,</span><br><span class=\"line\">  <span class=\"attr\">d</span>: anotherFunction</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"title class_\">Object</span>.<span class=\"title function_\">assign</span>( &#123;&#125;, myObject);</span><br><span class=\"line\">newObj.<span class=\"property\">a</span>; <span class=\"comment\">// 12</span></span><br><span class=\"line\">newObj.<span class=\"property\">b</span> === anotherObj; <span class=\"comment\">// true</span></span><br><span class=\"line\">newObj.<span class=\"property\">c</span> === anotherArray; <span class=\"comment\">// true</span></span><br><span class=\"line\">newObj.<span class=\"property\">d</span> === anotherFunction; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>但要注意的是，浅复制只是简单的使用<code>=</code>操作符赋值，对于引用类型值来说，指向的是同一个对象。也就是说，<code>newObj.b === myObject.b</code>。</p>\n<h1 id=\"属性描述符\"><a href=\"#属性描述符\" class=\"headerlink\" title=\"属性描述符\"></a>属性描述符</h1><p>ES5开始，所有的属性都有属性描述符。通过<code>Object.getOwnPropertyDesciptor(obj, prop)</code>可以获取对象的某个属性的属性描述符。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(myObj, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//Object &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  value: 12,</span></span><br><span class=\"line\"><span class=\"comment\">//  writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//  enumerable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//  configurable: true</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br></pre></td></tr></table></figure>\n<p>一般默认值<code>writable</code>、<code>enumerable</code>、<code>configurable</code>都为<code>true</code>，我们也可以用<code>Object.defineProperty()</code>来添加一个新属性或者修改一个已有属性（如果它是<code>configurable</code>）。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"writable\"><a href=\"#writable\" class=\"headerlink\" title=\"writable\"></a>writable</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，当我们修改<code>writable</code>为false，则该属性不可写了。</p>\n<h2 id=\"configurable\"><a href=\"#configurable\" class=\"headerlink\" title=\"configurable\"></a>configurable</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span>, <span class=\"comment\">// 不可配置</span></span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> myObject.<span class=\"property\">a</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;a&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;); <span class=\"comment\">// TypeError</span></span><br></pre></td></tr></table></figure>\n<p>一旦我们修改<code>configurable</code>为false，就无法撤销，并且不能重新配置属性，也无法删除该属性。</p>\n<h2 id=\"enumerable\"><a href=\"#enumerable\" class=\"headerlink\" title=\"enumerable\"></a>enumerable</h2><p>这个属性描述符代表属性是否会出现在对象的属性枚举中，比如<code>for ..in</code>循环。如果设置<code>enumerable: false</code>，则该属性不会出现在枚举中。</p>\n<h1 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h1><p>JavaScript不像其他语言，它是动态的，也就是可变的。但如果我们想属性或者对象是不可改变的，该怎么实现呢？</p>\n<h2 id=\"对象常量\"><a href=\"#对象常量\" class=\"headerlink\" title=\"对象常量\"></a>对象常量</h2><p>结合<code>writable: false</code>和<code>configurable: false</code>可以创建一个常量属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(myObject, <span class=\"string\">&quot;CONST_VARIABLE&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">100</span>,</span><br><span class=\"line\">  <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">  <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"禁止扩展\"><a href=\"#禁止扩展\" class=\"headerlink\" title=\"禁止扩展\"></a>禁止扩展</h2><p>如果想保留对象已有的属性并禁止向对象添加新的属性，则可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">12</span> &#125;;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">preventExtensions</span>( myObject );</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"property\">b</span> = <span class=\"number\">13</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">b</span>; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"密封\"><a href=\"#密封\" class=\"headerlink\" title=\"密封\"></a>密封</h2><p>使用<code>Object.seal(...)</code>会创建一个“密封”对象，相当于在对象上调用<code>Object.preventExtensions()</code>并且设置所有属性为<code>configurable: false</code>。</p>\n<p>所以，密封之后的对象只能修改已有属性的值，而不能添加新属性，也不能重新配置或删除已有属性。</p>\n<h2 id=\"冻结\"><a href=\"#冻结\" class=\"headerlink\" title=\"冻结\"></a>冻结</h2><p>使用<code>Object.freeze(...)</code>会创建一个冻结对象，相当于在对象上调用<code>Object.seal()</code>并且设置所有属性为<code>writable: false</code>。</p>\n<p>这个方法完全使对象不可变，会禁止对于对象本身及其任意直接属性的修改。</p>\n<blockquote>\n<p>需要注意的是，之前所有的方法创建的都是浅不可变，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的。</p>\n</blockquote>\n<h1 id=\"Getter和Setter\"><a href=\"#Getter和Setter\" class=\"headerlink\" title=\"Getter和Setter\"></a>Getter和Setter</h1><p>当访问某个对象属性时，实际上实现了<code>[[Get]]</code>操作，对象默认的内置<code>[[Get]]</code>操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，则会遍历原型链，如果还是没找到，则返回<code>undefined</code>。</p>\n<p>当设置某个对象属性的值，则有<code>[[Put]]</code>操作。<code>[[Put]]</code>会检查以下内容：</p>\n<ol>\n<li>属性是否存在setter，存在则调用setter</li>\n<li>属性的<code>writable</code>是否是<code>false</code>，是的话则赋值失败</li>\n<li>如果都不是，则对属性进行赋值</li>\n</ol>\n<p>我们可以给对象一个属性定义getter、setter，当访问或赋值对象的属性时，会忽略属性的<code>value</code>和<code>writable</code>特性，而关注<code>get</code>和<code>set</code>特性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">a</span>() &#123; <span class=\"comment\">// 给属性a定义一个getter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">11</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>( myObject, <span class=\"string\">&quot;b&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">get</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123; <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> * <span class=\"number\">2</span>; &#125;, <span class=\"comment\">// 给属性b设置一个getter</span></span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 11</span></span><br><span class=\"line\">myObject.<span class=\"property\">b</span>; <span class=\"comment\">// 22</span></span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n<p>当访问属性时会自动调用<code>get</code>函数，其返回值会被当作属性访问的返回值；注意的是，由于我们没有设置<code>set</code>，所以赋值操作被忽略了。而由于我们定义的<code>get</code>始终返回2，即使设置了<code>set</code>也没有意义。</p>\n<p>我们可以这样设置<code>getter</code>和<code>setter</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title function_\">a</span>() &#123; <span class=\"comment\">// 给属性a定义一个getter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_a</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title function_\">a</span>(<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">_a</span> = val * <span class=\"number\">5</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"property\">a</span> = <span class=\"number\">2</span>;</span><br><span class=\"line\">myObject.<span class=\"property\">a</span>; <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"属性的存在性\"><a href=\"#属性的存在性\" class=\"headerlink\" title=\"属性的存在性\"></a>属性的存在性</h1><p>当我们访问<code>object.a</code>返回的是<code>undefined</code>，可能是属性中本来存储的就是<code>undefined</code>，也可能是属性不存在，那么怎么判断属性是否存在呢？</p>\n<p>我们可以用<code>in</code>或者<code>Object.hasOwnProperty()</code>方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"string\">&quot;a&quot;</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"string\">&quot;b&quot;</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>这里要注意的是，<code>in</code>会检查属性是否在对象及其原型链中，而<code>hasOwnProperty</code>只会检查属性是否在对象中，不会检查原型链。</p>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><p>要检查某个属性是否可枚举，通常有两种方法：<br>第一种方法，使用<code>for...in</code>循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(myObject, <span class=\"string\">&quot;b&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"property\">b</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">(<span class=\"string\">&quot;b&quot;</span> <span class=\"keyword\">in</span> myObject); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k <span class=\"keyword\">in</span> myObject) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;k&#125;</span>:<span class=\"subst\">$&#123;myObject[k]&#125;</span>`</span>); <span class=\"comment\">// a:1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二种方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(myObject, <span class=\"string\">&quot;b&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">value</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">  <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">myObject.<span class=\"title function_\">propertyIsEnumerable</span>(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">myObject.<span class=\"title function_\">propertyIsEnumerable</span>(<span class=\"string\">&quot;b&quot;</span>); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(myObject); <span class=\"comment\">// [&quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyNames</span>(myObject); <span class=\"comment\">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>\n<p><code>propertyIsEnumerable()</code>可以判断给定的属性名是否直接存在于对象中且<code>enumerable: true</code>；<code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code>会返回一个数组，包含所有属性，无论它们是否可枚举。</p>\n<p>要注意的是，<code>Object.keys(..)</code>和<code>hasOwnProperty()</code>和<code>Object.getOwnPropertyNames(..)</code>不会查找原型链，而<code>in</code>和<code>for...in</code>会查找原型链。</p>\n<h1 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h1><p>对于数组来说，最常用的遍历就是<code>for</code>循环。然而javascript内置了一些数组的迭代器，包括<code>forEach(..)</code>、<code>every(..)</code>、<code>some(..)</code>、<code>map(..)</code>。它们都接受一个回调函数并把它应用到每个元素上，区别就是它们对回调函数返回值的处理方式不同。</p>\n<p><code>forEach(..)</code>遍历所有元素并忽略返回值；<code>every(..)</code>会一直运行直到返回值为<code>false</code>；<code>some(..)</code>会一直运行直到返回值为<code>true</code>；<code>map(..)</code>遍历所有元素并且用返回值代替当前元素。</p>\n<p>ES6还新增了遍历数组的<code>for...of</code>循环语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> v <span class=\"keyword\">of</span> myArray) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( v );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p><code>for..of</code>循环首先会向被访问对象请求一个 <strong>迭代器</strong> 对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。由于数组有内置的<code>@@iterator</code>，所以<code>for..of</code>可以直接应用在数组上，如果想让对象也使用<code>for..of</code>循环，则需要自定义<code>@@iterator</code>，这里就不多展开了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>JavaScript对象是引用类型，我们可以给对象添加属性并修改属性描述符来控制属性的特征，还可以用<code>get</code>和<code>set</code>来修改属性的访问和赋值操作，对象的属性还可以枚举和遍历。</p>\n<blockquote>\n<p>参考资料：<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch3.md\">You-Dont-Know-JS</a></p>\n</blockquote>"},{"title":"获取浏览器窗口大小","date":"2017-08-08T12:57:31.000Z","_content":"\n我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？\n\n先来看这样一段代码：\n```javascript\nfunction getBrowserSize() {\n  var de = document.documentElement;\n  return {\n    'width': (\n      window.innerWidth\n      || de && de.clientWidth\n      || document.body.clientWidth\n    ),\n    'height': (\n      window.innerHeight\n      || de && de.clientHeight\n      || document.body.clientHeight\n    )\n  };\n}\n```\n这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。\n<!--more-->\n  - `documentElement`:`document.documentElement`获取的是页面中的`<html>`元素，也就相当于整个页面。\n  - `innerWidth&&innerHeight`: innerWidth获取的是可视区域的宽度，但包括垂直滚动条；innerHeight则只包括可视区域高度，不包括功能框之类的。相比较之下，outerWidth和outerHeight则包含整个窗口的高度，包括功能框、滚动条之类的。\n  - `document.body`:获取页面中body元素。\n  - `Element.clientWidth`:获取元素的可视宽度（高度），它包括`padding`但不包括滚动条、`border`和`margin`。\n\n\n## 实际测试\n话不多说，直接上图：\n![window-inner-outer](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/window-inner%26outer.jpg)\n\n![browser-size-inner](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-inner.jpg)\n\n![browser-size-client](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client.jpg)\n\n![browser-size-client-body](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client-body.jpg)\n\n我们可以得出结论：\n* `window.innerWidth`和`window.outerWidth`基本是一样的，因为innerWidth也包括了滚动条，但如果侧面有功能栏的话，innerWidth就会比outerWidth小；`window.innerHeight`和`window.outerHeight`差别较大，因为下面有调试栏。\n* `document.documentElement.clientWidth(clientHeight)`获取的就是页面的可视窗口宽高，不包括滚动条和功能栏之类的。\n* `document.body.clientWidth(clientHeight)`获取的是`body`元素的宽高，不包括滚动条，但因为`body`的内容高度有465px，所以比`document.documentElement.clientHeight`要高。\n\n## 兼容性\n`document.documentElement`几乎每个浏览器都兼容；`window.outerWidth`和`window.innerWidth`IE8及以下都不支持；`document.body`和`clientWidth`IE6之前不支持。\n\n## 总结\n获取浏览器当前窗口大小，一般用`window.innerWidth(innerHeight)`就好了，但如果不兼容，则次之用`document.documentElement.clientWidth(clientHeight)`，再不行就只能用`document.body`获取了。\n\n前面提到的`getBrowserSize()`方法就是使用了这种理念。\n\n\n> 参考资料:\n> [documentElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement)\n> [innerWidth](https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth)\n> [outerWidth](https://developer.mozilla.org/en-US/docs/Web/API/Window/outerWidth)\n> [document.body](https://developer.mozilla.org/en-US/docs/Web/API/Document/body)\n> [clientWidth](https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth)\n> 《JavaScriptDOM高级程序设计》\n","source":"_posts/2017-08-08-get-browser-size.md","raw":"---\ntitle: 获取浏览器窗口大小\ndate: 2017-08-08 20:57:31\ncategories:\n- JS相关\ntags:\n- JS技巧\n---\n\n我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？\n\n先来看这样一段代码：\n```javascript\nfunction getBrowserSize() {\n  var de = document.documentElement;\n  return {\n    'width': (\n      window.innerWidth\n      || de && de.clientWidth\n      || document.body.clientWidth\n    ),\n    'height': (\n      window.innerHeight\n      || de && de.clientHeight\n      || document.body.clientHeight\n    )\n  };\n}\n```\n这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。\n<!--more-->\n  - `documentElement`:`document.documentElement`获取的是页面中的`<html>`元素，也就相当于整个页面。\n  - `innerWidth&&innerHeight`: innerWidth获取的是可视区域的宽度，但包括垂直滚动条；innerHeight则只包括可视区域高度，不包括功能框之类的。相比较之下，outerWidth和outerHeight则包含整个窗口的高度，包括功能框、滚动条之类的。\n  - `document.body`:获取页面中body元素。\n  - `Element.clientWidth`:获取元素的可视宽度（高度），它包括`padding`但不包括滚动条、`border`和`margin`。\n\n\n## 实际测试\n话不多说，直接上图：\n![window-inner-outer](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/window-inner%26outer.jpg)\n\n![browser-size-inner](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-inner.jpg)\n\n![browser-size-client](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client.jpg)\n\n![browser-size-client-body](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client-body.jpg)\n\n我们可以得出结论：\n* `window.innerWidth`和`window.outerWidth`基本是一样的，因为innerWidth也包括了滚动条，但如果侧面有功能栏的话，innerWidth就会比outerWidth小；`window.innerHeight`和`window.outerHeight`差别较大，因为下面有调试栏。\n* `document.documentElement.clientWidth(clientHeight)`获取的就是页面的可视窗口宽高，不包括滚动条和功能栏之类的。\n* `document.body.clientWidth(clientHeight)`获取的是`body`元素的宽高，不包括滚动条，但因为`body`的内容高度有465px，所以比`document.documentElement.clientHeight`要高。\n\n## 兼容性\n`document.documentElement`几乎每个浏览器都兼容；`window.outerWidth`和`window.innerWidth`IE8及以下都不支持；`document.body`和`clientWidth`IE6之前不支持。\n\n## 总结\n获取浏览器当前窗口大小，一般用`window.innerWidth(innerHeight)`就好了，但如果不兼容，则次之用`document.documentElement.clientWidth(clientHeight)`，再不行就只能用`document.body`获取了。\n\n前面提到的`getBrowserSize()`方法就是使用了这种理念。\n\n\n> 参考资料:\n> [documentElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement)\n> [innerWidth](https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth)\n> [outerWidth](https://developer.mozilla.org/en-US/docs/Web/API/Window/outerWidth)\n> [document.body](https://developer.mozilla.org/en-US/docs/Web/API/Document/body)\n> [clientWidth](https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth)\n> 《JavaScriptDOM高级程序设计》\n","slug":"get-browser-size","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cr001ira4k4zzh6jcy","content":"<p>我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？</p>\n<p>先来看这样一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getBrowserSize</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> de = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;width&#x27;</span>: (</span><br><span class=\"line\">      <span class=\"variable language_\">window</span>.<span class=\"property\">innerWidth</span></span><br><span class=\"line\">      || de &amp;&amp; de.<span class=\"property\">clientWidth</span></span><br><span class=\"line\">      || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientWidth</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"string\">&#x27;height&#x27;</span>: (</span><br><span class=\"line\">      <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span></span><br><span class=\"line\">      || de &amp;&amp; de.<span class=\"property\">clientHeight</span></span><br><span class=\"line\">      || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientHeight</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。</p>\n<span id=\"more\"></span>\n<ul>\n<li><code>documentElement</code>:<code>document.documentElement</code>获取的是页面中的<code>&lt;html&gt;</code>元素，也就相当于整个页面。</li>\n<li><code>innerWidth&amp;&amp;innerHeight</code>: innerWidth获取的是可视区域的宽度，但包括垂直滚动条；innerHeight则只包括可视区域高度，不包括功能框之类的。相比较之下，outerWidth和outerHeight则包含整个窗口的高度，包括功能框、滚动条之类的。</li>\n<li><code>document.body</code>:获取页面中body元素。</li>\n<li><code>Element.clientWidth</code>:获取元素的可视宽度（高度），它包括<code>padding</code>但不包括滚动条、<code>border</code>和<code>margin</code>。</li>\n</ul>\n<h2 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h2><p>话不多说，直接上图：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/window-inner%26outer.jpg\" alt=\"window-inner-outer\"></p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-inner.jpg\" alt=\"browser-size-inner\"></p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client.jpg\" alt=\"browser-size-client\"></p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client-body.jpg\" alt=\"browser-size-client-body\"></p>\n<p>我们可以得出结论：</p>\n<ul>\n<li><code>window.innerWidth</code>和<code>window.outerWidth</code>基本是一样的，因为innerWidth也包括了滚动条，但如果侧面有功能栏的话，innerWidth就会比outerWidth小；<code>window.innerHeight</code>和<code>window.outerHeight</code>差别较大，因为下面有调试栏。</li>\n<li><code>document.documentElement.clientWidth(clientHeight)</code>获取的就是页面的可视窗口宽高，不包括滚动条和功能栏之类的。</li>\n<li><code>document.body.clientWidth(clientHeight)</code>获取的是<code>body</code>元素的宽高，不包括滚动条，但因为<code>body</code>的内容高度有465px，所以比<code>document.documentElement.clientHeight</code>要高。</li>\n</ul>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p><code>document.documentElement</code>几乎每个浏览器都兼容；<code>window.outerWidth</code>和<code>window.innerWidth</code>IE8及以下都不支持；<code>document.body</code>和<code>clientWidth</code>IE6之前不支持。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>获取浏览器当前窗口大小，一般用<code>window.innerWidth(innerHeight)</code>就好了，但如果不兼容，则次之用<code>document.documentElement.clientWidth(clientHeight)</code>，再不行就只能用<code>document.body</code>获取了。</p>\n<p>前面提到的<code>getBrowserSize()</code>方法就是使用了这种理念。</p>\n<blockquote>\n<p>参考资料:<br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement\">documentElement</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth\">innerWidth</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/outerWidth\">outerWidth</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/body\">document.body</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth\">clientWidth</a><br>《JavaScriptDOM高级程序设计》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？</p>\n<p>先来看这样一段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getBrowserSize</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> de = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;width&#x27;</span>: (</span><br><span class=\"line\">      <span class=\"variable language_\">window</span>.<span class=\"property\">innerWidth</span></span><br><span class=\"line\">      || de &amp;&amp; de.<span class=\"property\">clientWidth</span></span><br><span class=\"line\">      || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientWidth</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"string\">&#x27;height&#x27;</span>: (</span><br><span class=\"line\">      <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span></span><br><span class=\"line\">      || de &amp;&amp; de.<span class=\"property\">clientHeight</span></span><br><span class=\"line\">      || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">clientHeight</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。</p>","more":"<ul>\n<li><code>documentElement</code>:<code>document.documentElement</code>获取的是页面中的<code>&lt;html&gt;</code>元素，也就相当于整个页面。</li>\n<li><code>innerWidth&amp;&amp;innerHeight</code>: innerWidth获取的是可视区域的宽度，但包括垂直滚动条；innerHeight则只包括可视区域高度，不包括功能框之类的。相比较之下，outerWidth和outerHeight则包含整个窗口的高度，包括功能框、滚动条之类的。</li>\n<li><code>document.body</code>:获取页面中body元素。</li>\n<li><code>Element.clientWidth</code>:获取元素的可视宽度（高度），它包括<code>padding</code>但不包括滚动条、<code>border</code>和<code>margin</code>。</li>\n</ul>\n<h2 id=\"实际测试\"><a href=\"#实际测试\" class=\"headerlink\" title=\"实际测试\"></a>实际测试</h2><p>话不多说，直接上图：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/window-inner%26outer.jpg\" alt=\"window-inner-outer\"></p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-inner.jpg\" alt=\"browser-size-inner\"></p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client.jpg\" alt=\"browser-size-client\"></p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client-body.jpg\" alt=\"browser-size-client-body\"></p>\n<p>我们可以得出结论：</p>\n<ul>\n<li><code>window.innerWidth</code>和<code>window.outerWidth</code>基本是一样的，因为innerWidth也包括了滚动条，但如果侧面有功能栏的话，innerWidth就会比outerWidth小；<code>window.innerHeight</code>和<code>window.outerHeight</code>差别较大，因为下面有调试栏。</li>\n<li><code>document.documentElement.clientWidth(clientHeight)</code>获取的就是页面的可视窗口宽高，不包括滚动条和功能栏之类的。</li>\n<li><code>document.body.clientWidth(clientHeight)</code>获取的是<code>body</code>元素的宽高，不包括滚动条，但因为<code>body</code>的内容高度有465px，所以比<code>document.documentElement.clientHeight</code>要高。</li>\n</ul>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p><code>document.documentElement</code>几乎每个浏览器都兼容；<code>window.outerWidth</code>和<code>window.innerWidth</code>IE8及以下都不支持；<code>document.body</code>和<code>clientWidth</code>IE6之前不支持。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>获取浏览器当前窗口大小，一般用<code>window.innerWidth(innerHeight)</code>就好了，但如果不兼容，则次之用<code>document.documentElement.clientWidth(clientHeight)</code>，再不行就只能用<code>document.body</code>获取了。</p>\n<p>前面提到的<code>getBrowserSize()</code>方法就是使用了这种理念。</p>\n<blockquote>\n<p>参考资料:<br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement\">documentElement</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth\">innerWidth</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Window/outerWidth\">outerWidth</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/body\">document.body</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth\">clientWidth</a><br>《JavaScriptDOM高级程序设计》</p>\n</blockquote>"},{"title":"这些天的感想","date":"2017-08-09T14:29:55.000Z","_content":"\n最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。\n<!--more-->\n\n暑假以来，一直在找实习，然而很多公司基本人都招满了，而投的几个也了无音讯，说实话，我感受到了强烈的失落感。\n我到底适不适合做前端？为什么没有公司要我呢？我应该怎么做？我应该坚持下去吗？\n\n每天我都陷入深深地自省中，我学前端真的对吗？我是真心想做前端开发吗？\n\n经过这段时间的思考，我还是决定了，继续走下去。既然选择了前端这条路，就不该放弃，即使没有公司实习，没关系，自己在家自学，写项目，看书，反正不让自己闲着。前端基础不好，补！静下心来看书、静下心来写代码！边学边准备校招。\n\n我知道，自己严格来说前端只学了不到一年的时间，比不上别人已经学了好几年，进工作室、公司实习过的大佬，但我相信，现在仍然为时不晚。我只不过是比别人起步晚，那就比别人花的时间长呗！我以前都只是听说勤能补拙，这次，我要自己实践下去。\n\n为什么选择前端？\n\n一开始是在知乎看到前端的介绍，那个时候第一次听到前端这个名词，之前完全不知道它是干什么的。后来慢慢去了解，发现前端看似很简单，用HTML、CSS、JavaScript稍加组合就能写出一个网页，不像后台开发那么没头绪、可视化不强，前端是即写即见的。后来一步步去W3SCHOOL上跟着教程走，上网找各种资料，图书馆借书看，发现前端并没有想象中的那么简单，要学的东西多而杂，光学好HTML、CSS还不行，还得会响应式开发，会用`Sass`、`Less`预处理，会`CSS3`动画...光会原生JS也不行，写项目时效率太低，得学会使用各种库，比如伟大的`JQuery`、`underscore`等等，后来发现还得了解工程化，因为前端的逻辑越来越复杂，所包含的内容越来越多，需要框架的帮助和自动化工具来提高开发效率，比如三大框架：`React`、`Vue`、`Angular`，还有打包工具`Webpack`、`gulp`、`grunt`等等。这里面每一个知识都值得去深挖，去研究。这还不够，你不能光会前端写页面，你还得会移动端开发，随着页面的复杂度提高，资源的增多，你还得会性能优化，缓存处理，HTTP协议相关。因为前端既要和用户进行交互，还要与后端进行交接，所以服务器方面的知识也得略知一二，比如`NodeJS`。\n\n当我刚了解这些我发现我头都大了一圈，前端要学的东西太多了吧！不光这样，每天关注技术博客、新闻、知乎等论坛时还会发现层出不穷的新名词，都是别人新写的库，宣传得多么多么厉害。让我这个前端小白看得眼花缭乱，不知道该不该去学。\n\n三四月份的时候真是我陷入迷茫期的时候，感觉自己什么都想学，但又觉得学不过来，不知道先学哪一个。经历了春招实习生的挫败后，我终于发现了，我学的太浮躁了。\n\n因为急于想要找到实习，希望学点新东西，新框架来显示自己的能力，但却忽略了最重要的一点：基础。基础不牢，学什么都白谈。基础没学好，去学那些花里胡哨的库却不能理解其中的源码、思想，只是机械地使用工具来码代码，那和最基本的劳动力有什么区别？别人凭什么招你呢？你的活完全可以找别人来替代，为什么要选你呢？\n\n于是，我开始重新翻阅书籍，静下心来去看，看到有意思的地方、值得记忆的地方就写下来，以后随时翻阅。但同时光看书也不行，实践能力差别人一大截，于是我又使用React+Node写了一个[博客系统](https://github.com/flyrk/myblog)，每天持续完善中。就这样，暑假过去了一个月。\n\n这一个月来，我虽然没有找到实习，但我找到了自己的学习方向。我知道我要先打好基础，同时动手能力也不能落下。\n\n我不知道即将到来的秋招会是怎样，但我唯有坚持下去，坚守自己的初心，不让自己后悔。\n\n---\n\n说了这么多关于前端的思考和自己的打算，再说说前端之外的吧。最近身体不好，去医院做了检查，索性无大碍。但是今天又有点感冒头晕，让我很是烦躁。不管怎样，身体一定要养好，有了好身体才有好力气干活。\n\n虽说自己没有出去找事做，但每天学习学习，码码代码，也还是过的挺充实的。加油吧，少年！\n","source":"_posts/2017-08-09-thought-of-today.md","raw":"---\ntitle: 这些天的感想\ndate: 2017-08-09 22:29:55\ncategories:\n- 经验分享\ntags:\n- 思考感悟\n---\n\n最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。\n<!--more-->\n\n暑假以来，一直在找实习，然而很多公司基本人都招满了，而投的几个也了无音讯，说实话，我感受到了强烈的失落感。\n我到底适不适合做前端？为什么没有公司要我呢？我应该怎么做？我应该坚持下去吗？\n\n每天我都陷入深深地自省中，我学前端真的对吗？我是真心想做前端开发吗？\n\n经过这段时间的思考，我还是决定了，继续走下去。既然选择了前端这条路，就不该放弃，即使没有公司实习，没关系，自己在家自学，写项目，看书，反正不让自己闲着。前端基础不好，补！静下心来看书、静下心来写代码！边学边准备校招。\n\n我知道，自己严格来说前端只学了不到一年的时间，比不上别人已经学了好几年，进工作室、公司实习过的大佬，但我相信，现在仍然为时不晚。我只不过是比别人起步晚，那就比别人花的时间长呗！我以前都只是听说勤能补拙，这次，我要自己实践下去。\n\n为什么选择前端？\n\n一开始是在知乎看到前端的介绍，那个时候第一次听到前端这个名词，之前完全不知道它是干什么的。后来慢慢去了解，发现前端看似很简单，用HTML、CSS、JavaScript稍加组合就能写出一个网页，不像后台开发那么没头绪、可视化不强，前端是即写即见的。后来一步步去W3SCHOOL上跟着教程走，上网找各种资料，图书馆借书看，发现前端并没有想象中的那么简单，要学的东西多而杂，光学好HTML、CSS还不行，还得会响应式开发，会用`Sass`、`Less`预处理，会`CSS3`动画...光会原生JS也不行，写项目时效率太低，得学会使用各种库，比如伟大的`JQuery`、`underscore`等等，后来发现还得了解工程化，因为前端的逻辑越来越复杂，所包含的内容越来越多，需要框架的帮助和自动化工具来提高开发效率，比如三大框架：`React`、`Vue`、`Angular`，还有打包工具`Webpack`、`gulp`、`grunt`等等。这里面每一个知识都值得去深挖，去研究。这还不够，你不能光会前端写页面，你还得会移动端开发，随着页面的复杂度提高，资源的增多，你还得会性能优化，缓存处理，HTTP协议相关。因为前端既要和用户进行交互，还要与后端进行交接，所以服务器方面的知识也得略知一二，比如`NodeJS`。\n\n当我刚了解这些我发现我头都大了一圈，前端要学的东西太多了吧！不光这样，每天关注技术博客、新闻、知乎等论坛时还会发现层出不穷的新名词，都是别人新写的库，宣传得多么多么厉害。让我这个前端小白看得眼花缭乱，不知道该不该去学。\n\n三四月份的时候真是我陷入迷茫期的时候，感觉自己什么都想学，但又觉得学不过来，不知道先学哪一个。经历了春招实习生的挫败后，我终于发现了，我学的太浮躁了。\n\n因为急于想要找到实习，希望学点新东西，新框架来显示自己的能力，但却忽略了最重要的一点：基础。基础不牢，学什么都白谈。基础没学好，去学那些花里胡哨的库却不能理解其中的源码、思想，只是机械地使用工具来码代码，那和最基本的劳动力有什么区别？别人凭什么招你呢？你的活完全可以找别人来替代，为什么要选你呢？\n\n于是，我开始重新翻阅书籍，静下心来去看，看到有意思的地方、值得记忆的地方就写下来，以后随时翻阅。但同时光看书也不行，实践能力差别人一大截，于是我又使用React+Node写了一个[博客系统](https://github.com/flyrk/myblog)，每天持续完善中。就这样，暑假过去了一个月。\n\n这一个月来，我虽然没有找到实习，但我找到了自己的学习方向。我知道我要先打好基础，同时动手能力也不能落下。\n\n我不知道即将到来的秋招会是怎样，但我唯有坚持下去，坚守自己的初心，不让自己后悔。\n\n---\n\n说了这么多关于前端的思考和自己的打算，再说说前端之外的吧。最近身体不好，去医院做了检查，索性无大碍。但是今天又有点感冒头晕，让我很是烦躁。不管怎样，身体一定要养好，有了好身体才有好力气干活。\n\n虽说自己没有出去找事做，但每天学习学习，码码代码，也还是过的挺充实的。加油吧，少年！\n","slug":"thought-of-today","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cs001lra4khyml6unf","content":"<p>最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。</p>\n<span id=\"more\"></span>\n\n<p>暑假以来，一直在找实习，然而很多公司基本人都招满了，而投的几个也了无音讯，说实话，我感受到了强烈的失落感。<br>我到底适不适合做前端？为什么没有公司要我呢？我应该怎么做？我应该坚持下去吗？</p>\n<p>每天我都陷入深深地自省中，我学前端真的对吗？我是真心想做前端开发吗？</p>\n<p>经过这段时间的思考，我还是决定了，继续走下去。既然选择了前端这条路，就不该放弃，即使没有公司实习，没关系，自己在家自学，写项目，看书，反正不让自己闲着。前端基础不好，补！静下心来看书、静下心来写代码！边学边准备校招。</p>\n<p>我知道，自己严格来说前端只学了不到一年的时间，比不上别人已经学了好几年，进工作室、公司实习过的大佬，但我相信，现在仍然为时不晚。我只不过是比别人起步晚，那就比别人花的时间长呗！我以前都只是听说勤能补拙，这次，我要自己实践下去。</p>\n<p>为什么选择前端？</p>\n<p>一开始是在知乎看到前端的介绍，那个时候第一次听到前端这个名词，之前完全不知道它是干什么的。后来慢慢去了解，发现前端看似很简单，用HTML、CSS、JavaScript稍加组合就能写出一个网页，不像后台开发那么没头绪、可视化不强，前端是即写即见的。后来一步步去W3SCHOOL上跟着教程走，上网找各种资料，图书馆借书看，发现前端并没有想象中的那么简单，要学的东西多而杂，光学好HTML、CSS还不行，还得会响应式开发，会用<code>Sass</code>、<code>Less</code>预处理，会<code>CSS3</code>动画…光会原生JS也不行，写项目时效率太低，得学会使用各种库，比如伟大的<code>JQuery</code>、<code>underscore</code>等等，后来发现还得了解工程化，因为前端的逻辑越来越复杂，所包含的内容越来越多，需要框架的帮助和自动化工具来提高开发效率，比如三大框架：<code>React</code>、<code>Vue</code>、<code>Angular</code>，还有打包工具<code>Webpack</code>、<code>gulp</code>、<code>grunt</code>等等。这里面每一个知识都值得去深挖，去研究。这还不够，你不能光会前端写页面，你还得会移动端开发，随着页面的复杂度提高，资源的增多，你还得会性能优化，缓存处理，HTTP协议相关。因为前端既要和用户进行交互，还要与后端进行交接，所以服务器方面的知识也得略知一二，比如<code>NodeJS</code>。</p>\n<p>当我刚了解这些我发现我头都大了一圈，前端要学的东西太多了吧！不光这样，每天关注技术博客、新闻、知乎等论坛时还会发现层出不穷的新名词，都是别人新写的库，宣传得多么多么厉害。让我这个前端小白看得眼花缭乱，不知道该不该去学。</p>\n<p>三四月份的时候真是我陷入迷茫期的时候，感觉自己什么都想学，但又觉得学不过来，不知道先学哪一个。经历了春招实习生的挫败后，我终于发现了，我学的太浮躁了。</p>\n<p>因为急于想要找到实习，希望学点新东西，新框架来显示自己的能力，但却忽略了最重要的一点：基础。基础不牢，学什么都白谈。基础没学好，去学那些花里胡哨的库却不能理解其中的源码、思想，只是机械地使用工具来码代码，那和最基本的劳动力有什么区别？别人凭什么招你呢？你的活完全可以找别人来替代，为什么要选你呢？</p>\n<p>于是，我开始重新翻阅书籍，静下心来去看，看到有意思的地方、值得记忆的地方就写下来，以后随时翻阅。但同时光看书也不行，实践能力差别人一大截，于是我又使用React+Node写了一个<a href=\"https://github.com/flyrk/myblog\">博客系统</a>，每天持续完善中。就这样，暑假过去了一个月。</p>\n<p>这一个月来，我虽然没有找到实习，但我找到了自己的学习方向。我知道我要先打好基础，同时动手能力也不能落下。</p>\n<p>我不知道即将到来的秋招会是怎样，但我唯有坚持下去，坚守自己的初心，不让自己后悔。</p>\n<hr>\n<p>说了这么多关于前端的思考和自己的打算，再说说前端之外的吧。最近身体不好，去医院做了检查，索性无大碍。但是今天又有点感冒头晕，让我很是烦躁。不管怎样，身体一定要养好，有了好身体才有好力气干活。</p>\n<p>虽说自己没有出去找事做，但每天学习学习，码码代码，也还是过的挺充实的。加油吧，少年！</p>\n","site":{"data":{}},"excerpt":"<p>最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。</p>","more":"<p>暑假以来，一直在找实习，然而很多公司基本人都招满了，而投的几个也了无音讯，说实话，我感受到了强烈的失落感。<br>我到底适不适合做前端？为什么没有公司要我呢？我应该怎么做？我应该坚持下去吗？</p>\n<p>每天我都陷入深深地自省中，我学前端真的对吗？我是真心想做前端开发吗？</p>\n<p>经过这段时间的思考，我还是决定了，继续走下去。既然选择了前端这条路，就不该放弃，即使没有公司实习，没关系，自己在家自学，写项目，看书，反正不让自己闲着。前端基础不好，补！静下心来看书、静下心来写代码！边学边准备校招。</p>\n<p>我知道，自己严格来说前端只学了不到一年的时间，比不上别人已经学了好几年，进工作室、公司实习过的大佬，但我相信，现在仍然为时不晚。我只不过是比别人起步晚，那就比别人花的时间长呗！我以前都只是听说勤能补拙，这次，我要自己实践下去。</p>\n<p>为什么选择前端？</p>\n<p>一开始是在知乎看到前端的介绍，那个时候第一次听到前端这个名词，之前完全不知道它是干什么的。后来慢慢去了解，发现前端看似很简单，用HTML、CSS、JavaScript稍加组合就能写出一个网页，不像后台开发那么没头绪、可视化不强，前端是即写即见的。后来一步步去W3SCHOOL上跟着教程走，上网找各种资料，图书馆借书看，发现前端并没有想象中的那么简单，要学的东西多而杂，光学好HTML、CSS还不行，还得会响应式开发，会用<code>Sass</code>、<code>Less</code>预处理，会<code>CSS3</code>动画…光会原生JS也不行，写项目时效率太低，得学会使用各种库，比如伟大的<code>JQuery</code>、<code>underscore</code>等等，后来发现还得了解工程化，因为前端的逻辑越来越复杂，所包含的内容越来越多，需要框架的帮助和自动化工具来提高开发效率，比如三大框架：<code>React</code>、<code>Vue</code>、<code>Angular</code>，还有打包工具<code>Webpack</code>、<code>gulp</code>、<code>grunt</code>等等。这里面每一个知识都值得去深挖，去研究。这还不够，你不能光会前端写页面，你还得会移动端开发，随着页面的复杂度提高，资源的增多，你还得会性能优化，缓存处理，HTTP协议相关。因为前端既要和用户进行交互，还要与后端进行交接，所以服务器方面的知识也得略知一二，比如<code>NodeJS</code>。</p>\n<p>当我刚了解这些我发现我头都大了一圈，前端要学的东西太多了吧！不光这样，每天关注技术博客、新闻、知乎等论坛时还会发现层出不穷的新名词，都是别人新写的库，宣传得多么多么厉害。让我这个前端小白看得眼花缭乱，不知道该不该去学。</p>\n<p>三四月份的时候真是我陷入迷茫期的时候，感觉自己什么都想学，但又觉得学不过来，不知道先学哪一个。经历了春招实习生的挫败后，我终于发现了，我学的太浮躁了。</p>\n<p>因为急于想要找到实习，希望学点新东西，新框架来显示自己的能力，但却忽略了最重要的一点：基础。基础不牢，学什么都白谈。基础没学好，去学那些花里胡哨的库却不能理解其中的源码、思想，只是机械地使用工具来码代码，那和最基本的劳动力有什么区别？别人凭什么招你呢？你的活完全可以找别人来替代，为什么要选你呢？</p>\n<p>于是，我开始重新翻阅书籍，静下心来去看，看到有意思的地方、值得记忆的地方就写下来，以后随时翻阅。但同时光看书也不行，实践能力差别人一大截，于是我又使用React+Node写了一个<a href=\"https://github.com/flyrk/myblog\">博客系统</a>，每天持续完善中。就这样，暑假过去了一个月。</p>\n<p>这一个月来，我虽然没有找到实习，但我找到了自己的学习方向。我知道我要先打好基础，同时动手能力也不能落下。</p>\n<p>我不知道即将到来的秋招会是怎样，但我唯有坚持下去，坚守自己的初心，不让自己后悔。</p>\n<hr>\n<p>说了这么多关于前端的思考和自己的打算，再说说前端之外的吧。最近身体不好，去医院做了检查，索性无大碍。但是今天又有点感冒头晕，让我很是烦躁。不管怎样，身体一定要养好，有了好身体才有好力气干活。</p>\n<p>虽说自己没有出去找事做，但每天学习学习，码码代码，也还是过的挺充实的。加油吧，少年！</p>"},{"title":"JS中\"类\"的构造与继承","date":"2017-08-10T13:46:33.000Z","_content":"\n有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：`String`、`Number`、`Boolean`、`Null`、`undefined`、`Symbol`。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。\n<!--more-->\n\n我们知道，JS里没有类似于C++、Java一样的`class`类，于是也就没有私有、公有之说。但这并不代表我们不能模拟一个类，因为类的思想在面向对象编程里是很重要的一点，对于对象的继承与方法的引用和代码的重构等等都有极大好处。所以很多人就在JS里模拟类的用法，ES6甚至官方定义了一个`class`语法，但这也不是真正的类，只是`class`的语法糖。\n\n说了这么多，JS里到底怎么实现类呢？利用函数的特性：所有的函数默认都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，也就是原型。\n\n\n# 构造函数\n什么是构造函数？我们知道`function`也是对象的一种，而当我们想要声明一个构造函数，可以使用下列形式：\n```javascript\nfunction myConstructor() {\n  this.name = 'Simon';\n  var car = 'BMW';\n  function getCar() {\n    console.log(car);\n  }\n  getCar();\n}\n\nvar myObj = new myConstructor();\n```\n使用上述方法我们就声明了一个构造函数`myConstructor`，但其实构造函数也是普通的对象，它和java里类的构造函数完全不一样。当我们使用`new`创建一个对象，实际上是把myObj的[[Prototype]]链接关联到myConstructor.prototype指向的对象。\n\n我们知道，真正的面向类的语言中，类可以被复制或者实例化很多次，每创建一个实例相当于把类的方法属性复制到新实例中。但javascript没有类似的复制机制，要想让新对象与构造的“类”对象有关系，就必须把两个对象的prototype关联起来。\n\n实际上并不存在所谓的“构造函数”，我们只是对函数的“构造调用”。\n\n当使用new来进行构造函数调用时，会执行以下四个步骤：\n  1. 创建一个全新的对象\n  2. 新对象会执行[[Prototype]]链接到constructor对象的prototype\n  3. 新对象会绑定到函数调用的this\n  4. 如果构造函数没有返回其他对象，那么new的函数调用会返回这个新对象\n\n这样一来，我们就把新对象与构造函数对象关联起来了。所以说函数不是构造函数，只是当且仅当使用new时，函数调用会变成“构造函数调用”。\n```javascript\nfunction Foo () {\n  //.....\n}\n\nvar a = new Foo();\n\na.constructor === Foo; // true\nFoo.prototype.constructor === Foo; // true\n```\n当我们创建了Foo函数，Foo.prototype默认有一个公有且不可枚举的属性constructor，这个属性引用的是对象关联的函数（也就是Foo）。而调用a.constructor，实际上只是通过[[Prototype]]委托给了Foo.prototype，所以指向了Foo。\n\n如果我们创建了新的原型对象，那么新对象并不会自动获得constructor属性，比如说：\n```javascript\nfunction Foo() {\n  //....\n}\nFoo.prototype = { /*....*/ }; // 创建了新的原型对象\n\nvar a = new Foo();\na.constructor === Foo; // false\na.constructor === Object; // true\n```\n\n\n但问题来了，运行以下代码：\n```javascript\nmyObj.name; // \"Simon\"\nmyObj.car; // undefined\nmyObj.getCar(); // Uncaught TypeError: myObj.getCar is not a function\n```\n为什么会这样呢？原因就是构造函数有作用域。`this.name = 'Simon'`相当于给构造函数这个对象的`name`属性赋值`\"Simon\"`，这里的`this`指代构造函数对象原型。而在构造函数里使用`var`、`function`创建的变量和函数都相当于 *局部变量*，也就是“私有方法”，因为作用域的问题，这些变量和属性在构造函数之外是不能访问的，“私有方法”中的函数可以访问其他的私有变量，构造函数的实例却不能访问这些方法。\n\n# 继承\n那么，如果我们想要实例能继承构造函数的属性或者方法怎么办呢？JS使用的机制为 *原型继承*，请看以下代码：\n```javascript\nmyConstructor.prototype.car = \"Farrari\";\nmyConstructor.prototype.getCar = function () {\n  console.log(this.car);\n};\n\nmyObj.car; // \"Farrari\"\nmyObj.getCar(); // \"Farrari\"\n```\n一旦我们在构造函数的原型上添加了属性car，当新对象myObj调用car属性时，它本身没有这个属性，于是就通过委托，在原型链上找，最后在myConsrtuctor.prototype上找到。\n\n但使用原型继承来实现子类继承父类更好的方法是这样：\n```javascript\nfunction Foo(name) {\n  this.name = name;\n}\nFoo,prototype.getName = function() {\n  console.log(this.name);\n};\n\nfunction Bar(name, type) {\n  Foo.call(this, name); // 相当于ES6的super(name);\n  this.type = type;\n}\n\nBar.prototype = Object.create(Foo.prototype); // 相当于ES6的extends\nBar.prototype.constructor = Bar; // 这里需要修复consructor\n\nBar.prototype.getType = function () {\n  console.log(this.type);\n};\n\nvar a = new Bar('a', 'obj a');\na.getName(); // 'a'\na.getType(); // 'obj a'\n```\n这里用到的核心语句就是`Bar.prototype = Object.create(Foo.prototype);`，调用Object.create(obj)会凭空创建一个新对象并把新对象的[[Prototype]]关联到obj上。\n\n我们来看看Object.create()的polyfill:\n```javascript\nif (!Object.create) {\n  Object.create = function (proto, propsObj) {\n    if (!(proto === null || typeof proto === 'object' || typeof proto === 'function')) {\n      throw TypeError('Arguments must be object, or Null');\n    }\n    var temp = new Object();\n    temp.__proto__ = proto;\n    if (propsObj) {\n      Object.defineProperty(temp, propsObj);\n    }\n    return temp;\n  };\n}\n```\n有的人可能会说，为什么不能直接`Bar.prototype = Foo.prototype;`呢？这样并不会创建一个关联到Foo.prototype的新对象，只是让Bar.prototype引用Foo.prototype对象，我们执行`Bar.prototype.getType = ....`也会在Foo.prototype上修改，跟预料的结果不一样。那这样根本不需要Bar，还不如直接在Foo上修改就好了。\n\n而之前介绍的`Bar.prototype = new Foo()`虽然也能实现原型继承，但它会有一些副作用。比如Foo如果有（写日志、修改状态、注册到其他对象、给this添加属性等等）的行为，就会影响到Bar的子类，造成无法预料的结果。\n\n所以，要创建一个关联的“子类”对象，我们必须使用Object.create()，但这样有一个缺点是要创建一个新对象而把旧对象抛弃。\n\n好在ES6添加了`Object.setPrototypeOf(...)`方法，可以修改关联。\n```javascript\nBar.prototype = Object.create(Foo.prototype); // ES6之前需要抛弃默认对象\n\nObject.setPrototypeOf(Bar.prototype, Foo.prototype); // ES6可以直接修改Bar.prototype对象\n```\n\n# 检查“类”的关系\n考虑以下代码：\n```javascript\nfunction Foo() {\n  //...\n}\nFoo.prototype.blah = ...;\n\nvar a = new Foo();\n```\n我们如果想要判断a的原型是否与Foo关联起来了，我们可以有以下几种方法：\n## instanceof\n```javascript\na instanceof Foo; // true\n```\n但这样有个缺点是只能处理对象和函数之间的关系。如果我们想判断两个对象之间是否通过[[Prototype]]关联。可以用下列方法：\n## isPrototypeOf()\n```javascript\nFoo.prototype.isPrototypeOf(a); // true\n```\n要判断两个对象之间的关系，更直接：\n```javascript\nb.isPrototypeOf(c); // 判断b是否出现在c的原型链中\n```\n## Object.getPrototypeOf()\n```javascript\nObject.getPrototypeOf(a) === Foo.prototype; // true\n```\n## __proto__\n我们可以直接用非标准的`__proto__`属性，`__proto__`实际上存在于内置的Object.prototype中，且不可枚举。\n```javascript\na.__proto__ === Foo.prototype; // true\n```\n\n# 总结\n要想创建类似于“类”的对象，可以使用构造函数调用，给构造函数添加公有方法，在构造函数的`prototype`上添加属性。新对象想要继承构造函数，使用Javascript的原型继承机制。\n","source":"_posts/2017-08-10-javascript-class-constructor.md","raw":"---\ntitle: JS中\"类\"的构造与继承\ndate: 2017-08-10 21:46:33\ncategories:\n- JS相关\ntags:\n- 类\n---\n\n有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：`String`、`Number`、`Boolean`、`Null`、`undefined`、`Symbol`。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。\n<!--more-->\n\n我们知道，JS里没有类似于C++、Java一样的`class`类，于是也就没有私有、公有之说。但这并不代表我们不能模拟一个类，因为类的思想在面向对象编程里是很重要的一点，对于对象的继承与方法的引用和代码的重构等等都有极大好处。所以很多人就在JS里模拟类的用法，ES6甚至官方定义了一个`class`语法，但这也不是真正的类，只是`class`的语法糖。\n\n说了这么多，JS里到底怎么实现类呢？利用函数的特性：所有的函数默认都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，也就是原型。\n\n\n# 构造函数\n什么是构造函数？我们知道`function`也是对象的一种，而当我们想要声明一个构造函数，可以使用下列形式：\n```javascript\nfunction myConstructor() {\n  this.name = 'Simon';\n  var car = 'BMW';\n  function getCar() {\n    console.log(car);\n  }\n  getCar();\n}\n\nvar myObj = new myConstructor();\n```\n使用上述方法我们就声明了一个构造函数`myConstructor`，但其实构造函数也是普通的对象，它和java里类的构造函数完全不一样。当我们使用`new`创建一个对象，实际上是把myObj的[[Prototype]]链接关联到myConstructor.prototype指向的对象。\n\n我们知道，真正的面向类的语言中，类可以被复制或者实例化很多次，每创建一个实例相当于把类的方法属性复制到新实例中。但javascript没有类似的复制机制，要想让新对象与构造的“类”对象有关系，就必须把两个对象的prototype关联起来。\n\n实际上并不存在所谓的“构造函数”，我们只是对函数的“构造调用”。\n\n当使用new来进行构造函数调用时，会执行以下四个步骤：\n  1. 创建一个全新的对象\n  2. 新对象会执行[[Prototype]]链接到constructor对象的prototype\n  3. 新对象会绑定到函数调用的this\n  4. 如果构造函数没有返回其他对象，那么new的函数调用会返回这个新对象\n\n这样一来，我们就把新对象与构造函数对象关联起来了。所以说函数不是构造函数，只是当且仅当使用new时，函数调用会变成“构造函数调用”。\n```javascript\nfunction Foo () {\n  //.....\n}\n\nvar a = new Foo();\n\na.constructor === Foo; // true\nFoo.prototype.constructor === Foo; // true\n```\n当我们创建了Foo函数，Foo.prototype默认有一个公有且不可枚举的属性constructor，这个属性引用的是对象关联的函数（也就是Foo）。而调用a.constructor，实际上只是通过[[Prototype]]委托给了Foo.prototype，所以指向了Foo。\n\n如果我们创建了新的原型对象，那么新对象并不会自动获得constructor属性，比如说：\n```javascript\nfunction Foo() {\n  //....\n}\nFoo.prototype = { /*....*/ }; // 创建了新的原型对象\n\nvar a = new Foo();\na.constructor === Foo; // false\na.constructor === Object; // true\n```\n\n\n但问题来了，运行以下代码：\n```javascript\nmyObj.name; // \"Simon\"\nmyObj.car; // undefined\nmyObj.getCar(); // Uncaught TypeError: myObj.getCar is not a function\n```\n为什么会这样呢？原因就是构造函数有作用域。`this.name = 'Simon'`相当于给构造函数这个对象的`name`属性赋值`\"Simon\"`，这里的`this`指代构造函数对象原型。而在构造函数里使用`var`、`function`创建的变量和函数都相当于 *局部变量*，也就是“私有方法”，因为作用域的问题，这些变量和属性在构造函数之外是不能访问的，“私有方法”中的函数可以访问其他的私有变量，构造函数的实例却不能访问这些方法。\n\n# 继承\n那么，如果我们想要实例能继承构造函数的属性或者方法怎么办呢？JS使用的机制为 *原型继承*，请看以下代码：\n```javascript\nmyConstructor.prototype.car = \"Farrari\";\nmyConstructor.prototype.getCar = function () {\n  console.log(this.car);\n};\n\nmyObj.car; // \"Farrari\"\nmyObj.getCar(); // \"Farrari\"\n```\n一旦我们在构造函数的原型上添加了属性car，当新对象myObj调用car属性时，它本身没有这个属性，于是就通过委托，在原型链上找，最后在myConsrtuctor.prototype上找到。\n\n但使用原型继承来实现子类继承父类更好的方法是这样：\n```javascript\nfunction Foo(name) {\n  this.name = name;\n}\nFoo,prototype.getName = function() {\n  console.log(this.name);\n};\n\nfunction Bar(name, type) {\n  Foo.call(this, name); // 相当于ES6的super(name);\n  this.type = type;\n}\n\nBar.prototype = Object.create(Foo.prototype); // 相当于ES6的extends\nBar.prototype.constructor = Bar; // 这里需要修复consructor\n\nBar.prototype.getType = function () {\n  console.log(this.type);\n};\n\nvar a = new Bar('a', 'obj a');\na.getName(); // 'a'\na.getType(); // 'obj a'\n```\n这里用到的核心语句就是`Bar.prototype = Object.create(Foo.prototype);`，调用Object.create(obj)会凭空创建一个新对象并把新对象的[[Prototype]]关联到obj上。\n\n我们来看看Object.create()的polyfill:\n```javascript\nif (!Object.create) {\n  Object.create = function (proto, propsObj) {\n    if (!(proto === null || typeof proto === 'object' || typeof proto === 'function')) {\n      throw TypeError('Arguments must be object, or Null');\n    }\n    var temp = new Object();\n    temp.__proto__ = proto;\n    if (propsObj) {\n      Object.defineProperty(temp, propsObj);\n    }\n    return temp;\n  };\n}\n```\n有的人可能会说，为什么不能直接`Bar.prototype = Foo.prototype;`呢？这样并不会创建一个关联到Foo.prototype的新对象，只是让Bar.prototype引用Foo.prototype对象，我们执行`Bar.prototype.getType = ....`也会在Foo.prototype上修改，跟预料的结果不一样。那这样根本不需要Bar，还不如直接在Foo上修改就好了。\n\n而之前介绍的`Bar.prototype = new Foo()`虽然也能实现原型继承，但它会有一些副作用。比如Foo如果有（写日志、修改状态、注册到其他对象、给this添加属性等等）的行为，就会影响到Bar的子类，造成无法预料的结果。\n\n所以，要创建一个关联的“子类”对象，我们必须使用Object.create()，但这样有一个缺点是要创建一个新对象而把旧对象抛弃。\n\n好在ES6添加了`Object.setPrototypeOf(...)`方法，可以修改关联。\n```javascript\nBar.prototype = Object.create(Foo.prototype); // ES6之前需要抛弃默认对象\n\nObject.setPrototypeOf(Bar.prototype, Foo.prototype); // ES6可以直接修改Bar.prototype对象\n```\n\n# 检查“类”的关系\n考虑以下代码：\n```javascript\nfunction Foo() {\n  //...\n}\nFoo.prototype.blah = ...;\n\nvar a = new Foo();\n```\n我们如果想要判断a的原型是否与Foo关联起来了，我们可以有以下几种方法：\n## instanceof\n```javascript\na instanceof Foo; // true\n```\n但这样有个缺点是只能处理对象和函数之间的关系。如果我们想判断两个对象之间是否通过[[Prototype]]关联。可以用下列方法：\n## isPrototypeOf()\n```javascript\nFoo.prototype.isPrototypeOf(a); // true\n```\n要判断两个对象之间的关系，更直接：\n```javascript\nb.isPrototypeOf(c); // 判断b是否出现在c的原型链中\n```\n## Object.getPrototypeOf()\n```javascript\nObject.getPrototypeOf(a) === Foo.prototype; // true\n```\n## __proto__\n我们可以直接用非标准的`__proto__`属性，`__proto__`实际上存在于内置的Object.prototype中，且不可枚举。\n```javascript\na.__proto__ === Foo.prototype; // true\n```\n\n# 总结\n要想创建类似于“类”的对象，可以使用构造函数调用，给构造函数添加公有方法，在构造函数的`prototype`上添加属性。新对象想要继承构造函数，使用Javascript的原型继承机制。\n","slug":"javascript-class-constructor","published":1,"updated":"2022-03-10T07:44:32.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cu001pra4k5etb55kv","content":"<p>有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>undefined</code>、<code>Symbol</code>。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。</p>\n<span id=\"more\"></span>\n\n<p>我们知道，JS里没有类似于C++、Java一样的<code>class</code>类，于是也就没有私有、公有之说。但这并不代表我们不能模拟一个类，因为类的思想在面向对象编程里是很重要的一点，对于对象的继承与方法的引用和代码的重构等等都有极大好处。所以很多人就在JS里模拟类的用法，ES6甚至官方定义了一个<code>class</code>语法，但这也不是真正的类，只是<code>class</code>的语法糖。</p>\n<p>说了这么多，JS里到底怎么实现类呢？利用函数的特性：所有的函数默认都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，也就是原型。</p>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p>什么是构造函数？我们知道<code>function</code>也是对象的一种，而当我们想要声明一个构造函数，可以使用下列形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myConstructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Simon&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> car = <span class=\"string\">&#x27;BMW&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">getCar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">getCar</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"title function_\">myConstructor</span>();</span><br></pre></td></tr></table></figure>\n<p>使用上述方法我们就声明了一个构造函数<code>myConstructor</code>，但其实构造函数也是普通的对象，它和java里类的构造函数完全不一样。当我们使用<code>new</code>创建一个对象，实际上是把myObj的[[Prototype]]链接关联到myConstructor.prototype指向的对象。</p>\n<p>我们知道，真正的面向类的语言中，类可以被复制或者实例化很多次，每创建一个实例相当于把类的方法属性复制到新实例中。但javascript没有类似的复制机制，要想让新对象与构造的“类”对象有关系，就必须把两个对象的prototype关联起来。</p>\n<p>实际上并不存在所谓的“构造函数”，我们只是对函数的“构造调用”。</p>\n<p>当使用new来进行构造函数调用时，会执行以下四个步骤：</p>\n<ol>\n<li>创建一个全新的对象</li>\n<li>新对象会执行[[Prototype]]链接到constructor对象的prototype</li>\n<li>新对象会绑定到函数调用的this</li>\n<li>如果构造函数没有返回其他对象，那么new的函数调用会返回这个新对象</li>\n</ol>\n<p>这样一来，我们就把新对象与构造函数对象关联起来了。所以说函数不是构造函数，只是当且仅当使用new时，函数调用会变成“构造函数调用”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span> () &#123;</span><br><span class=\"line\">  <span class=\"comment\">//.....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">a.<span class=\"property\">constructor</span> === <span class=\"title class_\">Foo</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Foo</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>当我们创建了Foo函数，Foo.prototype默认有一个公有且不可枚举的属性constructor，这个属性引用的是对象关联的函数（也就是Foo）。而调用a.constructor，实际上只是通过[[Prototype]]委托给了Foo.prototype，所以指向了Foo。</p>\n<p>如果我们创建了新的原型对象，那么新对象并不会自动获得constructor属性，比如说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123; <span class=\"comment\">/*....*/</span> &#125;; <span class=\"comment\">// 创建了新的原型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\">a.<span class=\"property\">constructor</span> === <span class=\"title class_\">Foo</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">a.<span class=\"property\">constructor</span> === <span class=\"title class_\">Object</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n\n<p>但问题来了，运行以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObj.<span class=\"property\">name</span>; <span class=\"comment\">// &quot;Simon&quot;</span></span><br><span class=\"line\">myObj.<span class=\"property\">car</span>; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">myObj.<span class=\"title function_\">getCar</span>(); <span class=\"comment\">// Uncaught TypeError: myObj.getCar is not a function</span></span><br></pre></td></tr></table></figure>\n<p>为什么会这样呢？原因就是构造函数有作用域。<code>this.name = &#39;Simon&#39;</code>相当于给构造函数这个对象的<code>name</code>属性赋值<code>&quot;Simon&quot;</code>，这里的<code>this</code>指代构造函数对象原型。而在构造函数里使用<code>var</code>、<code>function</code>创建的变量和函数都相当于 <em>局部变量</em>，也就是“私有方法”，因为作用域的问题，这些变量和属性在构造函数之外是不能访问的，“私有方法”中的函数可以访问其他的私有变量，构造函数的实例却不能访问这些方法。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>那么，如果我们想要实例能继承构造函数的属性或者方法怎么办呢？JS使用的机制为 <em>原型继承</em>，请看以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myConstructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">car</span> = <span class=\"string\">&quot;Farrari&quot;</span>;</span><br><span class=\"line\">myConstructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getCar</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">car</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.<span class=\"property\">car</span>; <span class=\"comment\">// &quot;Farrari&quot;</span></span><br><span class=\"line\">myObj.<span class=\"title function_\">getCar</span>(); <span class=\"comment\">// &quot;Farrari&quot;</span></span><br></pre></td></tr></table></figure>\n<p>一旦我们在构造函数的原型上添加了属性car，当新对象myObj调用car属性时，它本身没有这个属性，于是就通过委托，在原型链上找，最后在myConsrtuctor.prototype上找到。</p>\n<p>但使用原型继承来实现子类继承父类更好的方法是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>,prototype.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Bar</span>(<span class=\"params\">name, type</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Foo</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name); <span class=\"comment\">// 相当于ES6的super(name);</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">type</span> = type;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// 相当于ES6的extends</span></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"title class_\">Bar</span>; <span class=\"comment\">// 这里需要修复consructor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getType</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">type</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Bar</span>(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;obj a&#x27;</span>);</span><br><span class=\"line\">a.<span class=\"title function_\">getName</span>(); <span class=\"comment\">// &#x27;a&#x27;</span></span><br><span class=\"line\">a.<span class=\"title function_\">getType</span>(); <span class=\"comment\">// &#x27;obj a&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>这里用到的核心语句就是<code>Bar.prototype = Object.create(Foo.prototype);</code>，调用Object.create(obj)会凭空创建一个新对象并把新对象的[[Prototype]]关联到obj上。</p>\n<p>我们来看看Object.create()的polyfill:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Object</span>.<span class=\"property\">create</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"property\">create</span> = <span class=\"keyword\">function</span> (<span class=\"params\">proto, propsObj</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(proto === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> proto === <span class=\"string\">&#x27;object&#x27;</span> || <span class=\"keyword\">typeof</span> proto === <span class=\"string\">&#x27;function&#x27;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&#x27;Arguments must be object, or Null&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    temp.<span class=\"property\">__proto__</span> = proto;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propsObj) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(temp, propsObj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有的人可能会说，为什么不能直接<code>Bar.prototype = Foo.prototype;</code>呢？这样并不会创建一个关联到Foo.prototype的新对象，只是让Bar.prototype引用Foo.prototype对象，我们执行<code>Bar.prototype.getType = ....</code>也会在Foo.prototype上修改，跟预料的结果不一样。那这样根本不需要Bar，还不如直接在Foo上修改就好了。</p>\n<p>而之前介绍的<code>Bar.prototype = new Foo()</code>虽然也能实现原型继承，但它会有一些副作用。比如Foo如果有（写日志、修改状态、注册到其他对象、给this添加属性等等）的行为，就会影响到Bar的子类，造成无法预料的结果。</p>\n<p>所以，要创建一个关联的“子类”对象，我们必须使用Object.create()，但这样有一个缺点是要创建一个新对象而把旧对象抛弃。</p>\n<p>好在ES6添加了<code>Object.setPrototypeOf(...)</code>方法，可以修改关联。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// ES6之前需要抛弃默认对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototypeOf</span>(<span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>, <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// ES6可以直接修改Bar.prototype对象</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"检查“类”的关系\"><a href=\"#检查“类”的关系\" class=\"headerlink\" title=\"检查“类”的关系\"></a>检查“类”的关系</h1><p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">blah</span> = ...;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br></pre></td></tr></table></figure>\n<p>我们如果想要判断a的原型是否与Foo关联起来了，我们可以有以下几种方法：</p>\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Foo</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>但这样有个缺点是只能处理对象和函数之间的关系。如果我们想判断两个对象之间是否通过[[Prototype]]关联。可以用下列方法：</p>\n<h2 id=\"isPrototypeOf-NaN\"><a href=\"#isPrototypeOf-NaN\" class=\"headerlink\" title=\"isPrototypeOf()\"></a>isPrototypeOf()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(a); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>要判断两个对象之间的关系，更直接：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.<span class=\"title function_\">isPrototypeOf</span>(c); <span class=\"comment\">// 判断b是否出现在c的原型链中</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(a) === <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"proto\"></a><strong>proto</strong></h2><p>我们可以直接用非标准的<code>__proto__</code>属性，<code>__proto__</code>实际上存在于内置的Object.prototype中，且不可枚举。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>要想创建类似于“类”的对象，可以使用构造函数调用，给构造函数添加公有方法，在构造函数的<code>prototype</code>上添加属性。新对象想要继承构造函数，使用Javascript的原型继承机制。</p>\n","site":{"data":{}},"excerpt":"<p>有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>undefined</code>、<code>Symbol</code>。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。</p>","more":"<p>我们知道，JS里没有类似于C++、Java一样的<code>class</code>类，于是也就没有私有、公有之说。但这并不代表我们不能模拟一个类，因为类的思想在面向对象编程里是很重要的一点，对于对象的继承与方法的引用和代码的重构等等都有极大好处。所以很多人就在JS里模拟类的用法，ES6甚至官方定义了一个<code>class</code>语法，但这也不是真正的类，只是<code>class</code>的语法糖。</p>\n<p>说了这么多，JS里到底怎么实现类呢？利用函数的特性：所有的函数默认都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，也就是原型。</p>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p>什么是构造函数？我们知道<code>function</code>也是对象的一种，而当我们想要声明一个构造函数，可以使用下列形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myConstructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Simon&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> car = <span class=\"string\">&#x27;BMW&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">getCar</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">getCar</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObj = <span class=\"keyword\">new</span> <span class=\"title function_\">myConstructor</span>();</span><br></pre></td></tr></table></figure>\n<p>使用上述方法我们就声明了一个构造函数<code>myConstructor</code>，但其实构造函数也是普通的对象，它和java里类的构造函数完全不一样。当我们使用<code>new</code>创建一个对象，实际上是把myObj的[[Prototype]]链接关联到myConstructor.prototype指向的对象。</p>\n<p>我们知道，真正的面向类的语言中，类可以被复制或者实例化很多次，每创建一个实例相当于把类的方法属性复制到新实例中。但javascript没有类似的复制机制，要想让新对象与构造的“类”对象有关系，就必须把两个对象的prototype关联起来。</p>\n<p>实际上并不存在所谓的“构造函数”，我们只是对函数的“构造调用”。</p>\n<p>当使用new来进行构造函数调用时，会执行以下四个步骤：</p>\n<ol>\n<li>创建一个全新的对象</li>\n<li>新对象会执行[[Prototype]]链接到constructor对象的prototype</li>\n<li>新对象会绑定到函数调用的this</li>\n<li>如果构造函数没有返回其他对象，那么new的函数调用会返回这个新对象</li>\n</ol>\n<p>这样一来，我们就把新对象与构造函数对象关联起来了。所以说函数不是构造函数，只是当且仅当使用new时，函数调用会变成“构造函数调用”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span> () &#123;</span><br><span class=\"line\">  <span class=\"comment\">//.....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">a.<span class=\"property\">constructor</span> === <span class=\"title class_\">Foo</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Foo</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>当我们创建了Foo函数，Foo.prototype默认有一个公有且不可枚举的属性constructor，这个属性引用的是对象关联的函数（也就是Foo）。而调用a.constructor，实际上只是通过[[Prototype]]委托给了Foo.prototype，所以指向了Foo。</p>\n<p>如果我们创建了新的原型对象，那么新对象并不会自动获得constructor属性，比如说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123; <span class=\"comment\">/*....*/</span> &#125;; <span class=\"comment\">// 创建了新的原型对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br><span class=\"line\">a.<span class=\"property\">constructor</span> === <span class=\"title class_\">Foo</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\">a.<span class=\"property\">constructor</span> === <span class=\"title class_\">Object</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n\n<p>但问题来了，运行以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myObj.<span class=\"property\">name</span>; <span class=\"comment\">// &quot;Simon&quot;</span></span><br><span class=\"line\">myObj.<span class=\"property\">car</span>; <span class=\"comment\">// undefined</span></span><br><span class=\"line\">myObj.<span class=\"title function_\">getCar</span>(); <span class=\"comment\">// Uncaught TypeError: myObj.getCar is not a function</span></span><br></pre></td></tr></table></figure>\n<p>为什么会这样呢？原因就是构造函数有作用域。<code>this.name = &#39;Simon&#39;</code>相当于给构造函数这个对象的<code>name</code>属性赋值<code>&quot;Simon&quot;</code>，这里的<code>this</code>指代构造函数对象原型。而在构造函数里使用<code>var</code>、<code>function</code>创建的变量和函数都相当于 <em>局部变量</em>，也就是“私有方法”，因为作用域的问题，这些变量和属性在构造函数之外是不能访问的，“私有方法”中的函数可以访问其他的私有变量，构造函数的实例却不能访问这些方法。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>那么，如果我们想要实例能继承构造函数的属性或者方法怎么办呢？JS使用的机制为 <em>原型继承</em>，请看以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myConstructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">car</span> = <span class=\"string\">&quot;Farrari&quot;</span>;</span><br><span class=\"line\">myConstructor.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getCar</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">car</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">myObj.<span class=\"property\">car</span>; <span class=\"comment\">// &quot;Farrari&quot;</span></span><br><span class=\"line\">myObj.<span class=\"title function_\">getCar</span>(); <span class=\"comment\">// &quot;Farrari&quot;</span></span><br></pre></td></tr></table></figure>\n<p>一旦我们在构造函数的原型上添加了属性car，当新对象myObj调用car属性时，它本身没有这个属性，于是就通过委托，在原型链上找，最后在myConsrtuctor.prototype上找到。</p>\n<p>但使用原型继承来实现子类继承父类更好的方法是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>,prototype.<span class=\"property\">getName</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Bar</span>(<span class=\"params\">name, type</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Foo</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name); <span class=\"comment\">// 相当于ES6的super(name);</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">type</span> = type;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// 相当于ES6的extends</span></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"title class_\">Bar</span>; <span class=\"comment\">// 这里需要修复consructor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">getType</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">type</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Bar</span>(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;obj a&#x27;</span>);</span><br><span class=\"line\">a.<span class=\"title function_\">getName</span>(); <span class=\"comment\">// &#x27;a&#x27;</span></span><br><span class=\"line\">a.<span class=\"title function_\">getType</span>(); <span class=\"comment\">// &#x27;obj a&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>这里用到的核心语句就是<code>Bar.prototype = Object.create(Foo.prototype);</code>，调用Object.create(obj)会凭空创建一个新对象并把新对象的[[Prototype]]关联到obj上。</p>\n<p>我们来看看Object.create()的polyfill:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Object</span>.<span class=\"property\">create</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Object</span>.<span class=\"property\">create</span> = <span class=\"keyword\">function</span> (<span class=\"params\">proto, propsObj</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(proto === <span class=\"literal\">null</span> || <span class=\"keyword\">typeof</span> proto === <span class=\"string\">&#x27;object&#x27;</span> || <span class=\"keyword\">typeof</span> proto === <span class=\"string\">&#x27;function&#x27;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"title class_\">TypeError</span>(<span class=\"string\">&#x27;Arguments must be object, or Null&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> temp = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    temp.<span class=\"property\">__proto__</span> = proto;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propsObj) &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(temp, propsObj);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有的人可能会说，为什么不能直接<code>Bar.prototype = Foo.prototype;</code>呢？这样并不会创建一个关联到Foo.prototype的新对象，只是让Bar.prototype引用Foo.prototype对象，我们执行<code>Bar.prototype.getType = ....</code>也会在Foo.prototype上修改，跟预料的结果不一样。那这样根本不需要Bar，还不如直接在Foo上修改就好了。</p>\n<p>而之前介绍的<code>Bar.prototype = new Foo()</code>虽然也能实现原型继承，但它会有一些副作用。比如Foo如果有（写日志、修改状态、注册到其他对象、给this添加属性等等）的行为，就会影响到Bar的子类，造成无法预料的结果。</p>\n<p>所以，要创建一个关联的“子类”对象，我们必须使用Object.create()，但这样有一个缺点是要创建一个新对象而把旧对象抛弃。</p>\n<p>好在ES6添加了<code>Object.setPrototypeOf(...)</code>方法，可以修改关联。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"title class_\">Object</span>.<span class=\"title function_\">create</span>(<span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// ES6之前需要抛弃默认对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">setPrototypeOf</span>(<span class=\"title class_\">Bar</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>, <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>); <span class=\"comment\">// ES6可以直接修改Bar.prototype对象</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"检查“类”的关系\"><a href=\"#检查“类”的关系\" class=\"headerlink\" title=\"检查“类”的关系\"></a>检查“类”的关系</h1><p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">blah</span> = ...;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Foo</span>();</span><br></pre></td></tr></table></figure>\n<p>我们如果想要判断a的原型是否与Foo关联起来了，我们可以有以下几种方法：</p>\n<h2 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Foo</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>但这样有个缺点是只能处理对象和函数之间的关系。如果我们想判断两个对象之间是否通过[[Prototype]]关联。可以用下列方法：</p>\n<h2 id=\"isPrototypeOf-NaN\"><a href=\"#isPrototypeOf-NaN\" class=\"headerlink\" title=\"isPrototypeOf()\"></a>isPrototypeOf()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(a); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>要判断两个对象之间的关系，更直接：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b.<span class=\"title function_\">isPrototypeOf</span>(c); <span class=\"comment\">// 判断b是否出现在c的原型链中</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Object-getPrototypeOf\"><a href=\"#Object-getPrototypeOf\" class=\"headerlink\" title=\"Object.getPrototypeOf()\"></a>Object.getPrototypeOf()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(a) === <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"proto\"><a href=\"#proto\" class=\"headerlink\" title=\"proto\"></a><strong>proto</strong></h2><p>我们可以直接用非标准的<code>__proto__</code>属性，<code>__proto__</code>实际上存在于内置的Object.prototype中，且不可枚举。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a.<span class=\"property\">__proto__</span> === <span class=\"title class_\">Foo</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>要想创建类似于“类”的对象，可以使用构造函数调用，给构造函数添加公有方法，在构造函数的<code>prototype</code>上添加属性。新对象想要继承构造函数，使用Javascript的原型继承机制。</p>"},{"title":"JS如何设置Cookies","date":"2017-08-12T15:07:55.000Z","_content":"\nCookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。\n<!--more-->\n# 调用浏览器的CookiesAPI\n为了使用浏览器的CookieAPI，我们首先要在[manifest.json](https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json)里设置Cookie`permission`，还要设置`host-permission`确定能获取Cookie的网址。\n\n接下来就是调用CookieAPI方法。\n\n## Cookie.set\n使用`set()`方法添加新的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar setting = browser.cookies.set(\n  details               // object\n)\n```\n`details`是一个对象，其中有可选的几个参数：\n- `url`: 请求Cookie的url\n- `name`: Cookie的名字\n- `value`: Cookie的值\n- `domin`: Cookie的作用域名\n- `path`: Cookie的路径\n- `secure`: Cookie是否安全（true／false）\n- `httpOnly`: Cookie是否只能在http上（true／false）\n- `expirationDate`: Cookie的截止时间，如果没有设置，则Cookie变为Session Cookie\n- `storeId`: 代表Cookie的存储ID\n\n## Cookie.get\n使用`get()`方法获取已有的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar getting = browser.cookies.get(\n  details               // object\n)\n```\n`details`可选的参数有：`url`、`name`、`storeId`。\n\n## Cookie.getAll\n使用`getAll()`方法获取Cookie集合中所有匹配details的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar getting = browser.cookies.getAll(\n  details               // object\n)\n```\n`details`可选的参数有：`url`、`name`、`domain`、`path`、`secure`、`session`、`storeId`。其中`session`是bool值，代表是否要从cookies中过滤掉session cookie。\n\n## Cookie.remove\n使用`remove()`方法移除已有的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar removing = browser.cookies.remove(\n  details               // object\n)\n```\n`details`可选的参数有：`url`、`name`、`storeId`。\n\n## Cookie.getAllCookieStores\n使用`getAllCookieStores()`方法获取所有的Cookie集合，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar gettingStores = browser.cookies.getAllCookieStores();\n```\n返回的`Promise`对象中包含的数据是包括所有cookiestore对象的数组。举个例子：\n```javascript\nfunction logStores(cookieStores) {\n  for(store of cookieStores) {\n    console.log(`Cookie store: ${store.id}\\n Tab IDs: ${store.tabIds}`);\n  }\n}\n\nvar getting = browser.cookies.getAllCookieStores();\ngetting.then(logStores);\n```\n\n## Cookie.onChanged事件\n当Cookie改变时，我们可以为它设置onChanged事件：\n```javascript\nbrowser.cookies.onChanged.addListener(callback)\nbrowser.cookies.onChanged.removeListener(listener)\nbrowser.cookies.onChanged.hasListener(listener)\n```\n其中 `addListener`接受一个callback，callback有一个参数`changeInfo`，`changeInfo`有三个属性：\n  - removed：bool值，代表cookie是否移除\n  - cookie：包含添加或移除信息的cookie对象\n  - cause：Cookie改变的原因\n\n---\n\n# 使用document.cookie\nCookie的结构很简单，就是键-值对，一般是以`key-value;expiration_date;path;domain;`的顺序。\n\n最简单的设置当前页面Cookie的方法就是直接给`document.cookie`赋值，例如：`document.cookie = \"username=Simon, 12 Aug 2017 19:36:00 GMT; expires=Wed, 31 Oct 2017 11:00:00 GMT;\";`，这样就设置了Cookie。但每次都这样设置很麻烦，我们可以用函数封装赋值方法。这里借鉴了网上的一些方法：\n\n## setCookie()\n```javascript\nfunction setCookie(name, value, expires, path, domain) {\n  var cookie = name + \"=\" + encodeURIComponent(value) + \";\";\n\n  if (expires) {\n    // If it's a date\n    if(expires instanceof Date) {\n      // If it isn't a valid date\n      if (isNaN(expires.getTime()))\n       expires = new Date();\n    } else {\n      expires = new Date(new Date().getTime() + parseInt(expires) * 1000 * 60 * 60 * 24);\n    }\n    cookie += \"expires=\" + expires.toGMTString() + \";\";\n  }\n\n  if (path) {\n    cookie += \"path=\" + path + \";\";\n  }\n  if (domain) {\n    cookie += \"domain=\" + domain + \";\";\n  }\n  document.cookie = cookie;\n}\n```\n这里的`expires`可以是`Date`对象，也可以是代表天数的数字。\n\n要创建新的Cookie，可以这样：`setCookie(\"website\", \"xmflyrk.com\", new Date(new Date().getTime() + 10000));` 或者 `setCookie(\"author\", \"flyrk\", 30);`\n\n## getCookie()\n```javascript\nfunction getCookie(name) {\n  var cok = document.cookie.split(';'),\n        length = cok.length;\n  for (var i = 0; i < length; i++) {\n    var pairs = cok[i].trim();\n    if (~pairs.indexOf(name)) {\n      return pairs.substring(pairs.indexOf(name) + name.length + 1);\n    }\n  }\n  return null;\n}\n```\n调用`getCookie()`的例子：\n```javascript\ngetCookie('author'); // \"flyrk\"\ngetCookie('Something'); // null\n```\n\n## removeCookie()\n```javascript\nfunction removeCookie(name, path, domin) {\n  if (getCookie(name)) {\n    setCookie(name, \"\", -1, path, domin);\n  }\n}\n```\n删除某个Cookie我们就可以这样：\n```javascript\nremoveCookie(\"author\");\nconsole.log(getCookie(\"author\")); //null\n```\n\n---\n\n# 总结\n有了这些API和自己封装的函数，我们就能对Cookie进行操作，方便地设置Cookie数据。\n\n> 参考资料：\n> [cookies](https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies)\n> [How to deal with cookie](https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/)\n","source":"_posts/2017-08-12-how-to-set-cookie-in-js.md","raw":"---\ntitle: JS如何设置Cookies\ndate: 2017-08-12 23:07:55\ncategories:\n- 网络\ntags:\n- Cookies\n---\n\nCookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。\n<!--more-->\n# 调用浏览器的CookiesAPI\n为了使用浏览器的CookieAPI，我们首先要在[manifest.json](https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json)里设置Cookie`permission`，还要设置`host-permission`确定能获取Cookie的网址。\n\n接下来就是调用CookieAPI方法。\n\n## Cookie.set\n使用`set()`方法添加新的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar setting = browser.cookies.set(\n  details               // object\n)\n```\n`details`是一个对象，其中有可选的几个参数：\n- `url`: 请求Cookie的url\n- `name`: Cookie的名字\n- `value`: Cookie的值\n- `domin`: Cookie的作用域名\n- `path`: Cookie的路径\n- `secure`: Cookie是否安全（true／false）\n- `httpOnly`: Cookie是否只能在http上（true／false）\n- `expirationDate`: Cookie的截止时间，如果没有设置，则Cookie变为Session Cookie\n- `storeId`: 代表Cookie的存储ID\n\n## Cookie.get\n使用`get()`方法获取已有的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar getting = browser.cookies.get(\n  details               // object\n)\n```\n`details`可选的参数有：`url`、`name`、`storeId`。\n\n## Cookie.getAll\n使用`getAll()`方法获取Cookie集合中所有匹配details的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar getting = browser.cookies.getAll(\n  details               // object\n)\n```\n`details`可选的参数有：`url`、`name`、`domain`、`path`、`secure`、`session`、`storeId`。其中`session`是bool值，代表是否要从cookies中过滤掉session cookie。\n\n## Cookie.remove\n使用`remove()`方法移除已有的Cookie，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar removing = browser.cookies.remove(\n  details               // object\n)\n```\n`details`可选的参数有：`url`、`name`、`storeId`。\n\n## Cookie.getAllCookieStores\n使用`getAllCookieStores()`方法获取所有的Cookie集合，返回的是一个`Promise`对象。语法如下：\n```javascript\nvar gettingStores = browser.cookies.getAllCookieStores();\n```\n返回的`Promise`对象中包含的数据是包括所有cookiestore对象的数组。举个例子：\n```javascript\nfunction logStores(cookieStores) {\n  for(store of cookieStores) {\n    console.log(`Cookie store: ${store.id}\\n Tab IDs: ${store.tabIds}`);\n  }\n}\n\nvar getting = browser.cookies.getAllCookieStores();\ngetting.then(logStores);\n```\n\n## Cookie.onChanged事件\n当Cookie改变时，我们可以为它设置onChanged事件：\n```javascript\nbrowser.cookies.onChanged.addListener(callback)\nbrowser.cookies.onChanged.removeListener(listener)\nbrowser.cookies.onChanged.hasListener(listener)\n```\n其中 `addListener`接受一个callback，callback有一个参数`changeInfo`，`changeInfo`有三个属性：\n  - removed：bool值，代表cookie是否移除\n  - cookie：包含添加或移除信息的cookie对象\n  - cause：Cookie改变的原因\n\n---\n\n# 使用document.cookie\nCookie的结构很简单，就是键-值对，一般是以`key-value;expiration_date;path;domain;`的顺序。\n\n最简单的设置当前页面Cookie的方法就是直接给`document.cookie`赋值，例如：`document.cookie = \"username=Simon, 12 Aug 2017 19:36:00 GMT; expires=Wed, 31 Oct 2017 11:00:00 GMT;\";`，这样就设置了Cookie。但每次都这样设置很麻烦，我们可以用函数封装赋值方法。这里借鉴了网上的一些方法：\n\n## setCookie()\n```javascript\nfunction setCookie(name, value, expires, path, domain) {\n  var cookie = name + \"=\" + encodeURIComponent(value) + \";\";\n\n  if (expires) {\n    // If it's a date\n    if(expires instanceof Date) {\n      // If it isn't a valid date\n      if (isNaN(expires.getTime()))\n       expires = new Date();\n    } else {\n      expires = new Date(new Date().getTime() + parseInt(expires) * 1000 * 60 * 60 * 24);\n    }\n    cookie += \"expires=\" + expires.toGMTString() + \";\";\n  }\n\n  if (path) {\n    cookie += \"path=\" + path + \";\";\n  }\n  if (domain) {\n    cookie += \"domain=\" + domain + \";\";\n  }\n  document.cookie = cookie;\n}\n```\n这里的`expires`可以是`Date`对象，也可以是代表天数的数字。\n\n要创建新的Cookie，可以这样：`setCookie(\"website\", \"xmflyrk.com\", new Date(new Date().getTime() + 10000));` 或者 `setCookie(\"author\", \"flyrk\", 30);`\n\n## getCookie()\n```javascript\nfunction getCookie(name) {\n  var cok = document.cookie.split(';'),\n        length = cok.length;\n  for (var i = 0; i < length; i++) {\n    var pairs = cok[i].trim();\n    if (~pairs.indexOf(name)) {\n      return pairs.substring(pairs.indexOf(name) + name.length + 1);\n    }\n  }\n  return null;\n}\n```\n调用`getCookie()`的例子：\n```javascript\ngetCookie('author'); // \"flyrk\"\ngetCookie('Something'); // null\n```\n\n## removeCookie()\n```javascript\nfunction removeCookie(name, path, domin) {\n  if (getCookie(name)) {\n    setCookie(name, \"\", -1, path, domin);\n  }\n}\n```\n删除某个Cookie我们就可以这样：\n```javascript\nremoveCookie(\"author\");\nconsole.log(getCookie(\"author\")); //null\n```\n\n---\n\n# 总结\n有了这些API和自己封装的函数，我们就能对Cookie进行操作，方便地设置Cookie数据。\n\n> 参考资料：\n> [cookies](https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies)\n> [How to deal with cookie](https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/)\n","slug":"how-to-set-cookie-in-js","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cv001sra4k5efca4x5","content":"<p>Cookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。</p>\n<span id=\"more\"></span>\n<h1 id=\"调用浏览器的CookiesAPI\"><a href=\"#调用浏览器的CookiesAPI\" class=\"headerlink\" title=\"调用浏览器的CookiesAPI\"></a>调用浏览器的CookiesAPI</h1><p>为了使用浏览器的CookieAPI，我们首先要在<a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json\">manifest.json</a>里设置Cookie<code>permission</code>，还要设置<code>host-permission</code>确定能获取Cookie的网址。</p>\n<p>接下来就是调用CookieAPI方法。</p>\n<h2 id=\"Cookie-set\"><a href=\"#Cookie-set\" class=\"headerlink\" title=\"Cookie.set\"></a>Cookie.set</h2><p>使用<code>set()</code>方法添加新的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> setting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">set</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>是一个对象，其中有可选的几个参数：</p>\n<ul>\n<li><code>url</code>: 请求Cookie的url</li>\n<li><code>name</code>: Cookie的名字</li>\n<li><code>value</code>: Cookie的值</li>\n<li><code>domin</code>: Cookie的作用域名</li>\n<li><code>path</code>: Cookie的路径</li>\n<li><code>secure</code>: Cookie是否安全（true／false）</li>\n<li><code>httpOnly</code>: Cookie是否只能在http上（true／false）</li>\n<li><code>expirationDate</code>: Cookie的截止时间，如果没有设置，则Cookie变为Session Cookie</li>\n<li><code>storeId</code>: 代表Cookie的存储ID</li>\n</ul>\n<h2 id=\"Cookie-get\"><a href=\"#Cookie-get\" class=\"headerlink\" title=\"Cookie.get\"></a>Cookie.get</h2><p>使用<code>get()</code>方法获取已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">get</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p>\n<h2 id=\"Cookie-getAll\"><a href=\"#Cookie-getAll\" class=\"headerlink\" title=\"Cookie.getAll\"></a>Cookie.getAll</h2><p>使用<code>getAll()</code>方法获取Cookie集合中所有匹配details的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">getAll</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>session</code>、<code>storeId</code>。其中<code>session</code>是bool值，代表是否要从cookies中过滤掉session cookie。</p>\n<h2 id=\"Cookie-remove\"><a href=\"#Cookie-remove\" class=\"headerlink\" title=\"Cookie.remove\"></a>Cookie.remove</h2><p>使用<code>remove()</code>方法移除已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> removing = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">remove</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p>\n<h2 id=\"Cookie-getAllCookieStores\"><a href=\"#Cookie-getAllCookieStores\" class=\"headerlink\" title=\"Cookie.getAllCookieStores\"></a>Cookie.getAllCookieStores</h2><p>使用<code>getAllCookieStores()</code>方法获取所有的Cookie集合，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gettingStores = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">getAllCookieStores</span>();</span><br></pre></td></tr></table></figure>\n<p>返回的<code>Promise</code>对象中包含的数据是包括所有cookiestore对象的数组。举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logStores</span>(<span class=\"params\">cookieStores</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(store <span class=\"keyword\">of</span> cookieStores) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Cookie store: <span class=\"subst\">$&#123;store.id&#125;</span>\\n Tab IDs: <span class=\"subst\">$&#123;store.tabIds&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">getAllCookieStores</span>();</span><br><span class=\"line\">getting.<span class=\"title function_\">then</span>(logStores);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cookie-onChanged事件\"><a href=\"#Cookie-onChanged事件\" class=\"headerlink\" title=\"Cookie.onChanged事件\"></a>Cookie.onChanged事件</h2><p>当Cookie改变时，我们可以为它设置onChanged事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browser.<span class=\"property\">cookies</span>.<span class=\"property\">onChanged</span>.<span class=\"title function_\">addListener</span>(callback)</span><br><span class=\"line\">browser.<span class=\"property\">cookies</span>.<span class=\"property\">onChanged</span>.<span class=\"title function_\">removeListener</span>(listener)</span><br><span class=\"line\">browser.<span class=\"property\">cookies</span>.<span class=\"property\">onChanged</span>.<span class=\"title function_\">hasListener</span>(listener)</span><br></pre></td></tr></table></figure>\n<p>其中 <code>addListener</code>接受一个callback，callback有一个参数<code>changeInfo</code>，<code>changeInfo</code>有三个属性：</p>\n<ul>\n<li>removed：bool值，代表cookie是否移除</li>\n<li>cookie：包含添加或移除信息的cookie对象</li>\n<li>cause：Cookie改变的原因</li>\n</ul>\n<hr>\n<h1 id=\"使用document-cookie\"><a href=\"#使用document-cookie\" class=\"headerlink\" title=\"使用document.cookie\"></a>使用document.cookie</h1><p>Cookie的结构很简单，就是键-值对，一般是以<code>key-value;expiration_date;path;domain;</code>的顺序。</p>\n<p>最简单的设置当前页面Cookie的方法就是直接给<code>document.cookie</code>赋值，例如：<code>document.cookie = &quot;username=Simon, 12 Aug 2017 19:36:00 GMT; expires=Wed, 31 Oct 2017 11:00:00 GMT;&quot;;</code>，这样就设置了Cookie。但每次都这样设置很麻烦，我们可以用函数封装赋值方法。这里借鉴了网上的一些方法：</p>\n<h2 id=\"setCookie\"><a href=\"#setCookie\" class=\"headerlink\" title=\"setCookie()\"></a>setCookie()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setCookie</span>(<span class=\"params\">name, value, expires, path, domain</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cookie = name + <span class=\"string\">&quot;=&quot;</span> + <span class=\"built_in\">encodeURIComponent</span>(value) + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (expires) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If it&#x27;s a date</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(expires <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Date</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If it isn&#x27;t a valid date</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(expires.<span class=\"title function_\">getTime</span>()))</span><br><span class=\"line\">       expires = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      expires = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() + <span class=\"built_in\">parseInt</span>(expires) * <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cookie += <span class=\"string\">&quot;expires=&quot;</span> + expires.<span class=\"title function_\">toGMTString</span>() + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path) &#123;</span><br><span class=\"line\">    cookie += <span class=\"string\">&quot;path=&quot;</span> + path + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (domain) &#123;</span><br><span class=\"line\">    cookie += <span class=\"string\">&quot;domain=&quot;</span> + domain + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span> = cookie;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>expires</code>可以是<code>Date</code>对象，也可以是代表天数的数字。</p>\n<p>要创建新的Cookie，可以这样：<code>setCookie(&quot;website&quot;, &quot;xmflyrk.com&quot;, new Date(new Date().getTime() + 10000));</code> 或者 <code>setCookie(&quot;author&quot;, &quot;flyrk&quot;, 30);</code></p>\n<h2 id=\"getCookie\"><a href=\"#getCookie\" class=\"headerlink\" title=\"getCookie()\"></a>getCookie()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getCookie</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cok = <span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;;&#x27;</span>),</span><br><span class=\"line\">        length = cok.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pairs = cok[i].<span class=\"title function_\">trim</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (~pairs.<span class=\"title function_\">indexOf</span>(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pairs.<span class=\"title function_\">substring</span>(pairs.<span class=\"title function_\">indexOf</span>(name) + name.<span class=\"property\">length</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>getCookie()</code>的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">getCookie</span>(<span class=\"string\">&#x27;author&#x27;</span>); <span class=\"comment\">// &quot;flyrk&quot;</span></span><br><span class=\"line\"><span class=\"title function_\">getCookie</span>(<span class=\"string\">&#x27;Something&#x27;</span>); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"removeCookie\"><a href=\"#removeCookie\" class=\"headerlink\" title=\"removeCookie()\"></a>removeCookie()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeCookie</span>(<span class=\"params\">name, path, domin</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">getCookie</span>(name)) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCookie</span>(name, <span class=\"string\">&quot;&quot;</span>, -<span class=\"number\">1</span>, path, domin);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>删除某个Cookie我们就可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">removeCookie</span>(<span class=\"string\">&quot;author&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getCookie</span>(<span class=\"string\">&quot;author&quot;</span>)); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>有了这些API和自己封装的函数，我们就能对Cookie进行操作，方便地设置Cookie数据。</p>\n<blockquote>\n<p>参考资料：<br><a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies\">cookies</a><br><a href=\"https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/\">How to deal with cookie</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Cookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。</p>","more":"<h1 id=\"调用浏览器的CookiesAPI\"><a href=\"#调用浏览器的CookiesAPI\" class=\"headerlink\" title=\"调用浏览器的CookiesAPI\"></a>调用浏览器的CookiesAPI</h1><p>为了使用浏览器的CookieAPI，我们首先要在<a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json\">manifest.json</a>里设置Cookie<code>permission</code>，还要设置<code>host-permission</code>确定能获取Cookie的网址。</p>\n<p>接下来就是调用CookieAPI方法。</p>\n<h2 id=\"Cookie-set\"><a href=\"#Cookie-set\" class=\"headerlink\" title=\"Cookie.set\"></a>Cookie.set</h2><p>使用<code>set()</code>方法添加新的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> setting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">set</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>是一个对象，其中有可选的几个参数：</p>\n<ul>\n<li><code>url</code>: 请求Cookie的url</li>\n<li><code>name</code>: Cookie的名字</li>\n<li><code>value</code>: Cookie的值</li>\n<li><code>domin</code>: Cookie的作用域名</li>\n<li><code>path</code>: Cookie的路径</li>\n<li><code>secure</code>: Cookie是否安全（true／false）</li>\n<li><code>httpOnly</code>: Cookie是否只能在http上（true／false）</li>\n<li><code>expirationDate</code>: Cookie的截止时间，如果没有设置，则Cookie变为Session Cookie</li>\n<li><code>storeId</code>: 代表Cookie的存储ID</li>\n</ul>\n<h2 id=\"Cookie-get\"><a href=\"#Cookie-get\" class=\"headerlink\" title=\"Cookie.get\"></a>Cookie.get</h2><p>使用<code>get()</code>方法获取已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">get</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p>\n<h2 id=\"Cookie-getAll\"><a href=\"#Cookie-getAll\" class=\"headerlink\" title=\"Cookie.getAll\"></a>Cookie.getAll</h2><p>使用<code>getAll()</code>方法获取Cookie集合中所有匹配details的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">getAll</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>session</code>、<code>storeId</code>。其中<code>session</code>是bool值，代表是否要从cookies中过滤掉session cookie。</p>\n<h2 id=\"Cookie-remove\"><a href=\"#Cookie-remove\" class=\"headerlink\" title=\"Cookie.remove\"></a>Cookie.remove</h2><p>使用<code>remove()</code>方法移除已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> removing = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">remove</span>(</span><br><span class=\"line\">  details               <span class=\"comment\">// object</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p>\n<h2 id=\"Cookie-getAllCookieStores\"><a href=\"#Cookie-getAllCookieStores\" class=\"headerlink\" title=\"Cookie.getAllCookieStores\"></a>Cookie.getAllCookieStores</h2><p>使用<code>getAllCookieStores()</code>方法获取所有的Cookie集合，返回的是一个<code>Promise</code>对象。语法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gettingStores = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">getAllCookieStores</span>();</span><br></pre></td></tr></table></figure>\n<p>返回的<code>Promise</code>对象中包含的数据是包括所有cookiestore对象的数组。举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logStores</span>(<span class=\"params\">cookieStores</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(store <span class=\"keyword\">of</span> cookieStores) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Cookie store: <span class=\"subst\">$&#123;store.id&#125;</span>\\n Tab IDs: <span class=\"subst\">$&#123;store.tabIds&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getting = browser.<span class=\"property\">cookies</span>.<span class=\"title function_\">getAllCookieStores</span>();</span><br><span class=\"line\">getting.<span class=\"title function_\">then</span>(logStores);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Cookie-onChanged事件\"><a href=\"#Cookie-onChanged事件\" class=\"headerlink\" title=\"Cookie.onChanged事件\"></a>Cookie.onChanged事件</h2><p>当Cookie改变时，我们可以为它设置onChanged事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">browser.<span class=\"property\">cookies</span>.<span class=\"property\">onChanged</span>.<span class=\"title function_\">addListener</span>(callback)</span><br><span class=\"line\">browser.<span class=\"property\">cookies</span>.<span class=\"property\">onChanged</span>.<span class=\"title function_\">removeListener</span>(listener)</span><br><span class=\"line\">browser.<span class=\"property\">cookies</span>.<span class=\"property\">onChanged</span>.<span class=\"title function_\">hasListener</span>(listener)</span><br></pre></td></tr></table></figure>\n<p>其中 <code>addListener</code>接受一个callback，callback有一个参数<code>changeInfo</code>，<code>changeInfo</code>有三个属性：</p>\n<ul>\n<li>removed：bool值，代表cookie是否移除</li>\n<li>cookie：包含添加或移除信息的cookie对象</li>\n<li>cause：Cookie改变的原因</li>\n</ul>\n<hr>\n<h1 id=\"使用document-cookie\"><a href=\"#使用document-cookie\" class=\"headerlink\" title=\"使用document.cookie\"></a>使用document.cookie</h1><p>Cookie的结构很简单，就是键-值对，一般是以<code>key-value;expiration_date;path;domain;</code>的顺序。</p>\n<p>最简单的设置当前页面Cookie的方法就是直接给<code>document.cookie</code>赋值，例如：<code>document.cookie = &quot;username=Simon, 12 Aug 2017 19:36:00 GMT; expires=Wed, 31 Oct 2017 11:00:00 GMT;&quot;;</code>，这样就设置了Cookie。但每次都这样设置很麻烦，我们可以用函数封装赋值方法。这里借鉴了网上的一些方法：</p>\n<h2 id=\"setCookie\"><a href=\"#setCookie\" class=\"headerlink\" title=\"setCookie()\"></a>setCookie()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setCookie</span>(<span class=\"params\">name, value, expires, path, domain</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cookie = name + <span class=\"string\">&quot;=&quot;</span> + <span class=\"built_in\">encodeURIComponent</span>(value) + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (expires) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If it&#x27;s a date</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(expires <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Date</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If it isn&#x27;t a valid date</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(expires.<span class=\"title function_\">getTime</span>()))</span><br><span class=\"line\">       expires = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      expires = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">getTime</span>() + <span class=\"built_in\">parseInt</span>(expires) * <span class=\"number\">1000</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cookie += <span class=\"string\">&quot;expires=&quot;</span> + expires.<span class=\"title function_\">toGMTString</span>() + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (path) &#123;</span><br><span class=\"line\">    cookie += <span class=\"string\">&quot;path=&quot;</span> + path + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (domain) &#123;</span><br><span class=\"line\">    cookie += <span class=\"string\">&quot;domain=&quot;</span> + domain + <span class=\"string\">&quot;;&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span> = cookie;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>expires</code>可以是<code>Date</code>对象，也可以是代表天数的数字。</p>\n<p>要创建新的Cookie，可以这样：<code>setCookie(&quot;website&quot;, &quot;xmflyrk.com&quot;, new Date(new Date().getTime() + 10000));</code> 或者 <code>setCookie(&quot;author&quot;, &quot;flyrk&quot;, 30);</code></p>\n<h2 id=\"getCookie\"><a href=\"#getCookie\" class=\"headerlink\" title=\"getCookie()\"></a>getCookie()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getCookie</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cok = <span class=\"variable language_\">document</span>.<span class=\"property\">cookie</span>.<span class=\"title function_\">split</span>(<span class=\"string\">&#x27;;&#x27;</span>),</span><br><span class=\"line\">        length = cok.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pairs = cok[i].<span class=\"title function_\">trim</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (~pairs.<span class=\"title function_\">indexOf</span>(name)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> pairs.<span class=\"title function_\">substring</span>(pairs.<span class=\"title function_\">indexOf</span>(name) + name.<span class=\"property\">length</span> + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>getCookie()</code>的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">getCookie</span>(<span class=\"string\">&#x27;author&#x27;</span>); <span class=\"comment\">// &quot;flyrk&quot;</span></span><br><span class=\"line\"><span class=\"title function_\">getCookie</span>(<span class=\"string\">&#x27;Something&#x27;</span>); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"removeCookie\"><a href=\"#removeCookie\" class=\"headerlink\" title=\"removeCookie()\"></a>removeCookie()</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">removeCookie</span>(<span class=\"params\">name, path, domin</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"title function_\">getCookie</span>(name)) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setCookie</span>(name, <span class=\"string\">&quot;&quot;</span>, -<span class=\"number\">1</span>, path, domin);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>删除某个Cookie我们就可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">removeCookie</span>(<span class=\"string\">&quot;author&quot;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getCookie</span>(<span class=\"string\">&quot;author&quot;</span>)); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>有了这些API和自己封装的函数，我们就能对Cookie进行操作，方便地设置Cookie数据。</p>\n<blockquote>\n<p>参考资料：<br><a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies\">cookies</a><br><a href=\"https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/\">How to deal with cookie</a></p>\n</blockquote>"},{"title":"从Atom转战VSCode","date":"2017-08-20T13:24:01.000Z","_content":"\n最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。\n<!--more-->\n\n刚开始用Atom感觉的确很清爽，各种插件用得飞起。然后随着插件的增多，和项目大小的提升，感觉Atom越来越卡，打开一个文件也要很久，那种流畅感没有了。于是有了\b换编辑器的想法。毕竟“工欲善其事，必先利其器”，写代码还是想要一个用起来顺手的编辑器，写的时候心情都会舒畅点（可能这是个人癖好。。。真正重要的当然还是代码本身）。\n\n正好最近半年来VSCode越来越火，许多人都开始用它，\b群里一些大佬也在用VSCode，于是我就下了一个瞧瞧。\n\n说实话，打开速度比Atom快的真不是一点半点，即使装了一些插件后打开速度也还是很快。而且VSCode由于逐渐发展起来，插件也越来越丰富，一点也不输给Sublime和Atom，常用的插件应有尽有。\b\n\n用了VSCode后最大感受就是写代码变得舒服了。VSCode的代码高亮和Git操作真的很赞！鼠标悬停在某个函数或者属性上时还会有相应的说明，Git的操作也比Atom更可视化，一目了然。\n\n总之，转战VSCode后并没有什么不适应，反而更加得心应手。当然不是说Atom不好了，一切都只是个人习惯问题罢了。但不得不说，VSCode绝对是编程利器。\n\n最后，\b推荐一些常用的插件：\n- Beautify\n- ESLint\n- One Dark Pro\n- vscode-icons\n- IntelliSense for CSS\n- Git Lens\n- ES7 React/Redux/React-Native/JS snippets\n- Path Intellisense\n","source":"_posts/2017-08-20-changing-IDE-to-VSCODE.md","raw":"---\ntitle: 从Atom转战VSCode\ndate: 2017-08-20 21:24:01\ncategories:\n- 工具\ntags:\n- VSCode\n---\n\n最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。\n<!--more-->\n\n刚开始用Atom感觉的确很清爽，各种插件用得飞起。然后随着插件的增多，和项目大小的提升，感觉Atom越来越卡，打开一个文件也要很久，那种流畅感没有了。于是有了\b换编辑器的想法。毕竟“工欲善其事，必先利其器”，写代码还是想要一个用起来顺手的编辑器，写的时候心情都会舒畅点（可能这是个人癖好。。。真正重要的当然还是代码本身）。\n\n正好最近半年来VSCode越来越火，许多人都开始用它，\b群里一些大佬也在用VSCode，于是我就下了一个瞧瞧。\n\n说实话，打开速度比Atom快的真不是一点半点，即使装了一些插件后打开速度也还是很快。而且VSCode由于逐渐发展起来，插件也越来越丰富，一点也不输给Sublime和Atom，常用的插件应有尽有。\b\n\n用了VSCode后最大感受就是写代码变得舒服了。VSCode的代码高亮和Git操作真的很赞！鼠标悬停在某个函数或者属性上时还会有相应的说明，Git的操作也比Atom更可视化，一目了然。\n\n总之，转战VSCode后并没有什么不适应，反而更加得心应手。当然不是说Atom不好了，一切都只是个人习惯问题罢了。但不得不说，VSCode绝对是编程利器。\n\n最后，\b推荐一些常用的插件：\n- Beautify\n- ESLint\n- One Dark Pro\n- vscode-icons\n- IntelliSense for CSS\n- Git Lens\n- ES7 React/Redux/React-Native/JS snippets\n- Path Intellisense\n","slug":"changing-IDE-to-VSCODE","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cx001wra4kb75452z6","content":"<p>最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。</p>\n<span id=\"more\"></span>\n\n<p>刚开始用Atom感觉的确很清爽，各种插件用得飞起。然后随着插件的增多，和项目大小的提升，感觉Atom越来越卡，打开一个文件也要很久，那种流畅感没有了。于是有了\b换编辑器的想法。毕竟“工欲善其事，必先利其器”，写代码还是想要一个用起来顺手的编辑器，写的时候心情都会舒畅点（可能这是个人癖好。。。真正重要的当然还是代码本身）。</p>\n<p>正好最近半年来VSCode越来越火，许多人都开始用它，\b群里一些大佬也在用VSCode，于是我就下了一个瞧瞧。</p>\n<p>说实话，打开速度比Atom快的真不是一点半点，即使装了一些插件后打开速度也还是很快。而且VSCode由于逐渐发展起来，插件也越来越丰富，一点也不输给Sublime和Atom，常用的插件应有尽有。\b</p>\n<p>用了VSCode后最大感受就是写代码变得舒服了。VSCode的代码高亮和Git操作真的很赞！鼠标悬停在某个函数或者属性上时还会有相应的说明，Git的操作也比Atom更可视化，一目了然。</p>\n<p>总之，转战VSCode后并没有什么不适应，反而更加得心应手。当然不是说Atom不好了，一切都只是个人习惯问题罢了。但不得不说，VSCode绝对是编程利器。</p>\n<p>最后，\b推荐一些常用的插件：</p>\n<ul>\n<li>Beautify</li>\n<li>ESLint</li>\n<li>One Dark Pro</li>\n<li>vscode-icons</li>\n<li>IntelliSense for CSS</li>\n<li>Git Lens</li>\n<li>ES7 React&#x2F;Redux&#x2F;React-Native&#x2F;JS snippets</li>\n<li>Path Intellisense</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。</p>","more":"<p>刚开始用Atom感觉的确很清爽，各种插件用得飞起。然后随着插件的增多，和项目大小的提升，感觉Atom越来越卡，打开一个文件也要很久，那种流畅感没有了。于是有了\b换编辑器的想法。毕竟“工欲善其事，必先利其器”，写代码还是想要一个用起来顺手的编辑器，写的时候心情都会舒畅点（可能这是个人癖好。。。真正重要的当然还是代码本身）。</p>\n<p>正好最近半年来VSCode越来越火，许多人都开始用它，\b群里一些大佬也在用VSCode，于是我就下了一个瞧瞧。</p>\n<p>说实话，打开速度比Atom快的真不是一点半点，即使装了一些插件后打开速度也还是很快。而且VSCode由于逐渐发展起来，插件也越来越丰富，一点也不输给Sublime和Atom，常用的插件应有尽有。\b</p>\n<p>用了VSCode后最大感受就是写代码变得舒服了。VSCode的代码高亮和Git操作真的很赞！鼠标悬停在某个函数或者属性上时还会有相应的说明，Git的操作也比Atom更可视化，一目了然。</p>\n<p>总之，转战VSCode后并没有什么不适应，反而更加得心应手。当然不是说Atom不好了，一切都只是个人习惯问题罢了。但不得不说，VSCode绝对是编程利器。</p>\n<p>最后，\b推荐一些常用的插件：</p>\n<ul>\n<li>Beautify</li>\n<li>ESLint</li>\n<li>One Dark Pro</li>\n<li>vscode-icons</li>\n<li>IntelliSense for CSS</li>\n<li>Git Lens</li>\n<li>ES7 React&#x2F;Redux&#x2F;React-Native&#x2F;JS snippets</li>\n<li>Path Intellisense</li>\n</ul>"},{"title":"原生JS实现回到顶部的效果","date":"2017-08-22T06:31:45.000Z","_content":"\n我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？\n<!--more-->\n# JS实现滚动\n其实很简单，利用下列函数就可以实现：\n```javascript\n/*\n * func: 实现页面滚动到顶部的效果，\n * 离顶部越近滚动速度越慢\n * @acceleration: 滑动的加速度\n * @time: 延迟时间 \n */\nfunction goTop(acceleration, time) {\n  let xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0,   // 获取水平滚动坐标\n      yScroll = document.documentElement.scrollTop ||document.body.scrollTop || window.scrollTop || 0,  // 获取垂直滚动坐标\n      speed = 1 + acceleration; // 滚动速度\n\n  window.scrollTo(Math.floor(xScroll / speed), Math.floor(yScroll / speed)); // 屏幕滚动到某个坐标，因为speed大于1，所以x、y轴的坐标越来越小\n\n  \n  if (xScroll > 0 || yScroll > 0) { // 如果没有滚动到顶部就设置延迟time后继续滚动\n      setTimeout(() => {\n          goTop(acceleration, time);\n      }, time);\n  }\n}\n```\n\n在 *返回顶部* 的按钮上绑定`onClick=\"goTop();\"`就可以实现返回顶部操作。\n\n这里用到了`xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0;`，其实这三个值的效果都差不多，都代表滚动条水平移动的像素，只是浏览器兼容性可能有所不同，所以这样写兼容性更好。\n\n然后就是`window.scrollTo(x, y)`方法。该方法使当前窗口滚动到指定的x、y像素坐标。之所以除以speed，这样就以一定的速度慢慢减小，达到缓慢的动画效果。\n\n之后判断如果滚动条距离顶部还有一段距离的话，就继续循环调用该函数，并设置一定的延迟时间，以达到平滑滚动的动画效果。这里的`time`值要设置的比较小，超过100就显得比较不自然了。\n\n# 按钮的样式设置\n滚动特效实现了，但一般我们只有当页面发生滚动并且滚动到一定距离时才想要回到顶部，我们希望回到顶部的按钮在一定情况下才出现，于是我们需要设置按钮何时出现。通过在`scroll`事件上绑定函数：\n```javascript\nlet scrollBtn = document.getElementsByClassName('scroll2Top-btn')[0];\n  window.addEventListener('scroll', () => { // 这里用了ES6语法\n    let contentTop = document.documentElement.clientHeight || window.innerHeight, // 获取当前可视窗口的高度\n      scrollTop = document.documentElement.scrollTop || document.body.scrollTop;  // 获取垂直滚动条距离页面顶部的距离\n    \n    if (contentTop < scrollTop) { // 如果可视窗口的高度小于垂直滚动的距离，说明已经向下滚动超过一个可视窗口的距离，也就是说看不到顶部了，于是就设置按钮可见\n      scrollBtn.style.display = \"block\";\n    } else {\n      scrollBtn.style.display = \"none\";\n    }\n  });\n```\n---\n\n通过这两个简单的函数，实现了回到顶部的滚动效果，全部用原生JS编写，简单又实用。","source":"_posts/2017-08-22-scroll-to-top-btn.md","raw":"---\ntitle: 原生JS实现回到顶部的效果\ndate: 2017-08-22 14:31:45\ncategories:\n- JS相关\ntags:\n- JS技巧\n---\n\n我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？\n<!--more-->\n# JS实现滚动\n其实很简单，利用下列函数就可以实现：\n```javascript\n/*\n * func: 实现页面滚动到顶部的效果，\n * 离顶部越近滚动速度越慢\n * @acceleration: 滑动的加速度\n * @time: 延迟时间 \n */\nfunction goTop(acceleration, time) {\n  let xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0,   // 获取水平滚动坐标\n      yScroll = document.documentElement.scrollTop ||document.body.scrollTop || window.scrollTop || 0,  // 获取垂直滚动坐标\n      speed = 1 + acceleration; // 滚动速度\n\n  window.scrollTo(Math.floor(xScroll / speed), Math.floor(yScroll / speed)); // 屏幕滚动到某个坐标，因为speed大于1，所以x、y轴的坐标越来越小\n\n  \n  if (xScroll > 0 || yScroll > 0) { // 如果没有滚动到顶部就设置延迟time后继续滚动\n      setTimeout(() => {\n          goTop(acceleration, time);\n      }, time);\n  }\n}\n```\n\n在 *返回顶部* 的按钮上绑定`onClick=\"goTop();\"`就可以实现返回顶部操作。\n\n这里用到了`xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0;`，其实这三个值的效果都差不多，都代表滚动条水平移动的像素，只是浏览器兼容性可能有所不同，所以这样写兼容性更好。\n\n然后就是`window.scrollTo(x, y)`方法。该方法使当前窗口滚动到指定的x、y像素坐标。之所以除以speed，这样就以一定的速度慢慢减小，达到缓慢的动画效果。\n\n之后判断如果滚动条距离顶部还有一段距离的话，就继续循环调用该函数，并设置一定的延迟时间，以达到平滑滚动的动画效果。这里的`time`值要设置的比较小，超过100就显得比较不自然了。\n\n# 按钮的样式设置\n滚动特效实现了，但一般我们只有当页面发生滚动并且滚动到一定距离时才想要回到顶部，我们希望回到顶部的按钮在一定情况下才出现，于是我们需要设置按钮何时出现。通过在`scroll`事件上绑定函数：\n```javascript\nlet scrollBtn = document.getElementsByClassName('scroll2Top-btn')[0];\n  window.addEventListener('scroll', () => { // 这里用了ES6语法\n    let contentTop = document.documentElement.clientHeight || window.innerHeight, // 获取当前可视窗口的高度\n      scrollTop = document.documentElement.scrollTop || document.body.scrollTop;  // 获取垂直滚动条距离页面顶部的距离\n    \n    if (contentTop < scrollTop) { // 如果可视窗口的高度小于垂直滚动的距离，说明已经向下滚动超过一个可视窗口的距离，也就是说看不到顶部了，于是就设置按钮可见\n      scrollBtn.style.display = \"block\";\n    } else {\n      scrollBtn.style.display = \"none\";\n    }\n  });\n```\n---\n\n通过这两个简单的函数，实现了回到顶部的滚动效果，全部用原生JS编写，简单又实用。","slug":"scroll-to-top-btn","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05cy001zra4kaxhe9y3m","content":"<p>我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？</p>\n<span id=\"more\"></span>\n<h1 id=\"JS实现滚动\"><a href=\"#JS实现滚动\" class=\"headerlink\" title=\"JS实现滚动\"></a>JS实现滚动</h1><p>其实很简单，利用下列函数就可以实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * func: 实现页面滚动到顶部的效果，</span></span><br><span class=\"line\"><span class=\"comment\"> * 离顶部越近滚动速度越慢</span></span><br><span class=\"line\"><span class=\"comment\"> * @acceleration: 滑动的加速度</span></span><br><span class=\"line\"><span class=\"comment\"> * @time: 延迟时间 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">goTop</span>(<span class=\"params\">acceleration, time</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xScroll = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollLeft</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollLeft</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">scrollLeft</span> || <span class=\"number\">0</span>,   <span class=\"comment\">// 获取水平滚动坐标</span></span><br><span class=\"line\">      yScroll = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollTop</span> ||<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollTop</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">scrollTop</span> || <span class=\"number\">0</span>,  <span class=\"comment\">// 获取垂直滚动坐标</span></span><br><span class=\"line\">      speed = <span class=\"number\">1</span> + acceleration; <span class=\"comment\">// 滚动速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"title function_\">scrollTo</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(xScroll / speed), <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(yScroll / speed)); <span class=\"comment\">// 屏幕滚动到某个坐标，因为speed大于1，所以x、y轴的坐标越来越小</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xScroll &gt; <span class=\"number\">0</span> || yScroll &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果没有滚动到顶部就设置延迟time后继续滚动</span></span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">goTop</span>(acceleration, time);</span><br><span class=\"line\">      &#125;, time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <em>返回顶部</em> 的按钮上绑定<code>onClick=&quot;goTop();&quot;</code>就可以实现返回顶部操作。</p>\n<p>这里用到了<code>xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0;</code>，其实这三个值的效果都差不多，都代表滚动条水平移动的像素，只是浏览器兼容性可能有所不同，所以这样写兼容性更好。</p>\n<p>然后就是<code>window.scrollTo(x, y)</code>方法。该方法使当前窗口滚动到指定的x、y像素坐标。之所以除以speed，这样就以一定的速度慢慢减小，达到缓慢的动画效果。</p>\n<p>之后判断如果滚动条距离顶部还有一段距离的话，就继续循环调用该函数，并设置一定的延迟时间，以达到平滑滚动的动画效果。这里的<code>time</code>值要设置的比较小，超过100就显得比较不自然了。</p>\n<h1 id=\"按钮的样式设置\"><a href=\"#按钮的样式设置\" class=\"headerlink\" title=\"按钮的样式设置\"></a>按钮的样式设置</h1><p>滚动特效实现了，但一般我们只有当页面发生滚动并且滚动到一定距离时才想要回到顶部，我们希望回到顶部的按钮在一定情况下才出现，于是我们需要设置按钮何时出现。通过在<code>scroll</code>事件上绑定函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollBtn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;scroll2Top-btn&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 这里用了ES6语法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> contentTop = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">clientHeight</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span>, <span class=\"comment\">// 获取当前可视窗口的高度</span></span><br><span class=\"line\">      scrollTop = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollTop</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollTop</span>;  <span class=\"comment\">// 获取垂直滚动条距离页面顶部的距离</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contentTop &lt; scrollTop) &#123; <span class=\"comment\">// 如果可视窗口的高度小于垂直滚动的距离，说明已经向下滚动超过一个可视窗口的距离，也就是说看不到顶部了，于是就设置按钮可见</span></span><br><span class=\"line\">      scrollBtn.<span class=\"property\">style</span>.<span class=\"property\">display</span> = <span class=\"string\">&quot;block&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      scrollBtn.<span class=\"property\">style</span>.<span class=\"property\">display</span> = <span class=\"string\">&quot;none&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<p>通过这两个简单的函数，实现了回到顶部的滚动效果，全部用原生JS编写，简单又实用。</p>\n","site":{"data":{}},"excerpt":"<p>我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？</p>","more":"<h1 id=\"JS实现滚动\"><a href=\"#JS实现滚动\" class=\"headerlink\" title=\"JS实现滚动\"></a>JS实现滚动</h1><p>其实很简单，利用下列函数就可以实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * func: 实现页面滚动到顶部的效果，</span></span><br><span class=\"line\"><span class=\"comment\"> * 离顶部越近滚动速度越慢</span></span><br><span class=\"line\"><span class=\"comment\"> * @acceleration: 滑动的加速度</span></span><br><span class=\"line\"><span class=\"comment\"> * @time: 延迟时间 </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">goTop</span>(<span class=\"params\">acceleration, time</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xScroll = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollLeft</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollLeft</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">scrollLeft</span> || <span class=\"number\">0</span>,   <span class=\"comment\">// 获取水平滚动坐标</span></span><br><span class=\"line\">      yScroll = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollTop</span> ||<span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollTop</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">scrollTop</span> || <span class=\"number\">0</span>,  <span class=\"comment\">// 获取垂直滚动坐标</span></span><br><span class=\"line\">      speed = <span class=\"number\">1</span> + acceleration; <span class=\"comment\">// 滚动速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"title function_\">scrollTo</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(xScroll / speed), <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(yScroll / speed)); <span class=\"comment\">// 屏幕滚动到某个坐标，因为speed大于1，所以x、y轴的坐标越来越小</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xScroll &gt; <span class=\"number\">0</span> || yScroll &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果没有滚动到顶部就设置延迟time后继续滚动</span></span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"title function_\">goTop</span>(acceleration, time);</span><br><span class=\"line\">      &#125;, time);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <em>返回顶部</em> 的按钮上绑定<code>onClick=&quot;goTop();&quot;</code>就可以实现返回顶部操作。</p>\n<p>这里用到了<code>xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0;</code>，其实这三个值的效果都差不多，都代表滚动条水平移动的像素，只是浏览器兼容性可能有所不同，所以这样写兼容性更好。</p>\n<p>然后就是<code>window.scrollTo(x, y)</code>方法。该方法使当前窗口滚动到指定的x、y像素坐标。之所以除以speed，这样就以一定的速度慢慢减小，达到缓慢的动画效果。</p>\n<p>之后判断如果滚动条距离顶部还有一段距离的话，就继续循环调用该函数，并设置一定的延迟时间，以达到平滑滚动的动画效果。这里的<code>time</code>值要设置的比较小，超过100就显得比较不自然了。</p>\n<h1 id=\"按钮的样式设置\"><a href=\"#按钮的样式设置\" class=\"headerlink\" title=\"按钮的样式设置\"></a>按钮的样式设置</h1><p>滚动特效实现了，但一般我们只有当页面发生滚动并且滚动到一定距离时才想要回到顶部，我们希望回到顶部的按钮在一定情况下才出现，于是我们需要设置按钮何时出现。通过在<code>scroll</code>事件上绑定函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollBtn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;scroll2Top-btn&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123; <span class=\"comment\">// 这里用了ES6语法</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> contentTop = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">clientHeight</span> || <span class=\"variable language_\">window</span>.<span class=\"property\">innerHeight</span>, <span class=\"comment\">// 获取当前可视窗口的高度</span></span><br><span class=\"line\">      scrollTop = <span class=\"variable language_\">document</span>.<span class=\"property\">documentElement</span>.<span class=\"property\">scrollTop</span> || <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">scrollTop</span>;  <span class=\"comment\">// 获取垂直滚动条距离页面顶部的距离</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contentTop &lt; scrollTop) &#123; <span class=\"comment\">// 如果可视窗口的高度小于垂直滚动的距离，说明已经向下滚动超过一个可视窗口的距离，也就是说看不到顶部了，于是就设置按钮可见</span></span><br><span class=\"line\">      scrollBtn.<span class=\"property\">style</span>.<span class=\"property\">display</span> = <span class=\"string\">&quot;block&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      scrollBtn.<span class=\"property\">style</span>.<span class=\"property\">display</span> = <span class=\"string\">&quot;none&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<hr>\n<p>通过这两个简单的函数，实现了回到顶部的滚动效果，全部用原生JS编写，简单又实用。</p>"},{"title":"用原生JS写轮播图","date":"2017-08-27T08:53:36.000Z","_content":"\n我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。\n<!--more-->\n# 要实现的功能\n首先我们来看看要实现这么一个轮播图需要哪些功能，这里我把我想到的都列出来了。\n1. 页面加载后轮播图自动开始播放，每张图片停几秒钟。\n2. 图片与图片之间实现平滑过渡动画效果，不显突兀。\n3. 鼠标悬停到当前图片时轮播动画停止，鼠标离开图片后继续开始轮播。\n4. 图片上有左右翻页功能按钮，点击左边按钮图片往左滑动，点击右边按钮图片右滑。\n5. 图片下端有显示图片个数的小圆点，当前图片是第几个，则第几个小圆点“点亮”。\n6. 离开当前页面后轮播动画停止，回到当前页面后轮播动画继续。\n\n我能想到的要实现的功能就这么多，接下来就一步步开始实现。\n\n# HTMl结构\n先不管JS、CSS部分，我们先把整体结构定下来。这里直接贴上主体部分代码：\n```html\n<div class=\"wrap\">\n  <div class=\"loop-container\">\n    <img src=\"./assets/cat5.jpg\" alt=\"5\" class=\"loop-image\">\n    <img src=\"./assets/cat1.jpg\" alt=\"1\" class=\"loop-image\">\n    <img src=\"./assets/cat2.jpg\" alt=\"2\" class=\"loop-image\">\n    <img src=\"./assets/cat3.jpg\" alt=\"3\" class=\"loop-image\">\n    <img src=\"./assets/cat4.jpg\" alt=\"4\" class=\"loop-image\">\n    <img src=\"./assets/cat5.jpg\" alt=\"5\" class=\"loop-image\">\n    <img src=\"./assets/cat1.jpg\" alt=\"5\" class=\"loop-image\">\n  </div>\n  <div class=\"buttons\">\n    <span class=\"on\">1</span>\n    <span>2</span>\n    <span>3</span>\n    <span>4</span>\n    <span>5</span>\n  </div>\n\n  <div class=\"arrow arrow-left\">\n    <div class=\"pt\">\n      <span class=\"pt-inner\"></span>\n    </div>\n    \n  </div>\n\n  <div class=\"arrow arrow-right\">\n    <div class=\"pt\">\n      <span class=\"pt-inner\"></span>\n    </div>\n  </div>\n</div>\n```\n这里要强调的一点就是，虽然最后显示只有5张图片，但我插入了7个`img`标签，其中第一个和最后一张图一样，最后一个和第一个图一样。为什么要这么做呢？是因为要实现平滑的动画过渡效果，后面JS部分会提到。\n\n# CSS样式\n接下来就是CSS设置：\n```css\n\n.wrap {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  padding: 0;\n  margin: 0;\n  width: 600px;\n  height: 500px;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  overflow: hidden;\n}\n.wrap .loop-container {\n  position: absolute;\n  left: -600px;\n  top: 0;\n  width: 700%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  animation: left .6s ease-out;\n  font-size: 0;\n}\n.wrap:hover > .arrow {\n  display: block;\n}\n\n.loop-container .loop-image {\n  width: 600px;\n  height: 500px;\n  margin: 0;\n}\n\n```\n这里我没有把全部的CSS代码贴出来，完整的代码我会在最后给出。\n\n我只说几个要注意的地方：\n- 首先外部容器要设置`overflow:hidden`，这样才能把多余的图片遮住；\n- 其次由于img默认是inline元素，显示出来的特性是inline-block，所以img之间会有4px的空隙，即使设置了margin和padding为0也不能消除。为此我困惑了很久。。。后来上网找资料才发现解决方案。一般有几种解决方案，这里我用的是设置父元素的font-size为0，然后img的font-size设不设置根据需要，这样就可以消除空隙。更详尽的解决方案可以参考张大神的[博客](http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)\n\n其他css设置就根据样式慢慢调整了。\n\n# JS部分\n接下来就是重头戏，JS的实现了。我们一步一步来看。\n\n我先创建了一个整体的“类”，里面有一些所需要用到的方法和属性：\n```javascript\nfunction Marquee() {\n  this.timer = 0;\n  this.index = 0; // 保存当前是第几张图\n}\n\nMarquee.prototype.animate = function (aimLeft) {  // 具体的动画实现\n  var curLeft = parseInt(loopContainer.style.left) || -600, // 获取当前图片的left值\n      speed = (aimLeft - curLeft) / 20, // 每次left移动的距离\n      delay = 20,\n      self = this;\n  var time = setInterval(function () {  // 利用循环定时实现平滑移动的动画效果\n    curLeft += speed;\n    loopContainer.style.left = curLeft + 'px';\n    if (curLeft === aimLeft) {  // 如果移动到了下一张图片的位置，则此次移动动画结束\n      clearInterval(time);\n      if (aimLeft <= -3600) {  // 特殊设置，如果是从最后一张图到第一张图，中间加一张图片实现动画过渡，当到达最后一张图后，立即设置left为第二个img的left。 \n        loopContainer.style.left = '-600px';  // 第一张图实际的left为-600px，因为html里left为0的位置是最后一张图\n      }\n      if (aimLeft >= 0) { // 同理，当从第一张图过渡到最后一张图，先实现动画效果，当left为实际第一张图的位置0时，设置left为倒数第二个img的位置。\n        loopContainer.style.left = '-3000px';\n      }\n      self.showCurrentDot();  // 动画结束后再改变小圆点的外观\n    }\n  }, delay);\n};\nMarquee.prototype.showCurrentDot = function () {  // 设置代表当前图片位置的小圆点class\n  var dots = document.getElementsByTagName('span');\n  for (var i = 0, len = dots.length; i < len; i++) {\n    dots[i].className = '';\n  }\n  dots[this.index].className = 'on';\n};\n\nMarquee.prototype.changePhoto = function (offset) { // 自动改变图片的函数\n  var left = loopContainer.style.left,\n    newleft = left ? parseInt(left) + offset : offset - 600;  // 新的位置\n  \n  this.index = offset > 0 ? this.index - 1 : this.index + 1;  // 判断向左还是向右滑动\n  if (this.index > 4) {\n    this.index = 0;\n  }\n  if (this.index < 0) {\n    this.index = 4;\n  }\n  // console.log(left);\n  // console.log(newleft);\n  // console.log('------');\n  this.animate(newleft);\n};\n\nMarquee.prototype.gotoPhoto = function (count) {  // 跳转到第count个图片的函数\n  var newleft = count * -600;\n  // console.log(newleft);\n  this.index = count - 1;\n  this.animate(newleft);\n}\n\nvar maq = new Marquee();\n```\n## 自动播放图片\n轮播图，顾名思义就是轮流播放图片，所以首先要实现的功能就是自动轮流循环播放图片。 有了之前的类，我们要做的就是当页面加载完毕后开始循环播放：\n```javascript\nwindow.addEventListener('load', function() {\n  var prevBtn = document.getElementsByClassName('arrow-left')[0],\n      nextBtn = document.getElementsByClassName('arrow-right')[0],\n      loopContainer = document.getElementsByClassName('loop-container')[0],\n      btns = document.getElementsByClassName('buttons')[0],\n      wrap = document.getElementsByClassName('wrap')[0];\n  var stopFlag = 0;\n\n  function startInterval() {  // 开始循环动画\n    maq.timer = setTimeout(function () {\n      // console.log(stopFlag);\n      if (!stopFlag) {\n        maq.changePhoto(-600);\n        startInterval();\n      } else {\n        clearTimeout(maq.timer);\n      }\n    }, 4500);\n  }\n  startInterval();\n});\n```\n这里我循环动画没有用setInterval函数，而是用的setTimeout。因为setInterval的机制是每隔一段时间就把事件加入到队列中去，但如果之前的事件还没执行完，就会容易造成队列堵塞。比如说setInterval里的函数执行时间要4秒，如果setInterval的间隔时间少于4秒，则会造成队列里的事件越来越多，而之前的事件却没执行完，这样可能就会使队列里的事件堵塞，最后一次性全部执行，而没有达到预期的间隔效果。\n\n所以我用setTimeout来代替setInterval，每次要加入新的事件之前都先判断一下`stopFlag`是否为0。`stopFlag`的作用就是记录是否要停止动画，为0则不停止，为1则停止。\n\n这里记住要clearTimeout，目的是把已经在队列里但还没有执行的事件清除，这样可以达到立即停止动画的效果。\n\n## 鼠标悬停停止轮播动画，离开后开始动画\n监听mouseover和mouseout事件来达到目的：\n```javascript\nwrap.addEventListener('mouseover', function () {\n  stopFlag = 1;\n  clearTimeout(maq.timer);\n});\nwrap.addEventListener('mouseout', function () {\n  stopFlag = 0;\n  startInterval();\n});\n```\n\n## 左右切换图片\n通过点击左右箭头按钮实现图片之间的滚动切换：\n```javascript\nprevBtn.addEventListener('click', function() {\n    maq.changePhoto(600); // 向左滑\n});\nnextBtn.addEventListener('click', function () {\n  maq.changePhoto(-600);  // 向右滑\n});\n```\n\n## 点击小圆点跳转到对应图片\n这里我用了事件代理，不用在每个小圆点上绑定click事件，提高dom性能：\n```javascript\nbtns.addEventListener('click', function (event) {\n  var count = parseInt(event.target.innerText);\n  if (count < 6) {\n    maq.gotoPhoto(count);\n  }\n});\n```\n\n## 离开当前页面动画停止\n这里我开始没有想到，后来是当我每次切换到别的页面后再回到当前页面，发现动画效果出现问题了。经过一番debug才发现是因为chrome浏览器设置了离开当前页面后setInterval继续执行，如果setInterval的间隔时间小于100ms，则按100ms来执行，于是回来时动画的时间就发生错误了。\n\n所以我们需要设置离开页面时动画停止，这样也节省了不少性能。这里利用的是`onvisibilitychange`事件：\n```javascript\ndocument.addEventListener('visibilitychange', function () {  // 离开当前页面后动画停止\n  if (document.hidden) {\n    stopFlag = 1;\n    clearTimeout(maq.timer);\n  } else {\n    stopFlag = 0;\n    startInterval();\n  }\n});\n```\n这里可以直接调用`document.hidden`API判断当前页面是否被隐藏，如果document.hidden为true则代表已经切换到别的页面，于是设置`stopFlag`为1，使动画停止。也可以用`document.visibilityState`,如果不为'visible'，则代表离开了当前页面。\n\n这里其实可以不用setTimeout、setInterval来实现动画，而是用`requestAnimationFrame`，后者的优点是自动以浏览器支持的最小刷新间隔来实现重绘，使性能得到最大化提升，而且实现了离开页面重绘停止，大大节省性能。这里我就没有实现了，要想了解requestAnimationFrame，可参考[资料](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)。\n\n# 总结\n通过上述方法，最后实现了一个比较完善的轮播图，全部的动画效果都是用JS来实现的。其实要想实现自动轮播，也可以用CSS3的animation来实现，而且实现起来更快，这里我就不阐述了。\n\n最后贴出实现的[demo](https://codepen.io/flyrk/full/brxQBm/)。\n","source":"_posts/2017-08-27-how-to-write-js-marquee.md","raw":"---\ntitle: 用原生JS写轮播图\ndate: 2017-08-27 16:53:36\ncategories:\n- JS相关\ntags:\n- JS技巧\n---\n\n我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。\n<!--more-->\n# 要实现的功能\n首先我们来看看要实现这么一个轮播图需要哪些功能，这里我把我想到的都列出来了。\n1. 页面加载后轮播图自动开始播放，每张图片停几秒钟。\n2. 图片与图片之间实现平滑过渡动画效果，不显突兀。\n3. 鼠标悬停到当前图片时轮播动画停止，鼠标离开图片后继续开始轮播。\n4. 图片上有左右翻页功能按钮，点击左边按钮图片往左滑动，点击右边按钮图片右滑。\n5. 图片下端有显示图片个数的小圆点，当前图片是第几个，则第几个小圆点“点亮”。\n6. 离开当前页面后轮播动画停止，回到当前页面后轮播动画继续。\n\n我能想到的要实现的功能就这么多，接下来就一步步开始实现。\n\n# HTMl结构\n先不管JS、CSS部分，我们先把整体结构定下来。这里直接贴上主体部分代码：\n```html\n<div class=\"wrap\">\n  <div class=\"loop-container\">\n    <img src=\"./assets/cat5.jpg\" alt=\"5\" class=\"loop-image\">\n    <img src=\"./assets/cat1.jpg\" alt=\"1\" class=\"loop-image\">\n    <img src=\"./assets/cat2.jpg\" alt=\"2\" class=\"loop-image\">\n    <img src=\"./assets/cat3.jpg\" alt=\"3\" class=\"loop-image\">\n    <img src=\"./assets/cat4.jpg\" alt=\"4\" class=\"loop-image\">\n    <img src=\"./assets/cat5.jpg\" alt=\"5\" class=\"loop-image\">\n    <img src=\"./assets/cat1.jpg\" alt=\"5\" class=\"loop-image\">\n  </div>\n  <div class=\"buttons\">\n    <span class=\"on\">1</span>\n    <span>2</span>\n    <span>3</span>\n    <span>4</span>\n    <span>5</span>\n  </div>\n\n  <div class=\"arrow arrow-left\">\n    <div class=\"pt\">\n      <span class=\"pt-inner\"></span>\n    </div>\n    \n  </div>\n\n  <div class=\"arrow arrow-right\">\n    <div class=\"pt\">\n      <span class=\"pt-inner\"></span>\n    </div>\n  </div>\n</div>\n```\n这里要强调的一点就是，虽然最后显示只有5张图片，但我插入了7个`img`标签，其中第一个和最后一张图一样，最后一个和第一个图一样。为什么要这么做呢？是因为要实现平滑的动画过渡效果，后面JS部分会提到。\n\n# CSS样式\n接下来就是CSS设置：\n```css\n\n.wrap {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  padding: 0;\n  margin: 0;\n  width: 600px;\n  height: 500px;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  overflow: hidden;\n}\n.wrap .loop-container {\n  position: absolute;\n  left: -600px;\n  top: 0;\n  width: 700%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  animation: left .6s ease-out;\n  font-size: 0;\n}\n.wrap:hover > .arrow {\n  display: block;\n}\n\n.loop-container .loop-image {\n  width: 600px;\n  height: 500px;\n  margin: 0;\n}\n\n```\n这里我没有把全部的CSS代码贴出来，完整的代码我会在最后给出。\n\n我只说几个要注意的地方：\n- 首先外部容器要设置`overflow:hidden`，这样才能把多余的图片遮住；\n- 其次由于img默认是inline元素，显示出来的特性是inline-block，所以img之间会有4px的空隙，即使设置了margin和padding为0也不能消除。为此我困惑了很久。。。后来上网找资料才发现解决方案。一般有几种解决方案，这里我用的是设置父元素的font-size为0，然后img的font-size设不设置根据需要，这样就可以消除空隙。更详尽的解决方案可以参考张大神的[博客](http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)\n\n其他css设置就根据样式慢慢调整了。\n\n# JS部分\n接下来就是重头戏，JS的实现了。我们一步一步来看。\n\n我先创建了一个整体的“类”，里面有一些所需要用到的方法和属性：\n```javascript\nfunction Marquee() {\n  this.timer = 0;\n  this.index = 0; // 保存当前是第几张图\n}\n\nMarquee.prototype.animate = function (aimLeft) {  // 具体的动画实现\n  var curLeft = parseInt(loopContainer.style.left) || -600, // 获取当前图片的left值\n      speed = (aimLeft - curLeft) / 20, // 每次left移动的距离\n      delay = 20,\n      self = this;\n  var time = setInterval(function () {  // 利用循环定时实现平滑移动的动画效果\n    curLeft += speed;\n    loopContainer.style.left = curLeft + 'px';\n    if (curLeft === aimLeft) {  // 如果移动到了下一张图片的位置，则此次移动动画结束\n      clearInterval(time);\n      if (aimLeft <= -3600) {  // 特殊设置，如果是从最后一张图到第一张图，中间加一张图片实现动画过渡，当到达最后一张图后，立即设置left为第二个img的left。 \n        loopContainer.style.left = '-600px';  // 第一张图实际的left为-600px，因为html里left为0的位置是最后一张图\n      }\n      if (aimLeft >= 0) { // 同理，当从第一张图过渡到最后一张图，先实现动画效果，当left为实际第一张图的位置0时，设置left为倒数第二个img的位置。\n        loopContainer.style.left = '-3000px';\n      }\n      self.showCurrentDot();  // 动画结束后再改变小圆点的外观\n    }\n  }, delay);\n};\nMarquee.prototype.showCurrentDot = function () {  // 设置代表当前图片位置的小圆点class\n  var dots = document.getElementsByTagName('span');\n  for (var i = 0, len = dots.length; i < len; i++) {\n    dots[i].className = '';\n  }\n  dots[this.index].className = 'on';\n};\n\nMarquee.prototype.changePhoto = function (offset) { // 自动改变图片的函数\n  var left = loopContainer.style.left,\n    newleft = left ? parseInt(left) + offset : offset - 600;  // 新的位置\n  \n  this.index = offset > 0 ? this.index - 1 : this.index + 1;  // 判断向左还是向右滑动\n  if (this.index > 4) {\n    this.index = 0;\n  }\n  if (this.index < 0) {\n    this.index = 4;\n  }\n  // console.log(left);\n  // console.log(newleft);\n  // console.log('------');\n  this.animate(newleft);\n};\n\nMarquee.prototype.gotoPhoto = function (count) {  // 跳转到第count个图片的函数\n  var newleft = count * -600;\n  // console.log(newleft);\n  this.index = count - 1;\n  this.animate(newleft);\n}\n\nvar maq = new Marquee();\n```\n## 自动播放图片\n轮播图，顾名思义就是轮流播放图片，所以首先要实现的功能就是自动轮流循环播放图片。 有了之前的类，我们要做的就是当页面加载完毕后开始循环播放：\n```javascript\nwindow.addEventListener('load', function() {\n  var prevBtn = document.getElementsByClassName('arrow-left')[0],\n      nextBtn = document.getElementsByClassName('arrow-right')[0],\n      loopContainer = document.getElementsByClassName('loop-container')[0],\n      btns = document.getElementsByClassName('buttons')[0],\n      wrap = document.getElementsByClassName('wrap')[0];\n  var stopFlag = 0;\n\n  function startInterval() {  // 开始循环动画\n    maq.timer = setTimeout(function () {\n      // console.log(stopFlag);\n      if (!stopFlag) {\n        maq.changePhoto(-600);\n        startInterval();\n      } else {\n        clearTimeout(maq.timer);\n      }\n    }, 4500);\n  }\n  startInterval();\n});\n```\n这里我循环动画没有用setInterval函数，而是用的setTimeout。因为setInterval的机制是每隔一段时间就把事件加入到队列中去，但如果之前的事件还没执行完，就会容易造成队列堵塞。比如说setInterval里的函数执行时间要4秒，如果setInterval的间隔时间少于4秒，则会造成队列里的事件越来越多，而之前的事件却没执行完，这样可能就会使队列里的事件堵塞，最后一次性全部执行，而没有达到预期的间隔效果。\n\n所以我用setTimeout来代替setInterval，每次要加入新的事件之前都先判断一下`stopFlag`是否为0。`stopFlag`的作用就是记录是否要停止动画，为0则不停止，为1则停止。\n\n这里记住要clearTimeout，目的是把已经在队列里但还没有执行的事件清除，这样可以达到立即停止动画的效果。\n\n## 鼠标悬停停止轮播动画，离开后开始动画\n监听mouseover和mouseout事件来达到目的：\n```javascript\nwrap.addEventListener('mouseover', function () {\n  stopFlag = 1;\n  clearTimeout(maq.timer);\n});\nwrap.addEventListener('mouseout', function () {\n  stopFlag = 0;\n  startInterval();\n});\n```\n\n## 左右切换图片\n通过点击左右箭头按钮实现图片之间的滚动切换：\n```javascript\nprevBtn.addEventListener('click', function() {\n    maq.changePhoto(600); // 向左滑\n});\nnextBtn.addEventListener('click', function () {\n  maq.changePhoto(-600);  // 向右滑\n});\n```\n\n## 点击小圆点跳转到对应图片\n这里我用了事件代理，不用在每个小圆点上绑定click事件，提高dom性能：\n```javascript\nbtns.addEventListener('click', function (event) {\n  var count = parseInt(event.target.innerText);\n  if (count < 6) {\n    maq.gotoPhoto(count);\n  }\n});\n```\n\n## 离开当前页面动画停止\n这里我开始没有想到，后来是当我每次切换到别的页面后再回到当前页面，发现动画效果出现问题了。经过一番debug才发现是因为chrome浏览器设置了离开当前页面后setInterval继续执行，如果setInterval的间隔时间小于100ms，则按100ms来执行，于是回来时动画的时间就发生错误了。\n\n所以我们需要设置离开页面时动画停止，这样也节省了不少性能。这里利用的是`onvisibilitychange`事件：\n```javascript\ndocument.addEventListener('visibilitychange', function () {  // 离开当前页面后动画停止\n  if (document.hidden) {\n    stopFlag = 1;\n    clearTimeout(maq.timer);\n  } else {\n    stopFlag = 0;\n    startInterval();\n  }\n});\n```\n这里可以直接调用`document.hidden`API判断当前页面是否被隐藏，如果document.hidden为true则代表已经切换到别的页面，于是设置`stopFlag`为1，使动画停止。也可以用`document.visibilityState`,如果不为'visible'，则代表离开了当前页面。\n\n这里其实可以不用setTimeout、setInterval来实现动画，而是用`requestAnimationFrame`，后者的优点是自动以浏览器支持的最小刷新间隔来实现重绘，使性能得到最大化提升，而且实现了离开页面重绘停止，大大节省性能。这里我就没有实现了，要想了解requestAnimationFrame，可参考[资料](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)。\n\n# 总结\n通过上述方法，最后实现了一个比较完善的轮播图，全部的动画效果都是用JS来实现的。其实要想实现自动轮播，也可以用CSS3的animation来实现，而且实现起来更快，这里我就不阐述了。\n\n最后贴出实现的[demo](https://codepen.io/flyrk/full/brxQBm/)。\n","slug":"how-to-write-js-marquee","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d00023ra4kejp2brfr","content":"<p>我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。</p>\n<span id=\"more\"></span>\n<h1 id=\"要实现的功能\"><a href=\"#要实现的功能\" class=\"headerlink\" title=\"要实现的功能\"></a>要实现的功能</h1><p>首先我们来看看要实现这么一个轮播图需要哪些功能，这里我把我想到的都列出来了。</p>\n<ol>\n<li>页面加载后轮播图自动开始播放，每张图片停几秒钟。</li>\n<li>图片与图片之间实现平滑过渡动画效果，不显突兀。</li>\n<li>鼠标悬停到当前图片时轮播动画停止，鼠标离开图片后继续开始轮播。</li>\n<li>图片上有左右翻页功能按钮，点击左边按钮图片往左滑动，点击右边按钮图片右滑。</li>\n<li>图片下端有显示图片个数的小圆点，当前图片是第几个，则第几个小圆点“点亮”。</li>\n<li>离开当前页面后轮播动画停止，回到当前页面后轮播动画继续。</li>\n</ol>\n<p>我能想到的要实现的功能就这么多，接下来就一步步开始实现。</p>\n<h1 id=\"HTMl结构\"><a href=\"#HTMl结构\" class=\"headerlink\" title=\"HTMl结构\"></a>HTMl结构</h1><p>先不管JS、CSS部分，我们先把整体结构定下来。这里直接贴上主体部分代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrap&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat5.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat1.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat2.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat3.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;3&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat4.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;4&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat5.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat1.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;buttons&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;on&quot;</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;arrow arrow-left&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt-inner&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;arrow arrow-right&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt-inner&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里要强调的一点就是，虽然最后显示只有5张图片，但我插入了7个<code>img</code>标签，其中第一个和最后一张图一样，最后一个和第一个图一样。为什么要这么做呢？是因为要实现平滑的动画过渡效果，后面JS部分会提到。</p>\n<h1 id=\"CSS样式\"><a href=\"#CSS样式\" class=\"headerlink\" title=\"CSS样式\"></a>CSS样式</h1><p>接下来就是CSS设置：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">600px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>, -<span class=\"number\">50%</span>);</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span> <span class=\"selector-class\">.loop-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">600px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">700%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: left .<span class=\"number\">6s</span> ease-out;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span><span class=\"selector-pseudo\">:hover</span> &gt; <span class=\"selector-class\">.arrow</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.loop-container</span> <span class=\"selector-class\">.loop-image</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">600px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我没有把全部的CSS代码贴出来，完整的代码我会在最后给出。</p>\n<p>我只说几个要注意的地方：</p>\n<ul>\n<li>首先外部容器要设置<code>overflow:hidden</code>，这样才能把多余的图片遮住；</li>\n<li>其次由于img默认是inline元素，显示出来的特性是inline-block，所以img之间会有4px的空隙，即使设置了margin和padding为0也不能消除。为此我困惑了很久。。。后来上网找资料才发现解决方案。一般有几种解决方案，这里我用的是设置父元素的font-size为0，然后img的font-size设不设置根据需要，这样就可以消除空隙。更详尽的解决方案可以参考张大神的<a href=\"http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/\">博客</a></li>\n</ul>\n<p>其他css设置就根据样式慢慢调整了。</p>\n<h1 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h1><p>接下来就是重头戏，JS的实现了。我们一步一步来看。</p>\n<p>我先创建了一个整体的“类”，里面有一些所需要用到的方法和属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Marquee</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">timer</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 保存当前是第几张图</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">animate</span> = <span class=\"keyword\">function</span> (<span class=\"params\">aimLeft</span>) &#123;  <span class=\"comment\">// 具体的动画实现</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> curLeft = <span class=\"built_in\">parseInt</span>(loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span>) || -<span class=\"number\">600</span>, <span class=\"comment\">// 获取当前图片的left值</span></span><br><span class=\"line\">      speed = (aimLeft - curLeft) / <span class=\"number\">20</span>, <span class=\"comment\">// 每次left移动的距离</span></span><br><span class=\"line\">      delay = <span class=\"number\">20</span>,</span><br><span class=\"line\">      self = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> time = <span class=\"built_in\">setInterval</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 利用循环定时实现平滑移动的动画效果</span></span><br><span class=\"line\">    curLeft += speed;</span><br><span class=\"line\">    loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span> = curLeft + <span class=\"string\">&#x27;px&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curLeft === aimLeft) &#123;  <span class=\"comment\">// 如果移动到了下一张图片的位置，则此次移动动画结束</span></span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(time);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (aimLeft &lt;= -<span class=\"number\">3600</span>) &#123;  <span class=\"comment\">// 特殊设置，如果是从最后一张图到第一张图，中间加一张图片实现动画过渡，当到达最后一张图后，立即设置left为第二个img的left。 </span></span><br><span class=\"line\">        loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span> = <span class=\"string\">&#x27;-600px&#x27;</span>;  <span class=\"comment\">// 第一张图实际的left为-600px，因为html里left为0的位置是最后一张图</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (aimLeft &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 同理，当从第一张图过渡到最后一张图，先实现动画效果，当left为实际第一张图的位置0时，设置left为倒数第二个img的位置。</span></span><br><span class=\"line\">        loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span> = <span class=\"string\">&#x27;-3000px&#x27;</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      self.<span class=\"title function_\">showCurrentDot</span>();  <span class=\"comment\">// 动画结束后再改变小圆点的外观</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, delay);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">showCurrentDot</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 设置代表当前图片位置的小圆点class</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> dots = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;span&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = dots.<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    dots[i].<span class=\"property\">className</span> = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dots[<span class=\"variable language_\">this</span>.<span class=\"property\">index</span>].<span class=\"property\">className</span> = <span class=\"string\">&#x27;on&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">changePhoto</span> = <span class=\"keyword\">function</span> (<span class=\"params\">offset</span>) &#123; <span class=\"comment\">// 自动改变图片的函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span>,</span><br><span class=\"line\">    newleft = left ? <span class=\"built_in\">parseInt</span>(left) + offset : offset - <span class=\"number\">600</span>;  <span class=\"comment\">// 新的位置</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = offset &gt; <span class=\"number\">0</span> ? <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> - <span class=\"number\">1</span> : <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> + <span class=\"number\">1</span>;  <span class=\"comment\">// 判断向左还是向右滑动</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">index</span> &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">index</span> &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(left);</span></span><br><span class=\"line\">  <span class=\"comment\">// console.log(newleft);</span></span><br><span class=\"line\">  <span class=\"comment\">// console.log(&#x27;------&#x27;);</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">animate</span>(newleft);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">gotoPhoto</span> = <span class=\"keyword\">function</span> (<span class=\"params\">count</span>) &#123;  <span class=\"comment\">// 跳转到第count个图片的函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> newleft = count * -<span class=\"number\">600</span>;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(newleft);</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = count - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">animate</span>(newleft);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> maq = <span class=\"keyword\">new</span> <span class=\"title class_\">Marquee</span>();</span><br></pre></td></tr></table></figure>\n<h2 id=\"自动播放图片\"><a href=\"#自动播放图片\" class=\"headerlink\" title=\"自动播放图片\"></a>自动播放图片</h2><p>轮播图，顾名思义就是轮流播放图片，所以首先要实现的功能就是自动轮流循环播放图片。 有了之前的类，我们要做的就是当页面加载完毕后开始循环播放：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prevBtn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;arrow-left&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      nextBtn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;arrow-right&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      loopContainer = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;loop-container&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      btns = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;buttons&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      wrap = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;wrap&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stopFlag = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">startInterval</span>(<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 开始循环动画</span></span><br><span class=\"line\">    maq.<span class=\"property\">timer</span> = <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(stopFlag);</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!stopFlag) &#123;</span><br><span class=\"line\">        maq.<span class=\"title function_\">changePhoto</span>(-<span class=\"number\">600</span>);</span><br><span class=\"line\">        <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(maq.<span class=\"property\">timer</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">4500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里我循环动画没有用setInterval函数，而是用的setTimeout。因为setInterval的机制是每隔一段时间就把事件加入到队列中去，但如果之前的事件还没执行完，就会容易造成队列堵塞。比如说setInterval里的函数执行时间要4秒，如果setInterval的间隔时间少于4秒，则会造成队列里的事件越来越多，而之前的事件却没执行完，这样可能就会使队列里的事件堵塞，最后一次性全部执行，而没有达到预期的间隔效果。</p>\n<p>所以我用setTimeout来代替setInterval，每次要加入新的事件之前都先判断一下<code>stopFlag</code>是否为0。<code>stopFlag</code>的作用就是记录是否要停止动画，为0则不停止，为1则停止。</p>\n<p>这里记住要clearTimeout，目的是把已经在队列里但还没有执行的事件清除，这样可以达到立即停止动画的效果。</p>\n<h2 id=\"鼠标悬停停止轮播动画，离开后开始动画\"><a href=\"#鼠标悬停停止轮播动画，离开后开始动画\" class=\"headerlink\" title=\"鼠标悬停停止轮播动画，离开后开始动画\"></a>鼠标悬停停止轮播动画，离开后开始动画</h2><p>监听mouseover和mouseout事件来达到目的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrap.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseover&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  stopFlag = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">clearTimeout</span>(maq.<span class=\"property\">timer</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">wrap.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  stopFlag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"左右切换图片\"><a href=\"#左右切换图片\" class=\"headerlink\" title=\"左右切换图片\"></a>左右切换图片</h2><p>通过点击左右箭头按钮实现图片之间的滚动切换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prevBtn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    maq.<span class=\"title function_\">changePhoto</span>(<span class=\"number\">600</span>); <span class=\"comment\">// 向左滑</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">nextBtn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  maq.<span class=\"title function_\">changePhoto</span>(-<span class=\"number\">600</span>);  <span class=\"comment\">// 向右滑</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"点击小圆点跳转到对应图片\"><a href=\"#点击小圆点跳转到对应图片\" class=\"headerlink\" title=\"点击小圆点跳转到对应图片\"></a>点击小圆点跳转到对应图片</h2><p>这里我用了事件代理，不用在每个小圆点上绑定click事件，提高dom性能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btns.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"built_in\">parseInt</span>(event.<span class=\"property\">target</span>.<span class=\"property\">innerText</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">6</span>) &#123;</span><br><span class=\"line\">    maq.<span class=\"title function_\">gotoPhoto</span>(count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"离开当前页面动画停止\"><a href=\"#离开当前页面动画停止\" class=\"headerlink\" title=\"离开当前页面动画停止\"></a>离开当前页面动画停止</h2><p>这里我开始没有想到，后来是当我每次切换到别的页面后再回到当前页面，发现动画效果出现问题了。经过一番debug才发现是因为chrome浏览器设置了离开当前页面后setInterval继续执行，如果setInterval的间隔时间小于100ms，则按100ms来执行，于是回来时动画的时间就发生错误了。</p>\n<p>所以我们需要设置离开页面时动画停止，这样也节省了不少性能。这里利用的是<code>onvisibilitychange</code>事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;visibilitychange&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 离开当前页面后动画停止</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">document</span>.<span class=\"property\">hidden</span>) &#123;</span><br><span class=\"line\">    stopFlag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(maq.<span class=\"property\">timer</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    stopFlag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里可以直接调用<code>document.hidden</code>API判断当前页面是否被隐藏，如果document.hidden为true则代表已经切换到别的页面，于是设置<code>stopFlag</code>为1，使动画停止。也可以用<code>document.visibilityState</code>,如果不为’visible’，则代表离开了当前页面。</p>\n<p>这里其实可以不用setTimeout、setInterval来实现动画，而是用<code>requestAnimationFrame</code>，后者的优点是自动以浏览器支持的最小刷新间隔来实现重绘，使性能得到最大化提升，而且实现了离开页面重绘停止，大大节省性能。这里我就没有实现了，要想了解requestAnimationFrame，可参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\">资料</a>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述方法，最后实现了一个比较完善的轮播图，全部的动画效果都是用JS来实现的。其实要想实现自动轮播，也可以用CSS3的animation来实现，而且实现起来更快，这里我就不阐述了。</p>\n<p>最后贴出实现的<a href=\"https://codepen.io/flyrk/full/brxQBm/\">demo</a>。</p>\n","site":{"data":{}},"excerpt":"<p>我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。</p>","more":"<h1 id=\"要实现的功能\"><a href=\"#要实现的功能\" class=\"headerlink\" title=\"要实现的功能\"></a>要实现的功能</h1><p>首先我们来看看要实现这么一个轮播图需要哪些功能，这里我把我想到的都列出来了。</p>\n<ol>\n<li>页面加载后轮播图自动开始播放，每张图片停几秒钟。</li>\n<li>图片与图片之间实现平滑过渡动画效果，不显突兀。</li>\n<li>鼠标悬停到当前图片时轮播动画停止，鼠标离开图片后继续开始轮播。</li>\n<li>图片上有左右翻页功能按钮，点击左边按钮图片往左滑动，点击右边按钮图片右滑。</li>\n<li>图片下端有显示图片个数的小圆点，当前图片是第几个，则第几个小圆点“点亮”。</li>\n<li>离开当前页面后轮播动画停止，回到当前页面后轮播动画继续。</li>\n</ol>\n<p>我能想到的要实现的功能就这么多，接下来就一步步开始实现。</p>\n<h1 id=\"HTMl结构\"><a href=\"#HTMl结构\" class=\"headerlink\" title=\"HTMl结构\"></a>HTMl结构</h1><p>先不管JS、CSS部分，我们先把整体结构定下来。这里直接贴上主体部分代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;wrap&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat5.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat1.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat2.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat3.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;3&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat4.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;4&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat5.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./assets/cat1.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;loop-image&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;buttons&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;on&quot;</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>2<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>3<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>4<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>5<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;arrow arrow-left&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt-inner&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;arrow arrow-right&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;pt-inner&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里要强调的一点就是，虽然最后显示只有5张图片，但我插入了7个<code>img</code>标签，其中第一个和最后一张图一样，最后一个和第一个图一样。为什么要这么做呢？是因为要实现平滑的动画过渡效果，后面JS部分会提到。</p>\n<h1 id=\"CSS样式\"><a href=\"#CSS样式\" class=\"headerlink\" title=\"CSS样式\"></a>CSS样式</h1><p>接下来就是CSS设置：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">600px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>, -<span class=\"number\">50%</span>);</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span> <span class=\"selector-class\">.loop-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">600px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">700%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: left .<span class=\"number\">6s</span> ease-out;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.wrap</span><span class=\"selector-pseudo\">:hover</span> &gt; <span class=\"selector-class\">.arrow</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.loop-container</span> <span class=\"selector-class\">.loop-image</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">600px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里我没有把全部的CSS代码贴出来，完整的代码我会在最后给出。</p>\n<p>我只说几个要注意的地方：</p>\n<ul>\n<li>首先外部容器要设置<code>overflow:hidden</code>，这样才能把多余的图片遮住；</li>\n<li>其次由于img默认是inline元素，显示出来的特性是inline-block，所以img之间会有4px的空隙，即使设置了margin和padding为0也不能消除。为此我困惑了很久。。。后来上网找资料才发现解决方案。一般有几种解决方案，这里我用的是设置父元素的font-size为0，然后img的font-size设不设置根据需要，这样就可以消除空隙。更详尽的解决方案可以参考张大神的<a href=\"http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/\">博客</a></li>\n</ul>\n<p>其他css设置就根据样式慢慢调整了。</p>\n<h1 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h1><p>接下来就是重头戏，JS的实现了。我们一步一步来看。</p>\n<p>我先创建了一个整体的“类”，里面有一些所需要用到的方法和属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Marquee</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">timer</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 保存当前是第几张图</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">animate</span> = <span class=\"keyword\">function</span> (<span class=\"params\">aimLeft</span>) &#123;  <span class=\"comment\">// 具体的动画实现</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> curLeft = <span class=\"built_in\">parseInt</span>(loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span>) || -<span class=\"number\">600</span>, <span class=\"comment\">// 获取当前图片的left值</span></span><br><span class=\"line\">      speed = (aimLeft - curLeft) / <span class=\"number\">20</span>, <span class=\"comment\">// 每次left移动的距离</span></span><br><span class=\"line\">      delay = <span class=\"number\">20</span>,</span><br><span class=\"line\">      self = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> time = <span class=\"built_in\">setInterval</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 利用循环定时实现平滑移动的动画效果</span></span><br><span class=\"line\">    curLeft += speed;</span><br><span class=\"line\">    loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span> = curLeft + <span class=\"string\">&#x27;px&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curLeft === aimLeft) &#123;  <span class=\"comment\">// 如果移动到了下一张图片的位置，则此次移动动画结束</span></span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(time);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (aimLeft &lt;= -<span class=\"number\">3600</span>) &#123;  <span class=\"comment\">// 特殊设置，如果是从最后一张图到第一张图，中间加一张图片实现动画过渡，当到达最后一张图后，立即设置left为第二个img的left。 </span></span><br><span class=\"line\">        loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span> = <span class=\"string\">&#x27;-600px&#x27;</span>;  <span class=\"comment\">// 第一张图实际的left为-600px，因为html里left为0的位置是最后一张图</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (aimLeft &gt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 同理，当从第一张图过渡到最后一张图，先实现动画效果，当left为实际第一张图的位置0时，设置left为倒数第二个img的位置。</span></span><br><span class=\"line\">        loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span> = <span class=\"string\">&#x27;-3000px&#x27;</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      self.<span class=\"title function_\">showCurrentDot</span>();  <span class=\"comment\">// 动画结束后再改变小圆点的外观</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, delay);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">showCurrentDot</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 设置代表当前图片位置的小圆点class</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> dots = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByTagName</span>(<span class=\"string\">&#x27;span&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = dots.<span class=\"property\">length</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    dots[i].<span class=\"property\">className</span> = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  dots[<span class=\"variable language_\">this</span>.<span class=\"property\">index</span>].<span class=\"property\">className</span> = <span class=\"string\">&#x27;on&#x27;</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">changePhoto</span> = <span class=\"keyword\">function</span> (<span class=\"params\">offset</span>) &#123; <span class=\"comment\">// 自动改变图片的函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = loopContainer.<span class=\"property\">style</span>.<span class=\"property\">left</span>,</span><br><span class=\"line\">    newleft = left ? <span class=\"built_in\">parseInt</span>(left) + offset : offset - <span class=\"number\">600</span>;  <span class=\"comment\">// 新的位置</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = offset &gt; <span class=\"number\">0</span> ? <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> - <span class=\"number\">1</span> : <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> + <span class=\"number\">1</span>;  <span class=\"comment\">// 判断向左还是向右滑动</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">index</span> &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">index</span> &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(left);</span></span><br><span class=\"line\">  <span class=\"comment\">// console.log(newleft);</span></span><br><span class=\"line\">  <span class=\"comment\">// console.log(&#x27;------&#x27;);</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">animate</span>(newleft);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Marquee</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">gotoPhoto</span> = <span class=\"keyword\">function</span> (<span class=\"params\">count</span>) &#123;  <span class=\"comment\">// 跳转到第count个图片的函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> newleft = count * -<span class=\"number\">600</span>;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(newleft);</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">index</span> = count - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">animate</span>(newleft);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> maq = <span class=\"keyword\">new</span> <span class=\"title class_\">Marquee</span>();</span><br></pre></td></tr></table></figure>\n<h2 id=\"自动播放图片\"><a href=\"#自动播放图片\" class=\"headerlink\" title=\"自动播放图片\"></a>自动播放图片</h2><p>轮播图，顾名思义就是轮流播放图片，所以首先要实现的功能就是自动轮流循环播放图片。 有了之前的类，我们要做的就是当页面加载完毕后开始循环播放：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;load&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prevBtn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;arrow-left&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      nextBtn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;arrow-right&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      loopContainer = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;loop-container&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      btns = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;buttons&#x27;</span>)[<span class=\"number\">0</span>],</span><br><span class=\"line\">      wrap = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;wrap&#x27;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stopFlag = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">startInterval</span>(<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 开始循环动画</span></span><br><span class=\"line\">    maq.<span class=\"property\">timer</span> = <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// console.log(stopFlag);</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!stopFlag) &#123;</span><br><span class=\"line\">        maq.<span class=\"title function_\">changePhoto</span>(-<span class=\"number\">600</span>);</span><br><span class=\"line\">        <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(maq.<span class=\"property\">timer</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">4500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里我循环动画没有用setInterval函数，而是用的setTimeout。因为setInterval的机制是每隔一段时间就把事件加入到队列中去，但如果之前的事件还没执行完，就会容易造成队列堵塞。比如说setInterval里的函数执行时间要4秒，如果setInterval的间隔时间少于4秒，则会造成队列里的事件越来越多，而之前的事件却没执行完，这样可能就会使队列里的事件堵塞，最后一次性全部执行，而没有达到预期的间隔效果。</p>\n<p>所以我用setTimeout来代替setInterval，每次要加入新的事件之前都先判断一下<code>stopFlag</code>是否为0。<code>stopFlag</code>的作用就是记录是否要停止动画，为0则不停止，为1则停止。</p>\n<p>这里记住要clearTimeout，目的是把已经在队列里但还没有执行的事件清除，这样可以达到立即停止动画的效果。</p>\n<h2 id=\"鼠标悬停停止轮播动画，离开后开始动画\"><a href=\"#鼠标悬停停止轮播动画，离开后开始动画\" class=\"headerlink\" title=\"鼠标悬停停止轮播动画，离开后开始动画\"></a>鼠标悬停停止轮播动画，离开后开始动画</h2><p>监听mouseover和mouseout事件来达到目的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wrap.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseover&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  stopFlag = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">clearTimeout</span>(maq.<span class=\"property\">timer</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">wrap.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseout&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  stopFlag = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"左右切换图片\"><a href=\"#左右切换图片\" class=\"headerlink\" title=\"左右切换图片\"></a>左右切换图片</h2><p>通过点击左右箭头按钮实现图片之间的滚动切换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prevBtn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    maq.<span class=\"title function_\">changePhoto</span>(<span class=\"number\">600</span>); <span class=\"comment\">// 向左滑</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">nextBtn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  maq.<span class=\"title function_\">changePhoto</span>(-<span class=\"number\">600</span>);  <span class=\"comment\">// 向右滑</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"点击小圆点跳转到对应图片\"><a href=\"#点击小圆点跳转到对应图片\" class=\"headerlink\" title=\"点击小圆点跳转到对应图片\"></a>点击小圆点跳转到对应图片</h2><p>这里我用了事件代理，不用在每个小圆点上绑定click事件，提高dom性能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btns.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = <span class=\"built_in\">parseInt</span>(event.<span class=\"property\">target</span>.<span class=\"property\">innerText</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">6</span>) &#123;</span><br><span class=\"line\">    maq.<span class=\"title function_\">gotoPhoto</span>(count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"离开当前页面动画停止\"><a href=\"#离开当前页面动画停止\" class=\"headerlink\" title=\"离开当前页面动画停止\"></a>离开当前页面动画停止</h2><p>这里我开始没有想到，后来是当我每次切换到别的页面后再回到当前页面，发现动画效果出现问题了。经过一番debug才发现是因为chrome浏览器设置了离开当前页面后setInterval继续执行，如果setInterval的间隔时间小于100ms，则按100ms来执行，于是回来时动画的时间就发生错误了。</p>\n<p>所以我们需要设置离开页面时动画停止，这样也节省了不少性能。这里利用的是<code>onvisibilitychange</code>事件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;visibilitychange&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;  <span class=\"comment\">// 离开当前页面后动画停止</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">document</span>.<span class=\"property\">hidden</span>) &#123;</span><br><span class=\"line\">    stopFlag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(maq.<span class=\"property\">timer</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    stopFlag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"title function_\">startInterval</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里可以直接调用<code>document.hidden</code>API判断当前页面是否被隐藏，如果document.hidden为true则代表已经切换到别的页面，于是设置<code>stopFlag</code>为1，使动画停止。也可以用<code>document.visibilityState</code>,如果不为’visible’，则代表离开了当前页面。</p>\n<p>这里其实可以不用setTimeout、setInterval来实现动画，而是用<code>requestAnimationFrame</code>，后者的优点是自动以浏览器支持的最小刷新间隔来实现重绘，使性能得到最大化提升，而且实现了离开页面重绘停止，大大节省性能。这里我就没有实现了，要想了解requestAnimationFrame，可参考<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\">资料</a>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过上述方法，最后实现了一个比较完善的轮播图，全部的动画效果都是用JS来实现的。其实要想实现自动轮播，也可以用CSS3的animation来实现，而且实现起来更快，这里我就不阐述了。</p>\n<p>最后贴出实现的<a href=\"https://codepen.io/flyrk/full/brxQBm/\">demo</a>。</p>"},{"title":"什么是堆排序","date":"2017-09-05T02:02:06.000Z","_content":"\n堆排序是一种常见的排序算法，时间复杂度是O(nlgn)，与归并排序一样，但它又与插入排序一样具有*空间原址性* ：任何时候都只需要常数个额外的元素空间存储临时数据。\n<!--more-->\n# 什么是堆？\n  一般堆用数组存储，表现出近似完全二叉树形式，树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的且从左至右填充。\n\n# 最大堆和最小堆\n  * 最大堆：除了根以外的所有节点i都要满足A[parent(i)]>=A[i]，即堆中最大元素是根节点。\n  * 最小堆：除了根以外的所有节点i都要满足A[parent(i)]<=A[i]，即堆中最小元素是根节点。   \n\n# 堆中节点的高度\n  与二叉树的高度相同，定义为该节点到叶节点最长简单路径上边的数目。则包含n个元素的堆其高度为lgn。\n\n# 维护堆的性质与方法（数组下标都从1开始）\n  ## maxHeapify\n  时间复杂度为O(lgn)。通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆性质。代码如下:\n  ```javascript\n  function maxHeapify(arr, i) {\n    let largest;\n    let left = i * 2; // leftChild\n    let right = i * 2 + 1; // rightChild\n    if( left <= arr.length && arr[i] < arr[left] ) {\n      largest = left;  \n    } else {\n      largest = i;\n    }\n    if( right <= arr.length && arr[largest] < arr[right] ) {\n      largest = right;\n    }\n    if ( largest !== i ) { // 把左右子节点中最大的元素与当前节点i交换\n      arr[i] = arr[i] + arr[largest];\n      arr[largest] = arr[i] - arr[largest];\n      arr[i] = arr[i] - arr[largest];\n      maxHeapify(arr, largest);\n    }\n  }\n  ```\n  ## buildMaxHeap\n  时间复杂度为O(n)。用*自底向上*的方法利用maxHeapify把大小为n的数组转换为最大堆。因为最后一个叶节点序号为n，则其父节点序号为n/2,所以子数组[n/2+1,....,n]都是堆的叶节点，所以循环从n/2开始递减到1，每一次都保证节点i+1,i+2...,n都是一个最大堆的根节点的性质。\n  ```javascript\n  function buildMaxHeap(arr) {\n    for (var i = arr.length / 2; i >= 1; i--) {\n      maxHeapify(arr,i);\n    }\n  }\n  ```\n# heapSort:堆排序算法。\n  有了上述两个函数方法，我们就可以实现堆排序。\n  \n  先将数组arr建为一个最大堆，因为最大堆的根节点总是最大的，通过把它与arr[n]互换可以得到正确位置，保证arr[n]总是当前堆中最大元素，然后将arr[n]存储到新的数组中。可以算出时间复杂度为O(nlgn)。\n  ```javascript\n  function heapSort(arr) {\n    let arrSort = [];\n    buildMaxHeap(arr);  // 先建一个最大堆\n    let length = arr.length;\n    for (var i = length; i >= 2; i--) {\n      arr[1] = arr[i];\n      arrSort.push(arr[i]);\n      maxHeapify(arr, 1); // 每次交换后重新维护最大堆，复杂度为O(lgn)\n    }\n    arrSort.push(arr[1]);\n    return arrSort;\n  }\n  ```\n# 总结\n  通过堆排序的实现，我们可以在时间复杂度为O(nlgn)的情况下对数组进行排序。而且当我们只需要找出数组中最大的几个元素，则可以用堆排序来实现，因为每次最大的元素总是当前最后一个，这样就不需要将数组全排序。","source":"_posts/2017-09-05-what-is-heapSort.md","raw":"---\ntitle: 什么是堆排序\ndate: 2017-09-05 10:02:06\ncategories:\n- 算法\ntags:\n- 排序\n---\n\n堆排序是一种常见的排序算法，时间复杂度是O(nlgn)，与归并排序一样，但它又与插入排序一样具有*空间原址性* ：任何时候都只需要常数个额外的元素空间存储临时数据。\n<!--more-->\n# 什么是堆？\n  一般堆用数组存储，表现出近似完全二叉树形式，树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的且从左至右填充。\n\n# 最大堆和最小堆\n  * 最大堆：除了根以外的所有节点i都要满足A[parent(i)]>=A[i]，即堆中最大元素是根节点。\n  * 最小堆：除了根以外的所有节点i都要满足A[parent(i)]<=A[i]，即堆中最小元素是根节点。   \n\n# 堆中节点的高度\n  与二叉树的高度相同，定义为该节点到叶节点最长简单路径上边的数目。则包含n个元素的堆其高度为lgn。\n\n# 维护堆的性质与方法（数组下标都从1开始）\n  ## maxHeapify\n  时间复杂度为O(lgn)。通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆性质。代码如下:\n  ```javascript\n  function maxHeapify(arr, i) {\n    let largest;\n    let left = i * 2; // leftChild\n    let right = i * 2 + 1; // rightChild\n    if( left <= arr.length && arr[i] < arr[left] ) {\n      largest = left;  \n    } else {\n      largest = i;\n    }\n    if( right <= arr.length && arr[largest] < arr[right] ) {\n      largest = right;\n    }\n    if ( largest !== i ) { // 把左右子节点中最大的元素与当前节点i交换\n      arr[i] = arr[i] + arr[largest];\n      arr[largest] = arr[i] - arr[largest];\n      arr[i] = arr[i] - arr[largest];\n      maxHeapify(arr, largest);\n    }\n  }\n  ```\n  ## buildMaxHeap\n  时间复杂度为O(n)。用*自底向上*的方法利用maxHeapify把大小为n的数组转换为最大堆。因为最后一个叶节点序号为n，则其父节点序号为n/2,所以子数组[n/2+1,....,n]都是堆的叶节点，所以循环从n/2开始递减到1，每一次都保证节点i+1,i+2...,n都是一个最大堆的根节点的性质。\n  ```javascript\n  function buildMaxHeap(arr) {\n    for (var i = arr.length / 2; i >= 1; i--) {\n      maxHeapify(arr,i);\n    }\n  }\n  ```\n# heapSort:堆排序算法。\n  有了上述两个函数方法，我们就可以实现堆排序。\n  \n  先将数组arr建为一个最大堆，因为最大堆的根节点总是最大的，通过把它与arr[n]互换可以得到正确位置，保证arr[n]总是当前堆中最大元素，然后将arr[n]存储到新的数组中。可以算出时间复杂度为O(nlgn)。\n  ```javascript\n  function heapSort(arr) {\n    let arrSort = [];\n    buildMaxHeap(arr);  // 先建一个最大堆\n    let length = arr.length;\n    for (var i = length; i >= 2; i--) {\n      arr[1] = arr[i];\n      arrSort.push(arr[i]);\n      maxHeapify(arr, 1); // 每次交换后重新维护最大堆，复杂度为O(lgn)\n    }\n    arrSort.push(arr[1]);\n    return arrSort;\n  }\n  ```\n# 总结\n  通过堆排序的实现，我们可以在时间复杂度为O(nlgn)的情况下对数组进行排序。而且当我们只需要找出数组中最大的几个元素，则可以用堆排序来实现，因为每次最大的元素总是当前最后一个，这样就不需要将数组全排序。","slug":"what-is-heapSort","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d10026ra4k102kedza","content":"<p>堆排序是一种常见的排序算法，时间复杂度是O(nlgn)，与归并排序一样，但它又与插入排序一样具有<em>空间原址性</em> ：任何时候都只需要常数个额外的元素空间存储临时数据。</p>\n<span id=\"more\"></span>\n<h1 id=\"什么是堆？\"><a href=\"#什么是堆？\" class=\"headerlink\" title=\"什么是堆？\"></a>什么是堆？</h1><p>  一般堆用数组存储，表现出近似完全二叉树形式，树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的且从左至右填充。</p>\n<h1 id=\"最大堆和最小堆\"><a href=\"#最大堆和最小堆\" class=\"headerlink\" title=\"最大堆和最小堆\"></a>最大堆和最小堆</h1><ul>\n<li>最大堆：除了根以外的所有节点i都要满足A[parent(i)]&gt;&#x3D;A[i]，即堆中最大元素是根节点。</li>\n<li>最小堆：除了根以外的所有节点i都要满足A[parent(i)]&lt;&#x3D;A[i]，即堆中最小元素是根节点。</li>\n</ul>\n<h1 id=\"堆中节点的高度\"><a href=\"#堆中节点的高度\" class=\"headerlink\" title=\"堆中节点的高度\"></a>堆中节点的高度</h1><p>  与二叉树的高度相同，定义为该节点到叶节点最长简单路径上边的数目。则包含n个元素的堆其高度为lgn。</p>\n<h1 id=\"维护堆的性质与方法（数组下标都从1开始）\"><a href=\"#维护堆的性质与方法（数组下标都从1开始）\" class=\"headerlink\" title=\"维护堆的性质与方法（数组下标都从1开始）\"></a>维护堆的性质与方法（数组下标都从1开始）</h1><h2 id=\"maxHeapify\"><a href=\"#maxHeapify\" class=\"headerlink\" title=\"maxHeapify\"></a>maxHeapify</h2><p>  时间复杂度为O(lgn)。通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆性质。代码如下:<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxHeapify</span>(<span class=\"params\">arr, i</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> largest;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = i * <span class=\"number\">2</span>; <span class=\"comment\">// leftChild</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"comment\">// rightChild</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>( left &lt;= arr.<span class=\"property\">length</span> &amp;&amp; arr[i] &lt; arr[left] ) &#123;</span><br><span class=\"line\">    largest = left;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    largest = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( right &lt;= arr.<span class=\"property\">length</span> &amp;&amp; arr[largest] &lt; arr[right] ) &#123;</span><br><span class=\"line\">    largest = right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( largest !== i ) &#123; <span class=\"comment\">// 把左右子节点中最大的元素与当前节点i交换</span></span><br><span class=\"line\">    arr[i] = arr[i] + arr[largest];</span><br><span class=\"line\">    arr[largest] = arr[i] - arr[largest];</span><br><span class=\"line\">    arr[i] = arr[i] - arr[largest];</span><br><span class=\"line\">    <span class=\"title function_\">maxHeapify</span>(arr, largest);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"buildMaxHeap\"><a href=\"#buildMaxHeap\" class=\"headerlink\" title=\"buildMaxHeap\"></a>buildMaxHeap</h2><p>  时间复杂度为O(n)。用<em>自底向上</em>的方法利用maxHeapify把大小为n的数组转换为最大堆。因为最后一个叶节点序号为n，则其父节点序号为n&#x2F;2,所以子数组[n&#x2F;2+1,….,n]都是堆的叶节点，所以循环从n&#x2F;2开始递减到1，每一次都保证节点i+1,i+2…,n都是一个最大堆的根节点的性质。<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildMaxHeap</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.<span class=\"property\">length</span> / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">maxHeapify</span>(arr,i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"heapSort-堆排序算法。\"><a href=\"#heapSort-堆排序算法。\" class=\"headerlink\" title=\"heapSort:堆排序算法。\"></a>heapSort:堆排序算法。</h1><p>  有了上述两个函数方法，我们就可以实现堆排序。</p>\n<p>  先将数组arr建为一个最大堆，因为最大堆的根节点总是最大的，通过把它与arr[n]互换可以得到正确位置，保证arr[n]总是当前堆中最大元素，然后将arr[n]存储到新的数组中。可以算出时间复杂度为O(nlgn)。<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">heapSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arrSort = [];</span><br><span class=\"line\">  <span class=\"title function_\">buildMaxHeap</span>(arr);  <span class=\"comment\">// 先建一个最大堆</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> length = arr.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = length; i &gt;= <span class=\"number\">2</span>; i--) &#123;</span><br><span class=\"line\">    arr[<span class=\"number\">1</span>] = arr[i];</span><br><span class=\"line\">    arrSort.<span class=\"title function_\">push</span>(arr[i]);</span><br><span class=\"line\">    <span class=\"title function_\">maxHeapify</span>(arr, <span class=\"number\">1</span>); <span class=\"comment\">// 每次交换后重新维护最大堆，复杂度为O(lgn)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arrSort.<span class=\"title function_\">push</span>(arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arrSort;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>  通过堆排序的实现，我们可以在时间复杂度为O(nlgn)的情况下对数组进行排序。而且当我们只需要找出数组中最大的几个元素，则可以用堆排序来实现，因为每次最大的元素总是当前最后一个，这样就不需要将数组全排序。</p>\n","site":{"data":{}},"excerpt":"<p>堆排序是一种常见的排序算法，时间复杂度是O(nlgn)，与归并排序一样，但它又与插入排序一样具有<em>空间原址性</em> ：任何时候都只需要常数个额外的元素空间存储临时数据。</p>","more":"<h1 id=\"什么是堆？\"><a href=\"#什么是堆？\" class=\"headerlink\" title=\"什么是堆？\"></a>什么是堆？</h1><p>  一般堆用数组存储，表现出近似完全二叉树形式，树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的且从左至右填充。</p>\n<h1 id=\"最大堆和最小堆\"><a href=\"#最大堆和最小堆\" class=\"headerlink\" title=\"最大堆和最小堆\"></a>最大堆和最小堆</h1><ul>\n<li>最大堆：除了根以外的所有节点i都要满足A[parent(i)]&gt;&#x3D;A[i]，即堆中最大元素是根节点。</li>\n<li>最小堆：除了根以外的所有节点i都要满足A[parent(i)]&lt;&#x3D;A[i]，即堆中最小元素是根节点。</li>\n</ul>\n<h1 id=\"堆中节点的高度\"><a href=\"#堆中节点的高度\" class=\"headerlink\" title=\"堆中节点的高度\"></a>堆中节点的高度</h1><p>  与二叉树的高度相同，定义为该节点到叶节点最长简单路径上边的数目。则包含n个元素的堆其高度为lgn。</p>\n<h1 id=\"维护堆的性质与方法（数组下标都从1开始）\"><a href=\"#维护堆的性质与方法（数组下标都从1开始）\" class=\"headerlink\" title=\"维护堆的性质与方法（数组下标都从1开始）\"></a>维护堆的性质与方法（数组下标都从1开始）</h1><h2 id=\"maxHeapify\"><a href=\"#maxHeapify\" class=\"headerlink\" title=\"maxHeapify\"></a>maxHeapify</h2><p>  时间复杂度为O(lgn)。通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆性质。代码如下:<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">maxHeapify</span>(<span class=\"params\">arr, i</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> largest;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> left = i * <span class=\"number\">2</span>; <span class=\"comment\">// leftChild</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> right = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"comment\">// rightChild</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>( left &lt;= arr.<span class=\"property\">length</span> &amp;&amp; arr[i] &lt; arr[left] ) &#123;</span><br><span class=\"line\">    largest = left;  </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    largest = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>( right &lt;= arr.<span class=\"property\">length</span> &amp;&amp; arr[largest] &lt; arr[right] ) &#123;</span><br><span class=\"line\">    largest = right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( largest !== i ) &#123; <span class=\"comment\">// 把左右子节点中最大的元素与当前节点i交换</span></span><br><span class=\"line\">    arr[i] = arr[i] + arr[largest];</span><br><span class=\"line\">    arr[largest] = arr[i] - arr[largest];</span><br><span class=\"line\">    arr[i] = arr[i] - arr[largest];</span><br><span class=\"line\">    <span class=\"title function_\">maxHeapify</span>(arr, largest);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"buildMaxHeap\"><a href=\"#buildMaxHeap\" class=\"headerlink\" title=\"buildMaxHeap\"></a>buildMaxHeap</h2><p>  时间复杂度为O(n)。用<em>自底向上</em>的方法利用maxHeapify把大小为n的数组转换为最大堆。因为最后一个叶节点序号为n，则其父节点序号为n&#x2F;2,所以子数组[n&#x2F;2+1,….,n]都是堆的叶节点，所以循环从n&#x2F;2开始递减到1，每一次都保证节点i+1,i+2…,n都是一个最大堆的根节点的性质。<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">buildMaxHeap</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = arr.<span class=\"property\">length</span> / <span class=\"number\">2</span>; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">maxHeapify</span>(arr,i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"heapSort-堆排序算法。\"><a href=\"#heapSort-堆排序算法。\" class=\"headerlink\" title=\"heapSort:堆排序算法。\"></a>heapSort:堆排序算法。</h1><p>  有了上述两个函数方法，我们就可以实现堆排序。</p>\n<p>  先将数组arr建为一个最大堆，因为最大堆的根节点总是最大的，通过把它与arr[n]互换可以得到正确位置，保证arr[n]总是当前堆中最大元素，然后将arr[n]存储到新的数组中。可以算出时间复杂度为O(nlgn)。<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">heapSort</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arrSort = [];</span><br><span class=\"line\">  <span class=\"title function_\">buildMaxHeap</span>(arr);  <span class=\"comment\">// 先建一个最大堆</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> length = arr.<span class=\"property\">length</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = length; i &gt;= <span class=\"number\">2</span>; i--) &#123;</span><br><span class=\"line\">    arr[<span class=\"number\">1</span>] = arr[i];</span><br><span class=\"line\">    arrSort.<span class=\"title function_\">push</span>(arr[i]);</span><br><span class=\"line\">    <span class=\"title function_\">maxHeapify</span>(arr, <span class=\"number\">1</span>); <span class=\"comment\">// 每次交换后重新维护最大堆，复杂度为O(lgn)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  arrSort.<span class=\"title function_\">push</span>(arr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arrSort;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>  通过堆排序的实现，我们可以在时间复杂度为O(nlgn)的情况下对数组进行排序。而且当我们只需要找出数组中最大的几个元素，则可以用堆排序来实现，因为每次最大的元素总是当前最后一个，这样就不需要将数组全排序。</p>"},{"title":"纯CSS绘制不同的图形","date":"2018-12-03T12:44:19.000Z","_content":"\n为什么要用CSS绘制图形？我们知道，一般表示图案可以用`img`标签，直接用切好的图片，或者用`background`加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。\n<!--more-->\n\n这里我列举一些比较感兴趣的图形。\n\n# 基本图案\n\n## 圆形\n圆形可以说是除了方形以外最容易表达的图形了，多亏了CSS3的`border-radius`属性：\n\n### 基本圆形\n![circle](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/circle.jpg)\n```css\n.circle {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  border: 1px solid #000;\n  border-radius: 50%;\n}\n```\n\n### 椭圆形\n![oval](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/oval.jpg)\n```css\n.oval {\n  width: 50px;\n  height: 100px;\n  background-color: red;\n  border-radius: 50px / 100px;\n}\n```\n\n## 三角形\n三角形其实利用的是`border`属性，利用不同方向的`border`宽度和颜色可以展现不同的三角形。\n\n### triangle-top：\n![triangle-top](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-top.jpg)\n```css\n.top-triangle {\n  width: 0;\n  height: 0;\n  border-top: 100px solid red;\n  border-right: 50px solid transparent;\n  border-left: 50px solid transparent;\n}\n```\n\n### triangle-bottom\n![triangle-bottom](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-bottom.jpg)\n```css\n.bottom-triangle {\n  width: 0;\n  height: 0;\n  border-bottom: 100px solid red;\n  border-right: 50px solid transparent;\n  border-left: 50px solid transparent;\n}\n```\n\n### triangle-left\n![triangle-left](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-left.jpg)\n```css\n.left-triangle {\n  width: 0;\n  height: 0;\n  border-bottom: 50px solid transparent;\n  border-top: 50px solid transparent;\n  border-left: 100px solid red;\n}\n```\n\n### triangle-right\n![triangle-right](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-right.jpg)\n```css\n.right-triangle {\n  width: 0;\n  height: 0;\n  border-bottom: 50px solid transparent;\n  border-top: 50px solid transparent;\n  border-left: 100px solid red;\n}\n```\n\n其他的三角形也就是利用border属性进行的变形。\n\n# 特殊图案\n## 跳转图标\n![border-top-left-radius](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/border-top-left-radius.png)\n```css\n.curvedarrow {\n  position: relative;\n  width: 0;\n  height: 0;\n  border-top: 26px solid transparent;\n  border-right: 26px solid red;\n  transform: rotate(10deg);\n}\n.curvedarrow:after {\n  content: \"\";\n  position: absolute;\n  border: 0 solid transparent;\n  border-top: 6px solid red;\n  border-radius: 20px 0 0 0;\n  top: -26px;\n  left: -16px;\n  width: 30px;\n  height: 30px;\n  transform: rotate(45deg);\n}\n```\n这里主要利用的属性有两个，一个是`border-radius: 20px 0 0 0;`。为什么要这样用呢？其实`border-radius`最多支持四个值：`border-top-left-radius`, `border-top-right-radius`,`border-bottom-right-radius`, and `border-bottom-left-radius`。这里我们把`border-top-left-radius`设为20px，其他的都设为0，再加上只设`border-top`的宽度，最后出来是一个尾部有弧度的长条。\n\n第二个属性则是`rotate(deg)`，将两个图形经过不同的角度旋转后再移动长条的位置进行组合，最后达到跳转箭头的图标效果。\n\n## 等腰梯形\n![trapezoid](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/trapezoid.png)\n梯形其实很好理解，通过设置border的宽度和透明度就可以形成梯形：\n```css\n.trapezoid {\n  width: 100px;\n  border-left: 30px solid transparent;\n  border-right: 30px solid transparent;\n  border-bottom: 100px solid red;\n}\n```\n\n## 平行四边形\n![parallel](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/parallel.png)\n很简单，直接利用`transform: skew(deg)`就可以得到任意角度的平行四边形：\n```css\n.parallel {\n  width: 100px;\n  height: 50px;\n  background: red;\n  transform: skew(30deg);\n}\n```\n\n## 五角星\n其原理是利用三个三角形通过旋转不同的角度和绝对定位拼接而成。\n![star-five](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-five.png)\n具体代码如下：\n```css\n.star-five {\n  margin: 50px 0;\n  position: relative;\n  display: block;\n  color: red;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(35deg);\n}\n.star-five:before {\n  border-bottom: 80px solid red;\n  border-left: 30px solid transparent;\n  border-right: 30px solid transparent;\n  position: absolute;\n  height: 0;\n  width: 0;\n  top: -45px;\n  left: -65px;\n  display: block;\n  content: '';\n  transform: rotate(-35deg);\n}\n.star-five:after {\n  position: absolute;\n  display: block;\n  color: red;\n  top: 3px;\n  left: -105px;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(-70deg);\n  content: '';\n}\n```\n\n## 六角星\n利用两个三角形拼接而成。\n![star-six](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-six.png)\n```css\n.star-six {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n  position: relative;\n}\n.star-six:after {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 100px solid red;\n  position: absolute;\n  content: \"\";\n  top: 30px;\n  left: -50px;\n}\n```\n\n## 心形\n利用两个半圆长条形状旋转一定角度后拼装成心形。\n![heart](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/heart.png)\n```css\n.heart {\n  position: relative;\n  width: 100px;\n  height: 90px;\n}\n.heart:before,\n.heart:after {\n  position: absolute;\n  content: \"\";\n  left: 50px;\n  top: 0;\n  width: 50px;\n  height: 80px;\n  background: red;\n  border-radius: 50px 50px 0 0;\n  transform: rotate(-45deg);\n  transform-origin: 0 100%;\n}\n.heart:after {\n  left: 0;\n  transform: rotate(45deg);\n  transform-origin: 100% 100%;\n}\n```\n\n## 月亮\n非常简单，利用了`box-shadow`属性，`box-shadow`一般支持四个值：`offset-x`、`offset-y`、`blur-radius`、`spread-radius`、`color`。还有一个值`inset`表示shadow是否内嵌。这里我们通过设置`border-radius`使其为圆形然后令`box-shadow`便宜一定值得到月亮形状。\n![moon](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/moon.png)\n```css\n.moon {\n  width: 100px;\n  height: 100px;\n  border-radius: 50%;\n  box-shadow: 15px 15px 0 0 red;\n}\n```\n\n## 阴阳图案\n刚一看到这个图案感觉很神奇，不知道怎么实现的，但其实很简单，分三步：\n\n首先，利用`border-width`画出一个一半深、一半浅的圆形：\n![yin-yang1](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang1.png)\n```css\n.yin-yang {\n  width: 96px;\n  box-sizing: content-box;\n  height: 48px;\n  background: #eee;\n  border-color: black;\n  border-style: solid;\n  border-width: 2px 2px 50px 2px;\n  border-radius: 100%;\n  position: relative;\n}\n```\n\n然后，利用伪元素的`content`和`border`，生成一个小铜钱然后定位到适合的位置：\n![yin-yang2](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang2.png)\n```css\n.yin-yang:before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 0;\n  background: #eee;\n  border: 18px solid black;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}\n```\n\n最后，在对称的位置上在生成一个小铜钱，颜色与之前的相反。\n![yin-yang3](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang3.png)\n```css\n.yin-yang:after {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  background: black;\n  border: 18px solid #eee;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}\n```\n\n两个一拼接，就形成了想要的阴阳图案：\n![yin-yang](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang.png)\n\n# 总结\n利用CSS，我们可以实现很多简单甚至是较复杂的图案，这样省去了切图的烦恼，还减少了http请求，资源加载速度变快，唯一不足的可能就是基本上都是用的CSS3属性，有兼容性问题。但是，既然能直接用CSS画出图案，当然是用起来！\n\n> 更多图案参见[参考资料](https://css-tricks.com/the-shapes-of-css/)","source":"_posts/2018-12-03-draw-different-shapes-with-css.md","raw":"---\ntitle: 纯CSS绘制不同的图形\ndate: 2018-12-03 20:44:19\ncategories:\n- CSS相关\ntags:\n- CSS技巧\n---\n\n为什么要用CSS绘制图形？我们知道，一般表示图案可以用`img`标签，直接用切好的图片，或者用`background`加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。\n<!--more-->\n\n这里我列举一些比较感兴趣的图形。\n\n# 基本图案\n\n## 圆形\n圆形可以说是除了方形以外最容易表达的图形了，多亏了CSS3的`border-radius`属性：\n\n### 基本圆形\n![circle](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/circle.jpg)\n```css\n.circle {\n  width: 100px;\n  height: 100px;\n  background-color: red;\n  border: 1px solid #000;\n  border-radius: 50%;\n}\n```\n\n### 椭圆形\n![oval](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/oval.jpg)\n```css\n.oval {\n  width: 50px;\n  height: 100px;\n  background-color: red;\n  border-radius: 50px / 100px;\n}\n```\n\n## 三角形\n三角形其实利用的是`border`属性，利用不同方向的`border`宽度和颜色可以展现不同的三角形。\n\n### triangle-top：\n![triangle-top](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-top.jpg)\n```css\n.top-triangle {\n  width: 0;\n  height: 0;\n  border-top: 100px solid red;\n  border-right: 50px solid transparent;\n  border-left: 50px solid transparent;\n}\n```\n\n### triangle-bottom\n![triangle-bottom](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-bottom.jpg)\n```css\n.bottom-triangle {\n  width: 0;\n  height: 0;\n  border-bottom: 100px solid red;\n  border-right: 50px solid transparent;\n  border-left: 50px solid transparent;\n}\n```\n\n### triangle-left\n![triangle-left](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-left.jpg)\n```css\n.left-triangle {\n  width: 0;\n  height: 0;\n  border-bottom: 50px solid transparent;\n  border-top: 50px solid transparent;\n  border-left: 100px solid red;\n}\n```\n\n### triangle-right\n![triangle-right](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-right.jpg)\n```css\n.right-triangle {\n  width: 0;\n  height: 0;\n  border-bottom: 50px solid transparent;\n  border-top: 50px solid transparent;\n  border-left: 100px solid red;\n}\n```\n\n其他的三角形也就是利用border属性进行的变形。\n\n# 特殊图案\n## 跳转图标\n![border-top-left-radius](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/border-top-left-radius.png)\n```css\n.curvedarrow {\n  position: relative;\n  width: 0;\n  height: 0;\n  border-top: 26px solid transparent;\n  border-right: 26px solid red;\n  transform: rotate(10deg);\n}\n.curvedarrow:after {\n  content: \"\";\n  position: absolute;\n  border: 0 solid transparent;\n  border-top: 6px solid red;\n  border-radius: 20px 0 0 0;\n  top: -26px;\n  left: -16px;\n  width: 30px;\n  height: 30px;\n  transform: rotate(45deg);\n}\n```\n这里主要利用的属性有两个，一个是`border-radius: 20px 0 0 0;`。为什么要这样用呢？其实`border-radius`最多支持四个值：`border-top-left-radius`, `border-top-right-radius`,`border-bottom-right-radius`, and `border-bottom-left-radius`。这里我们把`border-top-left-radius`设为20px，其他的都设为0，再加上只设`border-top`的宽度，最后出来是一个尾部有弧度的长条。\n\n第二个属性则是`rotate(deg)`，将两个图形经过不同的角度旋转后再移动长条的位置进行组合，最后达到跳转箭头的图标效果。\n\n## 等腰梯形\n![trapezoid](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/trapezoid.png)\n梯形其实很好理解，通过设置border的宽度和透明度就可以形成梯形：\n```css\n.trapezoid {\n  width: 100px;\n  border-left: 30px solid transparent;\n  border-right: 30px solid transparent;\n  border-bottom: 100px solid red;\n}\n```\n\n## 平行四边形\n![parallel](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/parallel.png)\n很简单，直接利用`transform: skew(deg)`就可以得到任意角度的平行四边形：\n```css\n.parallel {\n  width: 100px;\n  height: 50px;\n  background: red;\n  transform: skew(30deg);\n}\n```\n\n## 五角星\n其原理是利用三个三角形通过旋转不同的角度和绝对定位拼接而成。\n![star-five](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-five.png)\n具体代码如下：\n```css\n.star-five {\n  margin: 50px 0;\n  position: relative;\n  display: block;\n  color: red;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(35deg);\n}\n.star-five:before {\n  border-bottom: 80px solid red;\n  border-left: 30px solid transparent;\n  border-right: 30px solid transparent;\n  position: absolute;\n  height: 0;\n  width: 0;\n  top: -45px;\n  left: -65px;\n  display: block;\n  content: '';\n  transform: rotate(-35deg);\n}\n.star-five:after {\n  position: absolute;\n  display: block;\n  color: red;\n  top: 3px;\n  left: -105px;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(-70deg);\n  content: '';\n}\n```\n\n## 六角星\n利用两个三角形拼接而成。\n![star-six](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-six.png)\n```css\n.star-six {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n  position: relative;\n}\n.star-six:after {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 100px solid red;\n  position: absolute;\n  content: \"\";\n  top: 30px;\n  left: -50px;\n}\n```\n\n## 心形\n利用两个半圆长条形状旋转一定角度后拼装成心形。\n![heart](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/heart.png)\n```css\n.heart {\n  position: relative;\n  width: 100px;\n  height: 90px;\n}\n.heart:before,\n.heart:after {\n  position: absolute;\n  content: \"\";\n  left: 50px;\n  top: 0;\n  width: 50px;\n  height: 80px;\n  background: red;\n  border-radius: 50px 50px 0 0;\n  transform: rotate(-45deg);\n  transform-origin: 0 100%;\n}\n.heart:after {\n  left: 0;\n  transform: rotate(45deg);\n  transform-origin: 100% 100%;\n}\n```\n\n## 月亮\n非常简单，利用了`box-shadow`属性，`box-shadow`一般支持四个值：`offset-x`、`offset-y`、`blur-radius`、`spread-radius`、`color`。还有一个值`inset`表示shadow是否内嵌。这里我们通过设置`border-radius`使其为圆形然后令`box-shadow`便宜一定值得到月亮形状。\n![moon](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/moon.png)\n```css\n.moon {\n  width: 100px;\n  height: 100px;\n  border-radius: 50%;\n  box-shadow: 15px 15px 0 0 red;\n}\n```\n\n## 阴阳图案\n刚一看到这个图案感觉很神奇，不知道怎么实现的，但其实很简单，分三步：\n\n首先，利用`border-width`画出一个一半深、一半浅的圆形：\n![yin-yang1](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang1.png)\n```css\n.yin-yang {\n  width: 96px;\n  box-sizing: content-box;\n  height: 48px;\n  background: #eee;\n  border-color: black;\n  border-style: solid;\n  border-width: 2px 2px 50px 2px;\n  border-radius: 100%;\n  position: relative;\n}\n```\n\n然后，利用伪元素的`content`和`border`，生成一个小铜钱然后定位到适合的位置：\n![yin-yang2](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang2.png)\n```css\n.yin-yang:before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 0;\n  background: #eee;\n  border: 18px solid black;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}\n```\n\n最后，在对称的位置上在生成一个小铜钱，颜色与之前的相反。\n![yin-yang3](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang3.png)\n```css\n.yin-yang:after {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  background: black;\n  border: 18px solid #eee;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}\n```\n\n两个一拼接，就形成了想要的阴阳图案：\n![yin-yang](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang.png)\n\n# 总结\n利用CSS，我们可以实现很多简单甚至是较复杂的图案，这样省去了切图的烦恼，还减少了http请求，资源加载速度变快，唯一不足的可能就是基本上都是用的CSS3属性，有兼容性问题。但是，既然能直接用CSS画出图案，当然是用起来！\n\n> 更多图案参见[参考资料](https://css-tricks.com/the-shapes-of-css/)","slug":"draw-different-shapes-with-css","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d20029ra4kdzs079j1","content":"<p>为什么要用CSS绘制图形？我们知道，一般表示图案可以用<code>img</code>标签，直接用切好的图片，或者用<code>background</code>加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。</p>\n<span id=\"more\"></span>\n\n<p>这里我列举一些比较感兴趣的图形。</p>\n<h1 id=\"基本图案\"><a href=\"#基本图案\" class=\"headerlink\" title=\"基本图案\"></a>基本图案</h1><h2 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h2><p>圆形可以说是除了方形以外最容易表达的图形了，多亏了CSS3的<code>border-radius</code>属性：</p>\n<h3 id=\"基本圆形\"><a href=\"#基本圆形\" class=\"headerlink\" title=\"基本圆形\"></a>基本圆形</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/circle.jpg\" alt=\"circle\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"椭圆形\"><a href=\"#椭圆形\" class=\"headerlink\" title=\"椭圆形\"></a>椭圆形</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/oval.jpg\" alt=\"oval\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.oval</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50px</span> / <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三角形\"><a href=\"#三角形\" class=\"headerlink\" title=\"三角形\"></a>三角形</h2><p>三角形其实利用的是<code>border</code>属性，利用不同方向的<code>border</code>宽度和颜色可以展现不同的三角形。</p>\n<h3 id=\"triangle-top：\"><a href=\"#triangle-top：\" class=\"headerlink\" title=\"triangle-top：\"></a>triangle-top：</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-top.jpg\" alt=\"triangle-top\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.top-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"triangle-bottom\"><a href=\"#triangle-bottom\" class=\"headerlink\" title=\"triangle-bottom\"></a>triangle-bottom</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-bottom.jpg\" alt=\"triangle-bottom\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bottom-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"triangle-left\"><a href=\"#triangle-left\" class=\"headerlink\" title=\"triangle-left\"></a>triangle-left</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-left.jpg\" alt=\"triangle-left\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"triangle-right\"><a href=\"#triangle-right\" class=\"headerlink\" title=\"triangle-right\"></a>triangle-right</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-right.jpg\" alt=\"triangle-right\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.right-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的三角形也就是利用border属性进行的变形。</p>\n<h1 id=\"特殊图案\"><a href=\"#特殊图案\" class=\"headerlink\" title=\"特殊图案\"></a>特殊图案</h1><h2 id=\"跳转图标\"><a href=\"#跳转图标\" class=\"headerlink\" title=\"跳转图标\"></a>跳转图标</h2><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/border-top-left-radius.png\" alt=\"border-top-left-radius\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.curvedarrow</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">26px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">26px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">10deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.curvedarrow</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">0</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">6px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">20px</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">26px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">16px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里主要利用的属性有两个，一个是<code>border-radius: 20px 0 0 0;</code>。为什么要这样用呢？其实<code>border-radius</code>最多支持四个值：<code>border-top-left-radius</code>, <code>border-top-right-radius</code>,<code>border-bottom-right-radius</code>, and <code>border-bottom-left-radius</code>。这里我们把<code>border-top-left-radius</code>设为20px，其他的都设为0，再加上只设<code>border-top</code>的宽度，最后出来是一个尾部有弧度的长条。</p>\n<p>第二个属性则是<code>rotate(deg)</code>，将两个图形经过不同的角度旋转后再移动长条的位置进行组合，最后达到跳转箭头的图标效果。</p>\n<h2 id=\"等腰梯形\"><a href=\"#等腰梯形\" class=\"headerlink\" title=\"等腰梯形\"></a>等腰梯形</h2><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/trapezoid.png\" alt=\"trapezoid\"><br>梯形其实很好理解，通过设置border的宽度和透明度就可以形成梯形：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.trapezoid</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"平行四边形\"><a href=\"#平行四边形\" class=\"headerlink\" title=\"平行四边形\"></a>平行四边形</h2><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/parallel.png\" alt=\"parallel\"><br>很简单，直接利用<code>transform: skew(deg)</code>就可以得到任意角度的平行四边形：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parallel</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(<span class=\"number\">30deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五角星\"><a href=\"#五角星\" class=\"headerlink\" title=\"五角星\"></a>五角星</h2><p>其原理是利用三个三角形通过旋转不同的角度和绝对定位拼接而成。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-five.png\" alt=\"star-five\"><br>具体代码如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.star-five</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">50px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">70px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">35deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.star-five</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">80px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">45px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">65px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">35deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.star-five</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">105px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">70px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">70deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六角星\"><a href=\"#六角星\" class=\"headerlink\" title=\"六角星\"></a>六角星</h2><p>利用两个三角形拼接而成。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-six.png\" alt=\"star-six\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.star-six</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.star-six</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"心形\"><a href=\"#心形\" class=\"headerlink\" title=\"心形\"></a>心形</h2><p>利用两个半圆长条形状旋转一定角度后拼装成心形。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/heart.png\" alt=\"heart\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.heart</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">90px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.heart</span><span class=\"selector-pseudo\">:before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.heart</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">80px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">45deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.heart</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"月亮\"><a href=\"#月亮\" class=\"headerlink\" title=\"月亮\"></a>月亮</h2><p>非常简单，利用了<code>box-shadow</code>属性，<code>box-shadow</code>一般支持四个值：<code>offset-x</code>、<code>offset-y</code>、<code>blur-radius</code>、<code>spread-radius</code>、<code>color</code>。还有一个值<code>inset</code>表示shadow是否内嵌。这里我们通过设置<code>border-radius</code>使其为圆形然后令<code>box-shadow</code>便宜一定值得到月亮形状。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/moon.png\" alt=\"moon\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.moon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">15px</span> <span class=\"number\">15px</span> <span class=\"number\">0</span> <span class=\"number\">0</span> red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"阴阳图案\"><a href=\"#阴阳图案\" class=\"headerlink\" title=\"阴阳图案\"></a>阴阳图案</h2><p>刚一看到这个图案感觉很神奇，不知道怎么实现的，但其实很简单，分三步：</p>\n<p>首先，利用<code>border-width</code>画出一个一半深、一半浅的圆形：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang1.png\" alt=\"yin-yang1\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.yin-yang</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">96px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">48px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: black;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">50px</span> <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，利用伪元素的<code>content</code>和<code>border</code>，生成一个小铜钱然后定位到适合的位置：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang2.png\" alt=\"yin-yang2\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.yin-yang</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">18px</span> solid black;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在对称的位置上在生成一个小铜钱，颜色与之前的相反。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang3.png\" alt=\"yin-yang3\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.yin-yang</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">18px</span> solid <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个一拼接，就形成了想要的阴阳图案：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang.png\" alt=\"yin-yang\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>利用CSS，我们可以实现很多简单甚至是较复杂的图案，这样省去了切图的烦恼，还减少了http请求，资源加载速度变快，唯一不足的可能就是基本上都是用的CSS3属性，有兼容性问题。但是，既然能直接用CSS画出图案，当然是用起来！</p>\n<blockquote>\n<p>更多图案参见<a href=\"https://css-tricks.com/the-shapes-of-css/\">参考资料</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>为什么要用CSS绘制图形？我们知道，一般表示图案可以用<code>img</code>标签，直接用切好的图片，或者用<code>background</code>加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。</p>","more":"<p>这里我列举一些比较感兴趣的图形。</p>\n<h1 id=\"基本图案\"><a href=\"#基本图案\" class=\"headerlink\" title=\"基本图案\"></a>基本图案</h1><h2 id=\"圆形\"><a href=\"#圆形\" class=\"headerlink\" title=\"圆形\"></a>圆形</h2><p>圆形可以说是除了方形以外最容易表达的图形了，多亏了CSS3的<code>border-radius</code>属性：</p>\n<h3 id=\"基本圆形\"><a href=\"#基本圆形\" class=\"headerlink\" title=\"基本圆形\"></a>基本圆形</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/circle.jpg\" alt=\"circle\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.circle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"椭圆形\"><a href=\"#椭圆形\" class=\"headerlink\" title=\"椭圆形\"></a>椭圆形</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/oval.jpg\" alt=\"oval\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.oval</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50px</span> / <span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三角形\"><a href=\"#三角形\" class=\"headerlink\" title=\"三角形\"></a>三角形</h2><p>三角形其实利用的是<code>border</code>属性，利用不同方向的<code>border</code>宽度和颜色可以展现不同的三角形。</p>\n<h3 id=\"triangle-top：\"><a href=\"#triangle-top：\" class=\"headerlink\" title=\"triangle-top：\"></a>triangle-top：</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-top.jpg\" alt=\"triangle-top\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.top-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"triangle-bottom\"><a href=\"#triangle-bottom\" class=\"headerlink\" title=\"triangle-bottom\"></a>triangle-bottom</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-bottom.jpg\" alt=\"triangle-bottom\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.bottom-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"triangle-left\"><a href=\"#triangle-left\" class=\"headerlink\" title=\"triangle-left\"></a>triangle-left</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-left.jpg\" alt=\"triangle-left\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.left-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"triangle-right\"><a href=\"#triangle-right\" class=\"headerlink\" title=\"triangle-right\"></a>triangle-right</h3><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-right.jpg\" alt=\"triangle-right\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.right-triangle</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他的三角形也就是利用border属性进行的变形。</p>\n<h1 id=\"特殊图案\"><a href=\"#特殊图案\" class=\"headerlink\" title=\"特殊图案\"></a>特殊图案</h1><h2 id=\"跳转图标\"><a href=\"#跳转图标\" class=\"headerlink\" title=\"跳转图标\"></a>跳转图标</h2><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/border-top-left-radius.png\" alt=\"border-top-left-radius\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.curvedarrow</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">26px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">26px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">10deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.curvedarrow</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">0</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">6px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">20px</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">26px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">16px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里主要利用的属性有两个，一个是<code>border-radius: 20px 0 0 0;</code>。为什么要这样用呢？其实<code>border-radius</code>最多支持四个值：<code>border-top-left-radius</code>, <code>border-top-right-radius</code>,<code>border-bottom-right-radius</code>, and <code>border-bottom-left-radius</code>。这里我们把<code>border-top-left-radius</code>设为20px，其他的都设为0，再加上只设<code>border-top</code>的宽度，最后出来是一个尾部有弧度的长条。</p>\n<p>第二个属性则是<code>rotate(deg)</code>，将两个图形经过不同的角度旋转后再移动长条的位置进行组合，最后达到跳转箭头的图标效果。</p>\n<h2 id=\"等腰梯形\"><a href=\"#等腰梯形\" class=\"headerlink\" title=\"等腰梯形\"></a>等腰梯形</h2><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/trapezoid.png\" alt=\"trapezoid\"><br>梯形其实很好理解，通过设置border的宽度和透明度就可以形成梯形：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.trapezoid</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"平行四边形\"><a href=\"#平行四边形\" class=\"headerlink\" title=\"平行四边形\"></a>平行四边形</h2><p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/parallel.png\" alt=\"parallel\"><br>很简单，直接利用<code>transform: skew(deg)</code>就可以得到任意角度的平行四边形：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.parallel</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">skew</span>(<span class=\"number\">30deg</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五角星\"><a href=\"#五角星\" class=\"headerlink\" title=\"五角星\"></a>五角星</h2><p>其原理是利用三个三角形通过旋转不同的角度和绝对定位拼接而成。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-five.png\" alt=\"star-five\"><br>具体代码如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.star-five</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">50px</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">70px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">35deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.star-five</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">80px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">30px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: -<span class=\"number\">45px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">65px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">35deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.star-five</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">3px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">105px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">70px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">100px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">70deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六角星\"><a href=\"#六角星\" class=\"headerlink\" title=\"六角星\"></a>六角星</h2><p>利用两个三角形拼接而成。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-six.png\" alt=\"star-six\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.star-six</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.star-six</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-right</span>: <span class=\"number\">50px</span> solid transparent;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">100px</span> solid red;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: -<span class=\"number\">50px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"心形\"><a href=\"#心形\" class=\"headerlink\" title=\"心形\"></a>心形</h2><p>利用两个半圆长条形状旋转一定角度后拼装成心形。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/heart.png\" alt=\"heart\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.heart</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">90px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.heart</span><span class=\"selector-pseudo\">:before</span>,</span><br><span class=\"line\"><span class=\"selector-class\">.heart</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">80px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50px</span> <span class=\"number\">50px</span> <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(-<span class=\"number\">45deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.heart</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(<span class=\"number\">45deg</span>);</span><br><span class=\"line\">  <span class=\"attribute\">transform-origin</span>: <span class=\"number\">100%</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"月亮\"><a href=\"#月亮\" class=\"headerlink\" title=\"月亮\"></a>月亮</h2><p>非常简单，利用了<code>box-shadow</code>属性，<code>box-shadow</code>一般支持四个值：<code>offset-x</code>、<code>offset-y</code>、<code>blur-radius</code>、<code>spread-radius</code>、<code>color</code>。还有一个值<code>inset</code>表示shadow是否内嵌。这里我们通过设置<code>border-radius</code>使其为圆形然后令<code>box-shadow</code>便宜一定值得到月亮形状。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/moon.png\" alt=\"moon\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.moon</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">15px</span> <span class=\"number\">15px</span> <span class=\"number\">0</span> <span class=\"number\">0</span> red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"阴阳图案\"><a href=\"#阴阳图案\" class=\"headerlink\" title=\"阴阳图案\"></a>阴阳图案</h2><p>刚一看到这个图案感觉很神奇，不知道怎么实现的，但其实很简单，分三步：</p>\n<p>首先，利用<code>border-width</code>画出一个一半深、一半浅的圆形：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang1.png\" alt=\"yin-yang1\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.yin-yang</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">96px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">48px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-color</span>: black;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: solid;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">50px</span> <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，利用伪元素的<code>content</code>和<code>border</code>，生成一个小铜钱然后定位到适合的位置：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang2.png\" alt=\"yin-yang2\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.yin-yang</span><span class=\"selector-pseudo\">:before</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">18px</span> solid black;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，在对称的位置上在生成一个小铜钱，颜色与之前的相反。<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang3.png\" alt=\"yin-yang3\"></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.yin-yang</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">18px</span> solid <span class=\"number\">#eee</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个一拼接，就形成了想要的阴阳图案：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang.png\" alt=\"yin-yang\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>利用CSS，我们可以实现很多简单甚至是较复杂的图案，这样省去了切图的烦恼，还减少了http请求，资源加载速度变快，唯一不足的可能就是基本上都是用的CSS3属性，有兼容性问题。但是，既然能直接用CSS画出图案，当然是用起来！</p>\n<blockquote>\n<p>更多图案参见<a href=\"https://css-tricks.com/the-shapes-of-css/\">参考资料</a></p>\n</blockquote>"},{"title":"点击按钮粘贴所选内容到剪贴板","date":"2018-12-04T13:13:09.000Z","_content":"\n我们经常可以看到这样的功能，点击某个按钮可以自动复制想要的内容到剪贴板。比如说某个图片、视频的地址，某个输入的内容，我们有的时候懒得去用键盘鼠标选中某个区域，希望只用点击一下，就能复制想要的内容。\n<!--more -->\n# 代码实现\n其实这个用原生JS实现难度不大，主要用到的是`document.execCommand()`。代码如下：\n\n```javascript\nfunction copy(e) {\n    let transfer = document.createElement('input');\n    document.body.appendChild(transfer);\n    transfer.value = target.value;  // 这里表示想要复制的内容\n    transfer.focus();\n    transfer.select();\n    if (document.execCommand('copy')) {\n        document.execCommand('copy');\n    }\n    transfer.blur();\n    console.log('复制成功');\n    document.body.removeChild(transfer);\n    \n}\n\n$('#copyBtn').addEventListener('click', copy);\n```\n\n这里我们其实就是新创建了一个`input`DOM元素，然后选中该元素，把要复制的内容赋给`input.value`，这个时候执行`document.execCommand('copy')`，会把当前页面所有选中的内容复制到剪贴板，也就实现了复制的操作，最后再把新建的DOM元素移除，在不影响DOM树的情况下达到复制的目的。\n\n# 总结\n```document.execCommand()``` 方法可以使当前选中的可编辑内容实现一些常用的操作，如copy、cut、paste、delete、contentReadOnly等等，具体请看[document.execCommand](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand)，但个人感觉一般最好不要去用里面的一些操作，因为这样可能会和用户的交互操作产生冲突，发生意想不到的结果。但是`document.execCommand`在富文本编辑器里又是个神器，值得之后慢慢研究。","source":"_posts/2018-12-04-copy-to-clipboard.md","raw":"---\ntitle: 点击按钮粘贴所选内容到剪贴板\ndate: 2018-12-04 21:13:09\ncategories:\n- JS相关\ntags:\n- JS技巧\n---\n\n我们经常可以看到这样的功能，点击某个按钮可以自动复制想要的内容到剪贴板。比如说某个图片、视频的地址，某个输入的内容，我们有的时候懒得去用键盘鼠标选中某个区域，希望只用点击一下，就能复制想要的内容。\n<!--more -->\n# 代码实现\n其实这个用原生JS实现难度不大，主要用到的是`document.execCommand()`。代码如下：\n\n```javascript\nfunction copy(e) {\n    let transfer = document.createElement('input');\n    document.body.appendChild(transfer);\n    transfer.value = target.value;  // 这里表示想要复制的内容\n    transfer.focus();\n    transfer.select();\n    if (document.execCommand('copy')) {\n        document.execCommand('copy');\n    }\n    transfer.blur();\n    console.log('复制成功');\n    document.body.removeChild(transfer);\n    \n}\n\n$('#copyBtn').addEventListener('click', copy);\n```\n\n这里我们其实就是新创建了一个`input`DOM元素，然后选中该元素，把要复制的内容赋给`input.value`，这个时候执行`document.execCommand('copy')`，会把当前页面所有选中的内容复制到剪贴板，也就实现了复制的操作，最后再把新建的DOM元素移除，在不影响DOM树的情况下达到复制的目的。\n\n# 总结\n```document.execCommand()``` 方法可以使当前选中的可编辑内容实现一些常用的操作，如copy、cut、paste、delete、contentReadOnly等等，具体请看[document.execCommand](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand)，但个人感觉一般最好不要去用里面的一些操作，因为这样可能会和用户的交互操作产生冲突，发生意想不到的结果。但是`document.execCommand`在富文本编辑器里又是个神器，值得之后慢慢研究。","slug":"copy-to-clipboard","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d3002dra4kc92w0qyf","content":"<p>我们经常可以看到这样的功能，点击某个按钮可以自动复制想要的内容到剪贴板。比如说某个图片、视频的地址，某个输入的内容，我们有的时候懒得去用键盘鼠标选中某个区域，希望只用点击一下，就能复制想要的内容。</p>\n<span id=\"more\"></span>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><p>其实这个用原生JS实现难度不大，主要用到的是<code>document.execCommand()</code>。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">copy</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> transfer = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;input&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(transfer);</span><br><span class=\"line\">    transfer.<span class=\"property\">value</span> = target.<span class=\"property\">value</span>;  <span class=\"comment\">// 这里表示想要复制的内容</span></span><br><span class=\"line\">    transfer.<span class=\"title function_\">focus</span>();</span><br><span class=\"line\">    transfer.<span class=\"title function_\">select</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    transfer.<span class=\"title function_\">blur</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(transfer);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">&#x27;#copyBtn&#x27;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, copy);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们其实就是新创建了一个<code>input</code>DOM元素，然后选中该元素，把要复制的内容赋给<code>input.value</code>，这个时候执行<code>document.execCommand(&#39;copy&#39;)</code>，会把当前页面所有选中的内容复制到剪贴板，也就实现了复制的操作，最后再把新建的DOM元素移除，在不影响DOM树的情况下达到复制的目的。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><code>document.execCommand()</code> 方法可以使当前选中的可编辑内容实现一些常用的操作，如copy、cut、paste、delete、contentReadOnly等等，具体请看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand\">document.execCommand</a>，但个人感觉一般最好不要去用里面的一些操作，因为这样可能会和用户的交互操作产生冲突，发生意想不到的结果。但是<code>document.execCommand</code>在富文本编辑器里又是个神器，值得之后慢慢研究。</p>\n","site":{"data":{}},"excerpt":"<p>我们经常可以看到这样的功能，点击某个按钮可以自动复制想要的内容到剪贴板。比如说某个图片、视频的地址，某个输入的内容，我们有的时候懒得去用键盘鼠标选中某个区域，希望只用点击一下，就能复制想要的内容。</p>","more":"<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><p>其实这个用原生JS实现难度不大，主要用到的是<code>document.execCommand()</code>。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">copy</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> transfer = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;input&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">appendChild</span>(transfer);</span><br><span class=\"line\">    transfer.<span class=\"property\">value</span> = target.<span class=\"property\">value</span>;  <span class=\"comment\">// 这里表示想要复制的内容</span></span><br><span class=\"line\">    transfer.<span class=\"title function_\">focus</span>();</span><br><span class=\"line\">    transfer.<span class=\"title function_\">select</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">document</span>.<span class=\"title function_\">execCommand</span>(<span class=\"string\">&#x27;copy&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    transfer.<span class=\"title function_\">blur</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;复制成功&#x27;</span>);</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"title function_\">removeChild</span>(transfer);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">&#x27;#copyBtn&#x27;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, copy);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们其实就是新创建了一个<code>input</code>DOM元素，然后选中该元素，把要复制的内容赋给<code>input.value</code>，这个时候执行<code>document.execCommand(&#39;copy&#39;)</code>，会把当前页面所有选中的内容复制到剪贴板，也就实现了复制的操作，最后再把新建的DOM元素移除，在不影响DOM树的情况下达到复制的目的。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><code>document.execCommand()</code> 方法可以使当前选中的可编辑内容实现一些常用的操作，如copy、cut、paste、delete、contentReadOnly等等，具体请看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand\">document.execCommand</a>，但个人感觉一般最好不要去用里面的一些操作，因为这样可能会和用户的交互操作产生冲突，发生意想不到的结果。但是<code>document.execCommand</code>在富文本编辑器里又是个神器，值得之后慢慢研究。</p>"},{"title":"实现基于codemirror的markdown编辑器(一)","date":"2018-12-15T14:23:57.000Z","toc":true,"_content":"\n我们知道，要实现一个Markdown编辑器，一般会想要实现这样的功能：实时预览、同步滚动、支持标签按钮添加、markdown语法高亮等等。那么如何去实现一个功能比较完整的markdown编辑器呢？\n\n首先这里我们只讨论web端，其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，很多都可以拿来直接用，满足基本需求足够了。但是作为前端程序员来说，当然想要实现一个自己定制化的markdown编辑器比较有意思，不过通过查阅资料文档和各种框架比较，发现也不是那么容易的事。\n<!--more-->\n# 框架选择\n要实现一个markdown编辑器，首先得找到一个合适的框架，目前市面上优秀的markdown框架五花八门。由于现在自己写的项目一般都使用React，所以理所当然能找到一个比较契合React的Markdown框架是更好的。\n\n经过前期调研，发现有几款基于React的Markdown框架还不错，[react-quill](https://zenoamaro.github.io/react-quill/)、facebook的[draft](https://draftjs.org/docs/getting-started.html)、[react-codemirror2](https://github.com/scniro/react-codemirror2)，但它们其实都是富文本编辑器，定制的东西已经很完善了，我想要的框架是可支持自定义扩展，定制化自己想要的功能，找来找去，最后决定基于[CodeMirror](https://codemirror.net/doc/manual.html#api)来自己实现一个定制化的markdown编辑器。因为CodeMirror其实相当于一个基础的框架，它有很多可配置项，可以自己添加工具栏，添加各种实用功能，这正好满足了我的需求，于是就决定用它了！\n\n# CodeMirror\n现代很多编辑器其实都基于`codemirror`，为什么要选择它呢？这都得益于它强大的API和配置项，在不失基本功能的同时给予了开发者极大的定制空间，开发者可以基于它开发出各种功能的markdown编辑器。这里我先简单介绍一下codemirror的一些基本操作。想要了解更多有关codemirror，可以去看[官方文档](https://codemirror.net/doc/manual.html)。\n\n## 如何加载codemirror\n一般我们在项目里npm下载完codemirror包后，在代码里引入`codemirror.js`，而且还会根据需要引入想要的语言模式包：\n```js\nimport * as CM from 'codemirror';\n\nimport 'codemirror/mode/xml/xml';\nimport 'codemirror/mode/markdown/markdown';\nimport 'codemirror/addon/edit/continuelist';\n```\n\n当然，我们还得在html里引入`codemirror.css`样式，也可以自己修改成想要的样式。\n\n然后，在需要加载的地方写html标签，id为`codemirror`，这里我们用的是JSX：\n```jsx\n<div className=\"editor-root\" ref={(elem) => { this.editRoot = elem; }}>\n  <textarea id=\"codemirror\" name={this.props.path} autoComplete=\"off\" />\n</div>\n```\n我在`textarea`外面用div包了一层，是为了方便之后的滚动效果。这样，我们就已经可以使用codemirror写一个markdown编辑器了。\n\n## options 可以使用的参数\n  CodeMirror函数和它的fromTextArea方法都可以使用一个配置对象作为第二个参数。这个options极为重要，基本就决定了你的编辑器主要的输入语言、样式、内容。这里列一下它几个常用的可选的参数：\n- value: string | CodeMirror.Doc\n  编辑器的初始值（文本），可以是字符串或者CodeMirror文档对象(不同于HTML文档对象)。\n- mode: string | object\n  通用的或者在CodeMirror中使用的与mode相关联的mime，当不设置这个值的时候，会默认使用第一个载入的mode定义文件。一般地，会使用关联的mime类型来设置这个值；除此之外，也可以使用一个带有name属性的对象来作为值（如：{name: “javascript”, json: true}）。可以通过访问CodeMirror.modes和CodeMirror.mimeModes获取定义的mode和MIME。\n- lineSeparator: string|null\n  明确指定编辑器使用的行分割符（换行符）。默认（值为null）情况下，文档会被 CRLF(以及单独的CR, LF)分割，单独的LF会在所有的输出中用作换行符（如：getValue）。当指定了换行字符串，行就只会被指定的串分割。\n- theme: string\n  配置编辑器的主题样式。要使用主题，必须保证名称为 .cm-s-[name] (name是设置的theme的值)的样式是加载上了的。当然，你也可以一次加载多个主题样式，使用方法和html和使用类一样，如： theme: foo bar，那么此时需要cm-s-foo cm-s-bar这两个样式都已经被加载上了。\n- indentUnit: integer\n  缩进单位，值为空格数，默认为2 。\n- smartIndent: boolean\n  自动缩进，设置是否根据上下文自动缩进（和上一行相同的缩进量）。默认为true。\n- tabSize: integer\n  tab字符的宽度，默认为4 。\n- indentWithTabs: boolean\n  在缩进时，是否需要把 n*tab宽度个空格替换成n个tab字符，默认为false 。\n- electricChars: boolean\n  在输入可能改变当前的缩进时，是否重新缩进，默认为true （仅在mode支持缩进时有效）。\n- keyMap: string\n  配置快捷键。默认值为default，即 codemorrir.js 内部定义。其它在key map目录下。\n- extraKeys: object\n  给编辑器绑定与前面keyMap配置不同的快捷键。\n- lineWrapping: boolean\n  在长行时文字是换行(wrap)还是滚动(scroll)，默认为滚动(scroll)。\n- lineNumbers: boolean\n  是否在编辑器左侧显示行号。\n- firstLineNumber: integer\n  行号从哪个数开始计数，默认为1 。\n- lineNumberFormatter: function(line: integer) → string\n  使用一个函数设置行号。\n- scrollbarStyle: string\n  设置滚动条。默认为”native”，显示原生的滚动条。核心库还提供了”null”样式，此样式会完全隐藏滚动条。Addons可以设置更多的滚动条模式。\n- inputStyle: string\n  选择CodeMirror处理输入和焦点的方式。核心库定义了textarea和contenteditable输入模式。在移动浏览器上，默认是contenteditable，在桌面浏览器上，默认是textarea。在contenteditable模式下对IME和屏幕阅读器支持更好。\n- readOnly: boolean|string\n  编辑器是否只读。如果设置为预设的值 “nocursor”，那么除了设置只读外，编辑区域还不能获得焦点。\n- showCursorWhenSelecting: boolean\n  在选择时是否显示光标，默认为false。\n- autofocus: boolean\n  是否在初始化时自动获取焦点。默认情况是关闭的。但是，在使用textarea并且没有明确指定值的时候会被自动设置为true。\n\n更多的配置请查看[相关文档](https://codemirror.net/doc/manual.html#config)。\n\n# 实时预览\n这个需求可以说是现代markdown编辑器的基本需求，因为markdown写起来本身是没有任何样式的，纯文本的话对于有些人来说不能看到最终效果就很不习惯，自己写的效果怎么样都不知道，写的心里就会很没底（当然再花哨的样式最后还是要看内容好不好）。说白了，实时预览更多是写作时一个心理上的满足，这对于写作体验的提升来说是必不可少的。\n\n这里的markdown渲染引擎我直接用了比较受欢迎的[`marked`](https://marked.js.org/#/README.md#README.md)库，其实markdown渲染是很考验技术的一门活，绝大部分都是用正则匹配来进行标签的替换，但由于markdown的语法相对还是较多的，要自己写一个markdown渲染引擎还是有点难度的，考虑到时间因素所以一般都会用现成的库，当然以后有时间的话我也会考虑写一个markdown渲染引擎玩玩。\n\n这里我因为是用`React`写的markdown组件，下面我就简单的介绍下如何实现实时预览。\n\n首先在组件渲染完后，我们在`componentDidMount`函数里对codemirror进行事件监听：\n```js\ncomponentDidMount () {\n  // 因为需要使用fromTextArea获取options，所以采用document.getElementById\n  this.codeMirror = CM.fromTextArea(ReactDOM.findDOMNode(document.getElementById('codemirror')), this.getOptions());\n  this.props.init(this.editRoot, this.codeMirror);\n  this.codeMirror.setValue(this.props.defaultValue);\n  this.codeMirror.on('change', this.codemirrorValueChanged);\n  this._currentCodemirrorValue = this.props.defaultValue;\n}\n```\n这里我们使用`fromTextArea`获取codemirror的dom节点，它支持两个参数，第一个是codemirror所挂载的dom节点，第二个是配置的options。\n\n之后调用init函数，这里之后会讲。然后就是初始值设置`codemirror.setValue(defaultValue)`，因为是编辑器，如果想对之前的文档进行修改，肯定需要传入初始值。\n\n然后就是关键的监听事件`change`，当输入变化时调用`this.codemirrorValueChanged`事件：\n```js\ncodemirrorValueChanged = (cm) => {\n  const newValue = cm.getValue();\n  this._currentCodemirrorValue = cm.getValue();\n  this.props.onChange && this.props.onChange(newValue);\n}\n```\n这里说下，我们通过`cm.getValue()`获取当前输入的值，然后通过调用`props.onChange(newValue)`将值抛给父组件处理。因为这里我想把编辑部分和预览部分分开来做成两个公共组件，这样组件复用性更强，有的可能只需要编辑功能，有的只需要预览展示功能。\n那么在父组件里，我们需要对`onChange`事件传入的值进行处理，将其渲染成html然后展示出来，其实很简单：\n```jsx\nclass MarkdownEditor extends Component {\n  //...\n\n  handleEditChange = (newCode) => {\n    this.props.renderMarkdown && this.props.renderMarkdown(newCode);\n    this.setState({\n      code: newCode,\n      hasChanged: true\n    });\n  }\n  debounceEditChange = debounce(this.handleEditChange, 500);\n  // ...\n  render() {\n    const preview = marked(this.state.code);\n    return (\n      <div>\n        <MyEditor\n          defaultValue={this.state.code}\n          onChange={this.debounceEditChange}\n        />\n        <div className=\"md-preview-container\">\n          <div className=\"preview-content\" dangerouslySetInnerHTML={{__html: preview}}/>\n        </div>\n      </div>\n    );\n  }\n}\n```\n这里要注意的是，我用到了`debounce`函数进行延迟处理：\n```js\nfunction debounce (fn, delay = 20) {\n  let timeout;\n\n  return function (...args) {\n    const self = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.call(self, ...args);\n    }, delay);\n  }\n}\n```\n因为考虑到性能原因，如果输入过快的话，`change`事件频繁触发，预览页面不断重绘，性能损耗十分严重，所以我用到了`debounce`，并设置延迟时间500毫秒，当然可以更短，这里我觉得设置500毫秒已经足够了。这样就达到了实时预览的效果。\n\n# 总结\n基于codemirror的markdown编辑器实现起来其实还有很多坑，本篇先介绍了`codemirror`的一些基本配置和如何实现markdown实时预览，接下来我将进一步介绍如何实现同屏滚动和自定义标签按钮等其他功能。\n","source":"_posts/2018-12-15-codemirror-markdown-editor-chapter1.md","raw":"---\ntitle: 实现基于codemirror的markdown编辑器(一)\ndate: 2018-12-15 22:23:57\ntoc: true\ncategories:\n- JS相关\ntags:\n- 编辑器\n- markdown\n---\n\n我们知道，要实现一个Markdown编辑器，一般会想要实现这样的功能：实时预览、同步滚动、支持标签按钮添加、markdown语法高亮等等。那么如何去实现一个功能比较完整的markdown编辑器呢？\n\n首先这里我们只讨论web端，其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，很多都可以拿来直接用，满足基本需求足够了。但是作为前端程序员来说，当然想要实现一个自己定制化的markdown编辑器比较有意思，不过通过查阅资料文档和各种框架比较，发现也不是那么容易的事。\n<!--more-->\n# 框架选择\n要实现一个markdown编辑器，首先得找到一个合适的框架，目前市面上优秀的markdown框架五花八门。由于现在自己写的项目一般都使用React，所以理所当然能找到一个比较契合React的Markdown框架是更好的。\n\n经过前期调研，发现有几款基于React的Markdown框架还不错，[react-quill](https://zenoamaro.github.io/react-quill/)、facebook的[draft](https://draftjs.org/docs/getting-started.html)、[react-codemirror2](https://github.com/scniro/react-codemirror2)，但它们其实都是富文本编辑器，定制的东西已经很完善了，我想要的框架是可支持自定义扩展，定制化自己想要的功能，找来找去，最后决定基于[CodeMirror](https://codemirror.net/doc/manual.html#api)来自己实现一个定制化的markdown编辑器。因为CodeMirror其实相当于一个基础的框架，它有很多可配置项，可以自己添加工具栏，添加各种实用功能，这正好满足了我的需求，于是就决定用它了！\n\n# CodeMirror\n现代很多编辑器其实都基于`codemirror`，为什么要选择它呢？这都得益于它强大的API和配置项，在不失基本功能的同时给予了开发者极大的定制空间，开发者可以基于它开发出各种功能的markdown编辑器。这里我先简单介绍一下codemirror的一些基本操作。想要了解更多有关codemirror，可以去看[官方文档](https://codemirror.net/doc/manual.html)。\n\n## 如何加载codemirror\n一般我们在项目里npm下载完codemirror包后，在代码里引入`codemirror.js`，而且还会根据需要引入想要的语言模式包：\n```js\nimport * as CM from 'codemirror';\n\nimport 'codemirror/mode/xml/xml';\nimport 'codemirror/mode/markdown/markdown';\nimport 'codemirror/addon/edit/continuelist';\n```\n\n当然，我们还得在html里引入`codemirror.css`样式，也可以自己修改成想要的样式。\n\n然后，在需要加载的地方写html标签，id为`codemirror`，这里我们用的是JSX：\n```jsx\n<div className=\"editor-root\" ref={(elem) => { this.editRoot = elem; }}>\n  <textarea id=\"codemirror\" name={this.props.path} autoComplete=\"off\" />\n</div>\n```\n我在`textarea`外面用div包了一层，是为了方便之后的滚动效果。这样，我们就已经可以使用codemirror写一个markdown编辑器了。\n\n## options 可以使用的参数\n  CodeMirror函数和它的fromTextArea方法都可以使用一个配置对象作为第二个参数。这个options极为重要，基本就决定了你的编辑器主要的输入语言、样式、内容。这里列一下它几个常用的可选的参数：\n- value: string | CodeMirror.Doc\n  编辑器的初始值（文本），可以是字符串或者CodeMirror文档对象(不同于HTML文档对象)。\n- mode: string | object\n  通用的或者在CodeMirror中使用的与mode相关联的mime，当不设置这个值的时候，会默认使用第一个载入的mode定义文件。一般地，会使用关联的mime类型来设置这个值；除此之外，也可以使用一个带有name属性的对象来作为值（如：{name: “javascript”, json: true}）。可以通过访问CodeMirror.modes和CodeMirror.mimeModes获取定义的mode和MIME。\n- lineSeparator: string|null\n  明确指定编辑器使用的行分割符（换行符）。默认（值为null）情况下，文档会被 CRLF(以及单独的CR, LF)分割，单独的LF会在所有的输出中用作换行符（如：getValue）。当指定了换行字符串，行就只会被指定的串分割。\n- theme: string\n  配置编辑器的主题样式。要使用主题，必须保证名称为 .cm-s-[name] (name是设置的theme的值)的样式是加载上了的。当然，你也可以一次加载多个主题样式，使用方法和html和使用类一样，如： theme: foo bar，那么此时需要cm-s-foo cm-s-bar这两个样式都已经被加载上了。\n- indentUnit: integer\n  缩进单位，值为空格数，默认为2 。\n- smartIndent: boolean\n  自动缩进，设置是否根据上下文自动缩进（和上一行相同的缩进量）。默认为true。\n- tabSize: integer\n  tab字符的宽度，默认为4 。\n- indentWithTabs: boolean\n  在缩进时，是否需要把 n*tab宽度个空格替换成n个tab字符，默认为false 。\n- electricChars: boolean\n  在输入可能改变当前的缩进时，是否重新缩进，默认为true （仅在mode支持缩进时有效）。\n- keyMap: string\n  配置快捷键。默认值为default，即 codemorrir.js 内部定义。其它在key map目录下。\n- extraKeys: object\n  给编辑器绑定与前面keyMap配置不同的快捷键。\n- lineWrapping: boolean\n  在长行时文字是换行(wrap)还是滚动(scroll)，默认为滚动(scroll)。\n- lineNumbers: boolean\n  是否在编辑器左侧显示行号。\n- firstLineNumber: integer\n  行号从哪个数开始计数，默认为1 。\n- lineNumberFormatter: function(line: integer) → string\n  使用一个函数设置行号。\n- scrollbarStyle: string\n  设置滚动条。默认为”native”，显示原生的滚动条。核心库还提供了”null”样式，此样式会完全隐藏滚动条。Addons可以设置更多的滚动条模式。\n- inputStyle: string\n  选择CodeMirror处理输入和焦点的方式。核心库定义了textarea和contenteditable输入模式。在移动浏览器上，默认是contenteditable，在桌面浏览器上，默认是textarea。在contenteditable模式下对IME和屏幕阅读器支持更好。\n- readOnly: boolean|string\n  编辑器是否只读。如果设置为预设的值 “nocursor”，那么除了设置只读外，编辑区域还不能获得焦点。\n- showCursorWhenSelecting: boolean\n  在选择时是否显示光标，默认为false。\n- autofocus: boolean\n  是否在初始化时自动获取焦点。默认情况是关闭的。但是，在使用textarea并且没有明确指定值的时候会被自动设置为true。\n\n更多的配置请查看[相关文档](https://codemirror.net/doc/manual.html#config)。\n\n# 实时预览\n这个需求可以说是现代markdown编辑器的基本需求，因为markdown写起来本身是没有任何样式的，纯文本的话对于有些人来说不能看到最终效果就很不习惯，自己写的效果怎么样都不知道，写的心里就会很没底（当然再花哨的样式最后还是要看内容好不好）。说白了，实时预览更多是写作时一个心理上的满足，这对于写作体验的提升来说是必不可少的。\n\n这里的markdown渲染引擎我直接用了比较受欢迎的[`marked`](https://marked.js.org/#/README.md#README.md)库，其实markdown渲染是很考验技术的一门活，绝大部分都是用正则匹配来进行标签的替换，但由于markdown的语法相对还是较多的，要自己写一个markdown渲染引擎还是有点难度的，考虑到时间因素所以一般都会用现成的库，当然以后有时间的话我也会考虑写一个markdown渲染引擎玩玩。\n\n这里我因为是用`React`写的markdown组件，下面我就简单的介绍下如何实现实时预览。\n\n首先在组件渲染完后，我们在`componentDidMount`函数里对codemirror进行事件监听：\n```js\ncomponentDidMount () {\n  // 因为需要使用fromTextArea获取options，所以采用document.getElementById\n  this.codeMirror = CM.fromTextArea(ReactDOM.findDOMNode(document.getElementById('codemirror')), this.getOptions());\n  this.props.init(this.editRoot, this.codeMirror);\n  this.codeMirror.setValue(this.props.defaultValue);\n  this.codeMirror.on('change', this.codemirrorValueChanged);\n  this._currentCodemirrorValue = this.props.defaultValue;\n}\n```\n这里我们使用`fromTextArea`获取codemirror的dom节点，它支持两个参数，第一个是codemirror所挂载的dom节点，第二个是配置的options。\n\n之后调用init函数，这里之后会讲。然后就是初始值设置`codemirror.setValue(defaultValue)`，因为是编辑器，如果想对之前的文档进行修改，肯定需要传入初始值。\n\n然后就是关键的监听事件`change`，当输入变化时调用`this.codemirrorValueChanged`事件：\n```js\ncodemirrorValueChanged = (cm) => {\n  const newValue = cm.getValue();\n  this._currentCodemirrorValue = cm.getValue();\n  this.props.onChange && this.props.onChange(newValue);\n}\n```\n这里说下，我们通过`cm.getValue()`获取当前输入的值，然后通过调用`props.onChange(newValue)`将值抛给父组件处理。因为这里我想把编辑部分和预览部分分开来做成两个公共组件，这样组件复用性更强，有的可能只需要编辑功能，有的只需要预览展示功能。\n那么在父组件里，我们需要对`onChange`事件传入的值进行处理，将其渲染成html然后展示出来，其实很简单：\n```jsx\nclass MarkdownEditor extends Component {\n  //...\n\n  handleEditChange = (newCode) => {\n    this.props.renderMarkdown && this.props.renderMarkdown(newCode);\n    this.setState({\n      code: newCode,\n      hasChanged: true\n    });\n  }\n  debounceEditChange = debounce(this.handleEditChange, 500);\n  // ...\n  render() {\n    const preview = marked(this.state.code);\n    return (\n      <div>\n        <MyEditor\n          defaultValue={this.state.code}\n          onChange={this.debounceEditChange}\n        />\n        <div className=\"md-preview-container\">\n          <div className=\"preview-content\" dangerouslySetInnerHTML={{__html: preview}}/>\n        </div>\n      </div>\n    );\n  }\n}\n```\n这里要注意的是，我用到了`debounce`函数进行延迟处理：\n```js\nfunction debounce (fn, delay = 20) {\n  let timeout;\n\n  return function (...args) {\n    const self = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.call(self, ...args);\n    }, delay);\n  }\n}\n```\n因为考虑到性能原因，如果输入过快的话，`change`事件频繁触发，预览页面不断重绘，性能损耗十分严重，所以我用到了`debounce`，并设置延迟时间500毫秒，当然可以更短，这里我觉得设置500毫秒已经足够了。这样就达到了实时预览的效果。\n\n# 总结\n基于codemirror的markdown编辑器实现起来其实还有很多坑，本篇先介绍了`codemirror`的一些基本配置和如何实现markdown实时预览，接下来我将进一步介绍如何实现同屏滚动和自定义标签按钮等其他功能。\n","slug":"codemirror-markdown-editor-chapter1","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d4002gra4k0z4k6yom","content":"<p>我们知道，要实现一个Markdown编辑器，一般会想要实现这样的功能：实时预览、同步滚动、支持标签按钮添加、markdown语法高亮等等。那么如何去实现一个功能比较完整的markdown编辑器呢？</p>\n<p>首先这里我们只讨论web端，其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，很多都可以拿来直接用，满足基本需求足够了。但是作为前端程序员来说，当然想要实现一个自己定制化的markdown编辑器比较有意思，不过通过查阅资料文档和各种框架比较，发现也不是那么容易的事。</p>\n<span id=\"more\"></span>\n<h1 id=\"框架选择\"><a href=\"#框架选择\" class=\"headerlink\" title=\"框架选择\"></a>框架选择</h1><p>要实现一个markdown编辑器，首先得找到一个合适的框架，目前市面上优秀的markdown框架五花八门。由于现在自己写的项目一般都使用React，所以理所当然能找到一个比较契合React的Markdown框架是更好的。</p>\n<p>经过前期调研，发现有几款基于React的Markdown框架还不错，<a href=\"https://zenoamaro.github.io/react-quill/\">react-quill</a>、facebook的<a href=\"https://draftjs.org/docs/getting-started.html\">draft</a>、<a href=\"https://github.com/scniro/react-codemirror2\">react-codemirror2</a>，但它们其实都是富文本编辑器，定制的东西已经很完善了，我想要的框架是可支持自定义扩展，定制化自己想要的功能，找来找去，最后决定基于<a href=\"https://codemirror.net/doc/manual.html#api\">CodeMirror</a>来自己实现一个定制化的markdown编辑器。因为CodeMirror其实相当于一个基础的框架，它有很多可配置项，可以自己添加工具栏，添加各种实用功能，这正好满足了我的需求，于是就决定用它了！</p>\n<h1 id=\"CodeMirror\"><a href=\"#CodeMirror\" class=\"headerlink\" title=\"CodeMirror\"></a>CodeMirror</h1><p>现代很多编辑器其实都基于<code>codemirror</code>，为什么要选择它呢？这都得益于它强大的API和配置项，在不失基本功能的同时给予了开发者极大的定制空间，开发者可以基于它开发出各种功能的markdown编辑器。这里我先简单介绍一下codemirror的一些基本操作。想要了解更多有关codemirror，可以去看<a href=\"https://codemirror.net/doc/manual.html\">官方文档</a>。</p>\n<h2 id=\"如何加载codemirror\"><a href=\"#如何加载codemirror\" class=\"headerlink\" title=\"如何加载codemirror\"></a>如何加载codemirror</h2><p>一般我们在项目里npm下载完codemirror包后，在代码里引入<code>codemirror.js</code>，而且还会根据需要引入想要的语言模式包：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"variable constant_\">CM</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;codemirror&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;codemirror/mode/xml/xml&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;codemirror/mode/markdown/markdown&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;codemirror/addon/edit/continuelist&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然，我们还得在html里引入<code>codemirror.css</code>样式，也可以自己修改成想要的样式。</p>\n<p>然后，在需要加载的地方写html标签，id为<code>codemirror</code>，这里我们用的是JSX：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div className=<span class=\"string\">&quot;editor-root&quot;</span> ref=&#123;<span class=\"function\">(<span class=\"params\">elem</span>) =&gt;</span> &#123; <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span> = elem; &#125;&#125;&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;codemirror&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;this.props.path&#125;</span> <span class=\"attr\">autoComplete</span>=<span class=\"string\">&quot;off&quot;</span> /&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>我在<code>textarea</code>外面用div包了一层，是为了方便之后的滚动效果。这样，我们就已经可以使用codemirror写一个markdown编辑器了。</p>\n<h2 id=\"options-可以使用的参数\"><a href=\"#options-可以使用的参数\" class=\"headerlink\" title=\"options 可以使用的参数\"></a>options 可以使用的参数</h2><p>  CodeMirror函数和它的fromTextArea方法都可以使用一个配置对象作为第二个参数。这个options极为重要，基本就决定了你的编辑器主要的输入语言、样式、内容。这里列一下它几个常用的可选的参数：</p>\n<ul>\n<li>value: string | CodeMirror.Doc<br>编辑器的初始值（文本），可以是字符串或者CodeMirror文档对象(不同于HTML文档对象)。</li>\n<li>mode: string | object<br>通用的或者在CodeMirror中使用的与mode相关联的mime，当不设置这个值的时候，会默认使用第一个载入的mode定义文件。一般地，会使用关联的mime类型来设置这个值；除此之外，也可以使用一个带有name属性的对象来作为值（如：{name: “javascript”, json: true}）。可以通过访问CodeMirror.modes和CodeMirror.mimeModes获取定义的mode和MIME。</li>\n<li>lineSeparator: string|null<br>明确指定编辑器使用的行分割符（换行符）。默认（值为null）情况下，文档会被 CRLF(以及单独的CR, LF)分割，单独的LF会在所有的输出中用作换行符（如：getValue）。当指定了换行字符串，行就只会被指定的串分割。</li>\n<li>theme: string<br>配置编辑器的主题样式。要使用主题，必须保证名称为 .cm-s-[name] (name是设置的theme的值)的样式是加载上了的。当然，你也可以一次加载多个主题样式，使用方法和html和使用类一样，如： theme: foo bar，那么此时需要cm-s-foo cm-s-bar这两个样式都已经被加载上了。</li>\n<li>indentUnit: integer<br>缩进单位，值为空格数，默认为2 。</li>\n<li>smartIndent: boolean<br>自动缩进，设置是否根据上下文自动缩进（和上一行相同的缩进量）。默认为true。</li>\n<li>tabSize: integer<br>tab字符的宽度，默认为4 。</li>\n<li>indentWithTabs: boolean<br>在缩进时，是否需要把 n*tab宽度个空格替换成n个tab字符，默认为false 。</li>\n<li>electricChars: boolean<br>在输入可能改变当前的缩进时，是否重新缩进，默认为true （仅在mode支持缩进时有效）。</li>\n<li>keyMap: string<br>配置快捷键。默认值为default，即 codemorrir.js 内部定义。其它在key map目录下。</li>\n<li>extraKeys: object<br>给编辑器绑定与前面keyMap配置不同的快捷键。</li>\n<li>lineWrapping: boolean<br>在长行时文字是换行(wrap)还是滚动(scroll)，默认为滚动(scroll)。</li>\n<li>lineNumbers: boolean<br>是否在编辑器左侧显示行号。</li>\n<li>firstLineNumber: integer<br>行号从哪个数开始计数，默认为1 。</li>\n<li>lineNumberFormatter: function(line: integer) → string<br>使用一个函数设置行号。</li>\n<li>scrollbarStyle: string<br>设置滚动条。默认为”native”，显示原生的滚动条。核心库还提供了”null”样式，此样式会完全隐藏滚动条。Addons可以设置更多的滚动条模式。</li>\n<li>inputStyle: string<br>选择CodeMirror处理输入和焦点的方式。核心库定义了textarea和contenteditable输入模式。在移动浏览器上，默认是contenteditable，在桌面浏览器上，默认是textarea。在contenteditable模式下对IME和屏幕阅读器支持更好。</li>\n<li>readOnly: boolean|string<br>编辑器是否只读。如果设置为预设的值 “nocursor”，那么除了设置只读外，编辑区域还不能获得焦点。</li>\n<li>showCursorWhenSelecting: boolean<br>在选择时是否显示光标，默认为false。</li>\n<li>autofocus: boolean<br>是否在初始化时自动获取焦点。默认情况是关闭的。但是，在使用textarea并且没有明确指定值的时候会被自动设置为true。</li>\n</ul>\n<p>更多的配置请查看<a href=\"https://codemirror.net/doc/manual.html#config\">相关文档</a>。</p>\n<h1 id=\"实时预览\"><a href=\"#实时预览\" class=\"headerlink\" title=\"实时预览\"></a>实时预览</h1><p>这个需求可以说是现代markdown编辑器的基本需求，因为markdown写起来本身是没有任何样式的，纯文本的话对于有些人来说不能看到最终效果就很不习惯，自己写的效果怎么样都不知道，写的心里就会很没底（当然再花哨的样式最后还是要看内容好不好）。说白了，实时预览更多是写作时一个心理上的满足，这对于写作体验的提升来说是必不可少的。</p>\n<p>这里的markdown渲染引擎我直接用了比较受欢迎的<a href=\"https://marked.js.org/#/README.md#README.md\"><code>marked</code></a>库，其实markdown渲染是很考验技术的一门活，绝大部分都是用正则匹配来进行标签的替换，但由于markdown的语法相对还是较多的，要自己写一个markdown渲染引擎还是有点难度的，考虑到时间因素所以一般都会用现成的库，当然以后有时间的话我也会考虑写一个markdown渲染引擎玩玩。</p>\n<p>这里我因为是用<code>React</code>写的markdown组件，下面我就简单的介绍下如何实现实时预览。</p>\n<p>首先在组件渲染完后，我们在<code>componentDidMount</code>函数里对codemirror进行事件监听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount () &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为需要使用fromTextArea获取options，所以采用document.getElementById</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span> = <span class=\"variable constant_\">CM</span>.<span class=\"title function_\">fromTextArea</span>(<span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">findDOMNode</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;codemirror&#x27;</span>)), <span class=\"variable language_\">this</span>.<span class=\"title function_\">getOptions</span>());</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">init</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">setValue</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">defaultValue</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codemirrorValueChanged</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">_currentCodemirrorValue</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">defaultValue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们使用<code>fromTextArea</code>获取codemirror的dom节点，它支持两个参数，第一个是codemirror所挂载的dom节点，第二个是配置的options。</p>\n<p>之后调用init函数，这里之后会讲。然后就是初始值设置<code>codemirror.setValue(defaultValue)</code>，因为是编辑器，如果想对之前的文档进行修改，肯定需要传入初始值。</p>\n<p>然后就是关键的监听事件<code>change</code>，当输入变化时调用<code>this.codemirrorValueChanged</code>事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codemirrorValueChanged = <span class=\"function\">(<span class=\"params\">cm</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newValue = cm.<span class=\"title function_\">getValue</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">_currentCodemirrorValue</span> = cm.<span class=\"title function_\">getValue</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">onChange</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">onChange</span>(newValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里说下，我们通过<code>cm.getValue()</code>获取当前输入的值，然后通过调用<code>props.onChange(newValue)</code>将值抛给父组件处理。因为这里我想把编辑部分和预览部分分开来做成两个公共组件，这样组件复用性更强，有的可能只需要编辑功能，有的只需要预览展示功能。<br>那么在父组件里，我们需要对<code>onChange</code>事件传入的值进行处理，将其渲染成html然后展示出来，其实很简单：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MarkdownEditor</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handleEditChange = <span class=\"function\">(<span class=\"params\">newCode</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">renderMarkdown</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">renderMarkdown</span>(newCode);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">code</span>: newCode,</span><br><span class=\"line\">      <span class=\"attr\">hasChanged</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  debounceEditChange = <span class=\"title function_\">debounce</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">handleEditChange</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> preview = <span class=\"title function_\">marked</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">code</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">MyEditor</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;this.state.code&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.debounceEditChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;md-preview-container&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;preview-content&quot;</span> <span class=\"attr\">dangerouslySetInnerHTML</span>=<span class=\"string\">&#123;&#123;__html:</span> <span class=\"attr\">preview</span>&#125;&#125;/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里要注意的是，我用到了<code>debounce</code>函数进行延迟处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span> (fn, delay = <span class=\"number\">20</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timeout = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      fn.<span class=\"title function_\">call</span>(self, ...args);</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为考虑到性能原因，如果输入过快的话，<code>change</code>事件频繁触发，预览页面不断重绘，性能损耗十分严重，所以我用到了<code>debounce</code>，并设置延迟时间500毫秒，当然可以更短，这里我觉得设置500毫秒已经足够了。这样就达到了实时预览的效果。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>基于codemirror的markdown编辑器实现起来其实还有很多坑，本篇先介绍了<code>codemirror</code>的一些基本配置和如何实现markdown实时预览，接下来我将进一步介绍如何实现同屏滚动和自定义标签按钮等其他功能。</p>\n","site":{"data":{}},"excerpt":"<p>我们知道，要实现一个Markdown编辑器，一般会想要实现这样的功能：实时预览、同步滚动、支持标签按钮添加、markdown语法高亮等等。那么如何去实现一个功能比较完整的markdown编辑器呢？</p>\n<p>首先这里我们只讨论web端，其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，很多都可以拿来直接用，满足基本需求足够了。但是作为前端程序员来说，当然想要实现一个自己定制化的markdown编辑器比较有意思，不过通过查阅资料文档和各种框架比较，发现也不是那么容易的事。</p>","more":"<h1 id=\"框架选择\"><a href=\"#框架选择\" class=\"headerlink\" title=\"框架选择\"></a>框架选择</h1><p>要实现一个markdown编辑器，首先得找到一个合适的框架，目前市面上优秀的markdown框架五花八门。由于现在自己写的项目一般都使用React，所以理所当然能找到一个比较契合React的Markdown框架是更好的。</p>\n<p>经过前期调研，发现有几款基于React的Markdown框架还不错，<a href=\"https://zenoamaro.github.io/react-quill/\">react-quill</a>、facebook的<a href=\"https://draftjs.org/docs/getting-started.html\">draft</a>、<a href=\"https://github.com/scniro/react-codemirror2\">react-codemirror2</a>，但它们其实都是富文本编辑器，定制的东西已经很完善了，我想要的框架是可支持自定义扩展，定制化自己想要的功能，找来找去，最后决定基于<a href=\"https://codemirror.net/doc/manual.html#api\">CodeMirror</a>来自己实现一个定制化的markdown编辑器。因为CodeMirror其实相当于一个基础的框架，它有很多可配置项，可以自己添加工具栏，添加各种实用功能，这正好满足了我的需求，于是就决定用它了！</p>\n<h1 id=\"CodeMirror\"><a href=\"#CodeMirror\" class=\"headerlink\" title=\"CodeMirror\"></a>CodeMirror</h1><p>现代很多编辑器其实都基于<code>codemirror</code>，为什么要选择它呢？这都得益于它强大的API和配置项，在不失基本功能的同时给予了开发者极大的定制空间，开发者可以基于它开发出各种功能的markdown编辑器。这里我先简单介绍一下codemirror的一些基本操作。想要了解更多有关codemirror，可以去看<a href=\"https://codemirror.net/doc/manual.html\">官方文档</a>。</p>\n<h2 id=\"如何加载codemirror\"><a href=\"#如何加载codemirror\" class=\"headerlink\" title=\"如何加载codemirror\"></a>如何加载codemirror</h2><p>一般我们在项目里npm下载完codemirror包后，在代码里引入<code>codemirror.js</code>，而且还会根据需要引入想要的语言模式包：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> <span class=\"variable constant_\">CM</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;codemirror&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;codemirror/mode/xml/xml&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;codemirror/mode/markdown/markdown&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;codemirror/addon/edit/continuelist&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然，我们还得在html里引入<code>codemirror.css</code>样式，也可以自己修改成想要的样式。</p>\n<p>然后，在需要加载的地方写html标签，id为<code>codemirror</code>，这里我们用的是JSX：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div className=<span class=\"string\">&quot;editor-root&quot;</span> ref=&#123;<span class=\"function\">(<span class=\"params\">elem</span>) =&gt;</span> &#123; <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span> = elem; &#125;&#125;&gt;</span><br><span class=\"line\">  <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;codemirror&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;this.props.path&#125;</span> <span class=\"attr\">autoComplete</span>=<span class=\"string\">&quot;off&quot;</span> /&gt;</span></span></span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>我在<code>textarea</code>外面用div包了一层，是为了方便之后的滚动效果。这样，我们就已经可以使用codemirror写一个markdown编辑器了。</p>\n<h2 id=\"options-可以使用的参数\"><a href=\"#options-可以使用的参数\" class=\"headerlink\" title=\"options 可以使用的参数\"></a>options 可以使用的参数</h2><p>  CodeMirror函数和它的fromTextArea方法都可以使用一个配置对象作为第二个参数。这个options极为重要，基本就决定了你的编辑器主要的输入语言、样式、内容。这里列一下它几个常用的可选的参数：</p>\n<ul>\n<li>value: string | CodeMirror.Doc<br>编辑器的初始值（文本），可以是字符串或者CodeMirror文档对象(不同于HTML文档对象)。</li>\n<li>mode: string | object<br>通用的或者在CodeMirror中使用的与mode相关联的mime，当不设置这个值的时候，会默认使用第一个载入的mode定义文件。一般地，会使用关联的mime类型来设置这个值；除此之外，也可以使用一个带有name属性的对象来作为值（如：{name: “javascript”, json: true}）。可以通过访问CodeMirror.modes和CodeMirror.mimeModes获取定义的mode和MIME。</li>\n<li>lineSeparator: string|null<br>明确指定编辑器使用的行分割符（换行符）。默认（值为null）情况下，文档会被 CRLF(以及单独的CR, LF)分割，单独的LF会在所有的输出中用作换行符（如：getValue）。当指定了换行字符串，行就只会被指定的串分割。</li>\n<li>theme: string<br>配置编辑器的主题样式。要使用主题，必须保证名称为 .cm-s-[name] (name是设置的theme的值)的样式是加载上了的。当然，你也可以一次加载多个主题样式，使用方法和html和使用类一样，如： theme: foo bar，那么此时需要cm-s-foo cm-s-bar这两个样式都已经被加载上了。</li>\n<li>indentUnit: integer<br>缩进单位，值为空格数，默认为2 。</li>\n<li>smartIndent: boolean<br>自动缩进，设置是否根据上下文自动缩进（和上一行相同的缩进量）。默认为true。</li>\n<li>tabSize: integer<br>tab字符的宽度，默认为4 。</li>\n<li>indentWithTabs: boolean<br>在缩进时，是否需要把 n*tab宽度个空格替换成n个tab字符，默认为false 。</li>\n<li>electricChars: boolean<br>在输入可能改变当前的缩进时，是否重新缩进，默认为true （仅在mode支持缩进时有效）。</li>\n<li>keyMap: string<br>配置快捷键。默认值为default，即 codemorrir.js 内部定义。其它在key map目录下。</li>\n<li>extraKeys: object<br>给编辑器绑定与前面keyMap配置不同的快捷键。</li>\n<li>lineWrapping: boolean<br>在长行时文字是换行(wrap)还是滚动(scroll)，默认为滚动(scroll)。</li>\n<li>lineNumbers: boolean<br>是否在编辑器左侧显示行号。</li>\n<li>firstLineNumber: integer<br>行号从哪个数开始计数，默认为1 。</li>\n<li>lineNumberFormatter: function(line: integer) → string<br>使用一个函数设置行号。</li>\n<li>scrollbarStyle: string<br>设置滚动条。默认为”native”，显示原生的滚动条。核心库还提供了”null”样式，此样式会完全隐藏滚动条。Addons可以设置更多的滚动条模式。</li>\n<li>inputStyle: string<br>选择CodeMirror处理输入和焦点的方式。核心库定义了textarea和contenteditable输入模式。在移动浏览器上，默认是contenteditable，在桌面浏览器上，默认是textarea。在contenteditable模式下对IME和屏幕阅读器支持更好。</li>\n<li>readOnly: boolean|string<br>编辑器是否只读。如果设置为预设的值 “nocursor”，那么除了设置只读外，编辑区域还不能获得焦点。</li>\n<li>showCursorWhenSelecting: boolean<br>在选择时是否显示光标，默认为false。</li>\n<li>autofocus: boolean<br>是否在初始化时自动获取焦点。默认情况是关闭的。但是，在使用textarea并且没有明确指定值的时候会被自动设置为true。</li>\n</ul>\n<p>更多的配置请查看<a href=\"https://codemirror.net/doc/manual.html#config\">相关文档</a>。</p>\n<h1 id=\"实时预览\"><a href=\"#实时预览\" class=\"headerlink\" title=\"实时预览\"></a>实时预览</h1><p>这个需求可以说是现代markdown编辑器的基本需求，因为markdown写起来本身是没有任何样式的，纯文本的话对于有些人来说不能看到最终效果就很不习惯，自己写的效果怎么样都不知道，写的心里就会很没底（当然再花哨的样式最后还是要看内容好不好）。说白了，实时预览更多是写作时一个心理上的满足，这对于写作体验的提升来说是必不可少的。</p>\n<p>这里的markdown渲染引擎我直接用了比较受欢迎的<a href=\"https://marked.js.org/#/README.md#README.md\"><code>marked</code></a>库，其实markdown渲染是很考验技术的一门活，绝大部分都是用正则匹配来进行标签的替换，但由于markdown的语法相对还是较多的，要自己写一个markdown渲染引擎还是有点难度的，考虑到时间因素所以一般都会用现成的库，当然以后有时间的话我也会考虑写一个markdown渲染引擎玩玩。</p>\n<p>这里我因为是用<code>React</code>写的markdown组件，下面我就简单的介绍下如何实现实时预览。</p>\n<p>首先在组件渲染完后，我们在<code>componentDidMount</code>函数里对codemirror进行事件监听：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount () &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 因为需要使用fromTextArea获取options，所以采用document.getElementById</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span> = <span class=\"variable constant_\">CM</span>.<span class=\"title function_\">fromTextArea</span>(<span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">findDOMNode</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;codemirror&#x27;</span>)), <span class=\"variable language_\">this</span>.<span class=\"title function_\">getOptions</span>());</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">init</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">setValue</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">defaultValue</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;change&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codemirrorValueChanged</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">_currentCodemirrorValue</span> = <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">defaultValue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们使用<code>fromTextArea</code>获取codemirror的dom节点，它支持两个参数，第一个是codemirror所挂载的dom节点，第二个是配置的options。</p>\n<p>之后调用init函数，这里之后会讲。然后就是初始值设置<code>codemirror.setValue(defaultValue)</code>，因为是编辑器，如果想对之前的文档进行修改，肯定需要传入初始值。</p>\n<p>然后就是关键的监听事件<code>change</code>，当输入变化时调用<code>this.codemirrorValueChanged</code>事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codemirrorValueChanged = <span class=\"function\">(<span class=\"params\">cm</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newValue = cm.<span class=\"title function_\">getValue</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">_currentCodemirrorValue</span> = cm.<span class=\"title function_\">getValue</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">onChange</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">onChange</span>(newValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里说下，我们通过<code>cm.getValue()</code>获取当前输入的值，然后通过调用<code>props.onChange(newValue)</code>将值抛给父组件处理。因为这里我想把编辑部分和预览部分分开来做成两个公共组件，这样组件复用性更强，有的可能只需要编辑功能，有的只需要预览展示功能。<br>那么在父组件里，我们需要对<code>onChange</code>事件传入的值进行处理，将其渲染成html然后展示出来，其实很简单：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MarkdownEditor</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">  handleEditChange = <span class=\"function\">(<span class=\"params\">newCode</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">renderMarkdown</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">renderMarkdown</span>(newCode);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">code</span>: newCode,</span><br><span class=\"line\">      <span class=\"attr\">hasChanged</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  debounceEditChange = <span class=\"title function_\">debounce</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">handleEditChange</span>, <span class=\"number\">500</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> preview = <span class=\"title function_\">marked</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">state</span>.<span class=\"property\">code</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">MyEditor</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;this.state.code&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">          <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.debounceEditChange&#125;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;md-preview-container&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">          <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;preview-content&quot;</span> <span class=\"attr\">dangerouslySetInnerHTML</span>=<span class=\"string\">&#123;&#123;__html:</span> <span class=\"attr\">preview</span>&#125;&#125;/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里要注意的是，我用到了<code>debounce</code>函数进行延迟处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span> (fn, delay = <span class=\"number\">20</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timeout = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      fn.<span class=\"title function_\">call</span>(self, ...args);</span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为考虑到性能原因，如果输入过快的话，<code>change</code>事件频繁触发，预览页面不断重绘，性能损耗十分严重，所以我用到了<code>debounce</code>，并设置延迟时间500毫秒，当然可以更短，这里我觉得设置500毫秒已经足够了。这样就达到了实时预览的效果。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>基于codemirror的markdown编辑器实现起来其实还有很多坑，本篇先介绍了<code>codemirror</code>的一些基本配置和如何实现markdown实时预览，接下来我将进一步介绍如何实现同屏滚动和自定义标签按钮等其他功能。</p>"},{"title":"实现基于codemirror的markdown编辑器(二)","date":"2018-12-20T10:39:16.000Z","toc":true,"_content":"\n前面我们提到了如何加载`codemirror`组件和一些基本配置，以及如何实现实时预览。接下来才是重头戏，我们需要实现同屏滚动和添加自定义按钮。\n<!--more-->\n\n这篇我们先来着重讲讲同屏滚动。\n\n# 同屏滚动\n我们写文档时，除了想要实时预览，还想要能同步滚动，这样写到哪预览页面就滚动到哪，不用鼠标移来移去，方便不少。但是如何实现呢？我们一步一步来。\n\n## 监听事件\n首先，要想滚动，肯定得监听滚动事件`onscroll`，但是这里我没有直接监听`scroll`事件，因为我们有两个区域，左边是输入文本框，右边是预览区，我想实现这样的功能：当鼠标移到左边使滚动条滚动时，这个时候先监听左边的滚动事件计算出相应的滚动高度后再修改右边的滚动高度，这样右边是跟着左边的高度滚动而滚动的。相应的，当鼠标移到右边区域使滚动条滚动时，先监听右边的滚动事件计算出滚动高度后再修改左边的滚动高度。这样滚动才能实现对应关系，但是如果直接监听滚动事件，则会出现一个问题，当右边滚动时，左边滚动事件没有移除，则又会触发，计算高度后引发右边滚动，形成一个一直滚动的死循环，最后整个页面滚动位置都是乱的。\n所以，这里我先监听`mouseover`和`mouseleave`事件，话不多说看代码：\n```javascript\n  //...\n  codemirrorScroll = (doc) => () => {\n    this.props.onScroll && this.props.onScroll(doc, this.editRoot);\n  }\n\n  codemirrorScrollHandler = () => {\n    this.codeMirror.on('scroll', this.codemirrorScroll(this.codeMirror.doc));\n  }\n\n  codemirrorRemoveScroll = () => {\n    this.codeMirror.off('scroll', this.codemirrorScroll(this.codeMirror.doc));\n  }\n  //...\n  componentDidMount() {\n    //...\n    this.editRoot.addEventListener('mouseover', this.codemirrorScrollHandler);\n    this.editRoot.addEventListener('mouseleave', this.codemirrorRemoveScroll);\n  }\n```\n注意到，我在`mouseover`的时候开始监听`scroll`事件，`mouseleave`的时候移除之前的`scroll`事件，所以这里要用`codemirrorScroll`函数封装，以便移除时是同一个函数。\n这里我把`scroll`事件的处理通过props抛给父组件，我们来看看父组件是怎么实现`scroll`事件的。\n\n首先考虑到性能和滚动流畅度问题，使用`debounce`函数包装一下：\n```js\n  debounceContentScroll = debounce(this.handleScrollContent);\n```\n接下来就是如何去计算当前滚动的位置并使另一边的内容自动滚动到对应高度，这里我用一幅图解释一下：\n![markdown-scroll](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/markdown-scroll.png)\n我们主要获取的就是这三个值：`child.offsetHeight`、`parent.offsetHeight`、`child.scrollTop`。所以我们需要在展示内容外面都用`div`包一层，代表`parent`元素。先看代码：\n```js\n  calcScrollScale = (scrollTopMax1, scrollTopMax2) => (scrollTopMax1 / scrollTopMax2);\n\n  calcScrollTopMax = (parent, child) => Math.abs((child.offsetHeight || child.height) - parent.offsetHeight)\n\n  updateScroll = (scrollTop, target, scrollTopMax1, scrollTopMax2) => {\n    const scale = this.calcScrollScale(scrollTopMax1, scrollTopMax2);\n    target.scrollTop = scrollTop / scale;\n  }\n\n  handleScrollContent = (doc, docParent) => {\n    const mdPreview = this.mdPreview.current;\n    const previewContent = this.previewContent.current;\n    const scrollTopMaxFrom = this.calcScrollTopMax(docParent, doc);\n    const scrollTopMaxTo = this.calcScrollTopMax(mdPreview, previewContent);\n    this.updateScroll(doc.scrollTop, mdPreview, scrollTopMaxFrom, scrollTopMaxTo);\n  }\n```\n这里有个很重要的参数：`scrollTopMax`。\n`scrollTopMax = |(child.offsetHeight || child.height) - parent.offsetHeight|`。使用`child.height`是因为codemirror的`doc`对象内容高度可以直接通过`height`属性获得。为什么要这样计算？\n我们算的是当前内容可滚动的最大高度，为什么要计算这个？因为我们知道因为渲染的原因，左边输入的时候是单纯的文本，右边渲染出来有标题、图片等等，实际高度会比左边高得多，通过计算两边相对父容器可滚动的最大高度，再计算这两个的比值：`calcScrollScale = (scrollTopMax1, scrollTopMax2) => (scrollTopMax1 / scrollTopMax2);`，可以得到一个`scrollScale`。\n我们有这样一个公式：`left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax`，那么我们很容易得出右边的滚动高度：`right.scrollTop = left.scrollTop / scrollScale`。于是就可以使右边滚动到对应内容的高度了！\n\n有了左边的范例，对右边预览的container同样使用一样的监听事件，这样就可以实现双向同步滚动绑定了！！！\n\n# 总结\n实现同步滚动的关键点其实有两个：一个是注意监听事件的变化，先监听`mouseover`和`mouseleave`，这样不会出现滚动死循环。另一个是理解公式：`left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax`。理解了这两个关键点，其实同步滚动就很容易了。\n但要注意的是，这里的`debounce`设置延迟时间可能还需要好好斟酌，我默认使用20毫秒，实际滚动时还是会有点卡顿，可以适当改变一下数值。\n还有就是，因为markdown语法原因，段落之间都必须有一个空行，不然渲染出来文本没换行，导致段落不一致。\n\n> 参考资料：\n> - [scrollTop](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop)\n> - [原生JS控制多个滚动条同步跟随滚动](https://juejin.im/post/5a3bb40e5188252b145b38e3)\n","source":"_posts/2018-12-20-codemirror-markdown-editor-chapter2.md","raw":"---\ntitle: 实现基于codemirror的markdown编辑器(二)\ndate: 2018-12-20 18:39:16\ntoc: true\ncategories:\n- JS相关\ntags:\n- 编辑器\n- markdown\n---\n\n前面我们提到了如何加载`codemirror`组件和一些基本配置，以及如何实现实时预览。接下来才是重头戏，我们需要实现同屏滚动和添加自定义按钮。\n<!--more-->\n\n这篇我们先来着重讲讲同屏滚动。\n\n# 同屏滚动\n我们写文档时，除了想要实时预览，还想要能同步滚动，这样写到哪预览页面就滚动到哪，不用鼠标移来移去，方便不少。但是如何实现呢？我们一步一步来。\n\n## 监听事件\n首先，要想滚动，肯定得监听滚动事件`onscroll`，但是这里我没有直接监听`scroll`事件，因为我们有两个区域，左边是输入文本框，右边是预览区，我想实现这样的功能：当鼠标移到左边使滚动条滚动时，这个时候先监听左边的滚动事件计算出相应的滚动高度后再修改右边的滚动高度，这样右边是跟着左边的高度滚动而滚动的。相应的，当鼠标移到右边区域使滚动条滚动时，先监听右边的滚动事件计算出滚动高度后再修改左边的滚动高度。这样滚动才能实现对应关系，但是如果直接监听滚动事件，则会出现一个问题，当右边滚动时，左边滚动事件没有移除，则又会触发，计算高度后引发右边滚动，形成一个一直滚动的死循环，最后整个页面滚动位置都是乱的。\n所以，这里我先监听`mouseover`和`mouseleave`事件，话不多说看代码：\n```javascript\n  //...\n  codemirrorScroll = (doc) => () => {\n    this.props.onScroll && this.props.onScroll(doc, this.editRoot);\n  }\n\n  codemirrorScrollHandler = () => {\n    this.codeMirror.on('scroll', this.codemirrorScroll(this.codeMirror.doc));\n  }\n\n  codemirrorRemoveScroll = () => {\n    this.codeMirror.off('scroll', this.codemirrorScroll(this.codeMirror.doc));\n  }\n  //...\n  componentDidMount() {\n    //...\n    this.editRoot.addEventListener('mouseover', this.codemirrorScrollHandler);\n    this.editRoot.addEventListener('mouseleave', this.codemirrorRemoveScroll);\n  }\n```\n注意到，我在`mouseover`的时候开始监听`scroll`事件，`mouseleave`的时候移除之前的`scroll`事件，所以这里要用`codemirrorScroll`函数封装，以便移除时是同一个函数。\n这里我把`scroll`事件的处理通过props抛给父组件，我们来看看父组件是怎么实现`scroll`事件的。\n\n首先考虑到性能和滚动流畅度问题，使用`debounce`函数包装一下：\n```js\n  debounceContentScroll = debounce(this.handleScrollContent);\n```\n接下来就是如何去计算当前滚动的位置并使另一边的内容自动滚动到对应高度，这里我用一幅图解释一下：\n![markdown-scroll](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/markdown-scroll.png)\n我们主要获取的就是这三个值：`child.offsetHeight`、`parent.offsetHeight`、`child.scrollTop`。所以我们需要在展示内容外面都用`div`包一层，代表`parent`元素。先看代码：\n```js\n  calcScrollScale = (scrollTopMax1, scrollTopMax2) => (scrollTopMax1 / scrollTopMax2);\n\n  calcScrollTopMax = (parent, child) => Math.abs((child.offsetHeight || child.height) - parent.offsetHeight)\n\n  updateScroll = (scrollTop, target, scrollTopMax1, scrollTopMax2) => {\n    const scale = this.calcScrollScale(scrollTopMax1, scrollTopMax2);\n    target.scrollTop = scrollTop / scale;\n  }\n\n  handleScrollContent = (doc, docParent) => {\n    const mdPreview = this.mdPreview.current;\n    const previewContent = this.previewContent.current;\n    const scrollTopMaxFrom = this.calcScrollTopMax(docParent, doc);\n    const scrollTopMaxTo = this.calcScrollTopMax(mdPreview, previewContent);\n    this.updateScroll(doc.scrollTop, mdPreview, scrollTopMaxFrom, scrollTopMaxTo);\n  }\n```\n这里有个很重要的参数：`scrollTopMax`。\n`scrollTopMax = |(child.offsetHeight || child.height) - parent.offsetHeight|`。使用`child.height`是因为codemirror的`doc`对象内容高度可以直接通过`height`属性获得。为什么要这样计算？\n我们算的是当前内容可滚动的最大高度，为什么要计算这个？因为我们知道因为渲染的原因，左边输入的时候是单纯的文本，右边渲染出来有标题、图片等等，实际高度会比左边高得多，通过计算两边相对父容器可滚动的最大高度，再计算这两个的比值：`calcScrollScale = (scrollTopMax1, scrollTopMax2) => (scrollTopMax1 / scrollTopMax2);`，可以得到一个`scrollScale`。\n我们有这样一个公式：`left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax`，那么我们很容易得出右边的滚动高度：`right.scrollTop = left.scrollTop / scrollScale`。于是就可以使右边滚动到对应内容的高度了！\n\n有了左边的范例，对右边预览的container同样使用一样的监听事件，这样就可以实现双向同步滚动绑定了！！！\n\n# 总结\n实现同步滚动的关键点其实有两个：一个是注意监听事件的变化，先监听`mouseover`和`mouseleave`，这样不会出现滚动死循环。另一个是理解公式：`left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax`。理解了这两个关键点，其实同步滚动就很容易了。\n但要注意的是，这里的`debounce`设置延迟时间可能还需要好好斟酌，我默认使用20毫秒，实际滚动时还是会有点卡顿，可以适当改变一下数值。\n还有就是，因为markdown语法原因，段落之间都必须有一个空行，不然渲染出来文本没换行，导致段落不一致。\n\n> 参考资料：\n> - [scrollTop](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop)\n> - [原生JS控制多个滚动条同步跟随滚动](https://juejin.im/post/5a3bb40e5188252b145b38e3)\n","slug":"codemirror-markdown-editor-chapter2","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d5002jra4kbdcd4r4q","content":"<p>前面我们提到了如何加载<code>codemirror</code>组件和一些基本配置，以及如何实现实时预览。接下来才是重头戏，我们需要实现同屏滚动和添加自定义按钮。</p>\n<span id=\"more\"></span>\n\n<p>这篇我们先来着重讲讲同屏滚动。</p>\n<h1 id=\"同屏滚动\"><a href=\"#同屏滚动\" class=\"headerlink\" title=\"同屏滚动\"></a>同屏滚动</h1><p>我们写文档时，除了想要实时预览，还想要能同步滚动，这样写到哪预览页面就滚动到哪，不用鼠标移来移去，方便不少。但是如何实现呢？我们一步一步来。</p>\n<h2 id=\"监听事件\"><a href=\"#监听事件\" class=\"headerlink\" title=\"监听事件\"></a>监听事件</h2><p>首先，要想滚动，肯定得监听滚动事件<code>onscroll</code>，但是这里我没有直接监听<code>scroll</code>事件，因为我们有两个区域，左边是输入文本框，右边是预览区，我想实现这样的功能：当鼠标移到左边使滚动条滚动时，这个时候先监听左边的滚动事件计算出相应的滚动高度后再修改右边的滚动高度，这样右边是跟着左边的高度滚动而滚动的。相应的，当鼠标移到右边区域使滚动条滚动时，先监听右边的滚动事件计算出滚动高度后再修改左边的滚动高度。这样滚动才能实现对应关系，但是如果直接监听滚动事件，则会出现一个问题，当右边滚动时，左边滚动事件没有移除，则又会触发，计算高度后引发右边滚动，形成一个一直滚动的死循环，最后整个页面滚动位置都是乱的。<br>所以，这里我先监听<code>mouseover</code>和<code>mouseleave</code>事件，话不多说看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">codemirrorScroll = <span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">onScroll</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">onScroll</span>(doc, <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">codemirrorScrollHandler = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"title function_\">codemirrorScroll</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"property\">doc</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">codemirrorRemoveScroll = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"title function_\">codemirrorScroll</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"property\">doc</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"title function_\">componentDidMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseover&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codemirrorScrollHandler</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseleave&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codemirrorRemoveScroll</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，我在<code>mouseover</code>的时候开始监听<code>scroll</code>事件，<code>mouseleave</code>的时候移除之前的<code>scroll</code>事件，所以这里要用<code>codemirrorScroll</code>函数封装，以便移除时是同一个函数。<br>这里我把<code>scroll</code>事件的处理通过props抛给父组件，我们来看看父组件是怎么实现<code>scroll</code>事件的。</p>\n<p>首先考虑到性能和滚动流畅度问题，使用<code>debounce</code>函数包装一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounceContentScroll = <span class=\"title function_\">debounce</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">handleScrollContent</span>);</span><br></pre></td></tr></table></figure>\n<p>接下来就是如何去计算当前滚动的位置并使另一边的内容自动滚动到对应高度，这里我用一幅图解释一下：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/markdown-scroll.png\" alt=\"markdown-scroll\"><br>我们主要获取的就是这三个值：<code>child.offsetHeight</code>、<code>parent.offsetHeight</code>、<code>child.scrollTop</code>。所以我们需要在展示内容外面都用<code>div</code>包一层，代表<code>parent</code>元素。先看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calcScrollScale = <span class=\"function\">(<span class=\"params\">scrollTopMax1, scrollTopMax2</span>) =&gt;</span> (scrollTopMax1 / scrollTopMax2);</span><br><span class=\"line\"></span><br><span class=\"line\">calcScrollTopMax = <span class=\"function\">(<span class=\"params\">parent, child</span>) =&gt;</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>((child.<span class=\"property\">offsetHeight</span> || child.<span class=\"property\">height</span>) - parent.<span class=\"property\">offsetHeight</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">updateScroll = <span class=\"function\">(<span class=\"params\">scrollTop, target, scrollTopMax1, scrollTopMax2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> scale = <span class=\"variable language_\">this</span>.<span class=\"title function_\">calcScrollScale</span>(scrollTopMax1, scrollTopMax2);</span><br><span class=\"line\">  target.<span class=\"property\">scrollTop</span> = scrollTop / scale;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">handleScrollContent = <span class=\"function\">(<span class=\"params\">doc, docParent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mdPreview = <span class=\"variable language_\">this</span>.<span class=\"property\">mdPreview</span>.<span class=\"property\">current</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> previewContent = <span class=\"variable language_\">this</span>.<span class=\"property\">previewContent</span>.<span class=\"property\">current</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> scrollTopMaxFrom = <span class=\"variable language_\">this</span>.<span class=\"title function_\">calcScrollTopMax</span>(docParent, doc);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> scrollTopMaxTo = <span class=\"variable language_\">this</span>.<span class=\"title function_\">calcScrollTopMax</span>(mdPreview, previewContent);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">updateScroll</span>(doc.<span class=\"property\">scrollTop</span>, mdPreview, scrollTopMaxFrom, scrollTopMaxTo);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有个很重要的参数：<code>scrollTopMax</code>。<br><code>scrollTopMax = |(child.offsetHeight || child.height) - parent.offsetHeight|</code>。使用<code>child.height</code>是因为codemirror的<code>doc</code>对象内容高度可以直接通过<code>height</code>属性获得。为什么要这样计算？<br>我们算的是当前内容可滚动的最大高度，为什么要计算这个？因为我们知道因为渲染的原因，左边输入的时候是单纯的文本，右边渲染出来有标题、图片等等，实际高度会比左边高得多，通过计算两边相对父容器可滚动的最大高度，再计算这两个的比值：<code>calcScrollScale = (scrollTopMax1, scrollTopMax2) =&gt; (scrollTopMax1 / scrollTopMax2);</code>，可以得到一个<code>scrollScale</code>。<br>我们有这样一个公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>，那么我们很容易得出右边的滚动高度：<code>right.scrollTop = left.scrollTop / scrollScale</code>。于是就可以使右边滚动到对应内容的高度了！</p>\n<p>有了左边的范例，对右边预览的container同样使用一样的监听事件，这样就可以实现双向同步滚动绑定了！！！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>实现同步滚动的关键点其实有两个：一个是注意监听事件的变化，先监听<code>mouseover</code>和<code>mouseleave</code>，这样不会出现滚动死循环。另一个是理解公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>。理解了这两个关键点，其实同步滚动就很容易了。<br>但要注意的是，这里的<code>debounce</code>设置延迟时间可能还需要好好斟酌，我默认使用20毫秒，实际滚动时还是会有点卡顿，可以适当改变一下数值。<br>还有就是，因为markdown语法原因，段落之间都必须有一个空行，不然渲染出来文本没换行，导致段落不一致。</p>\n<blockquote>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\">scrollTop</a></li>\n<li><a href=\"https://juejin.im/post/5a3bb40e5188252b145b38e3\">原生JS控制多个滚动条同步跟随滚动</a></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>前面我们提到了如何加载<code>codemirror</code>组件和一些基本配置，以及如何实现实时预览。接下来才是重头戏，我们需要实现同屏滚动和添加自定义按钮。</p>","more":"<p>这篇我们先来着重讲讲同屏滚动。</p>\n<h1 id=\"同屏滚动\"><a href=\"#同屏滚动\" class=\"headerlink\" title=\"同屏滚动\"></a>同屏滚动</h1><p>我们写文档时，除了想要实时预览，还想要能同步滚动，这样写到哪预览页面就滚动到哪，不用鼠标移来移去，方便不少。但是如何实现呢？我们一步一步来。</p>\n<h2 id=\"监听事件\"><a href=\"#监听事件\" class=\"headerlink\" title=\"监听事件\"></a>监听事件</h2><p>首先，要想滚动，肯定得监听滚动事件<code>onscroll</code>，但是这里我没有直接监听<code>scroll</code>事件，因为我们有两个区域，左边是输入文本框，右边是预览区，我想实现这样的功能：当鼠标移到左边使滚动条滚动时，这个时候先监听左边的滚动事件计算出相应的滚动高度后再修改右边的滚动高度，这样右边是跟着左边的高度滚动而滚动的。相应的，当鼠标移到右边区域使滚动条滚动时，先监听右边的滚动事件计算出滚动高度后再修改左边的滚动高度。这样滚动才能实现对应关系，但是如果直接监听滚动事件，则会出现一个问题，当右边滚动时，左边滚动事件没有移除，则又会触发，计算高度后引发右边滚动，形成一个一直滚动的死循环，最后整个页面滚动位置都是乱的。<br>所以，这里我先监听<code>mouseover</code>和<code>mouseleave</code>事件，话不多说看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\">codemirrorScroll = <span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"property\">onScroll</span> &amp;&amp; <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">onScroll</span>(doc, <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">codemirrorScrollHandler = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">on</span>(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"title function_\">codemirrorScroll</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"property\">doc</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">codemirrorRemoveScroll = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;scroll&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"title function_\">codemirrorScroll</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">codeMirror</span>.<span class=\"property\">doc</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"title function_\">componentDidMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseover&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codemirrorScrollHandler</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">editRoot</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;mouseleave&#x27;</span>, <span class=\"variable language_\">this</span>.<span class=\"property\">codemirrorRemoveScroll</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到，我在<code>mouseover</code>的时候开始监听<code>scroll</code>事件，<code>mouseleave</code>的时候移除之前的<code>scroll</code>事件，所以这里要用<code>codemirrorScroll</code>函数封装，以便移除时是同一个函数。<br>这里我把<code>scroll</code>事件的处理通过props抛给父组件，我们来看看父组件是怎么实现<code>scroll</code>事件的。</p>\n<p>首先考虑到性能和滚动流畅度问题，使用<code>debounce</code>函数包装一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debounceContentScroll = <span class=\"title function_\">debounce</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">handleScrollContent</span>);</span><br></pre></td></tr></table></figure>\n<p>接下来就是如何去计算当前滚动的位置并使另一边的内容自动滚动到对应高度，这里我用一幅图解释一下：<br><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/markdown-scroll.png\" alt=\"markdown-scroll\"><br>我们主要获取的就是这三个值：<code>child.offsetHeight</code>、<code>parent.offsetHeight</code>、<code>child.scrollTop</code>。所以我们需要在展示内容外面都用<code>div</code>包一层，代表<code>parent</code>元素。先看代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">calcScrollScale = <span class=\"function\">(<span class=\"params\">scrollTopMax1, scrollTopMax2</span>) =&gt;</span> (scrollTopMax1 / scrollTopMax2);</span><br><span class=\"line\"></span><br><span class=\"line\">calcScrollTopMax = <span class=\"function\">(<span class=\"params\">parent, child</span>) =&gt;</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">abs</span>((child.<span class=\"property\">offsetHeight</span> || child.<span class=\"property\">height</span>) - parent.<span class=\"property\">offsetHeight</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">updateScroll = <span class=\"function\">(<span class=\"params\">scrollTop, target, scrollTopMax1, scrollTopMax2</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> scale = <span class=\"variable language_\">this</span>.<span class=\"title function_\">calcScrollScale</span>(scrollTopMax1, scrollTopMax2);</span><br><span class=\"line\">  target.<span class=\"property\">scrollTop</span> = scrollTop / scale;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">handleScrollContent = <span class=\"function\">(<span class=\"params\">doc, docParent</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> mdPreview = <span class=\"variable language_\">this</span>.<span class=\"property\">mdPreview</span>.<span class=\"property\">current</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> previewContent = <span class=\"variable language_\">this</span>.<span class=\"property\">previewContent</span>.<span class=\"property\">current</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> scrollTopMaxFrom = <span class=\"variable language_\">this</span>.<span class=\"title function_\">calcScrollTopMax</span>(docParent, doc);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> scrollTopMaxTo = <span class=\"variable language_\">this</span>.<span class=\"title function_\">calcScrollTopMax</span>(mdPreview, previewContent);</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"title function_\">updateScroll</span>(doc.<span class=\"property\">scrollTop</span>, mdPreview, scrollTopMaxFrom, scrollTopMaxTo);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有个很重要的参数：<code>scrollTopMax</code>。<br><code>scrollTopMax = |(child.offsetHeight || child.height) - parent.offsetHeight|</code>。使用<code>child.height</code>是因为codemirror的<code>doc</code>对象内容高度可以直接通过<code>height</code>属性获得。为什么要这样计算？<br>我们算的是当前内容可滚动的最大高度，为什么要计算这个？因为我们知道因为渲染的原因，左边输入的时候是单纯的文本，右边渲染出来有标题、图片等等，实际高度会比左边高得多，通过计算两边相对父容器可滚动的最大高度，再计算这两个的比值：<code>calcScrollScale = (scrollTopMax1, scrollTopMax2) =&gt; (scrollTopMax1 / scrollTopMax2);</code>，可以得到一个<code>scrollScale</code>。<br>我们有这样一个公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>，那么我们很容易得出右边的滚动高度：<code>right.scrollTop = left.scrollTop / scrollScale</code>。于是就可以使右边滚动到对应内容的高度了！</p>\n<p>有了左边的范例，对右边预览的container同样使用一样的监听事件，这样就可以实现双向同步滚动绑定了！！！</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>实现同步滚动的关键点其实有两个：一个是注意监听事件的变化，先监听<code>mouseover</code>和<code>mouseleave</code>，这样不会出现滚动死循环。另一个是理解公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>。理解了这两个关键点，其实同步滚动就很容易了。<br>但要注意的是，这里的<code>debounce</code>设置延迟时间可能还需要好好斟酌，我默认使用20毫秒，实际滚动时还是会有点卡顿，可以适当改变一下数值。<br>还有就是，因为markdown语法原因，段落之间都必须有一个空行，不然渲染出来文本没换行，导致段落不一致。</p>\n<blockquote>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop\">scrollTop</a></li>\n<li><a href=\"https://juejin.im/post/5a3bb40e5188252b145b38e3\">原生JS控制多个滚动条同步跟随滚动</a></li>\n</ul>\n</blockquote>"},{"title":"迟来的2018总结","date":"2019-01-09T10:40:33.000Z","_content":"\n已经2019年了，由于最近一大堆事情，没有时间更博，现在终于有时间好好坐下来总结一下自己的2018了。\n\n<!--more-->\n\n要是问我生命中最重要的年份有哪些，2018年肯定是其中之一。\n\n这一年，我结束了学生生涯，正式踏上了工作岗位，成为了社会人。\n\n这一年，我从成都只身一人来到杭州，没有听父母的意见去传统行业寻求稳定的工作，而是投入到互联网的浪潮当中。\n\n这一年，我找到了我爱的那个她，希望可以和她一起走下去，我们的路，才刚刚开始。\n\n这一年...\n\n# 工作\n\n这一年最大的改变，就是我脱离了学生这个群体，走向了社会这个大熔炉。说实话，6月底刚刚毕业离开校园，心里面还是充满了对未来未知的恐惧。从小到大，生活都是按部就班，小学、中学、到大学，你可以清晰地看到前面的路，要做的就是好好学习，往前走就行了。但是，现在不同了，工作以后，前面的路一切都是未知的，走得怎么样，全取决于自己，没有人替我安排。\n\n工作半年，其实挺困惑的，因为很多时候自己还停留在学生思维，学生时代做事，都有人推着你走，老师会帮你监督，做的好不好，更多的时候取决于你考的好不好，得到的反馈简单又明了。但是工作后才发现，所有的事情都变的不一样了。没有人帮你设定目标，没有人推着你走，即使你什么都不做也不会有人来管你，领导只看最后的结果，用数据说话，只有主动出击，才能收获成果，被动地等待，永远只能在原地打转。\n\n所以说，作为职场新人，我还有很长的路要走，首先需要改变的就是自己的思维模式，做一个主动出击的人。\n\n# 技术\n\n作为一个刚入门的前端工程师，2018年也是我技术提升最快的一年。这里用一张思维导图记录下自己的前端学习之路。\n\n![frontend-learning](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/front-end-learning.jpg)\n\n这只是我总结的一个大概版本，之后还会不断补充。其实里面很多知识我都只是刚刚了解，还需要不断深入。\n\n2018，对于我来说算是正式入了前端的大门，对整个前端的大架构也有了初步的了解，但是这还只是刚开始，前端要学的东西太多了，我不能停止学习的步伐，虽然工作后可能学习的时间变少了，但不管怎样都要抽时间出来自学，时刻保持好奇心和学习力。而且，前端工程师也是程序员，算法、数据结构、计算机网络等基本知识也需要巩固了解，技术的路上，学无止境。\n\n2019我需要在巩固基础知识的同时，不断扩展自己的知识面，多写代码，多实践，只有在实践中才能真正学会运用相关知识。talk is cheap, just show the code.\n\n# 生活\n\n2018最幸福的事，就是终于脱离了单身狗的队伍！撒狗粮的事就不多说了，一切才刚刚开始，我希望未来能和她一起携手度过每一天，成为我们彼此眼中那个更好的自己。\n\n工作后，离开了父母的怀抱，生活中某种意义上成为了真正独立的个体，很多事情都需要自己来操作，我需要慢慢适应新生活的节奏，承担起更多的责任，平衡好工作与生活的时间点。\n\n# 总结\n\n碎碎念了这么多，新的一年，新的开始，我希望未来的一年在工作、技术、生活方面都能不断成长蜕变，不停下自己的脚步。","source":"_posts/2019-01-09-2018-road-to-grow-up.md","raw":"---\ntitle: 迟来的2018总结\ndate: 2019-01-09 18:40:33\ncategories:\n- 随笔\ntags:\n- 思考感悟\n---\n\n已经2019年了，由于最近一大堆事情，没有时间更博，现在终于有时间好好坐下来总结一下自己的2018了。\n\n<!--more-->\n\n要是问我生命中最重要的年份有哪些，2018年肯定是其中之一。\n\n这一年，我结束了学生生涯，正式踏上了工作岗位，成为了社会人。\n\n这一年，我从成都只身一人来到杭州，没有听父母的意见去传统行业寻求稳定的工作，而是投入到互联网的浪潮当中。\n\n这一年，我找到了我爱的那个她，希望可以和她一起走下去，我们的路，才刚刚开始。\n\n这一年...\n\n# 工作\n\n这一年最大的改变，就是我脱离了学生这个群体，走向了社会这个大熔炉。说实话，6月底刚刚毕业离开校园，心里面还是充满了对未来未知的恐惧。从小到大，生活都是按部就班，小学、中学、到大学，你可以清晰地看到前面的路，要做的就是好好学习，往前走就行了。但是，现在不同了，工作以后，前面的路一切都是未知的，走得怎么样，全取决于自己，没有人替我安排。\n\n工作半年，其实挺困惑的，因为很多时候自己还停留在学生思维，学生时代做事，都有人推着你走，老师会帮你监督，做的好不好，更多的时候取决于你考的好不好，得到的反馈简单又明了。但是工作后才发现，所有的事情都变的不一样了。没有人帮你设定目标，没有人推着你走，即使你什么都不做也不会有人来管你，领导只看最后的结果，用数据说话，只有主动出击，才能收获成果，被动地等待，永远只能在原地打转。\n\n所以说，作为职场新人，我还有很长的路要走，首先需要改变的就是自己的思维模式，做一个主动出击的人。\n\n# 技术\n\n作为一个刚入门的前端工程师，2018年也是我技术提升最快的一年。这里用一张思维导图记录下自己的前端学习之路。\n\n![frontend-learning](https://photos-1258216033.cos.ap-shanghai.myqcloud.com/front-end-learning.jpg)\n\n这只是我总结的一个大概版本，之后还会不断补充。其实里面很多知识我都只是刚刚了解，还需要不断深入。\n\n2018，对于我来说算是正式入了前端的大门，对整个前端的大架构也有了初步的了解，但是这还只是刚开始，前端要学的东西太多了，我不能停止学习的步伐，虽然工作后可能学习的时间变少了，但不管怎样都要抽时间出来自学，时刻保持好奇心和学习力。而且，前端工程师也是程序员，算法、数据结构、计算机网络等基本知识也需要巩固了解，技术的路上，学无止境。\n\n2019我需要在巩固基础知识的同时，不断扩展自己的知识面，多写代码，多实践，只有在实践中才能真正学会运用相关知识。talk is cheap, just show the code.\n\n# 生活\n\n2018最幸福的事，就是终于脱离了单身狗的队伍！撒狗粮的事就不多说了，一切才刚刚开始，我希望未来能和她一起携手度过每一天，成为我们彼此眼中那个更好的自己。\n\n工作后，离开了父母的怀抱，生活中某种意义上成为了真正独立的个体，很多事情都需要自己来操作，我需要慢慢适应新生活的节奏，承担起更多的责任，平衡好工作与生活的时间点。\n\n# 总结\n\n碎碎念了这么多，新的一年，新的开始，我希望未来的一年在工作、技术、生活方面都能不断成长蜕变，不停下自己的脚步。","slug":"2018-road-to-grow-up","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d6002lra4k1pi19hte","content":"<p>已经2019年了，由于最近一大堆事情，没有时间更博，现在终于有时间好好坐下来总结一下自己的2018了。</p>\n<span id=\"more\"></span>\n\n<p>要是问我生命中最重要的年份有哪些，2018年肯定是其中之一。</p>\n<p>这一年，我结束了学生生涯，正式踏上了工作岗位，成为了社会人。</p>\n<p>这一年，我从成都只身一人来到杭州，没有听父母的意见去传统行业寻求稳定的工作，而是投入到互联网的浪潮当中。</p>\n<p>这一年，我找到了我爱的那个她，希望可以和她一起走下去，我们的路，才刚刚开始。</p>\n<p>这一年…</p>\n<h1 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h1><p>这一年最大的改变，就是我脱离了学生这个群体，走向了社会这个大熔炉。说实话，6月底刚刚毕业离开校园，心里面还是充满了对未来未知的恐惧。从小到大，生活都是按部就班，小学、中学、到大学，你可以清晰地看到前面的路，要做的就是好好学习，往前走就行了。但是，现在不同了，工作以后，前面的路一切都是未知的，走得怎么样，全取决于自己，没有人替我安排。</p>\n<p>工作半年，其实挺困惑的，因为很多时候自己还停留在学生思维，学生时代做事，都有人推着你走，老师会帮你监督，做的好不好，更多的时候取决于你考的好不好，得到的反馈简单又明了。但是工作后才发现，所有的事情都变的不一样了。没有人帮你设定目标，没有人推着你走，即使你什么都不做也不会有人来管你，领导只看最后的结果，用数据说话，只有主动出击，才能收获成果，被动地等待，永远只能在原地打转。</p>\n<p>所以说，作为职场新人，我还有很长的路要走，首先需要改变的就是自己的思维模式，做一个主动出击的人。</p>\n<h1 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h1><p>作为一个刚入门的前端工程师，2018年也是我技术提升最快的一年。这里用一张思维导图记录下自己的前端学习之路。</p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/front-end-learning.jpg\" alt=\"frontend-learning\"></p>\n<p>这只是我总结的一个大概版本，之后还会不断补充。其实里面很多知识我都只是刚刚了解，还需要不断深入。</p>\n<p>2018，对于我来说算是正式入了前端的大门，对整个前端的大架构也有了初步的了解，但是这还只是刚开始，前端要学的东西太多了，我不能停止学习的步伐，虽然工作后可能学习的时间变少了，但不管怎样都要抽时间出来自学，时刻保持好奇心和学习力。而且，前端工程师也是程序员，算法、数据结构、计算机网络等基本知识也需要巩固了解，技术的路上，学无止境。</p>\n<p>2019我需要在巩固基础知识的同时，不断扩展自己的知识面，多写代码，多实践，只有在实践中才能真正学会运用相关知识。talk is cheap, just show the code.</p>\n<h1 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h1><p>2018最幸福的事，就是终于脱离了单身狗的队伍！撒狗粮的事就不多说了，一切才刚刚开始，我希望未来能和她一起携手度过每一天，成为我们彼此眼中那个更好的自己。</p>\n<p>工作后，离开了父母的怀抱，生活中某种意义上成为了真正独立的个体，很多事情都需要自己来操作，我需要慢慢适应新生活的节奏，承担起更多的责任，平衡好工作与生活的时间点。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>碎碎念了这么多，新的一年，新的开始，我希望未来的一年在工作、技术、生活方面都能不断成长蜕变，不停下自己的脚步。</p>\n","site":{"data":{}},"excerpt":"<p>已经2019年了，由于最近一大堆事情，没有时间更博，现在终于有时间好好坐下来总结一下自己的2018了。</p>","more":"<p>要是问我生命中最重要的年份有哪些，2018年肯定是其中之一。</p>\n<p>这一年，我结束了学生生涯，正式踏上了工作岗位，成为了社会人。</p>\n<p>这一年，我从成都只身一人来到杭州，没有听父母的意见去传统行业寻求稳定的工作，而是投入到互联网的浪潮当中。</p>\n<p>这一年，我找到了我爱的那个她，希望可以和她一起走下去，我们的路，才刚刚开始。</p>\n<p>这一年…</p>\n<h1 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h1><p>这一年最大的改变，就是我脱离了学生这个群体，走向了社会这个大熔炉。说实话，6月底刚刚毕业离开校园，心里面还是充满了对未来未知的恐惧。从小到大，生活都是按部就班，小学、中学、到大学，你可以清晰地看到前面的路，要做的就是好好学习，往前走就行了。但是，现在不同了，工作以后，前面的路一切都是未知的，走得怎么样，全取决于自己，没有人替我安排。</p>\n<p>工作半年，其实挺困惑的，因为很多时候自己还停留在学生思维，学生时代做事，都有人推着你走，老师会帮你监督，做的好不好，更多的时候取决于你考的好不好，得到的反馈简单又明了。但是工作后才发现，所有的事情都变的不一样了。没有人帮你设定目标，没有人推着你走，即使你什么都不做也不会有人来管你，领导只看最后的结果，用数据说话，只有主动出击，才能收获成果，被动地等待，永远只能在原地打转。</p>\n<p>所以说，作为职场新人，我还有很长的路要走，首先需要改变的就是自己的思维模式，做一个主动出击的人。</p>\n<h1 id=\"技术\"><a href=\"#技术\" class=\"headerlink\" title=\"技术\"></a>技术</h1><p>作为一个刚入门的前端工程师，2018年也是我技术提升最快的一年。这里用一张思维导图记录下自己的前端学习之路。</p>\n<p><img src=\"https://photos-1258216033.cos.ap-shanghai.myqcloud.com/front-end-learning.jpg\" alt=\"frontend-learning\"></p>\n<p>这只是我总结的一个大概版本，之后还会不断补充。其实里面很多知识我都只是刚刚了解，还需要不断深入。</p>\n<p>2018，对于我来说算是正式入了前端的大门，对整个前端的大架构也有了初步的了解，但是这还只是刚开始，前端要学的东西太多了，我不能停止学习的步伐，虽然工作后可能学习的时间变少了，但不管怎样都要抽时间出来自学，时刻保持好奇心和学习力。而且，前端工程师也是程序员，算法、数据结构、计算机网络等基本知识也需要巩固了解，技术的路上，学无止境。</p>\n<p>2019我需要在巩固基础知识的同时，不断扩展自己的知识面，多写代码，多实践，只有在实践中才能真正学会运用相关知识。talk is cheap, just show the code.</p>\n<h1 id=\"生活\"><a href=\"#生活\" class=\"headerlink\" title=\"生活\"></a>生活</h1><p>2018最幸福的事，就是终于脱离了单身狗的队伍！撒狗粮的事就不多说了，一切才刚刚开始，我希望未来能和她一起携手度过每一天，成为我们彼此眼中那个更好的自己。</p>\n<p>工作后，离开了父母的怀抱，生活中某种意义上成为了真正独立的个体，很多事情都需要自己来操作，我需要慢慢适应新生活的节奏，承担起更多的责任，平衡好工作与生活的时间点。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>碎碎念了这么多，新的一年，新的开始，我希望未来的一年在工作、技术、生活方面都能不断成长蜕变，不停下自己的脚步。</p>"},{"title":"如何实现页面不同内容之间的跳转","date":"2019-01-12T09:10:54.000Z","_content":"\n我们常常会碰到这样的需求：点击某个标题、某段话，跳转到页面对应的位置，并且浏览器不会刷新，相当于在页面进行内部导航，这在浏览文章、或者是内容比较多的长屏单页应用上有着迫切的需求。那么，如何实现这个简单的功能呢？\n\n<!--more-->\n\n# 利用a标签的href值\n\n我们知道，`<a>`标签的`href`属性支持绝对路径和相对路径，其实它还支持路由hash。打个比方，我们的浏览器地址是：`http://www.example.com`，HTML里有这样一个标签：`<a href=\"#start\">click</a>`，点击该标签后，浏览器的URL地址后面就会多出一个hash值：`http://www.example.com#start`，如果HTML里有id为`start`的元素，则浏览器窗口会自动滚动到该元素所在的位置，也就是使该元素滚动到视窗最上面。\n\n那么，很简单的我们就可以利用这个属性实现跳转到页面任何位置，只要在想要跳转的地方设置`id`值，再通过设置`a`标签的`href`为`#id`，我们就可以实现跳转。\n\n为什么我们可以使用`#id`实现跳转呢？我们先来看看MDN的定义：\n\n> **href**\n>\n> Contains a URL or a URL fragment that the hyperlink points to.\n>\n> A URL fragment is a name preceded by a hash mark (`#`), which specifies an internal target location (an `id` of an HTML element) within the current document.\n\n什么意思呢？其实`href`就是给定一个超链接，它的值指向的其实是一个URL或者URL片段，而一个URL片段通常是以`#name`的形式，代表着当前文档页面内部target的位置（也就是一个HTML元素的id），所以我们就可以利用`id`来进行页面内部元素之间的跳转。\n\n那么如果要跳转到页面顶部呢？有的人可能会说：用JS设置`scrollTop`的值不就好了，这当然可以，之前我也写过跳转到顶部的[文章](https://xmflyrk.com/2017/08/22/scroll-to-top-btn/)。但是，如果不用JS呢？很简单，我们直接这样设置：`<a href=\"#\">click to top</a>`，点击就能直接跳转到页面顶部了！\n\n这是为什么呢？我们知道`#`后面的name值代表的是某个元素的`id`，但如果没有这个name，那就代表所有元素，也就是整个页面，所以就把页面移动到视窗的最顶部了，是不是很方便呢。但是这样有一点不好，就是没有滚动动画，跳转比较生硬，对于UI动画要求不高的页面用这个非常合适。\n\n# Input和Label的妙用\n\n那么除了利用`a`标签，还有其他方法可以在不用JS的情况下实现跳转吗？答案就是利用`input`和`label`标签！\n\n我们先在想要跳转的地方增加一个`input`标签：\n\n```html\n<body>\n    <input id=\"anchor\">\t// 这是我们要跳转的位置\n    <article>\n    \t<h1>This is a title</h1>\n        <p>\n            LoraeraweMefawef wefaewfaw fawe fwae faw\n        </p>\n        // 假设文章很长...\n    </article>\n</body>\n```\n\n然后设置`CSS`令其不可见：\n\n```css\n#anchor {\n  content: '';\n  font-size: 0;\n  width: 0;\n  height: 0;\n  border: 0 transparent;\n}\n#anchor:focus {\n  outline: 0;\n}\n```\n\n接下来做什么呢？我们知道`label`标签有一个`for`属性，它的值代表着对应`input`的`id`，当设置了`for`值为某个`input`的`id`，我们点击`label`，则会令对应的`<input>`变为`focus`状态，而当某个元素为focus状态时，浏览器窗口会自动使其滚动到视窗内，这样我们就实现了点击跳转功能！\n\n```html\n<body>\n    <input id=\"anchor\">\t// 这是我们要跳转的位置\n    <article>\n    \t<h1>This is a title</h1>\n        <p>\n            LoraeraweMefawef wefaewfaw fawe fwae faw\n        </p>\n        // 假设文章很长...\n    </article>\n    <label for=\"anchor\">点击跳转</label>\n</body>\n```\n\n# 总结\n\n这里我们用到了两种方法实现页面元素跳转，都没有用到JavaScript，在对滚动动画要求不高的条件下，用这两种方法能简单有效的实现跳转需求，值得一试！","source":"_posts/2019-01-12-use-anchor-jump-to-anywhere-in-page.md","raw":"---\ntitle: 如何实现页面不同内容之间的跳转\ndate: 2019-01-12 17:10:54\ncategories:\n- JS相关\ntags:\n- JS技巧\n---\n\n我们常常会碰到这样的需求：点击某个标题、某段话，跳转到页面对应的位置，并且浏览器不会刷新，相当于在页面进行内部导航，这在浏览文章、或者是内容比较多的长屏单页应用上有着迫切的需求。那么，如何实现这个简单的功能呢？\n\n<!--more-->\n\n# 利用a标签的href值\n\n我们知道，`<a>`标签的`href`属性支持绝对路径和相对路径，其实它还支持路由hash。打个比方，我们的浏览器地址是：`http://www.example.com`，HTML里有这样一个标签：`<a href=\"#start\">click</a>`，点击该标签后，浏览器的URL地址后面就会多出一个hash值：`http://www.example.com#start`，如果HTML里有id为`start`的元素，则浏览器窗口会自动滚动到该元素所在的位置，也就是使该元素滚动到视窗最上面。\n\n那么，很简单的我们就可以利用这个属性实现跳转到页面任何位置，只要在想要跳转的地方设置`id`值，再通过设置`a`标签的`href`为`#id`，我们就可以实现跳转。\n\n为什么我们可以使用`#id`实现跳转呢？我们先来看看MDN的定义：\n\n> **href**\n>\n> Contains a URL or a URL fragment that the hyperlink points to.\n>\n> A URL fragment is a name preceded by a hash mark (`#`), which specifies an internal target location (an `id` of an HTML element) within the current document.\n\n什么意思呢？其实`href`就是给定一个超链接，它的值指向的其实是一个URL或者URL片段，而一个URL片段通常是以`#name`的形式，代表着当前文档页面内部target的位置（也就是一个HTML元素的id），所以我们就可以利用`id`来进行页面内部元素之间的跳转。\n\n那么如果要跳转到页面顶部呢？有的人可能会说：用JS设置`scrollTop`的值不就好了，这当然可以，之前我也写过跳转到顶部的[文章](https://xmflyrk.com/2017/08/22/scroll-to-top-btn/)。但是，如果不用JS呢？很简单，我们直接这样设置：`<a href=\"#\">click to top</a>`，点击就能直接跳转到页面顶部了！\n\n这是为什么呢？我们知道`#`后面的name值代表的是某个元素的`id`，但如果没有这个name，那就代表所有元素，也就是整个页面，所以就把页面移动到视窗的最顶部了，是不是很方便呢。但是这样有一点不好，就是没有滚动动画，跳转比较生硬，对于UI动画要求不高的页面用这个非常合适。\n\n# Input和Label的妙用\n\n那么除了利用`a`标签，还有其他方法可以在不用JS的情况下实现跳转吗？答案就是利用`input`和`label`标签！\n\n我们先在想要跳转的地方增加一个`input`标签：\n\n```html\n<body>\n    <input id=\"anchor\">\t// 这是我们要跳转的位置\n    <article>\n    \t<h1>This is a title</h1>\n        <p>\n            LoraeraweMefawef wefaewfaw fawe fwae faw\n        </p>\n        // 假设文章很长...\n    </article>\n</body>\n```\n\n然后设置`CSS`令其不可见：\n\n```css\n#anchor {\n  content: '';\n  font-size: 0;\n  width: 0;\n  height: 0;\n  border: 0 transparent;\n}\n#anchor:focus {\n  outline: 0;\n}\n```\n\n接下来做什么呢？我们知道`label`标签有一个`for`属性，它的值代表着对应`input`的`id`，当设置了`for`值为某个`input`的`id`，我们点击`label`，则会令对应的`<input>`变为`focus`状态，而当某个元素为focus状态时，浏览器窗口会自动使其滚动到视窗内，这样我们就实现了点击跳转功能！\n\n```html\n<body>\n    <input id=\"anchor\">\t// 这是我们要跳转的位置\n    <article>\n    \t<h1>This is a title</h1>\n        <p>\n            LoraeraweMefawef wefaewfaw fawe fwae faw\n        </p>\n        // 假设文章很长...\n    </article>\n    <label for=\"anchor\">点击跳转</label>\n</body>\n```\n\n# 总结\n\n这里我们用到了两种方法实现页面元素跳转，都没有用到JavaScript，在对滚动动画要求不高的条件下，用这两种方法能简单有效的实现跳转需求，值得一试！","slug":"use-anchor-jump-to-anywhere-in-page","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d8002ora4khr954jkp","content":"<p>我们常常会碰到这样的需求：点击某个标题、某段话，跳转到页面对应的位置，并且浏览器不会刷新，相当于在页面进行内部导航，这在浏览文章、或者是内容比较多的长屏单页应用上有着迫切的需求。那么，如何实现这个简单的功能呢？</p>\n<span id=\"more\"></span>\n\n<h1 id=\"利用a标签的href值\"><a href=\"#利用a标签的href值\" class=\"headerlink\" title=\"利用a标签的href值\"></a>利用a标签的href值</h1><p>我们知道，<code>&lt;a&gt;</code>标签的<code>href</code>属性支持绝对路径和相对路径，其实它还支持路由hash。打个比方，我们的浏览器地址是：<code>http://www.example.com</code>，HTML里有这样一个标签：<code>&lt;a href=&quot;#start&quot;&gt;click&lt;/a&gt;</code>，点击该标签后，浏览器的URL地址后面就会多出一个hash值：<code>http://www.example.com#start</code>，如果HTML里有id为<code>start</code>的元素，则浏览器窗口会自动滚动到该元素所在的位置，也就是使该元素滚动到视窗最上面。</p>\n<p>那么，很简单的我们就可以利用这个属性实现跳转到页面任何位置，只要在想要跳转的地方设置<code>id</code>值，再通过设置<code>a</code>标签的<code>href</code>为<code>#id</code>，我们就可以实现跳转。</p>\n<p>为什么我们可以使用<code>#id</code>实现跳转呢？我们先来看看MDN的定义：</p>\n<blockquote>\n<p><strong>href</strong></p>\n<p>Contains a URL or a URL fragment that the hyperlink points to.</p>\n<p>A URL fragment is a name preceded by a hash mark (<code>#</code>), which specifies an internal target location (an <code>id</code> of an HTML element) within the current document.</p>\n</blockquote>\n<p>什么意思呢？其实<code>href</code>就是给定一个超链接，它的值指向的其实是一个URL或者URL片段，而一个URL片段通常是以<code>#name</code>的形式，代表着当前文档页面内部target的位置（也就是一个HTML元素的id），所以我们就可以利用<code>id</code>来进行页面内部元素之间的跳转。</p>\n<p>那么如果要跳转到页面顶部呢？有的人可能会说：用JS设置<code>scrollTop</code>的值不就好了，这当然可以，之前我也写过跳转到顶部的<a href=\"https://xmflyrk.com/2017/08/22/scroll-to-top-btn/\">文章</a>。但是，如果不用JS呢？很简单，我们直接这样设置：<code>&lt;a href=&quot;#&quot;&gt;click to top&lt;/a&gt;</code>，点击就能直接跳转到页面顶部了！</p>\n<p>这是为什么呢？我们知道<code>#</code>后面的name值代表的是某个元素的<code>id</code>，但如果没有这个name，那就代表所有元素，也就是整个页面，所以就把页面移动到视窗的最顶部了，是不是很方便呢。但是这样有一点不好，就是没有滚动动画，跳转比较生硬，对于UI动画要求不高的页面用这个非常合适。</p>\n<h1 id=\"Input和Label的妙用\"><a href=\"#Input和Label的妙用\" class=\"headerlink\" title=\"Input和Label的妙用\"></a>Input和Label的妙用</h1><p>那么除了利用<code>a</code>标签，还有其他方法可以在不用JS的情况下实现跳转吗？答案就是利用<code>input</code>和<code>label</code>标签！</p>\n<p>我们先在想要跳转的地方增加一个<code>input</code>标签：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;anchor&quot;</span>&gt;</span>\t// 这是我们要跳转的位置</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>This is a title<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        // 假设文章很长...</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后设置<code>CSS</code>令其不可见：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#anchor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">0</span> transparent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#anchor</span><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">outline</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来做什么呢？我们知道<code>label</code>标签有一个<code>for</code>属性，它的值代表着对应<code>input</code>的<code>id</code>，当设置了<code>for</code>值为某个<code>input</code>的<code>id</code>，我们点击<code>label</code>，则会令对应的<code>&lt;input&gt;</code>变为<code>focus</code>状态，而当某个元素为focus状态时，浏览器窗口会自动使其滚动到视窗内，这样我们就实现了点击跳转功能！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;anchor&quot;</span>&gt;</span>\t// 这是我们要跳转的位置</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>This is a title<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        // 假设文章很长...</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;anchor&quot;</span>&gt;</span>点击跳转<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这里我们用到了两种方法实现页面元素跳转，都没有用到JavaScript，在对滚动动画要求不高的条件下，用这两种方法能简单有效的实现跳转需求，值得一试！</p>\n","site":{"data":{}},"excerpt":"<p>我们常常会碰到这样的需求：点击某个标题、某段话，跳转到页面对应的位置，并且浏览器不会刷新，相当于在页面进行内部导航，这在浏览文章、或者是内容比较多的长屏单页应用上有着迫切的需求。那么，如何实现这个简单的功能呢？</p>","more":"<h1 id=\"利用a标签的href值\"><a href=\"#利用a标签的href值\" class=\"headerlink\" title=\"利用a标签的href值\"></a>利用a标签的href值</h1><p>我们知道，<code>&lt;a&gt;</code>标签的<code>href</code>属性支持绝对路径和相对路径，其实它还支持路由hash。打个比方，我们的浏览器地址是：<code>http://www.example.com</code>，HTML里有这样一个标签：<code>&lt;a href=&quot;#start&quot;&gt;click&lt;/a&gt;</code>，点击该标签后，浏览器的URL地址后面就会多出一个hash值：<code>http://www.example.com#start</code>，如果HTML里有id为<code>start</code>的元素，则浏览器窗口会自动滚动到该元素所在的位置，也就是使该元素滚动到视窗最上面。</p>\n<p>那么，很简单的我们就可以利用这个属性实现跳转到页面任何位置，只要在想要跳转的地方设置<code>id</code>值，再通过设置<code>a</code>标签的<code>href</code>为<code>#id</code>，我们就可以实现跳转。</p>\n<p>为什么我们可以使用<code>#id</code>实现跳转呢？我们先来看看MDN的定义：</p>\n<blockquote>\n<p><strong>href</strong></p>\n<p>Contains a URL or a URL fragment that the hyperlink points to.</p>\n<p>A URL fragment is a name preceded by a hash mark (<code>#</code>), which specifies an internal target location (an <code>id</code> of an HTML element) within the current document.</p>\n</blockquote>\n<p>什么意思呢？其实<code>href</code>就是给定一个超链接，它的值指向的其实是一个URL或者URL片段，而一个URL片段通常是以<code>#name</code>的形式，代表着当前文档页面内部target的位置（也就是一个HTML元素的id），所以我们就可以利用<code>id</code>来进行页面内部元素之间的跳转。</p>\n<p>那么如果要跳转到页面顶部呢？有的人可能会说：用JS设置<code>scrollTop</code>的值不就好了，这当然可以，之前我也写过跳转到顶部的<a href=\"https://xmflyrk.com/2017/08/22/scroll-to-top-btn/\">文章</a>。但是，如果不用JS呢？很简单，我们直接这样设置：<code>&lt;a href=&quot;#&quot;&gt;click to top&lt;/a&gt;</code>，点击就能直接跳转到页面顶部了！</p>\n<p>这是为什么呢？我们知道<code>#</code>后面的name值代表的是某个元素的<code>id</code>，但如果没有这个name，那就代表所有元素，也就是整个页面，所以就把页面移动到视窗的最顶部了，是不是很方便呢。但是这样有一点不好，就是没有滚动动画，跳转比较生硬，对于UI动画要求不高的页面用这个非常合适。</p>\n<h1 id=\"Input和Label的妙用\"><a href=\"#Input和Label的妙用\" class=\"headerlink\" title=\"Input和Label的妙用\"></a>Input和Label的妙用</h1><p>那么除了利用<code>a</code>标签，还有其他方法可以在不用JS的情况下实现跳转吗？答案就是利用<code>input</code>和<code>label</code>标签！</p>\n<p>我们先在想要跳转的地方增加一个<code>input</code>标签：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;anchor&quot;</span>&gt;</span>\t// 这是我们要跳转的位置</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>This is a title<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        // 假设文章很长...</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后设置<code>CSS</code>令其不可见：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#anchor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">0</span> transparent;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#anchor</span><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">outline</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来做什么呢？我们知道<code>label</code>标签有一个<code>for</code>属性，它的值代表着对应<code>input</code>的<code>id</code>，当设置了<code>for</code>值为某个<code>input</code>的<code>id</code>，我们点击<code>label</code>，则会令对应的<code>&lt;input&gt;</code>变为<code>focus</code>状态，而当某个元素为focus状态时，浏览器窗口会自动使其滚动到视窗内，这样我们就实现了点击跳转功能！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;anchor&quot;</span>&gt;</span>\t// 这是我们要跳转的位置</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>This is a title<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        // 假设文章很长...</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">&quot;anchor&quot;</span>&gt;</span>点击跳转<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这里我们用到了两种方法实现页面元素跳转，都没有用到JavaScript，在对滚动动画要求不高的条件下，用这两种方法能简单有效的实现跳转需求，值得一试！</p>"},{"title":"如何实现文字输入效果","date":"2019-01-23T11:01:58.000Z","_content":"\n我们看到有些网站的文字会有类似于输入的效果，就好像自动打字一样，虽然这个效果用的地方可能不多，但如果用的好的话可能会有奇效，比如在博客、演讲展示等方面应用。那么，怎么实现呢？\n\n<!--more-->\n\n## 使用setTimeout实现\n\n第一种方法是使用setTimeout进行文字控制，每一个文字都是一个`span`，利用DOM操作以一定的间隔将每个文字添加到文档中，同时设置`opacity:1`使其显示出来。光标闪烁的效果则利用`border-left`进行animation动画展示。\n\n### HTML结构\n\n先看代码：\n\n```html\n<div class=\"container\">\n  <article class=\"input-container\">\n      <!--这里是需要展示的原始文字，设为display:none;-->\n    <p class=\"originWords\">Hello world!</p>\n  </article>\n  <article class=\"typewriter-container\">\n      <!--这里是最终有文字输入效果的文字-->\n    <p class=\"typewriter-output\"></p>\n  </article>\n</div>\n```\n\n解释一下，我们首先把原始文字设为`display: none;`，这样不会占用文档位置，然后我们给之后添加的文字`span`块指定class为`word`。\n\n### CSS设置\n\n先看代码：\n\n```css\n.container {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n}\n\n.input-container {\n  display: none;\n}\n.typewriter-container {\n  width: 50%;\n}\n.word {\n  opacity: 0;\n  transition: opacity 2s step-start;\n}\n.typewriter-output:after {\n  display: inline-block;\n  content: '';\n  vertical-align: -1px;\n  height: 14px;\n  width: 1px;\n  border-left: 2px solid black;\n  margin-left: 2px;\n  animation: shine 1s infinite;\n}\n@keyframes shine {\n  50% {\n    border-left: 0;\n  }\n}\n```\n\n我们对`word`设置`transition: opacity 2s step-start;`。这里之所以通过`opacity`来进行transition，是因为transition不支持`display`，而`opacity`只需要设置`0`或`1`就可以使元素进行显示而不需要重排。\n\n这里`transition-timing-function`使用`step-start`，使其有跳跃的效果，`step-start`相当于`steps(1, jump-start)`，`steps(n, <jumpterm>)`代表transition会停顿n次，每一次的效果为`<jumpterm>`，`jump-start`代表第一个跳跃发生在`transition`刚开始的时候，更多效果见[文档](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function)。\n\n为什么要使用`:after`呢？因为我是逐步向`typewriter-output`添加`span`块，所以一开始宽度是不确定的，而且光标高度也不好设置，所以我想了个笨方法，使用`after`伪元素生成一个光标，并用`animation`控制其`border-left`的显示。但这里有个bug就是文字显示的间隔不能超过300ms，所以说这样处理还是有些问题，以后可能会有更好的方法。\n\n### JS部分\n\n其实就是利用`setTimout`设置时间间隔，通过DOM操作进行添加文字，先看代码：\n\n```javascript\nvar words = document.querySelector('.originWords').innerText;\nvar output = document.querySelector('.typewriter-output');\nvar word = null;\nvar lastWord = null;\n\nfor (var i = 0, l = words.length; i< l; i++) {\n  setTimeout(writeWord(i), i * 200);\t// 每隔0.2s输出一个文字\n}\n// 这里使用闭包保存i\nfunction writeWord(index) {\n  return function () {\n    word = document.createElement('span');\n    word.classList.add('word');\n    output.appendChild(word);\n    if (!lastWord) {\n      lastWord = word;\n    }\n\n    if (lastWord !== word) {\n     lastWord.style.opacity = '1'; \n    }\n    word.innerText = words[index];\n    lastWord = word;\n    if (index === words.length - 1) {\n      lastWord.style.opacity = '1';\n    }\n  }\n}\n```\n\n代码部分很简单，就是先获取需要展示的文字内容，然后每个字都通过dom操作塞进去，设置`opacity:1`，再进行一下边界判断，就实现了文字的展示。\n\n---\n\n## 纯animation实现\n\n这次我们不用`setTimeout`，所有展示的动画全部用`animation`来实现。废话不多说，我们来看一下。\n\n### HTML结构\n\n```html\n<h1 id=\"typewriter\">Hello, My friend.</h1>\n```\n\n这种方法的好处就是不用有一个隐藏的原始文字段落，直接显示想显示的内容。\n\n### CSS设置\n\n接下来我们设置CSS：\n\n```css\nbody {\n    background: black;\n    color: #fff;\n}\n\nh1 {\n    font: bold 100% monospace;\n    border-right: 0.1em solid;\n    margin: 2em 1em;\n    white-space: nowrap;\n    overflow: hidden;\n}\n\n@keyframes typing {\n    from {\n        width: 0;\n    }\n}\n\n@keyframes cursor-blink {\n    50% {\n        border-color: transparent;\n    }\n}\n```\n\n看起来很简单对不对？挨？说好的动画呢？别急，我们通过JS来设置`animation`。\n\n### JS部分\n\n先看代码：\n\n```javascript\nvar typewriter = document.getElementById('typewriter');\nvar words = typewriter.innerText.length;\nif (words) {\n    typewriter.style.width = words + 'ch';\n    typewriter.style.animation = 'typing 3s steps(' + words + ', end), cursor-blink 0.5s step-end infinite alternate';\n}\n```\n\n这里我们所做的事就是获取文字段落字符串的长度，然后设置其宽度和动画效果。非常简单！\n\n那么，为什么这样做可以呢？别急，我们来分析分析。\n\n首先，在获取了文字字符串长度后，我们设置段落的宽度为`width: Xch;`，这里X代表字符串长度，`ch`是长度单位，代表数字“0”的宽度，通常也就是一个字符的宽度。\n\n然后，我们直接设置动画：\n`animation: typing 3s steps(X, end), cursor-blink 0.5s step-end infinite alternate;`\n一切就搞定了！为啥？通过CSS我们设置了`@keyframe`typing，表示宽度从0开始，一直到设置的`Xch`，持续3s，用`steps`动画函数，分为X步，也就是有多少个字符，就停顿多少下，达到输入的效果。至于光标的效果，我们直接通过动画设定`50%`的时候`border-color`为`transparent`，则每一秒闪烁一次，因为只有`border-right`设置了宽度，所以完美达到光标的效果。\n\n## 总结\n\n两种方法比较起来，第二种方法更加实用简便，推荐大家使用。这只是简单的CSS3 animation动画应用，今后还可以开动脑筋，实现更多炫酷有趣的效果。","source":"_posts/2019-01-23-how-to-achieve-typewriter-effect.md","raw":"---\ntitle: 如何实现文字输入效果\ndate: 2019-01-23 19:01:58\ncategories:\n- CSS相关\ntags:\n- CSS技巧\n---\n\n我们看到有些网站的文字会有类似于输入的效果，就好像自动打字一样，虽然这个效果用的地方可能不多，但如果用的好的话可能会有奇效，比如在博客、演讲展示等方面应用。那么，怎么实现呢？\n\n<!--more-->\n\n## 使用setTimeout实现\n\n第一种方法是使用setTimeout进行文字控制，每一个文字都是一个`span`，利用DOM操作以一定的间隔将每个文字添加到文档中，同时设置`opacity:1`使其显示出来。光标闪烁的效果则利用`border-left`进行animation动画展示。\n\n### HTML结构\n\n先看代码：\n\n```html\n<div class=\"container\">\n  <article class=\"input-container\">\n      <!--这里是需要展示的原始文字，设为display:none;-->\n    <p class=\"originWords\">Hello world!</p>\n  </article>\n  <article class=\"typewriter-container\">\n      <!--这里是最终有文字输入效果的文字-->\n    <p class=\"typewriter-output\"></p>\n  </article>\n</div>\n```\n\n解释一下，我们首先把原始文字设为`display: none;`，这样不会占用文档位置，然后我们给之后添加的文字`span`块指定class为`word`。\n\n### CSS设置\n\n先看代码：\n\n```css\n.container {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n}\n\n.input-container {\n  display: none;\n}\n.typewriter-container {\n  width: 50%;\n}\n.word {\n  opacity: 0;\n  transition: opacity 2s step-start;\n}\n.typewriter-output:after {\n  display: inline-block;\n  content: '';\n  vertical-align: -1px;\n  height: 14px;\n  width: 1px;\n  border-left: 2px solid black;\n  margin-left: 2px;\n  animation: shine 1s infinite;\n}\n@keyframes shine {\n  50% {\n    border-left: 0;\n  }\n}\n```\n\n我们对`word`设置`transition: opacity 2s step-start;`。这里之所以通过`opacity`来进行transition，是因为transition不支持`display`，而`opacity`只需要设置`0`或`1`就可以使元素进行显示而不需要重排。\n\n这里`transition-timing-function`使用`step-start`，使其有跳跃的效果，`step-start`相当于`steps(1, jump-start)`，`steps(n, <jumpterm>)`代表transition会停顿n次，每一次的效果为`<jumpterm>`，`jump-start`代表第一个跳跃发生在`transition`刚开始的时候，更多效果见[文档](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function)。\n\n为什么要使用`:after`呢？因为我是逐步向`typewriter-output`添加`span`块，所以一开始宽度是不确定的，而且光标高度也不好设置，所以我想了个笨方法，使用`after`伪元素生成一个光标，并用`animation`控制其`border-left`的显示。但这里有个bug就是文字显示的间隔不能超过300ms，所以说这样处理还是有些问题，以后可能会有更好的方法。\n\n### JS部分\n\n其实就是利用`setTimout`设置时间间隔，通过DOM操作进行添加文字，先看代码：\n\n```javascript\nvar words = document.querySelector('.originWords').innerText;\nvar output = document.querySelector('.typewriter-output');\nvar word = null;\nvar lastWord = null;\n\nfor (var i = 0, l = words.length; i< l; i++) {\n  setTimeout(writeWord(i), i * 200);\t// 每隔0.2s输出一个文字\n}\n// 这里使用闭包保存i\nfunction writeWord(index) {\n  return function () {\n    word = document.createElement('span');\n    word.classList.add('word');\n    output.appendChild(word);\n    if (!lastWord) {\n      lastWord = word;\n    }\n\n    if (lastWord !== word) {\n     lastWord.style.opacity = '1'; \n    }\n    word.innerText = words[index];\n    lastWord = word;\n    if (index === words.length - 1) {\n      lastWord.style.opacity = '1';\n    }\n  }\n}\n```\n\n代码部分很简单，就是先获取需要展示的文字内容，然后每个字都通过dom操作塞进去，设置`opacity:1`，再进行一下边界判断，就实现了文字的展示。\n\n---\n\n## 纯animation实现\n\n这次我们不用`setTimeout`，所有展示的动画全部用`animation`来实现。废话不多说，我们来看一下。\n\n### HTML结构\n\n```html\n<h1 id=\"typewriter\">Hello, My friend.</h1>\n```\n\n这种方法的好处就是不用有一个隐藏的原始文字段落，直接显示想显示的内容。\n\n### CSS设置\n\n接下来我们设置CSS：\n\n```css\nbody {\n    background: black;\n    color: #fff;\n}\n\nh1 {\n    font: bold 100% monospace;\n    border-right: 0.1em solid;\n    margin: 2em 1em;\n    white-space: nowrap;\n    overflow: hidden;\n}\n\n@keyframes typing {\n    from {\n        width: 0;\n    }\n}\n\n@keyframes cursor-blink {\n    50% {\n        border-color: transparent;\n    }\n}\n```\n\n看起来很简单对不对？挨？说好的动画呢？别急，我们通过JS来设置`animation`。\n\n### JS部分\n\n先看代码：\n\n```javascript\nvar typewriter = document.getElementById('typewriter');\nvar words = typewriter.innerText.length;\nif (words) {\n    typewriter.style.width = words + 'ch';\n    typewriter.style.animation = 'typing 3s steps(' + words + ', end), cursor-blink 0.5s step-end infinite alternate';\n}\n```\n\n这里我们所做的事就是获取文字段落字符串的长度，然后设置其宽度和动画效果。非常简单！\n\n那么，为什么这样做可以呢？别急，我们来分析分析。\n\n首先，在获取了文字字符串长度后，我们设置段落的宽度为`width: Xch;`，这里X代表字符串长度，`ch`是长度单位，代表数字“0”的宽度，通常也就是一个字符的宽度。\n\n然后，我们直接设置动画：\n`animation: typing 3s steps(X, end), cursor-blink 0.5s step-end infinite alternate;`\n一切就搞定了！为啥？通过CSS我们设置了`@keyframe`typing，表示宽度从0开始，一直到设置的`Xch`，持续3s，用`steps`动画函数，分为X步，也就是有多少个字符，就停顿多少下，达到输入的效果。至于光标的效果，我们直接通过动画设定`50%`的时候`border-color`为`transparent`，则每一秒闪烁一次，因为只有`border-right`设置了宽度，所以完美达到光标的效果。\n\n## 总结\n\n两种方法比较起来，第二种方法更加实用简便，推荐大家使用。这只是简单的CSS3 animation动画应用，今后还可以开动脑筋，实现更多炫酷有趣的效果。","slug":"how-to-achieve-typewriter-effect","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05d9002rra4kddhy0qxj","content":"<p>我们看到有些网站的文字会有类似于输入的效果，就好像自动打字一样，虽然这个效果用的地方可能不多，但如果用的好的话可能会有奇效，比如在博客、演讲展示等方面应用。那么，怎么实现呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"使用setTimeout实现\"><a href=\"#使用setTimeout实现\" class=\"headerlink\" title=\"使用setTimeout实现\"></a>使用setTimeout实现</h2><p>第一种方法是使用setTimeout进行文字控制，每一个文字都是一个<code>span</code>，利用DOM操作以一定的间隔将每个文字添加到文档中，同时设置<code>opacity:1</code>使其显示出来。光标闪烁的效果则利用<code>border-left</code>进行animation动画展示。</p>\n<h3 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h3><p>先看代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;input-container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--这里是需要展示的原始文字，设为display:none;--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;originWords&quot;</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;typewriter-container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--这里是最终有文字输入效果的文字--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;typewriter-output&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释一下，我们首先把原始文字设为<code>display: none;</code>，这样不会占用文档位置，然后我们给之后添加的文字<code>span</code>块指定class为<code>word</code>。</p>\n<h3 id=\"CSS设置\"><a href=\"#CSS设置\" class=\"headerlink\" title=\"CSS设置\"></a>CSS设置</h3><p>先看代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.input-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.typewriter-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.word</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">2s</span> step-start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.typewriter-output</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: -<span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">14px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: shine <span class=\"number\">1s</span> infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> shine &#123;</span><br><span class=\"line\">  <span class=\"number\">50%</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们对<code>word</code>设置<code>transition: opacity 2s step-start;</code>。这里之所以通过<code>opacity</code>来进行transition，是因为transition不支持<code>display</code>，而<code>opacity</code>只需要设置<code>0</code>或<code>1</code>就可以使元素进行显示而不需要重排。</p>\n<p>这里<code>transition-timing-function</code>使用<code>step-start</code>，使其有跳跃的效果，<code>step-start</code>相当于<code>steps(1, jump-start)</code>，<code>steps(n, &lt;jumpterm&gt;)</code>代表transition会停顿n次，每一次的效果为<code>&lt;jumpterm&gt;</code>，<code>jump-start</code>代表第一个跳跃发生在<code>transition</code>刚开始的时候，更多效果见<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function\">文档</a>。</p>\n<p>为什么要使用<code>:after</code>呢？因为我是逐步向<code>typewriter-output</code>添加<code>span</code>块，所以一开始宽度是不确定的，而且光标高度也不好设置，所以我想了个笨方法，使用<code>after</code>伪元素生成一个光标，并用<code>animation</code>控制其<code>border-left</code>的显示。但这里有个bug就是文字显示的间隔不能超过300ms，所以说这样处理还是有些问题，以后可能会有更好的方法。</p>\n<h3 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h3><p>其实就是利用<code>setTimout</code>设置时间间隔，通过DOM操作进行添加文字，先看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;.originWords&#x27;</span>).<span class=\"property\">innerText</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> output = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;.typewriter-output&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> word = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastWord = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = words.<span class=\"property\">length</span>; i&lt; l; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"title function_\">writeWord</span>(i), i * <span class=\"number\">200</span>);\t<span class=\"comment\">// 每隔0.2s输出一个文字</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里使用闭包保存i</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">writeWord</span>(<span class=\"params\">index</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    word = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;span&#x27;</span>);</span><br><span class=\"line\">    word.<span class=\"property\">classList</span>.<span class=\"title function_\">add</span>(<span class=\"string\">&#x27;word&#x27;</span>);</span><br><span class=\"line\">    output.<span class=\"title function_\">appendChild</span>(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lastWord) &#123;</span><br><span class=\"line\">      lastWord = word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastWord !== word) &#123;</span><br><span class=\"line\">     lastWord.<span class=\"property\">style</span>.<span class=\"property\">opacity</span> = <span class=\"string\">&#x27;1&#x27;</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    word.<span class=\"property\">innerText</span> = words[index];</span><br><span class=\"line\">    lastWord = word;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === words.<span class=\"property\">length</span> - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      lastWord.<span class=\"property\">style</span>.<span class=\"property\">opacity</span> = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码部分很简单，就是先获取需要展示的文字内容，然后每个字都通过dom操作塞进去，设置<code>opacity:1</code>，再进行一下边界判断，就实现了文字的展示。</p>\n<hr>\n<h2 id=\"纯animation实现\"><a href=\"#纯animation实现\" class=\"headerlink\" title=\"纯animation实现\"></a>纯animation实现</h2><p>这次我们不用<code>setTimeout</code>，所有展示的动画全部用<code>animation</code>来实现。废话不多说，我们来看一下。</p>\n<h3 id=\"HTML结构-1\"><a href=\"#HTML结构-1\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;typewriter&quot;</span>&gt;</span>Hello, My friend.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这种方法的好处就是不用有一个隐藏的原始文字段落，直接显示想显示的内容。</p>\n<h3 id=\"CSS设置-1\"><a href=\"#CSS设置-1\" class=\"headerlink\" title=\"CSS设置\"></a>CSS设置</h3><p>接下来我们设置CSS：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: bold <span class=\"number\">100%</span> monospace;</span><br><span class=\"line\">    <span class=\"attribute\">border-right</span>: <span class=\"number\">0.1em</span> solid;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">2em</span> <span class=\"number\">1em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">white-space</span>: nowrap;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> typing &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> cursor-blink &#123;</span><br><span class=\"line\">    <span class=\"number\">50%</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border-color</span>: transparent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很简单对不对？挨？说好的动画呢？别急，我们通过JS来设置<code>animation</code>。</p>\n<h3 id=\"JS部分-1\"><a href=\"#JS部分-1\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h3><p>先看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typewriter = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;typewriter&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> words = typewriter.<span class=\"property\">innerText</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (words) &#123;</span><br><span class=\"line\">    typewriter.<span class=\"property\">style</span>.<span class=\"property\">width</span> = words + <span class=\"string\">&#x27;ch&#x27;</span>;</span><br><span class=\"line\">    typewriter.<span class=\"property\">style</span>.<span class=\"property\">animation</span> = <span class=\"string\">&#x27;typing 3s steps(&#x27;</span> + words + <span class=\"string\">&#x27;, end), cursor-blink 0.5s step-end infinite alternate&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们所做的事就是获取文字段落字符串的长度，然后设置其宽度和动画效果。非常简单！</p>\n<p>那么，为什么这样做可以呢？别急，我们来分析分析。</p>\n<p>首先，在获取了文字字符串长度后，我们设置段落的宽度为<code>width: Xch;</code>，这里X代表字符串长度，<code>ch</code>是长度单位，代表数字“0”的宽度，通常也就是一个字符的宽度。</p>\n<p>然后，我们直接设置动画：<br><code>animation: typing 3s steps(X, end), cursor-blink 0.5s step-end infinite alternate;</code><br>一切就搞定了！为啥？通过CSS我们设置了<code>@keyframe</code>typing，表示宽度从0开始，一直到设置的<code>Xch</code>，持续3s，用<code>steps</code>动画函数，分为X步，也就是有多少个字符，就停顿多少下，达到输入的效果。至于光标的效果，我们直接通过动画设定<code>50%</code>的时候<code>border-color</code>为<code>transparent</code>，则每一秒闪烁一次，因为只有<code>border-right</code>设置了宽度，所以完美达到光标的效果。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两种方法比较起来，第二种方法更加实用简便，推荐大家使用。这只是简单的CSS3 animation动画应用，今后还可以开动脑筋，实现更多炫酷有趣的效果。</p>\n","site":{"data":{}},"excerpt":"<p>我们看到有些网站的文字会有类似于输入的效果，就好像自动打字一样，虽然这个效果用的地方可能不多，但如果用的好的话可能会有奇效，比如在博客、演讲展示等方面应用。那么，怎么实现呢？</p>","more":"<h2 id=\"使用setTimeout实现\"><a href=\"#使用setTimeout实现\" class=\"headerlink\" title=\"使用setTimeout实现\"></a>使用setTimeout实现</h2><p>第一种方法是使用setTimeout进行文字控制，每一个文字都是一个<code>span</code>，利用DOM操作以一定的间隔将每个文字添加到文档中，同时设置<code>opacity:1</code>使其显示出来。光标闪烁的效果则利用<code>border-left</code>进行animation动画展示。</p>\n<h3 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h3><p>先看代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;input-container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--这里是需要展示的原始文字，设为display:none;--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;originWords&quot;</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">article</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;typewriter-container&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--这里是最终有文字输入效果的文字--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;typewriter-output&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>解释一下，我们首先把原始文字设为<code>display: none;</code>，这样不会占用文档位置，然后我们给之后添加的文字<code>span</code>块指定class为<code>word</code>。</p>\n<h3 id=\"CSS设置\"><a href=\"#CSS设置\" class=\"headerlink\" title=\"CSS设置\"></a>CSS设置</h3><p>先看代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">  <span class=\"attribute\">justify-content</span>: center;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.input-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.typewriter-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.word</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">transition</span>: opacity <span class=\"number\">2s</span> step-start;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.typewriter-output</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">  <span class=\"attribute\">content</span>: <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">vertical-align</span>: -<span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">14px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-left</span>: <span class=\"number\">2px</span> solid black;</span><br><span class=\"line\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">animation</span>: shine <span class=\"number\">1s</span> infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> shine &#123;</span><br><span class=\"line\">  <span class=\"number\">50%</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们对<code>word</code>设置<code>transition: opacity 2s step-start;</code>。这里之所以通过<code>opacity</code>来进行transition，是因为transition不支持<code>display</code>，而<code>opacity</code>只需要设置<code>0</code>或<code>1</code>就可以使元素进行显示而不需要重排。</p>\n<p>这里<code>transition-timing-function</code>使用<code>step-start</code>，使其有跳跃的效果，<code>step-start</code>相当于<code>steps(1, jump-start)</code>，<code>steps(n, &lt;jumpterm&gt;)</code>代表transition会停顿n次，每一次的效果为<code>&lt;jumpterm&gt;</code>，<code>jump-start</code>代表第一个跳跃发生在<code>transition</code>刚开始的时候，更多效果见<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function\">文档</a>。</p>\n<p>为什么要使用<code>:after</code>呢？因为我是逐步向<code>typewriter-output</code>添加<code>span</code>块，所以一开始宽度是不确定的，而且光标高度也不好设置，所以我想了个笨方法，使用<code>after</code>伪元素生成一个光标，并用<code>animation</code>控制其<code>border-left</code>的显示。但这里有个bug就是文字显示的间隔不能超过300ms，所以说这样处理还是有些问题，以后可能会有更好的方法。</p>\n<h3 id=\"JS部分\"><a href=\"#JS部分\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h3><p>其实就是利用<code>setTimout</code>设置时间间隔，通过DOM操作进行添加文字，先看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;.originWords&#x27;</span>).<span class=\"property\">innerText</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> output = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&#x27;.typewriter-output&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> word = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastWord = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = words.<span class=\"property\">length</span>; i&lt; l; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"title function_\">writeWord</span>(i), i * <span class=\"number\">200</span>);\t<span class=\"comment\">// 每隔0.2s输出一个文字</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里使用闭包保存i</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">writeWord</span>(<span class=\"params\">index</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    word = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;span&#x27;</span>);</span><br><span class=\"line\">    word.<span class=\"property\">classList</span>.<span class=\"title function_\">add</span>(<span class=\"string\">&#x27;word&#x27;</span>);</span><br><span class=\"line\">    output.<span class=\"title function_\">appendChild</span>(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!lastWord) &#123;</span><br><span class=\"line\">      lastWord = word;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastWord !== word) &#123;</span><br><span class=\"line\">     lastWord.<span class=\"property\">style</span>.<span class=\"property\">opacity</span> = <span class=\"string\">&#x27;1&#x27;</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    word.<span class=\"property\">innerText</span> = words[index];</span><br><span class=\"line\">    lastWord = word;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index === words.<span class=\"property\">length</span> - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      lastWord.<span class=\"property\">style</span>.<span class=\"property\">opacity</span> = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码部分很简单，就是先获取需要展示的文字内容，然后每个字都通过dom操作塞进去，设置<code>opacity:1</code>，再进行一下边界判断，就实现了文字的展示。</p>\n<hr>\n<h2 id=\"纯animation实现\"><a href=\"#纯animation实现\" class=\"headerlink\" title=\"纯animation实现\"></a>纯animation实现</h2><p>这次我们不用<code>setTimeout</code>，所有展示的动画全部用<code>animation</code>来实现。废话不多说，我们来看一下。</p>\n<h3 id=\"HTML结构-1\"><a href=\"#HTML结构-1\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;typewriter&quot;</span>&gt;</span>Hello, My friend.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这种方法的好处就是不用有一个隐藏的原始文字段落，直接显示想显示的内容。</p>\n<h3 id=\"CSS设置-1\"><a href=\"#CSS设置-1\" class=\"headerlink\" title=\"CSS设置\"></a>CSS设置</h3><p>接下来我们设置CSS：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: black;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font</span>: bold <span class=\"number\">100%</span> monospace;</span><br><span class=\"line\">    <span class=\"attribute\">border-right</span>: <span class=\"number\">0.1em</span> solid;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">2em</span> <span class=\"number\">1em</span>;</span><br><span class=\"line\">    <span class=\"attribute\">white-space</span>: nowrap;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> typing &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@keyframes</span> cursor-blink &#123;</span><br><span class=\"line\">    <span class=\"number\">50%</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border-color</span>: transparent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来很简单对不对？挨？说好的动画呢？别急，我们通过JS来设置<code>animation</code>。</p>\n<h3 id=\"JS部分-1\"><a href=\"#JS部分-1\" class=\"headerlink\" title=\"JS部分\"></a>JS部分</h3><p>先看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typewriter = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;typewriter&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> words = typewriter.<span class=\"property\">innerText</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (words) &#123;</span><br><span class=\"line\">    typewriter.<span class=\"property\">style</span>.<span class=\"property\">width</span> = words + <span class=\"string\">&#x27;ch&#x27;</span>;</span><br><span class=\"line\">    typewriter.<span class=\"property\">style</span>.<span class=\"property\">animation</span> = <span class=\"string\">&#x27;typing 3s steps(&#x27;</span> + words + <span class=\"string\">&#x27;, end), cursor-blink 0.5s step-end infinite alternate&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们所做的事就是获取文字段落字符串的长度，然后设置其宽度和动画效果。非常简单！</p>\n<p>那么，为什么这样做可以呢？别急，我们来分析分析。</p>\n<p>首先，在获取了文字字符串长度后，我们设置段落的宽度为<code>width: Xch;</code>，这里X代表字符串长度，<code>ch</code>是长度单位，代表数字“0”的宽度，通常也就是一个字符的宽度。</p>\n<p>然后，我们直接设置动画：<br><code>animation: typing 3s steps(X, end), cursor-blink 0.5s step-end infinite alternate;</code><br>一切就搞定了！为啥？通过CSS我们设置了<code>@keyframe</code>typing，表示宽度从0开始，一直到设置的<code>Xch</code>，持续3s，用<code>steps</code>动画函数，分为X步，也就是有多少个字符，就停顿多少下，达到输入的效果。至于光标的效果，我们直接通过动画设定<code>50%</code>的时候<code>border-color</code>为<code>transparent</code>，则每一秒闪烁一次，因为只有<code>border-right</code>设置了宽度，所以完美达到光标的效果。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>两种方法比较起来，第二种方法更加实用简便，推荐大家使用。这只是简单的CSS3 animation动画应用，今后还可以开动脑筋，实现更多炫酷有趣的效果。</p>"},{"title":"NodeJS常用的一些文件操作技巧","date":"2019-01-29T10:20:04.000Z","_content":"\n在使用NodeJS的时候，我们经常会遇到对文件进行查找、删除、增加内容等操作，还好NodeJS内置了`fs`模块，`fs`的API提供了一系列方法，通过它我们可以实现基本的文件操作，接下来我们就来见识见识。\n<!--more-->\n\n> 说明:\n> 本文全部使用ES6语法\n> 提到的每个方法都有异步和同步的区别，同步则在方法后面加上`Sync`\n\n# 文件夹操作\n## 读取文件夹内容\n很多时候我们得到一个文件夹路径，如果需要获取文件夹里有哪些文件，我们可以利用`fs.readdir()`，例如：\n```javascript\nconst fs = require('fs');\nconst dest = '.../work/myFiles';\n\n// 异步读取文件夹内容\nfs.readdir(dest, (err, files) => {  // callback函数\n  if (!err) {\n    files.forEach(file => console.log(file));  // 返回的files是一个包含目录中所有文件名的数组\n  } else {\n    throw err;\n  }\n});\n\n// 同步读取文件夹内容\ntry {\n  const files = fs.readdirSync(dest);\n  files.forEach(file => console.log(file));\n} catch (err) {\n  throw err;\n}\n```\n\n## 创建文件夹\n创建文件夹利用的API是`fs.mkdir()`，这个操作我们其实很熟悉了，在bash里我们经常用`mkdir filedirectionName`这一操作来新建文件夹，这里也是一样的，但有几个方面要注意：\n```javascript\n// 异步创建文件夹\nfs.mkdir(dest, { recursive: true }, (err) => {\n  if (err) {\n    throw err;\n  }\n});\n\n// 同步创建文件夹\nfs.mkdirSync(dest, { recursive: true });\n```\n\n这里我们看到`{ recursive: true }`这个参数，设置为true代表应该创建父文件夹。比如我们设置`recursive`为true后，要创建`/tmp/a/app`目录，则无论是否存在`/tmp/a`目录都会新建，如果不设置`recursive`，则没有父文件夹的情况下新建会不成功。\n\n`fs.mkdirSync()`返回`undefined`。\n\n## 确认某个文件夹是否存在\n之前我们在创建文件夹的时候可以通过设置`recursive`为true来创建父文件夹不存在的情况下的文件夹，但是有的时候我们得到一个文件夹路径，我们并不知道它的父文件夹是否存在，甚至不知道它父文件夹的父文件夹是否存在...所以，我们不想关心那么多，我们就想知道这个文件夹是否存在，怎么办呢？\n\n这里我用到了`fs-extra`模块，它是在`fs`的基础上进行了一些扩展，有兴趣的可以去[Github](https://github.com/jprichardson/node-fs-extra)查看。其中有一个API：`ensurDir()`，它可以用来查找文件夹是否存在，如果不存在，则新建该文件夹，且会自动把父文件夹也新建了（如果父文件夹不存在）。说白了，就是能确保你想要查找的文件夹存在，因为我们一般发现某个文件夹不存在的话肯定会想要新建这个文件夹，这个API则帮我们把操作都实现了：\n```javascript\nconst fs = require('fs-extra');\n\n// 异步\nfs.ensureDir(dest, err => console.log(err));\n\n// 同步\ntry {\n  fs.ensureDirSync(dest);\n} catch (err) {\n  throw err;\n}\n```\n\n# 文件操作\n## 读取文件内容\n之前介绍了如何读取文件夹内容，但如果我们想要读取文件内容又如何操作呢？这里有两种方法。\n\n### fs.readFile\n通过这个方法我们可以获取到文件的内容：\n```javascript\n// 异步\nfs.readFile(dest, {encoding: 'utf8'}, (err, data) => {\n  if (err) {\n    throw err;\n  } else {\n    console.log(data);\n  }\n});\n\n// 同步\ntry {\n  const data = fs.readFileSync(dest, {encoding: 'utf8'});\n} catch (err) {\n  throw err;\n}\n```\n\n这里我们options可以设置参数：`encoding`，代表返回的data内容字符串编码方式，如果不指定的话，则返回的data格式为buffer。\n\n### fs.readJson\n除了上面那个方法，我们还可以使用`readJson`方法，当然这个是`fs-extra`里的扩展方法。因为我们现在存储数据很多时候都用JSON文件来存储，利用这个方法可以很方便的读取JSON文件，返回的是将JSON内容转化为Object的JSON对象，方便我们对数据进行操作。\n```javascript\nconst fs = require('fs-extra');\n\n// 异步\nfs.readJson('./package.json', (err, packageObj) => {\n  if (err) {\n    throw err;\n  } else {\n    console.log(packageObj.version);  // 可以直接对对象的属性进行访问\n  }\n});\n\n// 同步\ntry {\n  const packageObj = fs.readJsonSync('./package.json');\n} catch (err) {\n  throw err;\n}\n```\n\n## 写入文件内容\n有了读取文件内容，我们还需要写入文件内容，同样有两种方法，一种是`writeFile`，另一种是`writeJson`。前者和`readFile`差不多，只是第二个参数变成了要写入的内容，具体可参考[文档](http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback)。\n\n后者则也是对JSON文件进行的写入，要注意的是，每次写入都会覆盖之前所有的内容，所以我们如果想在原有的基础上新增内容，则需要先读取修改完内容再写入，这里我就只演示异步操作：\n```javascript\nconst fs = require('fs-extra');\n\n// 读取\nfs.readJson('./package.json', (err, packageObj) => {\n  if (err) {\n    throw err;\n  } else {\n    packageObj.newProperty = 'new Property';\n    fs.writeJson('./package.json', packageObj, err => {\n      if (err) {\n        throw err;\n      } else {\n        console.log('success');\n      }\n    })\n  }\n})\n```\n\n# 拷贝文件或者文件夹\n在`fs-extra`模块，提供了`copy(src, dest, [options, callback])`操作，其中`src`可以为文件夹也可以为文件。当`src`为文件夹，则会拷贝文件夹里的所有文件和文件夹，要注意`src`和`dest`必须同时为文件夹或者同时为文件，这样才能正确的把`src`的内容拷贝到`dest`里。\n```javascript\nconst fs = require('fs-extra');\nconst src = '/tmp/srcfile';\nconst dest = '/tmp/destfile';\n\nfs.copy(src, dest, err => {\n  if (err) console.log(err);\n})\n```\n\n# 获取文件状态\n当我们想要获取某个文件的状态，我们可以用`fs.stat(path)`、`fs.lstat(path)`、`fs.fstat(path)`，它们都返回一个`fs.stats`类对象。区别在于，`fs.lstat`的path可以是符号链接，`fs.fstat`的path是文件描述符`fd`。\n\n返回的`Stats`类包含许多代表文件状态的属性和方法，常用的有：\n- stats.isDirectory()。判断是否是文件夹\n- stats.isFile()。判断是否是文件\n- stats.dev。包含改文件的设备的数字标识符\n- stats.size。文件的大小（字节为单位）\n- stats.atime。上次访问此文件的时间戳。（要注意是系统本地时间，因此如果复制到别的电脑系统时间不一样可能会造成不可预知的后果，所以慎用）\n- stats.mtime。上次修改此文件的时间戳。\n\n# 总结\n这里我只粗略地介绍了几个常用的方法，`fs`还有很多文件操作，官方文档有更加详细的解释，感兴趣的小伙伴可以戳[这里](http://nodejs.cn/api/fs.html)了解更多，帮助自己在使用NodeJS操作文件时更加得心应手。","source":"_posts/2019-01-29-nodeJS-file-system-operation.md","raw":"---\ntitle: NodeJS常用的一些文件操作技巧\ndate: 2019-01-29 18:20:04\ncategories:\n- JS相关\ntags:\n- nodejs\n---\n\n在使用NodeJS的时候，我们经常会遇到对文件进行查找、删除、增加内容等操作，还好NodeJS内置了`fs`模块，`fs`的API提供了一系列方法，通过它我们可以实现基本的文件操作，接下来我们就来见识见识。\n<!--more-->\n\n> 说明:\n> 本文全部使用ES6语法\n> 提到的每个方法都有异步和同步的区别，同步则在方法后面加上`Sync`\n\n# 文件夹操作\n## 读取文件夹内容\n很多时候我们得到一个文件夹路径，如果需要获取文件夹里有哪些文件，我们可以利用`fs.readdir()`，例如：\n```javascript\nconst fs = require('fs');\nconst dest = '.../work/myFiles';\n\n// 异步读取文件夹内容\nfs.readdir(dest, (err, files) => {  // callback函数\n  if (!err) {\n    files.forEach(file => console.log(file));  // 返回的files是一个包含目录中所有文件名的数组\n  } else {\n    throw err;\n  }\n});\n\n// 同步读取文件夹内容\ntry {\n  const files = fs.readdirSync(dest);\n  files.forEach(file => console.log(file));\n} catch (err) {\n  throw err;\n}\n```\n\n## 创建文件夹\n创建文件夹利用的API是`fs.mkdir()`，这个操作我们其实很熟悉了，在bash里我们经常用`mkdir filedirectionName`这一操作来新建文件夹，这里也是一样的，但有几个方面要注意：\n```javascript\n// 异步创建文件夹\nfs.mkdir(dest, { recursive: true }, (err) => {\n  if (err) {\n    throw err;\n  }\n});\n\n// 同步创建文件夹\nfs.mkdirSync(dest, { recursive: true });\n```\n\n这里我们看到`{ recursive: true }`这个参数，设置为true代表应该创建父文件夹。比如我们设置`recursive`为true后，要创建`/tmp/a/app`目录，则无论是否存在`/tmp/a`目录都会新建，如果不设置`recursive`，则没有父文件夹的情况下新建会不成功。\n\n`fs.mkdirSync()`返回`undefined`。\n\n## 确认某个文件夹是否存在\n之前我们在创建文件夹的时候可以通过设置`recursive`为true来创建父文件夹不存在的情况下的文件夹，但是有的时候我们得到一个文件夹路径，我们并不知道它的父文件夹是否存在，甚至不知道它父文件夹的父文件夹是否存在...所以，我们不想关心那么多，我们就想知道这个文件夹是否存在，怎么办呢？\n\n这里我用到了`fs-extra`模块，它是在`fs`的基础上进行了一些扩展，有兴趣的可以去[Github](https://github.com/jprichardson/node-fs-extra)查看。其中有一个API：`ensurDir()`，它可以用来查找文件夹是否存在，如果不存在，则新建该文件夹，且会自动把父文件夹也新建了（如果父文件夹不存在）。说白了，就是能确保你想要查找的文件夹存在，因为我们一般发现某个文件夹不存在的话肯定会想要新建这个文件夹，这个API则帮我们把操作都实现了：\n```javascript\nconst fs = require('fs-extra');\n\n// 异步\nfs.ensureDir(dest, err => console.log(err));\n\n// 同步\ntry {\n  fs.ensureDirSync(dest);\n} catch (err) {\n  throw err;\n}\n```\n\n# 文件操作\n## 读取文件内容\n之前介绍了如何读取文件夹内容，但如果我们想要读取文件内容又如何操作呢？这里有两种方法。\n\n### fs.readFile\n通过这个方法我们可以获取到文件的内容：\n```javascript\n// 异步\nfs.readFile(dest, {encoding: 'utf8'}, (err, data) => {\n  if (err) {\n    throw err;\n  } else {\n    console.log(data);\n  }\n});\n\n// 同步\ntry {\n  const data = fs.readFileSync(dest, {encoding: 'utf8'});\n} catch (err) {\n  throw err;\n}\n```\n\n这里我们options可以设置参数：`encoding`，代表返回的data内容字符串编码方式，如果不指定的话，则返回的data格式为buffer。\n\n### fs.readJson\n除了上面那个方法，我们还可以使用`readJson`方法，当然这个是`fs-extra`里的扩展方法。因为我们现在存储数据很多时候都用JSON文件来存储，利用这个方法可以很方便的读取JSON文件，返回的是将JSON内容转化为Object的JSON对象，方便我们对数据进行操作。\n```javascript\nconst fs = require('fs-extra');\n\n// 异步\nfs.readJson('./package.json', (err, packageObj) => {\n  if (err) {\n    throw err;\n  } else {\n    console.log(packageObj.version);  // 可以直接对对象的属性进行访问\n  }\n});\n\n// 同步\ntry {\n  const packageObj = fs.readJsonSync('./package.json');\n} catch (err) {\n  throw err;\n}\n```\n\n## 写入文件内容\n有了读取文件内容，我们还需要写入文件内容，同样有两种方法，一种是`writeFile`，另一种是`writeJson`。前者和`readFile`差不多，只是第二个参数变成了要写入的内容，具体可参考[文档](http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback)。\n\n后者则也是对JSON文件进行的写入，要注意的是，每次写入都会覆盖之前所有的内容，所以我们如果想在原有的基础上新增内容，则需要先读取修改完内容再写入，这里我就只演示异步操作：\n```javascript\nconst fs = require('fs-extra');\n\n// 读取\nfs.readJson('./package.json', (err, packageObj) => {\n  if (err) {\n    throw err;\n  } else {\n    packageObj.newProperty = 'new Property';\n    fs.writeJson('./package.json', packageObj, err => {\n      if (err) {\n        throw err;\n      } else {\n        console.log('success');\n      }\n    })\n  }\n})\n```\n\n# 拷贝文件或者文件夹\n在`fs-extra`模块，提供了`copy(src, dest, [options, callback])`操作，其中`src`可以为文件夹也可以为文件。当`src`为文件夹，则会拷贝文件夹里的所有文件和文件夹，要注意`src`和`dest`必须同时为文件夹或者同时为文件，这样才能正确的把`src`的内容拷贝到`dest`里。\n```javascript\nconst fs = require('fs-extra');\nconst src = '/tmp/srcfile';\nconst dest = '/tmp/destfile';\n\nfs.copy(src, dest, err => {\n  if (err) console.log(err);\n})\n```\n\n# 获取文件状态\n当我们想要获取某个文件的状态，我们可以用`fs.stat(path)`、`fs.lstat(path)`、`fs.fstat(path)`，它们都返回一个`fs.stats`类对象。区别在于，`fs.lstat`的path可以是符号链接，`fs.fstat`的path是文件描述符`fd`。\n\n返回的`Stats`类包含许多代表文件状态的属性和方法，常用的有：\n- stats.isDirectory()。判断是否是文件夹\n- stats.isFile()。判断是否是文件\n- stats.dev。包含改文件的设备的数字标识符\n- stats.size。文件的大小（字节为单位）\n- stats.atime。上次访问此文件的时间戳。（要注意是系统本地时间，因此如果复制到别的电脑系统时间不一样可能会造成不可预知的后果，所以慎用）\n- stats.mtime。上次修改此文件的时间戳。\n\n# 总结\n这里我只粗略地介绍了几个常用的方法，`fs`还有很多文件操作，官方文档有更加详细的解释，感兴趣的小伙伴可以戳[这里](http://nodejs.cn/api/fs.html)了解更多，帮助自己在使用NodeJS操作文件时更加得心应手。","slug":"nodeJS-file-system-operation","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05da002vra4ke27y8a5i","content":"<p>在使用NodeJS的时候，我们经常会遇到对文件进行查找、删除、增加内容等操作，还好NodeJS内置了<code>fs</code>模块，<code>fs</code>的API提供了一系列方法，通过它我们可以实现基本的文件操作，接下来我们就来见识见识。</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>说明:<br>本文全部使用ES6语法<br>提到的每个方法都有异步和同步的区别，同步则在方法后面加上<code>Sync</code></p>\n</blockquote>\n<h1 id=\"文件夹操作\"><a href=\"#文件夹操作\" class=\"headerlink\" title=\"文件夹操作\"></a>文件夹操作</h1><h2 id=\"读取文件夹内容\"><a href=\"#读取文件夹内容\" class=\"headerlink\" title=\"读取文件夹内容\"></a>读取文件夹内容</h2><p>很多时候我们得到一个文件夹路径，如果需要获取文件夹里有哪些文件，我们可以利用<code>fs.readdir()</code>，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> dest = <span class=\"string\">&#x27;.../work/myFiles&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步读取文件夹内容</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readdir</span>(dest, <span class=\"function\">(<span class=\"params\">err, files</span>) =&gt;</span> &#123;  <span class=\"comment\">// callback函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">    files.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">file</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(file));  <span class=\"comment\">// 返回的files是一个包含目录中所有文件名的数组</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步读取文件夹内容</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> files = fs.<span class=\"title function_\">readdirSync</span>(dest);</span><br><span class=\"line\">  files.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">file</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(file));</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h2><p>创建文件夹利用的API是<code>fs.mkdir()</code>，这个操作我们其实很熟悉了，在bash里我们经常用<code>mkdir filedirectionName</code>这一操作来新建文件夹，这里也是一样的，但有几个方面要注意：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步创建文件夹</span></span><br><span class=\"line\">fs.<span class=\"title function_\">mkdir</span>(dest, &#123; <span class=\"attr\">recursive</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步创建文件夹</span></span><br><span class=\"line\">fs.<span class=\"title function_\">mkdirSync</span>(dest, &#123; <span class=\"attr\">recursive</span>: <span class=\"literal\">true</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们看到<code>&#123; recursive: true &#125;</code>这个参数，设置为true代表应该创建父文件夹。比如我们设置<code>recursive</code>为true后，要创建<code>/tmp/a/app</code>目录，则无论是否存在<code>/tmp/a</code>目录都会新建，如果不设置<code>recursive</code>，则没有父文件夹的情况下新建会不成功。</p>\n<p><code>fs.mkdirSync()</code>返回<code>undefined</code>。</p>\n<h2 id=\"确认某个文件夹是否存在\"><a href=\"#确认某个文件夹是否存在\" class=\"headerlink\" title=\"确认某个文件夹是否存在\"></a>确认某个文件夹是否存在</h2><p>之前我们在创建文件夹的时候可以通过设置<code>recursive</code>为true来创建父文件夹不存在的情况下的文件夹，但是有的时候我们得到一个文件夹路径，我们并不知道它的父文件夹是否存在，甚至不知道它父文件夹的父文件夹是否存在…所以，我们不想关心那么多，我们就想知道这个文件夹是否存在，怎么办呢？</p>\n<p>这里我用到了<code>fs-extra</code>模块，它是在<code>fs</code>的基础上进行了一些扩展，有兴趣的可以去<a href=\"https://github.com/jprichardson/node-fs-extra\">Github</a>查看。其中有一个API：<code>ensurDir()</code>，它可以用来查找文件夹是否存在，如果不存在，则新建该文件夹，且会自动把父文件夹也新建了（如果父文件夹不存在）。说白了，就是能确保你想要查找的文件夹存在，因为我们一般发现某个文件夹不存在的话肯定会想要新建这个文件夹，这个API则帮我们把操作都实现了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步</span></span><br><span class=\"line\">fs.<span class=\"title function_\">ensureDir</span>(dest, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  fs.<span class=\"title function_\">ensureDirSync</span>(dest);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h1><h2 id=\"读取文件内容\"><a href=\"#读取文件内容\" class=\"headerlink\" title=\"读取文件内容\"></a>读取文件内容</h2><p>之前介绍了如何读取文件夹内容，但如果我们想要读取文件内容又如何操作呢？这里有两种方法。</p>\n<h3 id=\"fs-readFile\"><a href=\"#fs-readFile\" class=\"headerlink\" title=\"fs.readFile\"></a>fs.readFile</h3><p>通过这个方法我们可以获取到文件的内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(dest, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf8&#x27;</span>&#125;, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = fs.<span class=\"title function_\">readFileSync</span>(dest, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf8&#x27;</span>&#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们options可以设置参数：<code>encoding</code>，代表返回的data内容字符串编码方式，如果不指定的话，则返回的data格式为buffer。</p>\n<h3 id=\"fs-readJson\"><a href=\"#fs-readJson\" class=\"headerlink\" title=\"fs.readJson\"></a>fs.readJson</h3><p>除了上面那个方法，我们还可以使用<code>readJson</code>方法，当然这个是<code>fs-extra</code>里的扩展方法。因为我们现在存储数据很多时候都用JSON文件来存储，利用这个方法可以很方便的读取JSON文件，返回的是将JSON内容转化为Object的JSON对象，方便我们对数据进行操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readJson</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, packageObj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(packageObj.<span class=\"property\">version</span>);  <span class=\"comment\">// 可以直接对对象的属性进行访问</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> packageObj = fs.<span class=\"title function_\">readJsonSync</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写入文件内容\"><a href=\"#写入文件内容\" class=\"headerlink\" title=\"写入文件内容\"></a>写入文件内容</h2><p>有了读取文件内容，我们还需要写入文件内容，同样有两种方法，一种是<code>writeFile</code>，另一种是<code>writeJson</code>。前者和<code>readFile</code>差不多，只是第二个参数变成了要写入的内容，具体可参考<a href=\"http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback\">文档</a>。</p>\n<p>后者则也是对JSON文件进行的写入，要注意的是，每次写入都会覆盖之前所有的内容，所以我们如果想在原有的基础上新增内容，则需要先读取修改完内容再写入，这里我就只演示异步操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readJson</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, packageObj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    packageObj.<span class=\"property\">newProperty</span> = <span class=\"string\">&#x27;new Property&#x27;</span>;</span><br><span class=\"line\">    fs.<span class=\"title function_\">writeJson</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>, packageObj, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;success&#x27;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"拷贝文件或者文件夹\"><a href=\"#拷贝文件或者文件夹\" class=\"headerlink\" title=\"拷贝文件或者文件夹\"></a>拷贝文件或者文件夹</h1><p>在<code>fs-extra</code>模块，提供了<code>copy(src, dest, [options, callback])</code>操作，其中<code>src</code>可以为文件夹也可以为文件。当<code>src</code>为文件夹，则会拷贝文件夹里的所有文件和文件夹，要注意<code>src</code>和<code>dest</code>必须同时为文件夹或者同时为文件，这样才能正确的把<code>src</code>的内容拷贝到<code>dest</code>里。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> src = <span class=\"string\">&#x27;/tmp/srcfile&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dest = <span class=\"string\">&#x27;/tmp/destfile&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">copy</span>(src, dest, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"获取文件状态\"><a href=\"#获取文件状态\" class=\"headerlink\" title=\"获取文件状态\"></a>获取文件状态</h1><p>当我们想要获取某个文件的状态，我们可以用<code>fs.stat(path)</code>、<code>fs.lstat(path)</code>、<code>fs.fstat(path)</code>，它们都返回一个<code>fs.stats</code>类对象。区别在于，<code>fs.lstat</code>的path可以是符号链接，<code>fs.fstat</code>的path是文件描述符<code>fd</code>。</p>\n<p>返回的<code>Stats</code>类包含许多代表文件状态的属性和方法，常用的有：</p>\n<ul>\n<li>stats.isDirectory()。判断是否是文件夹</li>\n<li>stats.isFile()。判断是否是文件</li>\n<li>stats.dev。包含改文件的设备的数字标识符</li>\n<li>stats.size。文件的大小（字节为单位）</li>\n<li>stats.atime。上次访问此文件的时间戳。（要注意是系统本地时间，因此如果复制到别的电脑系统时间不一样可能会造成不可预知的后果，所以慎用）</li>\n<li>stats.mtime。上次修改此文件的时间戳。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这里我只粗略地介绍了几个常用的方法，<code>fs</code>还有很多文件操作，官方文档有更加详细的解释，感兴趣的小伙伴可以戳<a href=\"http://nodejs.cn/api/fs.html\">这里</a>了解更多，帮助自己在使用NodeJS操作文件时更加得心应手。</p>\n","site":{"data":{}},"excerpt":"<p>在使用NodeJS的时候，我们经常会遇到对文件进行查找、删除、增加内容等操作，还好NodeJS内置了<code>fs</code>模块，<code>fs</code>的API提供了一系列方法，通过它我们可以实现基本的文件操作，接下来我们就来见识见识。</p>","more":"<blockquote>\n<p>说明:<br>本文全部使用ES6语法<br>提到的每个方法都有异步和同步的区别，同步则在方法后面加上<code>Sync</code></p>\n</blockquote>\n<h1 id=\"文件夹操作\"><a href=\"#文件夹操作\" class=\"headerlink\" title=\"文件夹操作\"></a>文件夹操作</h1><h2 id=\"读取文件夹内容\"><a href=\"#读取文件夹内容\" class=\"headerlink\" title=\"读取文件夹内容\"></a>读取文件夹内容</h2><p>很多时候我们得到一个文件夹路径，如果需要获取文件夹里有哪些文件，我们可以利用<code>fs.readdir()</code>，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> dest = <span class=\"string\">&#x27;.../work/myFiles&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步读取文件夹内容</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readdir</span>(dest, <span class=\"function\">(<span class=\"params\">err, files</span>) =&gt;</span> &#123;  <span class=\"comment\">// callback函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">    files.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">file</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(file));  <span class=\"comment\">// 返回的files是一个包含目录中所有文件名的数组</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步读取文件夹内容</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> files = fs.<span class=\"title function_\">readdirSync</span>(dest);</span><br><span class=\"line\">  files.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">file</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(file));</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建文件夹\"><a href=\"#创建文件夹\" class=\"headerlink\" title=\"创建文件夹\"></a>创建文件夹</h2><p>创建文件夹利用的API是<code>fs.mkdir()</code>，这个操作我们其实很熟悉了，在bash里我们经常用<code>mkdir filedirectionName</code>这一操作来新建文件夹，这里也是一样的，但有几个方面要注意：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步创建文件夹</span></span><br><span class=\"line\">fs.<span class=\"title function_\">mkdir</span>(dest, &#123; <span class=\"attr\">recursive</span>: <span class=\"literal\">true</span> &#125;, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步创建文件夹</span></span><br><span class=\"line\">fs.<span class=\"title function_\">mkdirSync</span>(dest, &#123; <span class=\"attr\">recursive</span>: <span class=\"literal\">true</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这里我们看到<code>&#123; recursive: true &#125;</code>这个参数，设置为true代表应该创建父文件夹。比如我们设置<code>recursive</code>为true后，要创建<code>/tmp/a/app</code>目录，则无论是否存在<code>/tmp/a</code>目录都会新建，如果不设置<code>recursive</code>，则没有父文件夹的情况下新建会不成功。</p>\n<p><code>fs.mkdirSync()</code>返回<code>undefined</code>。</p>\n<h2 id=\"确认某个文件夹是否存在\"><a href=\"#确认某个文件夹是否存在\" class=\"headerlink\" title=\"确认某个文件夹是否存在\"></a>确认某个文件夹是否存在</h2><p>之前我们在创建文件夹的时候可以通过设置<code>recursive</code>为true来创建父文件夹不存在的情况下的文件夹，但是有的时候我们得到一个文件夹路径，我们并不知道它的父文件夹是否存在，甚至不知道它父文件夹的父文件夹是否存在…所以，我们不想关心那么多，我们就想知道这个文件夹是否存在，怎么办呢？</p>\n<p>这里我用到了<code>fs-extra</code>模块，它是在<code>fs</code>的基础上进行了一些扩展，有兴趣的可以去<a href=\"https://github.com/jprichardson/node-fs-extra\">Github</a>查看。其中有一个API：<code>ensurDir()</code>，它可以用来查找文件夹是否存在，如果不存在，则新建该文件夹，且会自动把父文件夹也新建了（如果父文件夹不存在）。说白了，就是能确保你想要查找的文件夹存在，因为我们一般发现某个文件夹不存在的话肯定会想要新建这个文件夹，这个API则帮我们把操作都实现了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步</span></span><br><span class=\"line\">fs.<span class=\"title function_\">ensureDir</span>(dest, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  fs.<span class=\"title function_\">ensureDirSync</span>(dest);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h1><h2 id=\"读取文件内容\"><a href=\"#读取文件内容\" class=\"headerlink\" title=\"读取文件内容\"></a>读取文件内容</h2><p>之前介绍了如何读取文件夹内容，但如果我们想要读取文件内容又如何操作呢？这里有两种方法。</p>\n<h3 id=\"fs-readFile\"><a href=\"#fs-readFile\" class=\"headerlink\" title=\"fs.readFile\"></a>fs.readFile</h3><p>通过这个方法我们可以获取到文件的内容：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(dest, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf8&#x27;</span>&#125;, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = fs.<span class=\"title function_\">readFileSync</span>(dest, &#123;<span class=\"attr\">encoding</span>: <span class=\"string\">&#x27;utf8&#x27;</span>&#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们options可以设置参数：<code>encoding</code>，代表返回的data内容字符串编码方式，如果不指定的话，则返回的data格式为buffer。</p>\n<h3 id=\"fs-readJson\"><a href=\"#fs-readJson\" class=\"headerlink\" title=\"fs.readJson\"></a>fs.readJson</h3><p>除了上面那个方法，我们还可以使用<code>readJson</code>方法，当然这个是<code>fs-extra</code>里的扩展方法。因为我们现在存储数据很多时候都用JSON文件来存储，利用这个方法可以很方便的读取JSON文件，返回的是将JSON内容转化为Object的JSON对象，方便我们对数据进行操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readJson</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, packageObj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(packageObj.<span class=\"property\">version</span>);  <span class=\"comment\">// 可以直接对对象的属性进行访问</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 同步</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> packageObj = fs.<span class=\"title function_\">readJsonSync</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"写入文件内容\"><a href=\"#写入文件内容\" class=\"headerlink\" title=\"写入文件内容\"></a>写入文件内容</h2><p>有了读取文件内容，我们还需要写入文件内容，同样有两种方法，一种是<code>writeFile</code>，另一种是<code>writeJson</code>。前者和<code>readFile</code>差不多，只是第二个参数变成了要写入的内容，具体可参考<a href=\"http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback\">文档</a>。</p>\n<p>后者则也是对JSON文件进行的写入，要注意的是，每次写入都会覆盖之前所有的内容，所以我们如果想在原有的基础上新增内容，则需要先读取修改完内容再写入，这里我就只演示异步操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取</span></span><br><span class=\"line\">fs.<span class=\"title function_\">readJson</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>, <span class=\"function\">(<span class=\"params\">err, packageObj</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    packageObj.<span class=\"property\">newProperty</span> = <span class=\"string\">&#x27;new Property&#x27;</span>;</span><br><span class=\"line\">    fs.<span class=\"title function_\">writeJson</span>(<span class=\"string\">&#x27;./package.json&#x27;</span>, packageObj, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;success&#x27;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"拷贝文件或者文件夹\"><a href=\"#拷贝文件或者文件夹\" class=\"headerlink\" title=\"拷贝文件或者文件夹\"></a>拷贝文件或者文件夹</h1><p>在<code>fs-extra</code>模块，提供了<code>copy(src, dest, [options, callback])</code>操作，其中<code>src</code>可以为文件夹也可以为文件。当<code>src</code>为文件夹，则会拷贝文件夹里的所有文件和文件夹，要注意<code>src</code>和<code>dest</code>必须同时为文件夹或者同时为文件，这样才能正确的把<code>src</code>的内容拷贝到<code>dest</code>里。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs-extra&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> src = <span class=\"string\">&#x27;/tmp/srcfile&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dest = <span class=\"string\">&#x27;/tmp/destfile&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">copy</span>(src, dest, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"获取文件状态\"><a href=\"#获取文件状态\" class=\"headerlink\" title=\"获取文件状态\"></a>获取文件状态</h1><p>当我们想要获取某个文件的状态，我们可以用<code>fs.stat(path)</code>、<code>fs.lstat(path)</code>、<code>fs.fstat(path)</code>，它们都返回一个<code>fs.stats</code>类对象。区别在于，<code>fs.lstat</code>的path可以是符号链接，<code>fs.fstat</code>的path是文件描述符<code>fd</code>。</p>\n<p>返回的<code>Stats</code>类包含许多代表文件状态的属性和方法，常用的有：</p>\n<ul>\n<li>stats.isDirectory()。判断是否是文件夹</li>\n<li>stats.isFile()。判断是否是文件</li>\n<li>stats.dev。包含改文件的设备的数字标识符</li>\n<li>stats.size。文件的大小（字节为单位）</li>\n<li>stats.atime。上次访问此文件的时间戳。（要注意是系统本地时间，因此如果复制到别的电脑系统时间不一样可能会造成不可预知的后果，所以慎用）</li>\n<li>stats.mtime。上次修改此文件的时间戳。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>这里我只粗略地介绍了几个常用的方法，<code>fs</code>还有很多文件操作，官方文档有更加详细的解释，感兴趣的小伙伴可以戳<a href=\"http://nodejs.cn/api/fs.html\">这里</a>了解更多，帮助自己在使用NodeJS操作文件时更加得心应手。</p>"},{"title":"快速实现标签条切换效果","date":"2019-02-15T02:57:57.000Z","_content":"\n现在的单页应用中，我们经常需要通过切换不同的标签条显示相应的内容，一般想到的方法就是通过DOM操作给标签条添加点击事件然后加载对应内容，那么，有没有方法可以基本靠HTML和CSS就能快速实现标签条切换效果呢？我们来看一看。\n<!-- more -->\n\n# HTML结构\n这里我先简单的把HTML结构展示出来，然后慢慢解释：\n```html\n<div class='pane-container'>\n  <div class='pane-item'>\n    <div class='content' id='tab1'>\n      <p>Tab1 Content</p>\n    </div>\n    <a class='pane-btn' href='#tab1'>Tab1</a>\n  </div>\n  <div class='pane-item'>\n    <div class='content' id='tab2'>\n      <p>Tab2 Content</p>\n    </div>\n    <a class='pane-btn' href='#tab2'>Tab2</a>\n  </div>\n  <div class='pane-item'>\n    <div class='content' id='tab3'>\n      <p>Tab3 Content</p>\n    </div>\n    <a class='pane-btn' href='#tab3'>Tab3</a>\n  </div>\n</div>\n```\n\n我们可以看到，每一个标签条都是一个`a`标签，对应的内容为`.content`块。这里我为什么要用`a`标签来表示标签条呢？\n\n原因就是，`a`标签的`href`属性可以设置`href='#myid'`，这样点击就能跳转到当前页面id为myid的元素。有人会说，但这里我们不需要跳转啊，别急，这样设置的目的是为了方便之后的CSS设置。\n\n# 关键的CSS操作\n## :target伪类\n这里我们用到了一个关键的CSS选择器：`:target`伪类。`E:target`伪类选择的是匹配到URL的E元素，就是说如果我们设置了E元素的id为`eId`，并且当前URL后面有`#eId`，则E元素就被CSS选择器选中了，我们就可以设置E元素的CSS属性！来看代码：\n```css\n.content {\n  position: absolute;\n  top: 28px;\n  left: 0;\n  width: 500px;\n  height: 200px;\n  display: none;\n  border: 1px solid #EDEDED;\n  border-radius: 2px;\n  text-align: left;\n}\n.content:target {\n  display: block;\n}\n```\n这里我们要选中的元素是class为`content`的元素，也就是要展示的内容。先对`content`设置`display:none;`，然后通过`.content:target`选择到当前选中的`content`元素，再让其可见，就达到了内容切换的目的！怎么样，是不是很简单？\n\n## 修改tab选中样式\n当然为了更加直观一点，我们还需要对选中的标签进行一点修饰，代表当前选中的是哪个标签，其主要也是运用了`:target`和兄弟选择器：`E~F`。这里要注意的是，`~`匹配的是E后面所有兄弟元素F，也就是说F的位置必须在E后面，我们来看代码：\n```css\n.pane-btn:hover {\n  background-color: #F1F1F1;\n}\n.content:target ~ .pane-btn {\n  border-top: 1px solid #6EAED8;\n}\n```\n这样就能比较明显的显示当前选中的标签。\n\n## 完整CSS代码\n```css\n.pane-container {\n  position: relative;\n  width: 100%;\n  display: flex;\n}\n.pane-btn {\n  background-color: #fff;\n  border-style: none;\n  font-size: 20px;\n  padding: 0 5px;\n  width: 50px;\n  height: 24px;\n  border-radius: 2px;\n}\n.pane-btn:hover {\n  background-color: #F1F1F1;\n}\na {\n  text-decoration: none;\n  color: #000;\n}\n.content:target {\n  display: block;\n}\n.content:target ~ .pane-btn {\n  border-top: 1px solid #6EAED8;\n}\n\n.content {\n  position: absolute;\n  top: 28px;\n  left: 0;\n  width: 500px;\n  height: 200px;\n  display: none;\n  border: 1px solid #EDEDED;\n  border-radius: 2px;\n  text-align: left;\n}\n```\n\n# 最后\n你以为这样就OK了？还差最后一步。经过上面的HTML和CSS设置，我们虽然可以在标签之间进行切换并且显示对应内容，但是在页面初次加载进来后是没有显示任何内容的，因为此时没有任何标签被点击！所以我们还得用JS小小的设置一下：\n```javascript\nvar tabPaneOne = document.getElementsByClassName('pane-btn')[0];  // 这里默认显示第一个标签\ntabPaneOne.click();\n```\n这样就能完美的显示啦！完整效果请看<a href=\"https://codepen.io/flyrk/pen/aXaBOj\" target=\"_blank\">demo</a>。\n\n# 总结\n利用`:target`伪类，我们很好的实现了点击标签切换内容的效果。虽然这只是很简单的效果，但是在实际开发过程中我们也可以运用起来，在其基础上再加一些动画都是Ok的。这样实现的好处是会少很多DOM操作，从性能和代码简洁角度来说也是很大的一个提升。","source":"_posts/2019-02-15-fast-achieve-tabpane-effect.md","raw":"---\ntitle: 快速实现标签条切换效果\ndate: 2019-02-15 10:57:57\ncategories:\n- CSS相关\ntags:\n- CSS技巧\n---\n\n现在的单页应用中，我们经常需要通过切换不同的标签条显示相应的内容，一般想到的方法就是通过DOM操作给标签条添加点击事件然后加载对应内容，那么，有没有方法可以基本靠HTML和CSS就能快速实现标签条切换效果呢？我们来看一看。\n<!-- more -->\n\n# HTML结构\n这里我先简单的把HTML结构展示出来，然后慢慢解释：\n```html\n<div class='pane-container'>\n  <div class='pane-item'>\n    <div class='content' id='tab1'>\n      <p>Tab1 Content</p>\n    </div>\n    <a class='pane-btn' href='#tab1'>Tab1</a>\n  </div>\n  <div class='pane-item'>\n    <div class='content' id='tab2'>\n      <p>Tab2 Content</p>\n    </div>\n    <a class='pane-btn' href='#tab2'>Tab2</a>\n  </div>\n  <div class='pane-item'>\n    <div class='content' id='tab3'>\n      <p>Tab3 Content</p>\n    </div>\n    <a class='pane-btn' href='#tab3'>Tab3</a>\n  </div>\n</div>\n```\n\n我们可以看到，每一个标签条都是一个`a`标签，对应的内容为`.content`块。这里我为什么要用`a`标签来表示标签条呢？\n\n原因就是，`a`标签的`href`属性可以设置`href='#myid'`，这样点击就能跳转到当前页面id为myid的元素。有人会说，但这里我们不需要跳转啊，别急，这样设置的目的是为了方便之后的CSS设置。\n\n# 关键的CSS操作\n## :target伪类\n这里我们用到了一个关键的CSS选择器：`:target`伪类。`E:target`伪类选择的是匹配到URL的E元素，就是说如果我们设置了E元素的id为`eId`，并且当前URL后面有`#eId`，则E元素就被CSS选择器选中了，我们就可以设置E元素的CSS属性！来看代码：\n```css\n.content {\n  position: absolute;\n  top: 28px;\n  left: 0;\n  width: 500px;\n  height: 200px;\n  display: none;\n  border: 1px solid #EDEDED;\n  border-radius: 2px;\n  text-align: left;\n}\n.content:target {\n  display: block;\n}\n```\n这里我们要选中的元素是class为`content`的元素，也就是要展示的内容。先对`content`设置`display:none;`，然后通过`.content:target`选择到当前选中的`content`元素，再让其可见，就达到了内容切换的目的！怎么样，是不是很简单？\n\n## 修改tab选中样式\n当然为了更加直观一点，我们还需要对选中的标签进行一点修饰，代表当前选中的是哪个标签，其主要也是运用了`:target`和兄弟选择器：`E~F`。这里要注意的是，`~`匹配的是E后面所有兄弟元素F，也就是说F的位置必须在E后面，我们来看代码：\n```css\n.pane-btn:hover {\n  background-color: #F1F1F1;\n}\n.content:target ~ .pane-btn {\n  border-top: 1px solid #6EAED8;\n}\n```\n这样就能比较明显的显示当前选中的标签。\n\n## 完整CSS代码\n```css\n.pane-container {\n  position: relative;\n  width: 100%;\n  display: flex;\n}\n.pane-btn {\n  background-color: #fff;\n  border-style: none;\n  font-size: 20px;\n  padding: 0 5px;\n  width: 50px;\n  height: 24px;\n  border-radius: 2px;\n}\n.pane-btn:hover {\n  background-color: #F1F1F1;\n}\na {\n  text-decoration: none;\n  color: #000;\n}\n.content:target {\n  display: block;\n}\n.content:target ~ .pane-btn {\n  border-top: 1px solid #6EAED8;\n}\n\n.content {\n  position: absolute;\n  top: 28px;\n  left: 0;\n  width: 500px;\n  height: 200px;\n  display: none;\n  border: 1px solid #EDEDED;\n  border-radius: 2px;\n  text-align: left;\n}\n```\n\n# 最后\n你以为这样就OK了？还差最后一步。经过上面的HTML和CSS设置，我们虽然可以在标签之间进行切换并且显示对应内容，但是在页面初次加载进来后是没有显示任何内容的，因为此时没有任何标签被点击！所以我们还得用JS小小的设置一下：\n```javascript\nvar tabPaneOne = document.getElementsByClassName('pane-btn')[0];  // 这里默认显示第一个标签\ntabPaneOne.click();\n```\n这样就能完美的显示啦！完整效果请看<a href=\"https://codepen.io/flyrk/pen/aXaBOj\" target=\"_blank\">demo</a>。\n\n# 总结\n利用`:target`伪类，我们很好的实现了点击标签切换内容的效果。虽然这只是很简单的效果，但是在实际开发过程中我们也可以运用起来，在其基础上再加一些动画都是Ok的。这样实现的好处是会少很多DOM操作，从性能和代码简洁角度来说也是很大的一个提升。","slug":"fast-achieve-tabpane-effect","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05db002yra4k9bgrbaoc","content":"<p>现在的单页应用中，我们经常需要通过切换不同的标签条显示相应的内容，一般想到的方法就是通过DOM操作给标签条添加点击事件然后加载对应内容，那么，有没有方法可以基本靠HTML和CSS就能快速实现标签条切换效果呢？我们来看一看。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h1><p>这里我先简单的把HTML结构展示出来，然后慢慢解释：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-container&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-item&#x27;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;content&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&#x27;tab1&#x27;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Tab1 Content<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-btn&#x27;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#tab1&#x27;</span>&gt;</span>Tab1<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-item&#x27;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;content&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&#x27;tab2&#x27;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Tab2 Content<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-btn&#x27;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#tab2&#x27;</span>&gt;</span>Tab2<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-item&#x27;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;content&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&#x27;tab3&#x27;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Tab3 Content<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-btn&#x27;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#tab3&#x27;</span>&gt;</span>Tab3<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，每一个标签条都是一个<code>a</code>标签，对应的内容为<code>.content</code>块。这里我为什么要用<code>a</code>标签来表示标签条呢？</p>\n<p>原因就是，<code>a</code>标签的<code>href</code>属性可以设置<code>href=&#39;#myid&#39;</code>，这样点击就能跳转到当前页面id为myid的元素。有人会说，但这里我们不需要跳转啊，别急，这样设置的目的是为了方便之后的CSS设置。</p>\n<h1 id=\"关键的CSS操作\"><a href=\"#关键的CSS操作\" class=\"headerlink\" title=\"关键的CSS操作\"></a>关键的CSS操作</h1><h2 id=\"target伪类\"><a href=\"#target伪类\" class=\"headerlink\" title=\":target伪类\"></a>:target伪类</h2><p>这里我们用到了一个关键的CSS选择器：<code>:target</code>伪类。<code>E:target</code>伪类选择的是匹配到URL的E元素，就是说如果我们设置了E元素的id为<code>eId</code>，并且当前URL后面有<code>#eId</code>，则E元素就被CSS选择器选中了，我们就可以设置E元素的CSS属性！来看代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">28px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#EDEDED</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们要选中的元素是class为<code>content</code>的元素，也就是要展示的内容。先对<code>content</code>设置<code>display:none;</code>，然后通过<code>.content:target</code>选择到当前选中的<code>content</code>元素，再让其可见，就达到了内容切换的目的！怎么样，是不是很简单？</p>\n<h2 id=\"修改tab选中样式\"><a href=\"#修改tab选中样式\" class=\"headerlink\" title=\"修改tab选中样式\"></a>修改tab选中样式</h2><p>当然为了更加直观一点，我们还需要对选中的标签进行一点修饰，代表当前选中的是哪个标签，其主要也是运用了<code>:target</code>和兄弟选择器：<code>E~F</code>。这里要注意的是，<code>~</code>匹配的是E后面所有兄弟元素F，也就是说F的位置必须在E后面，我们来看代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.pane-btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#F1F1F1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> ~ <span class=\"selector-class\">.pane-btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#6EAED8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就能比较明显的显示当前选中的标签。</p>\n<h2 id=\"完整CSS代码\"><a href=\"#完整CSS代码\" class=\"headerlink\" title=\"完整CSS代码\"></a>完整CSS代码</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.pane-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.pane-btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">24px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.pane-btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#F1F1F1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> ~ <span class=\"selector-class\">.pane-btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#6EAED8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">28px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#EDEDED</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>你以为这样就OK了？还差最后一步。经过上面的HTML和CSS设置，我们虽然可以在标签之间进行切换并且显示对应内容，但是在页面初次加载进来后是没有显示任何内容的，因为此时没有任何标签被点击！所以我们还得用JS小小的设置一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tabPaneOne = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;pane-btn&#x27;</span>)[<span class=\"number\">0</span>];  <span class=\"comment\">// 这里默认显示第一个标签</span></span><br><span class=\"line\">tabPaneOne.<span class=\"title function_\">click</span>();</span><br></pre></td></tr></table></figure>\n<p>这样就能完美的显示啦！完整效果请看<a href=\"https://codepen.io/flyrk/pen/aXaBOj\" target=\"_blank\">demo</a>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>利用<code>:target</code>伪类，我们很好的实现了点击标签切换内容的效果。虽然这只是很简单的效果，但是在实际开发过程中我们也可以运用起来，在其基础上再加一些动画都是Ok的。这样实现的好处是会少很多DOM操作，从性能和代码简洁角度来说也是很大的一个提升。</p>\n","site":{"data":{}},"excerpt":"<p>现在的单页应用中，我们经常需要通过切换不同的标签条显示相应的内容，一般想到的方法就是通过DOM操作给标签条添加点击事件然后加载对应内容，那么，有没有方法可以基本靠HTML和CSS就能快速实现标签条切换效果呢？我们来看一看。</p>","more":"<h1 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h1><p>这里我先简单的把HTML结构展示出来，然后慢慢解释：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-container&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-item&#x27;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;content&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&#x27;tab1&#x27;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Tab1 Content<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-btn&#x27;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#tab1&#x27;</span>&gt;</span>Tab1<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-item&#x27;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;content&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&#x27;tab2&#x27;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Tab2 Content<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-btn&#x27;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#tab2&#x27;</span>&gt;</span>Tab2<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-item&#x27;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;content&#x27;</span> <span class=\"attr\">id</span>=<span class=\"string\">&#x27;tab3&#x27;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Tab3 Content<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;pane-btn&#x27;</span> <span class=\"attr\">href</span>=<span class=\"string\">&#x27;#tab3&#x27;</span>&gt;</span>Tab3<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，每一个标签条都是一个<code>a</code>标签，对应的内容为<code>.content</code>块。这里我为什么要用<code>a</code>标签来表示标签条呢？</p>\n<p>原因就是，<code>a</code>标签的<code>href</code>属性可以设置<code>href=&#39;#myid&#39;</code>，这样点击就能跳转到当前页面id为myid的元素。有人会说，但这里我们不需要跳转啊，别急，这样设置的目的是为了方便之后的CSS设置。</p>\n<h1 id=\"关键的CSS操作\"><a href=\"#关键的CSS操作\" class=\"headerlink\" title=\"关键的CSS操作\"></a>关键的CSS操作</h1><h2 id=\"target伪类\"><a href=\"#target伪类\" class=\"headerlink\" title=\":target伪类\"></a>:target伪类</h2><p>这里我们用到了一个关键的CSS选择器：<code>:target</code>伪类。<code>E:target</code>伪类选择的是匹配到URL的E元素，就是说如果我们设置了E元素的id为<code>eId</code>，并且当前URL后面有<code>#eId</code>，则E元素就被CSS选择器选中了，我们就可以设置E元素的CSS属性！来看代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">28px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#EDEDED</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们要选中的元素是class为<code>content</code>的元素，也就是要展示的内容。先对<code>content</code>设置<code>display:none;</code>，然后通过<code>.content:target</code>选择到当前选中的<code>content</code>元素，再让其可见，就达到了内容切换的目的！怎么样，是不是很简单？</p>\n<h2 id=\"修改tab选中样式\"><a href=\"#修改tab选中样式\" class=\"headerlink\" title=\"修改tab选中样式\"></a>修改tab选中样式</h2><p>当然为了更加直观一点，我们还需要对选中的标签进行一点修饰，代表当前选中的是哪个标签，其主要也是运用了<code>:target</code>和兄弟选择器：<code>E~F</code>。这里要注意的是，<code>~</code>匹配的是E后面所有兄弟元素F，也就是说F的位置必须在E后面，我们来看代码：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.pane-btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#F1F1F1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> ~ <span class=\"selector-class\">.pane-btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#6EAED8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就能比较明显的显示当前选中的标签。</p>\n<h2 id=\"完整CSS代码\"><a href=\"#完整CSS代码\" class=\"headerlink\" title=\"完整CSS代码\"></a>完整CSS代码</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.pane-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.pane-btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-style</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">5px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">24px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.pane-btn</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: <span class=\"number\">#F1F1F1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">text-decoration</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.content</span><span class=\"selector-pseudo\">:target</span> ~ <span class=\"selector-class\">.pane-btn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-top</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#6EAED8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">top</span>: <span class=\"number\">28px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">500px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#EDEDED</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">2px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">text-align</span>: left;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>你以为这样就OK了？还差最后一步。经过上面的HTML和CSS设置，我们虽然可以在标签之间进行切换并且显示对应内容，但是在页面初次加载进来后是没有显示任何内容的，因为此时没有任何标签被点击！所以我们还得用JS小小的设置一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tabPaneOne = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementsByClassName</span>(<span class=\"string\">&#x27;pane-btn&#x27;</span>)[<span class=\"number\">0</span>];  <span class=\"comment\">// 这里默认显示第一个标签</span></span><br><span class=\"line\">tabPaneOne.<span class=\"title function_\">click</span>();</span><br></pre></td></tr></table></figure>\n<p>这样就能完美的显示啦！完整效果请看<a href=\"https://codepen.io/flyrk/pen/aXaBOj\" target=\"_blank\">demo</a>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>利用<code>:target</code>伪类，我们很好的实现了点击标签切换内容的效果。虽然这只是很简单的效果，但是在实际开发过程中我们也可以运用起来，在其基础上再加一些动画都是Ok的。这样实现的好处是会少很多DOM操作，从性能和代码简洁角度来说也是很大的一个提升。</p>"},{"title":"有意思的leetcode算法题——巧用数学知识","date":"2019-02-27T04:42:43.000Z","_content":"\n最近在leetcode上刷算法题，发现了一道比较有意思的题目，虽然不难，但要想尽可能的降低时间复杂度达到最优解，还是要有点技巧的，我们来看看。\n<!-- more -->\n\n# 题干\n[sum-of-even-numbers-after-queries](https://leetcode.com/problems/sum-of-even-numbers-after-queries)。这道题的意思是说，给定一个包含一系列数字的数组A，和一个queries数组，对于`queries[i]`，设定`val=queries[i][0]`，`index=queries[i][1]`，使得`A[index]+=val`，求`ans`数组，使得`ans[i]`为经过`queries[i]`之后的A数组所有偶数数字之和。\n\n# 初步模拟\n初看完题目，我马上想到这不就是个简单的模拟题吗？照着题干的意思写不就行了，再一看数据范围不超过10000，嗯，O(n^2)先试试看，应该不会超时。于是很快的就把代码写出来了：\n```javascript\n/**\n * @param {number[]} A\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar sumEvenAfterQueries = function(A, queries) {\n    var ans = [], val = null, index = 0, evenSum = 0;\n    for (var i = 0, l = queries.length; i < l; i++) {\n        val = queries[i][0];\n        index = queries[i][1];\n        A[index] += val;\n        evenSum = 0;\n        for (var j = 0, l2 = A.length; j < l2; j++) {\n            if (A[j] % 2 === 0) {\n                evenSum += A[j];   \n            }\n        }\n        ans.push(evenSum);\n    }\n    return ans;\n};\n```\n\n写完提交，成功！emmmm，很简单嘛，下一题.....\n\n等等，这时间好像有点多啊，8216ms，差一点就超时了。不行，肯定有什么更简便的方法。\n\n# 数学妙用\n在经过别人的答案启发后，我突然发现原来利用数学的知识这道题可以这么简单！话不多说，我们来看代码：\n```javascript\nvar sumEvenAfterQueries = function(A, queries) {\n  var ans = [], val = null, index = 0, tmpSum = 0, evenSum = 0;\n  evenSum = A.reduce((p, n) => {\n    return n % 2 === 0 ? p + n : p;\n  }, 0);\n  \n  queries.forEach((query) => {\n    val = query[0];\n    index = query[1];\n    tmpSum = A[index] + val;\n    tmpSum % 2 === 0 ?\n      (A[index] % 2 === 0 ? evenSum += val : evenSum += tmpSum)\n      : (A[index] % 2 === 0 ? evenSum -= A[index] : null)\n    A[index] = tmpSum;\n    ans.push(evenSum);\n  })\n  return ans;\n};\n```\n\n写完一提交居然只用了20ms左右！！！复杂度也只有O(n)，怎么做到的呢？\n\n我们来分析分析：\n```javascript\nevenSum = A.reduce((p, n) => {\n  return n % 2 === 0 ? p + n : p;\n}, 0);\n```\n首先我们先把原始数组所有偶数数字加起来，为了方便之后直接在上面加减。\n\n```javascript\ntmpSum % 2 === 0 ?\n      (A[index] % 2 === 0 ? evenSum += val : evenSum += tmpSum)\n      : (A[index] % 2 === 0 ? evenSum -= A[index] : null)\n    A[index] = tmpSum;\n    ans.push(evenSum);\n```\n接着这段最关键的代码，我们对每次加完后的数字`tmpSum`进行判断，如果是偶数的话，分两种情况：`A[index]`是偶数，则代表之前的evenSum已经把`A[index]`加进去了，所以我们只用加上新的`val`，反之我们把`A[index]`和`val`都给加上；如果是奇数，我们则需要判断之前的`A[index]`是不是偶数，是的话需要把它给减去。\n\n经过这样的处理最后得到的就是每一轮所有偶数的和，最后完美的解决了问题，时间复杂度也只有O(n)。\n\n# 总结\n虽然这道题很简单，但我还是想记录下来，因为它代表了一种思维方法，以后做算法题或者写业务代码时都应该多问问自己，还有没有最优解？还能不能继续优化？我们很多时候都是做完结果对了就万事大吉，等到问题出现的时候才去想怎么去解决。而大多时候的问题都是有更好的解决办法的，不怕你做不到，就怕你想不到。平时做事时多拓宽自己的思路，我们在真正遇到问题的时候才不会害怕。","source":"_posts/2019-02-27-leetcode-sum-of-even-numbers-after-queries-solution.md","raw":"---\ntitle: 有意思的leetcode算法题——巧用数学知识\ndate: 2019-02-27 12:42:43\ncategories:\n- 算法\ntags:\n- leetcode\n---\n\n最近在leetcode上刷算法题，发现了一道比较有意思的题目，虽然不难，但要想尽可能的降低时间复杂度达到最优解，还是要有点技巧的，我们来看看。\n<!-- more -->\n\n# 题干\n[sum-of-even-numbers-after-queries](https://leetcode.com/problems/sum-of-even-numbers-after-queries)。这道题的意思是说，给定一个包含一系列数字的数组A，和一个queries数组，对于`queries[i]`，设定`val=queries[i][0]`，`index=queries[i][1]`，使得`A[index]+=val`，求`ans`数组，使得`ans[i]`为经过`queries[i]`之后的A数组所有偶数数字之和。\n\n# 初步模拟\n初看完题目，我马上想到这不就是个简单的模拟题吗？照着题干的意思写不就行了，再一看数据范围不超过10000，嗯，O(n^2)先试试看，应该不会超时。于是很快的就把代码写出来了：\n```javascript\n/**\n * @param {number[]} A\n * @param {number[][]} queries\n * @return {number[]}\n */\nvar sumEvenAfterQueries = function(A, queries) {\n    var ans = [], val = null, index = 0, evenSum = 0;\n    for (var i = 0, l = queries.length; i < l; i++) {\n        val = queries[i][0];\n        index = queries[i][1];\n        A[index] += val;\n        evenSum = 0;\n        for (var j = 0, l2 = A.length; j < l2; j++) {\n            if (A[j] % 2 === 0) {\n                evenSum += A[j];   \n            }\n        }\n        ans.push(evenSum);\n    }\n    return ans;\n};\n```\n\n写完提交，成功！emmmm，很简单嘛，下一题.....\n\n等等，这时间好像有点多啊，8216ms，差一点就超时了。不行，肯定有什么更简便的方法。\n\n# 数学妙用\n在经过别人的答案启发后，我突然发现原来利用数学的知识这道题可以这么简单！话不多说，我们来看代码：\n```javascript\nvar sumEvenAfterQueries = function(A, queries) {\n  var ans = [], val = null, index = 0, tmpSum = 0, evenSum = 0;\n  evenSum = A.reduce((p, n) => {\n    return n % 2 === 0 ? p + n : p;\n  }, 0);\n  \n  queries.forEach((query) => {\n    val = query[0];\n    index = query[1];\n    tmpSum = A[index] + val;\n    tmpSum % 2 === 0 ?\n      (A[index] % 2 === 0 ? evenSum += val : evenSum += tmpSum)\n      : (A[index] % 2 === 0 ? evenSum -= A[index] : null)\n    A[index] = tmpSum;\n    ans.push(evenSum);\n  })\n  return ans;\n};\n```\n\n写完一提交居然只用了20ms左右！！！复杂度也只有O(n)，怎么做到的呢？\n\n我们来分析分析：\n```javascript\nevenSum = A.reduce((p, n) => {\n  return n % 2 === 0 ? p + n : p;\n}, 0);\n```\n首先我们先把原始数组所有偶数数字加起来，为了方便之后直接在上面加减。\n\n```javascript\ntmpSum % 2 === 0 ?\n      (A[index] % 2 === 0 ? evenSum += val : evenSum += tmpSum)\n      : (A[index] % 2 === 0 ? evenSum -= A[index] : null)\n    A[index] = tmpSum;\n    ans.push(evenSum);\n```\n接着这段最关键的代码，我们对每次加完后的数字`tmpSum`进行判断，如果是偶数的话，分两种情况：`A[index]`是偶数，则代表之前的evenSum已经把`A[index]`加进去了，所以我们只用加上新的`val`，反之我们把`A[index]`和`val`都给加上；如果是奇数，我们则需要判断之前的`A[index]`是不是偶数，是的话需要把它给减去。\n\n经过这样的处理最后得到的就是每一轮所有偶数的和，最后完美的解决了问题，时间复杂度也只有O(n)。\n\n# 总结\n虽然这道题很简单，但我还是想记录下来，因为它代表了一种思维方法，以后做算法题或者写业务代码时都应该多问问自己，还有没有最优解？还能不能继续优化？我们很多时候都是做完结果对了就万事大吉，等到问题出现的时候才去想怎么去解决。而大多时候的问题都是有更好的解决办法的，不怕你做不到，就怕你想不到。平时做事时多拓宽自己的思路，我们在真正遇到问题的时候才不会害怕。","slug":"leetcode-sum-of-even-numbers-after-queries-solution","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05dc0030ra4ke3x82d7w","content":"<p>最近在leetcode上刷算法题，发现了一道比较有意思的题目，虽然不难，但要想尽可能的降低时间复杂度达到最优解，还是要有点技巧的，我们来看看。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"题干\"><a href=\"#题干\" class=\"headerlink\" title=\"题干\"></a>题干</h1><p><a href=\"https://leetcode.com/problems/sum-of-even-numbers-after-queries\">sum-of-even-numbers-after-queries</a>。这道题的意思是说，给定一个包含一系列数字的数组A，和一个queries数组，对于<code>queries[i]</code>，设定<code>val=queries[i][0]</code>，<code>index=queries[i][1]</code>，使得<code>A[index]+=val</code>，求<code>ans</code>数组，使得<code>ans[i]</code>为经过<code>queries[i]</code>之后的A数组所有偶数数字之和。</p>\n<h1 id=\"初步模拟\"><a href=\"#初步模拟\" class=\"headerlink\" title=\"初步模拟\"></a>初步模拟</h1><p>初看完题目，我马上想到这不就是个简单的模拟题吗？照着题干的意思写不就行了，再一看数据范围不超过10000，嗯，O(n^2)先试试看，应该不会超时。于是很快的就把代码写出来了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">A</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[][]</span>&#125; <span class=\"variable\">queries</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sumEvenAfterQueries = <span class=\"keyword\">function</span>(<span class=\"params\">A, queries</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans = [], val = <span class=\"literal\">null</span>, index = <span class=\"number\">0</span>, evenSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = queries.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">        val = queries[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        index = queries[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">        A[index] += val;</span><br><span class=\"line\">        evenSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>, l2 = A.<span class=\"property\">length</span>; j &lt; l2; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[j] % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                evenSum += A[j];   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.<span class=\"title function_\">push</span>(evenSum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>写完提交，成功！emmmm，很简单嘛，下一题…..</p>\n<p>等等，这时间好像有点多啊，8216ms，差一点就超时了。不行，肯定有什么更简便的方法。</p>\n<h1 id=\"数学妙用\"><a href=\"#数学妙用\" class=\"headerlink\" title=\"数学妙用\"></a>数学妙用</h1><p>在经过别人的答案启发后，我突然发现原来利用数学的知识这道题可以这么简单！话不多说，我们来看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sumEvenAfterQueries = <span class=\"keyword\">function</span>(<span class=\"params\">A, queries</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ans = [], val = <span class=\"literal\">null</span>, index = <span class=\"number\">0</span>, tmpSum = <span class=\"number\">0</span>, evenSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  evenSum = A.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">p, n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? p + n : p;</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  queries.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">query</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    val = query[<span class=\"number\">0</span>];</span><br><span class=\"line\">    index = query[<span class=\"number\">1</span>];</span><br><span class=\"line\">    tmpSum = A[index] + val;</span><br><span class=\"line\">    tmpSum % <span class=\"number\">2</span> === <span class=\"number\">0</span> ?</span><br><span class=\"line\">      (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum += val : evenSum += tmpSum)</span><br><span class=\"line\">      : (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum -= A[index] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">    A[index] = tmpSum;</span><br><span class=\"line\">    ans.<span class=\"title function_\">push</span>(evenSum);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>写完一提交居然只用了20ms左右！！！复杂度也只有O(n)，怎么做到的呢？</p>\n<p>我们来分析分析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evenSum = A.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">p, n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? p + n : p;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们先把原始数组所有偶数数字加起来，为了方便之后直接在上面加减。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmpSum % <span class=\"number\">2</span> === <span class=\"number\">0</span> ?</span><br><span class=\"line\">      (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum += val : evenSum += tmpSum)</span><br><span class=\"line\">      : (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum -= A[index] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">    A[index] = tmpSum;</span><br><span class=\"line\">    ans.<span class=\"title function_\">push</span>(evenSum);</span><br></pre></td></tr></table></figure>\n<p>接着这段最关键的代码，我们对每次加完后的数字<code>tmpSum</code>进行判断，如果是偶数的话，分两种情况：<code>A[index]</code>是偶数，则代表之前的evenSum已经把<code>A[index]</code>加进去了，所以我们只用加上新的<code>val</code>，反之我们把<code>A[index]</code>和<code>val</code>都给加上；如果是奇数，我们则需要判断之前的<code>A[index]</code>是不是偶数，是的话需要把它给减去。</p>\n<p>经过这样的处理最后得到的就是每一轮所有偶数的和，最后完美的解决了问题，时间复杂度也只有O(n)。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>虽然这道题很简单，但我还是想记录下来，因为它代表了一种思维方法，以后做算法题或者写业务代码时都应该多问问自己，还有没有最优解？还能不能继续优化？我们很多时候都是做完结果对了就万事大吉，等到问题出现的时候才去想怎么去解决。而大多时候的问题都是有更好的解决办法的，不怕你做不到，就怕你想不到。平时做事时多拓宽自己的思路，我们在真正遇到问题的时候才不会害怕。</p>\n","site":{"data":{}},"excerpt":"<p>最近在leetcode上刷算法题，发现了一道比较有意思的题目，虽然不难，但要想尽可能的降低时间复杂度达到最优解，还是要有点技巧的，我们来看看。</p>","more":"<h1 id=\"题干\"><a href=\"#题干\" class=\"headerlink\" title=\"题干\"></a>题干</h1><p><a href=\"https://leetcode.com/problems/sum-of-even-numbers-after-queries\">sum-of-even-numbers-after-queries</a>。这道题的意思是说，给定一个包含一系列数字的数组A，和一个queries数组，对于<code>queries[i]</code>，设定<code>val=queries[i][0]</code>，<code>index=queries[i][1]</code>，使得<code>A[index]+=val</code>，求<code>ans</code>数组，使得<code>ans[i]</code>为经过<code>queries[i]</code>之后的A数组所有偶数数字之和。</p>\n<h1 id=\"初步模拟\"><a href=\"#初步模拟\" class=\"headerlink\" title=\"初步模拟\"></a>初步模拟</h1><p>初看完题目，我马上想到这不就是个简单的模拟题吗？照着题干的意思写不就行了，再一看数据范围不超过10000，嗯，O(n^2)先试试看，应该不会超时。于是很快的就把代码写出来了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[]</span>&#125; <span class=\"variable\">A</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &#123;<span class=\"type\">number[][]</span>&#125; <span class=\"variable\">queries</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> &#123;<span class=\"type\">number[]</span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sumEvenAfterQueries = <span class=\"keyword\">function</span>(<span class=\"params\">A, queries</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans = [], val = <span class=\"literal\">null</span>, index = <span class=\"number\">0</span>, evenSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, l = queries.<span class=\"property\">length</span>; i &lt; l; i++) &#123;</span><br><span class=\"line\">        val = queries[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        index = queries[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">        A[index] += val;</span><br><span class=\"line\">        evenSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>, l2 = A.<span class=\"property\">length</span>; j &lt; l2; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (A[j] % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                evenSum += A[j];   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.<span class=\"title function_\">push</span>(evenSum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>写完提交，成功！emmmm，很简单嘛，下一题…..</p>\n<p>等等，这时间好像有点多啊，8216ms，差一点就超时了。不行，肯定有什么更简便的方法。</p>\n<h1 id=\"数学妙用\"><a href=\"#数学妙用\" class=\"headerlink\" title=\"数学妙用\"></a>数学妙用</h1><p>在经过别人的答案启发后，我突然发现原来利用数学的知识这道题可以这么简单！话不多说，我们来看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sumEvenAfterQueries = <span class=\"keyword\">function</span>(<span class=\"params\">A, queries</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ans = [], val = <span class=\"literal\">null</span>, index = <span class=\"number\">0</span>, tmpSum = <span class=\"number\">0</span>, evenSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  evenSum = A.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">p, n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? p + n : p;</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  queries.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">query</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    val = query[<span class=\"number\">0</span>];</span><br><span class=\"line\">    index = query[<span class=\"number\">1</span>];</span><br><span class=\"line\">    tmpSum = A[index] + val;</span><br><span class=\"line\">    tmpSum % <span class=\"number\">2</span> === <span class=\"number\">0</span> ?</span><br><span class=\"line\">      (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum += val : evenSum += tmpSum)</span><br><span class=\"line\">      : (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum -= A[index] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">    A[index] = tmpSum;</span><br><span class=\"line\">    ans.<span class=\"title function_\">push</span>(evenSum);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>写完一提交居然只用了20ms左右！！！复杂度也只有O(n)，怎么做到的呢？</p>\n<p>我们来分析分析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evenSum = A.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">p, n</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? p + n : p;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>首先我们先把原始数组所有偶数数字加起来，为了方便之后直接在上面加减。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tmpSum % <span class=\"number\">2</span> === <span class=\"number\">0</span> ?</span><br><span class=\"line\">      (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum += val : evenSum += tmpSum)</span><br><span class=\"line\">      : (A[index] % <span class=\"number\">2</span> === <span class=\"number\">0</span> ? evenSum -= A[index] : <span class=\"literal\">null</span>)</span><br><span class=\"line\">    A[index] = tmpSum;</span><br><span class=\"line\">    ans.<span class=\"title function_\">push</span>(evenSum);</span><br></pre></td></tr></table></figure>\n<p>接着这段最关键的代码，我们对每次加完后的数字<code>tmpSum</code>进行判断，如果是偶数的话，分两种情况：<code>A[index]</code>是偶数，则代表之前的evenSum已经把<code>A[index]</code>加进去了，所以我们只用加上新的<code>val</code>，反之我们把<code>A[index]</code>和<code>val</code>都给加上；如果是奇数，我们则需要判断之前的<code>A[index]</code>是不是偶数，是的话需要把它给减去。</p>\n<p>经过这样的处理最后得到的就是每一轮所有偶数的和，最后完美的解决了问题，时间复杂度也只有O(n)。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>虽然这道题很简单，但我还是想记录下来，因为它代表了一种思维方法，以后做算法题或者写业务代码时都应该多问问自己，还有没有最优解？还能不能继续优化？我们很多时候都是做完结果对了就万事大吉，等到问题出现的时候才去想怎么去解决。而大多时候的问题都是有更好的解决办法的，不怕你做不到，就怕你想不到。平时做事时多拓宽自己的思路，我们在真正遇到问题的时候才不会害怕。</p>"},{"title":"写作能带给我什么","date":"2019-08-11T13:01:33.000Z","_content":"\n差不多有半年没更过博客了，自己差点都快把它忘了，最近偶尔翻到自己以前写的文章，突然又有了写的冲动。虽然文笔依然很烂，但还是想把写博客捡起来，有空写点什么。\n\n这半年来，其实生活上经历的挺多的，生活的城市从杭州又回到了广州，工作、生活都发生了巨大的变化，自己也忙于处理各种事情，但这不应该成为我没有更博的借口。最近这个月，感觉生活总算是稍微稳定下来了，可以安心去做点事，于是就想把写作这块捡起来。\n\n说实话，身为理科生，自己的写作水平的确不怎么样，女票还为此嘲笑过我好几次。但是，我还是想写点什么，微博也好知乎也好，还是自己的博客，目的不是为了吸引关注博眼球，（目前自己也没那个本事），而是觉得，写作这件事，其实是很值得去做的。每次写作时，不管是写什么内容，都是一个自我思考的过程，在写作中不断反思、不断总结，对自己的思维是一个很好的锻炼，语言组织表达能力也是一个大大的提升，要是能够引起大家的讨论和交流，那是再好不过了。\n\n以前大家总觉得写作是件很麻烦的事，只有作家、专业写手才能干得来，但是现在，有了微博、有了知乎、有了微信公众号，让自媒体兴起了，让大家有了发声的渠道。我们每一个人都可以表达我们的观点，并且借助平台让它传播开来，大家一起讨论，碰撞知识的火花。\n\n所以，我要开始写起来，不管文笔多烂，写得再不好，至少，我能表达出自己的想法，这就够了。\n\n","source":"_posts/2019-08-11-half-year-summary.md","raw":"---\ntitle: 写作能带给我什么\ndate: 2019-08-11 21:01:33\ncategories:\n- 随笔\ntags:\n- 思考感悟\n---\n\n差不多有半年没更过博客了，自己差点都快把它忘了，最近偶尔翻到自己以前写的文章，突然又有了写的冲动。虽然文笔依然很烂，但还是想把写博客捡起来，有空写点什么。\n\n这半年来，其实生活上经历的挺多的，生活的城市从杭州又回到了广州，工作、生活都发生了巨大的变化，自己也忙于处理各种事情，但这不应该成为我没有更博的借口。最近这个月，感觉生活总算是稍微稳定下来了，可以安心去做点事，于是就想把写作这块捡起来。\n\n说实话，身为理科生，自己的写作水平的确不怎么样，女票还为此嘲笑过我好几次。但是，我还是想写点什么，微博也好知乎也好，还是自己的博客，目的不是为了吸引关注博眼球，（目前自己也没那个本事），而是觉得，写作这件事，其实是很值得去做的。每次写作时，不管是写什么内容，都是一个自我思考的过程，在写作中不断反思、不断总结，对自己的思维是一个很好的锻炼，语言组织表达能力也是一个大大的提升，要是能够引起大家的讨论和交流，那是再好不过了。\n\n以前大家总觉得写作是件很麻烦的事，只有作家、专业写手才能干得来，但是现在，有了微博、有了知乎、有了微信公众号，让自媒体兴起了，让大家有了发声的渠道。我们每一个人都可以表达我们的观点，并且借助平台让它传播开来，大家一起讨论，碰撞知识的火花。\n\n所以，我要开始写起来，不管文笔多烂，写得再不好，至少，我能表达出自己的想法，这就够了。\n\n","slug":"half-year-summary","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05dd0034ra4kc8kxcw71","content":"<p>差不多有半年没更过博客了，自己差点都快把它忘了，最近偶尔翻到自己以前写的文章，突然又有了写的冲动。虽然文笔依然很烂，但还是想把写博客捡起来，有空写点什么。</p>\n<p>这半年来，其实生活上经历的挺多的，生活的城市从杭州又回到了广州，工作、生活都发生了巨大的变化，自己也忙于处理各种事情，但这不应该成为我没有更博的借口。最近这个月，感觉生活总算是稍微稳定下来了，可以安心去做点事，于是就想把写作这块捡起来。</p>\n<p>说实话，身为理科生，自己的写作水平的确不怎么样，女票还为此嘲笑过我好几次。但是，我还是想写点什么，微博也好知乎也好，还是自己的博客，目的不是为了吸引关注博眼球，（目前自己也没那个本事），而是觉得，写作这件事，其实是很值得去做的。每次写作时，不管是写什么内容，都是一个自我思考的过程，在写作中不断反思、不断总结，对自己的思维是一个很好的锻炼，语言组织表达能力也是一个大大的提升，要是能够引起大家的讨论和交流，那是再好不过了。</p>\n<p>以前大家总觉得写作是件很麻烦的事，只有作家、专业写手才能干得来，但是现在，有了微博、有了知乎、有了微信公众号，让自媒体兴起了，让大家有了发声的渠道。我们每一个人都可以表达我们的观点，并且借助平台让它传播开来，大家一起讨论，碰撞知识的火花。</p>\n<p>所以，我要开始写起来，不管文笔多烂，写得再不好，至少，我能表达出自己的想法，这就够了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>差不多有半年没更过博客了，自己差点都快把它忘了，最近偶尔翻到自己以前写的文章，突然又有了写的冲动。虽然文笔依然很烂，但还是想把写博客捡起来，有空写点什么。</p>\n<p>这半年来，其实生活上经历的挺多的，生活的城市从杭州又回到了广州，工作、生活都发生了巨大的变化，自己也忙于处理各种事情，但这不应该成为我没有更博的借口。最近这个月，感觉生活总算是稍微稳定下来了，可以安心去做点事，于是就想把写作这块捡起来。</p>\n<p>说实话，身为理科生，自己的写作水平的确不怎么样，女票还为此嘲笑过我好几次。但是，我还是想写点什么，微博也好知乎也好，还是自己的博客，目的不是为了吸引关注博眼球，（目前自己也没那个本事），而是觉得，写作这件事，其实是很值得去做的。每次写作时，不管是写什么内容，都是一个自我思考的过程，在写作中不断反思、不断总结，对自己的思维是一个很好的锻炼，语言组织表达能力也是一个大大的提升，要是能够引起大家的讨论和交流，那是再好不过了。</p>\n<p>以前大家总觉得写作是件很麻烦的事，只有作家、专业写手才能干得来，但是现在，有了微博、有了知乎、有了微信公众号，让自媒体兴起了，让大家有了发声的渠道。我们每一个人都可以表达我们的观点，并且借助平台让它传播开来，大家一起讨论，碰撞知识的火花。</p>\n<p>所以，我要开始写起来，不管文笔多烂，写得再不好，至少，我能表达出自己的想法，这就够了。</p>\n"},{"title":"我是如何当上程序员的（一）","date":"2019-08-18T13:28:46.000Z","toc":true,"_content":"\n今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？\n<!--more-->\n# 初识编程\n说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。\n\n那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。\n\n那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。\n\n后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。\n\n上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。\n\n# 再学编程\n转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。\n\n进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？\n\n接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。\n\n那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。\n\n# 接触前端\n后来，我接触到了前端开发这个职业，也就是我现在在做的工作。\n\n那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！\n\n于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。\n\n才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。\n\n大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。\n\n当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。\n\n后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。\n\n未完待续…","source":"_posts/2019-08-18-how-can-i-be-a-programmer-1.md","raw":"---\ntitle: 我是如何当上程序员的（一）\ndate: 2019-08-18 21:28:46\ntoc: true\ncategories:\n- 经验分享\ntags:\n- 职业规划\n---\n\n今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？\n<!--more-->\n# 初识编程\n说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。\n\n那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。\n\n那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。\n\n后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。\n\n上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。\n\n# 再学编程\n转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。\n\n进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？\n\n接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。\n\n那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。\n\n# 接触前端\n后来，我接触到了前端开发这个职业，也就是我现在在做的工作。\n\n那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！\n\n于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。\n\n才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。\n\n大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。\n\n当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。\n\n后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。\n\n未完待续…","slug":"how-can-i-be-a-programmer-1","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05de0037ra4k8jxi071n","content":"<p>今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？</p>\n<span id=\"more\"></span>\n<h1 id=\"初识编程\"><a href=\"#初识编程\" class=\"headerlink\" title=\"初识编程\"></a>初识编程</h1><p>说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。</p>\n<p>那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。</p>\n<p>那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。</p>\n<p>后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。</p>\n<p>上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。</p>\n<h1 id=\"再学编程\"><a href=\"#再学编程\" class=\"headerlink\" title=\"再学编程\"></a>再学编程</h1><p>转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。</p>\n<p>进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？</p>\n<p>接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。</p>\n<p>那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。</p>\n<h1 id=\"接触前端\"><a href=\"#接触前端\" class=\"headerlink\" title=\"接触前端\"></a>接触前端</h1><p>后来，我接触到了前端开发这个职业，也就是我现在在做的工作。</p>\n<p>那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！</p>\n<p>于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。</p>\n<p>才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。</p>\n<p>大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。</p>\n<p>当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。</p>\n<p>后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。</p>\n<p>未完待续…</p>\n","site":{"data":{}},"excerpt":"<p>今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？</p>","more":"<h1 id=\"初识编程\"><a href=\"#初识编程\" class=\"headerlink\" title=\"初识编程\"></a>初识编程</h1><p>说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。</p>\n<p>那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。</p>\n<p>那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。</p>\n<p>后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。</p>\n<p>上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。</p>\n<h1 id=\"再学编程\"><a href=\"#再学编程\" class=\"headerlink\" title=\"再学编程\"></a>再学编程</h1><p>转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。</p>\n<p>进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？</p>\n<p>接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。</p>\n<p>那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。</p>\n<h1 id=\"接触前端\"><a href=\"#接触前端\" class=\"headerlink\" title=\"接触前端\"></a>接触前端</h1><p>后来，我接触到了前端开发这个职业，也就是我现在在做的工作。</p>\n<p>那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！</p>\n<p>于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。</p>\n<p>才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。</p>\n<p>大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。</p>\n<p>当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。</p>\n<p>后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。</p>\n<p>未完待续…</p>"},{"title":"我是如何当上程序员的（二）","date":"2019-08-25T14:32:40.000Z","toc":true,"_content":"\n接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？\n<!--more-->\n# 找工作\n人生最怕没有目标，一旦有了目标，生活就有了动力。\n\n在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。\n\n接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。\n\n然而，事与愿违，那段时间成了我最痛苦的一段时间。\n\n因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。\n\n接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。\n\n调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。\n\n就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。\n\n因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。\n\n一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。\n\n但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。\n\n到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。\n\n后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。\n\n# 回顾\n回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。\n\n其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。\n\n金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。\n\n但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。\n\n程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！\n\n最后，附上自己当时校招找工作时看的部分书单：\n\n- 《JavaScript高级程序设计》——必读\n- 《你不知道的JS》——强烈推荐\n- 《CSS禅意花园》——学习CSS很有用\n- 《JavaScript设计模式》——对代码质量提升很大\n- 《高性能网站建设指南》——了解网站优化\n- 《响应式Web设计全流程解析》——响应式布局、网页设计\n","source":"_posts/2019-08-25-how-can-i-be-a-programmer-2.md","raw":"---\ntitle: 我是如何当上程序员的（二）\ndate: 2019-08-25 22:32:40\ntoc: true\ncategories:\n- 经验分享\ntags:\n- 职业规划\n---\n\n接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？\n<!--more-->\n# 找工作\n人生最怕没有目标，一旦有了目标，生活就有了动力。\n\n在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。\n\n接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。\n\n然而，事与愿违，那段时间成了我最痛苦的一段时间。\n\n因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。\n\n接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。\n\n调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。\n\n就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。\n\n因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。\n\n一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。\n\n但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。\n\n到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。\n\n后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。\n\n# 回顾\n回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。\n\n其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。\n\n金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。\n\n但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。\n\n程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！\n\n最后，附上自己当时校招找工作时看的部分书单：\n\n- 《JavaScript高级程序设计》——必读\n- 《你不知道的JS》——强烈推荐\n- 《CSS禅意花园》——学习CSS很有用\n- 《JavaScript设计模式》——对代码质量提升很大\n- 《高性能网站建设指南》——了解网站优化\n- 《响应式Web设计全流程解析》——响应式布局、网页设计\n","slug":"how-can-i-be-a-programmer-2","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05dg003bra4kcfeb623c","content":"<p>接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？</p>\n<span id=\"more\"></span>\n<h1 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h1><p>人生最怕没有目标，一旦有了目标，生活就有了动力。</p>\n<p>在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。</p>\n<p>接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。</p>\n<p>然而，事与愿违，那段时间成了我最痛苦的一段时间。</p>\n<p>因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。</p>\n<p>接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。</p>\n<p>调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。</p>\n<p>就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。</p>\n<p>因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。</p>\n<p>一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。</p>\n<p>但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。</p>\n<p>到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。</p>\n<p>后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。</p>\n<h1 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h1><p>回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。</p>\n<p>其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。</p>\n<p>金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。</p>\n<p>但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。</p>\n<p>程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！</p>\n<p>最后，附上自己当时校招找工作时看的部分书单：</p>\n<ul>\n<li>《JavaScript高级程序设计》——必读</li>\n<li>《你不知道的JS》——强烈推荐</li>\n<li>《CSS禅意花园》——学习CSS很有用</li>\n<li>《JavaScript设计模式》——对代码质量提升很大</li>\n<li>《高性能网站建设指南》——了解网站优化</li>\n<li>《响应式Web设计全流程解析》——响应式布局、网页设计</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？</p>","more":"<h1 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h1><p>人生最怕没有目标，一旦有了目标，生活就有了动力。</p>\n<p>在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。</p>\n<p>接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。</p>\n<p>然而，事与愿违，那段时间成了我最痛苦的一段时间。</p>\n<p>因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。</p>\n<p>接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。</p>\n<p>调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。</p>\n<p>就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。</p>\n<p>因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。</p>\n<p>一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。</p>\n<p>但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。</p>\n<p>到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。</p>\n<p>后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。</p>\n<h1 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h1><p>回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。</p>\n<p>其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。</p>\n<p>金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。</p>\n<p>但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。</p>\n<p>程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！</p>\n<p>最后，附上自己当时校招找工作时看的部分书单：</p>\n<ul>\n<li>《JavaScript高级程序设计》——必读</li>\n<li>《你不知道的JS》——强烈推荐</li>\n<li>《CSS禅意花园》——学习CSS很有用</li>\n<li>《JavaScript设计模式》——对代码质量提升很大</li>\n<li>《高性能网站建设指南》——了解网站优化</li>\n<li>《响应式Web设计全流程解析》——响应式布局、网页设计</li>\n</ul>"},{"title":"git命令手册（持续更新）","date":"2020-01-25T08:47:41.000Z","toc":true,"_content":"\n本篇不定时更新git实践技巧，方便查阅git命令。\n<!--more-->\n\n# 分支相关操作\n## git checkout\n切换分支，例如：`git checkout -b ${branch_name}`\n\n## git show\n显示各种类型的对象。可以是blobs，树，标签和提交。\n\n## git remote\n对本地远程增删改查\n\ngit remote -v 获取远程分支信息\n\n## git fetch\n从远端拉取代码，默认拉取`origin`。\n\n## git merge\n合并分支操作，例如：`git merge master`，把`master`分支的内容合并到当前分支。\n\n## git pull\n拉取代码，用得最多的命令。pull = fetch + merge\n\n## git push\n推送代码到远程分支。\n\n# 修改相关操作\n## git add\n添加变更，最常用的命令：`git add .`，添加当前所有变更。\n\n## git status\n查看当前git状态。\n\n## git diff\n对比两个分支的差异。\n\n## git stash\n缓存当前变更，一般在要切换到别的分支，而当前分支的变更又不想提交时用。`git stash`，然后恢复的时候：`git stash apply`。\n\n# 提交相关操作\n## git commit\n提交变更，最常用的命令：`git commit -m \"commit message\"`。\n\n## git revert\n撤销某次版本，`git revert -n 版本号`\n\n## git log\n查看git提交信息。\n\n# 奇淫技巧\n- git blame 查看文件每一行修改记录\n- git reflog 查看操作记录\n- git rebase -i HEAD-n 修改已提交的前n个commit操作\n- 更新子模块url：`git submodule sync --recursive`","source":"_posts/2020-01-25-git-commend-list.md","raw":"---\ntitle: git命令手册（持续更新）\ndate: 2020-01-25 16:47:41\ntoc: true\ncategories:\n- 工具\ntags:\n- git\n---\n\n本篇不定时更新git实践技巧，方便查阅git命令。\n<!--more-->\n\n# 分支相关操作\n## git checkout\n切换分支，例如：`git checkout -b ${branch_name}`\n\n## git show\n显示各种类型的对象。可以是blobs，树，标签和提交。\n\n## git remote\n对本地远程增删改查\n\ngit remote -v 获取远程分支信息\n\n## git fetch\n从远端拉取代码，默认拉取`origin`。\n\n## git merge\n合并分支操作，例如：`git merge master`，把`master`分支的内容合并到当前分支。\n\n## git pull\n拉取代码，用得最多的命令。pull = fetch + merge\n\n## git push\n推送代码到远程分支。\n\n# 修改相关操作\n## git add\n添加变更，最常用的命令：`git add .`，添加当前所有变更。\n\n## git status\n查看当前git状态。\n\n## git diff\n对比两个分支的差异。\n\n## git stash\n缓存当前变更，一般在要切换到别的分支，而当前分支的变更又不想提交时用。`git stash`，然后恢复的时候：`git stash apply`。\n\n# 提交相关操作\n## git commit\n提交变更，最常用的命令：`git commit -m \"commit message\"`。\n\n## git revert\n撤销某次版本，`git revert -n 版本号`\n\n## git log\n查看git提交信息。\n\n# 奇淫技巧\n- git blame 查看文件每一行修改记录\n- git reflog 查看操作记录\n- git rebase -i HEAD-n 修改已提交的前n个commit操作\n- 更新子模块url：`git submodule sync --recursive`","slug":"git-commend-list","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05di003era4k2v7ybpxg","content":"<p>本篇不定时更新git实践技巧，方便查阅git命令。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"分支相关操作\"><a href=\"#分支相关操作\" class=\"headerlink\" title=\"分支相关操作\"></a>分支相关操作</h1><h2 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h2><p>切换分支，例如：<code>git checkout -b $&#123;branch_name&#125;</code></p>\n<h2 id=\"git-show\"><a href=\"#git-show\" class=\"headerlink\" title=\"git show\"></a>git show</h2><p>显示各种类型的对象。可以是blobs，树，标签和提交。</p>\n<h2 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h2><p>对本地远程增删改查</p>\n<p>git remote -v 获取远程分支信息</p>\n<h2 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h2><p>从远端拉取代码，默认拉取<code>origin</code>。</p>\n<h2 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h2><p>合并分支操作，例如：<code>git merge master</code>，把<code>master</code>分支的内容合并到当前分支。</p>\n<h2 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h2><p>拉取代码，用得最多的命令。pull &#x3D; fetch + merge</p>\n<h2 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h2><p>推送代码到远程分支。</p>\n<h1 id=\"修改相关操作\"><a href=\"#修改相关操作\" class=\"headerlink\" title=\"修改相关操作\"></a>修改相关操作</h1><h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h2><p>添加变更，最常用的命令：<code>git add .</code>，添加当前所有变更。</p>\n<h2 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h2><p>查看当前git状态。</p>\n<h2 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h2><p>对比两个分支的差异。</p>\n<h2 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h2><p>缓存当前变更，一般在要切换到别的分支，而当前分支的变更又不想提交时用。<code>git stash</code>，然后恢复的时候：<code>git stash apply</code>。</p>\n<h1 id=\"提交相关操作\"><a href=\"#提交相关操作\" class=\"headerlink\" title=\"提交相关操作\"></a>提交相关操作</h1><h2 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h2><p>提交变更，最常用的命令：<code>git commit -m &quot;commit message&quot;</code>。</p>\n<h2 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git revert\"></a>git revert</h2><p>撤销某次版本，<code>git revert -n 版本号</code></p>\n<h2 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h2><p>查看git提交信息。</p>\n<h1 id=\"奇淫技巧\"><a href=\"#奇淫技巧\" class=\"headerlink\" title=\"奇淫技巧\"></a>奇淫技巧</h1><ul>\n<li>git blame 查看文件每一行修改记录</li>\n<li>git reflog 查看操作记录</li>\n<li>git rebase -i HEAD-n 修改已提交的前n个commit操作</li>\n<li>更新子模块url：<code>git submodule sync --recursive</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本篇不定时更新git实践技巧，方便查阅git命令。</p>","more":"<h1 id=\"分支相关操作\"><a href=\"#分支相关操作\" class=\"headerlink\" title=\"分支相关操作\"></a>分支相关操作</h1><h2 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h2><p>切换分支，例如：<code>git checkout -b $&#123;branch_name&#125;</code></p>\n<h2 id=\"git-show\"><a href=\"#git-show\" class=\"headerlink\" title=\"git show\"></a>git show</h2><p>显示各种类型的对象。可以是blobs，树，标签和提交。</p>\n<h2 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h2><p>对本地远程增删改查</p>\n<p>git remote -v 获取远程分支信息</p>\n<h2 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h2><p>从远端拉取代码，默认拉取<code>origin</code>。</p>\n<h2 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h2><p>合并分支操作，例如：<code>git merge master</code>，把<code>master</code>分支的内容合并到当前分支。</p>\n<h2 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h2><p>拉取代码，用得最多的命令。pull &#x3D; fetch + merge</p>\n<h2 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h2><p>推送代码到远程分支。</p>\n<h1 id=\"修改相关操作\"><a href=\"#修改相关操作\" class=\"headerlink\" title=\"修改相关操作\"></a>修改相关操作</h1><h2 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h2><p>添加变更，最常用的命令：<code>git add .</code>，添加当前所有变更。</p>\n<h2 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h2><p>查看当前git状态。</p>\n<h2 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h2><p>对比两个分支的差异。</p>\n<h2 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h2><p>缓存当前变更，一般在要切换到别的分支，而当前分支的变更又不想提交时用。<code>git stash</code>，然后恢复的时候：<code>git stash apply</code>。</p>\n<h1 id=\"提交相关操作\"><a href=\"#提交相关操作\" class=\"headerlink\" title=\"提交相关操作\"></a>提交相关操作</h1><h2 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h2><p>提交变更，最常用的命令：<code>git commit -m &quot;commit message&quot;</code>。</p>\n<h2 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git revert\"></a>git revert</h2><p>撤销某次版本，<code>git revert -n 版本号</code></p>\n<h2 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h2><p>查看git提交信息。</p>\n<h1 id=\"奇淫技巧\"><a href=\"#奇淫技巧\" class=\"headerlink\" title=\"奇淫技巧\"></a>奇淫技巧</h1><ul>\n<li>git blame 查看文件每一行修改记录</li>\n<li>git reflog 查看操作记录</li>\n<li>git rebase -i HEAD-n 修改已提交的前n个commit操作</li>\n<li>更新子模块url：<code>git submodule sync --recursive</code></li>\n</ul>"},{"title":"clarity-js源码分析系列（一）","date":"2022-02-24T07:20:47.000Z","toc":true,"_content":"\n前端监控一直是前端不可或缺的一部分，这里我调研了微软的[clarity](https://github.com/microsoft/clarity)，它们主要是针对用户的行为监控进行录制回放，并且能生成热力图分析。为了彻底搞清楚其中的原理，对`clarity-js`进行了源码分析。\n\n话不多说，直接开始！\n<!--more-->\n# 整体代码结构\n```\nclarity-js\n    -- src\n        -- core\n        -- data\n        -- diagnostic\n        -- interaction\n        -- layout\n        -- performance\n        clarity.ts\n        global.ts\n        index.ts\n```\n下面围绕入口文件``index.ts``开始逐步分析。\n\n# 代码分析\n## index.ts\n入口文件，主要导出三个对象：``export { clarity, version, helper };``。\n\n这里我们主要关注`clarity`对象。\n\n`clarity`关键导出四个方法：``start、pause、resume、stop``，从字面上也能猜出他们分别代表的功能：开始、暂停、继续、停止。\n\n先来看源码：\n\n```typescript\nexport function start(config: Config = null): void {\n  // 先检查浏览器是否支持相关api\n  // 保证不会多次执行start\n  if (core.check()) {\n    core.config(config);\n    core.start();\n    data.start();\n    modules.forEach(x => measure(x.start)());\n  }\n}\n\nexport function pause(): void {\n  if (core.active()) {\n    data.event(Constant.Clarity, Constant.Pause);\n    task.pause();\n  }\n}\n\n\nexport function resume(): void {\n  if (core.active()) {\n    task.resume();\n    data.event(Constant.Clarity, Constant.Resume);\n  }\n}\n\nexport function stop(): void {\n  if (core.active()) {\n    // 以与modules初始化相反的顺序去停止\n    modules.slice().reverse().forEach(x => measure(x.stop)());\n    data.stop();\n    core.stop();\n  }\n}\n```\n从源码很容易看出，这里主要就是针对整个监控流程的一个生命周期操作。主要是对``core、data、modules``这几个对象进行操作，其实最关键的部分就是初始化，我们来分模块看下。\n\n## core\n### core.config\n说白了就是支持自定义配置项，具体配置内容先不深入讲，之后用到的时候再讨论。这里给出``Config``实例：\n```typescript\nexport interface Config {\n  projectId?: string;\n  delay?: number;\n  lean?: boolean;\n  track?: boolean;\n  content?: boolean;\n  mask?: string[];\n  unmask?: string[];\n  regions?: Region[];\n  metrics?: Metric[];\n  dimensions?: Dimension[];\n  cookies?: string[];\n  report?: string;\n  upload?: string | UploadCallback;\n  fallback?: string;\n  upgrade?: (key: string) => void;\n}\n```\n\n### core.start\n初始化操作：\n```typescript\nexport function start(): void {\n  status = true;\n  time.start();    // 时间打点开始\n  task.reset();    // 重置任务队列\n  event.reset();   // 移除所有事件绑定\n  report.reset();  // 清除缓存的上报数据\n  history.start(); // 开始记录url的history state\n}\n```\n这里其他的方法都好理解，关键来看看最后的``history.start``。\n\n总共做了两件事：\n\n1、绑定``window.popstate``事件\n```flow\nst=>start: 绑定window.popstate事件\ncond=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond\ncond(yes)->sub1->sub2->e\ncond(no)->e\n```\n\n2、代理``history.pushState``和``history.replaceState``事件\n```flow\nst=>start: 代理pushState、replaceState事件\nop1=>operation: 正常执行pushState、replaceState事件\ncond1=>condition: 调用堆栈是否小于20？\ncond2=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond1\ncond1(yes)->op1->cond2\ncond1(no)->e\ncond2(yes)->sub1->sub2->e\ncond2(no)->e\n```\n这样就能确保当url地址发生变化时，能及时重启clarity实例，保证跟踪到每个页面的状态。\n\n## data\n\n```typescript\nexport function start(): void {\n  metric.start(); // 初始化所有与性能相关的信息\n  modules.forEach(x => measure(x.start)()); // 初始化数据，并且测量耗时\n}\n```\n\n这里的主要目的就是初始化所有数据，包括了一系列需要记录的信息：如页面浏览器、页面来源、userid、页面长宽、鼠标指针等等。数据非常繁多，同时也支持自定义，总之是尽可能地去收集页面数据，方便之后的日志分析。\n\n但看到这里同时引入一个问题：这么庞大的数据是怎么保存和上传分析的呢？别急，之后会拿来专门分析。\n\n## modules\n这里加载了一些模块，然后进行初始化。模块包括：\n\n`diagnostic, layout, interaction, performance`\n\n那么这些模块在初始化时又做了些什么呢，来看看他们的操作。\n\n### diagnostic\n通过代码发现，主要做了两件事：\n\n1、绑定`window.error`事件，记录一些错误堆栈和相关信息。\n\n2、初始化历史缓存，用来之后打log\n\n### layout\n这个模块跟页面元素的变化息息相关，又细分了很多模块。\n\n首先看源码：\n```typescript\nexport function start(): void {\n  // 这里的执行顺序非常重要\n  doc.start();\n  region.start();\n  dom.start();\n  mutation.start();\n  discover.start();\n  box.start();\n}\n```\n\n通过源码分析，可以得到各个模块的大概作用：\n\n**doc**：记录整个页面的最大宽度和高度。\n\n**region**：利用了`IntersectionObserver`，来观察元素的变化，记录元素的交互状态，方便之后的数据重放与还原。\n\n**dom**：遍历所有元素，记录需要遮罩的元素和监听记录所有元素的属性、状态、性能变化。\n\n**mutation**：利用`MutationObserver`，监听DOM树和CSS的变化。\n\n**discover**：记录dom和region变化函数的耗时。\n\n**box**：利用`ResizeObserver`监听元素size的变化。\n\n### interaction\n这个模块主要是做一些跟交互有关的操作，先看代码：\n```typescript\nexport function start(): void {\n  timeline.start();\n  click.start();\n  clipboard.start();\n  pointer.start();\n  input.start();\n  resize.start();\n  visibility.start();\n  scroll.start();\n  selection.start();\n  submit.start();\n  unload.start();\n}\n```\n\n分别做了以下事情：\n\n**timeline**：记录跟踪click事件的时间线。\n\n**click**：监听点击事件，记录点击元素相关信息。这里要着重看下记录了哪些信息，来看这段关键代码。\n```typescript\nif (x !== null && y !== null) {\n  state.push({\n    time: time(), event, data: {\n      target: t,  // 当前元素\n      x,          // pageX\n      y,          // pageY\n      eX,         // 点击时相对元素坐标X\n      eY,         // 点击时相对元素坐标 Y\n      button: evt.button,      // 点击按钮元素\n      reaction: reaction(t),   // 是否是点击无交互元素，比如纯文本，或者非\"input\", \"textarea\", \"radio\", \"button\", \"canvas\"元素\n      context: context(a),     // link标签a元素的target类型，比如：blank、parent、top\n      text: text(t),           // 点击文本，截取前25个非空字符\n      link: a ? a.href : null, // 跳转链接\n      hash: null\n    }\n  });\n  schedule(encode.bind(this, event));\n}\n```\n\n这样一来，就能相对完整地记录点击的元素信息，方便之后还原。\n\n**clipboard**：监听`cut、copy、paste`事件，并记录相应的event对象。\n\n**pointer**：监听所有跟鼠标指针交互相关的事件：`mousedown、mouseup、mousemove、mousewheel、dblclick、touchstart、touchend、touchmove、touchcancel`，并记录指针位置。\n\n**input**：监听`input`事件，包括`value、attr、placeholder`等方面的隐私处理，主要记录value。\n\n**resize**：监听`window.resize`事件，记录window视窗变化。\n\n**visibility**：监听`visibilitychange`事件，记录`document.visibilityState`。\n\n**scroll**：监听元素的`scroll`事件，记录当前滚动元素和滚动位置。\n\n**selection**：监听元素`selectstart、selectionchange`事件，记录选区起始和结束锚点和元素。\n\n**submit**：监听元素`submit`事件，记录当前元素。\n\n**unload**：监听`window.pagehide`事件，记录事件，停止clarity实例。\n\n\n\n### performance\n这里的模块很容易理解，就是记录页面的各种性能，主要包括以下两部分：\n\n**navigation**：利用`PerformanceNavigationTiming`记录页面首屏性能指标，包括：DNS解析时间、请求时间、DOM解析时间、重定向时间等等。\n\n**observer**：利用`PerformanceObserver`观测页面性能指标，包括：浏览器、资源、长任务、首次输入延迟、累积布局偏移、最大内容绘制。\n\n# 总结\n到此，我们分析了clarity的代码结构，和初始化时各个模块的分工。\n\n下一篇，我将着重分析关键的数据存储和上报方式，并且回顾整个系统架构，整体分析clarity的设计理念。","source":"_posts/2022-02-24-clarity-source-analysis-1.md","raw":"---\ntitle: clarity-js源码分析系列（一）\ndate: 2022-02-24 15:20:47\ntoc: true\ncategories:\n- JS相关\ntags:\n- 源码分析\n- 前端监控\n- 录制回放\n---\n\n前端监控一直是前端不可或缺的一部分，这里我调研了微软的[clarity](https://github.com/microsoft/clarity)，它们主要是针对用户的行为监控进行录制回放，并且能生成热力图分析。为了彻底搞清楚其中的原理，对`clarity-js`进行了源码分析。\n\n话不多说，直接开始！\n<!--more-->\n# 整体代码结构\n```\nclarity-js\n    -- src\n        -- core\n        -- data\n        -- diagnostic\n        -- interaction\n        -- layout\n        -- performance\n        clarity.ts\n        global.ts\n        index.ts\n```\n下面围绕入口文件``index.ts``开始逐步分析。\n\n# 代码分析\n## index.ts\n入口文件，主要导出三个对象：``export { clarity, version, helper };``。\n\n这里我们主要关注`clarity`对象。\n\n`clarity`关键导出四个方法：``start、pause、resume、stop``，从字面上也能猜出他们分别代表的功能：开始、暂停、继续、停止。\n\n先来看源码：\n\n```typescript\nexport function start(config: Config = null): void {\n  // 先检查浏览器是否支持相关api\n  // 保证不会多次执行start\n  if (core.check()) {\n    core.config(config);\n    core.start();\n    data.start();\n    modules.forEach(x => measure(x.start)());\n  }\n}\n\nexport function pause(): void {\n  if (core.active()) {\n    data.event(Constant.Clarity, Constant.Pause);\n    task.pause();\n  }\n}\n\n\nexport function resume(): void {\n  if (core.active()) {\n    task.resume();\n    data.event(Constant.Clarity, Constant.Resume);\n  }\n}\n\nexport function stop(): void {\n  if (core.active()) {\n    // 以与modules初始化相反的顺序去停止\n    modules.slice().reverse().forEach(x => measure(x.stop)());\n    data.stop();\n    core.stop();\n  }\n}\n```\n从源码很容易看出，这里主要就是针对整个监控流程的一个生命周期操作。主要是对``core、data、modules``这几个对象进行操作，其实最关键的部分就是初始化，我们来分模块看下。\n\n## core\n### core.config\n说白了就是支持自定义配置项，具体配置内容先不深入讲，之后用到的时候再讨论。这里给出``Config``实例：\n```typescript\nexport interface Config {\n  projectId?: string;\n  delay?: number;\n  lean?: boolean;\n  track?: boolean;\n  content?: boolean;\n  mask?: string[];\n  unmask?: string[];\n  regions?: Region[];\n  metrics?: Metric[];\n  dimensions?: Dimension[];\n  cookies?: string[];\n  report?: string;\n  upload?: string | UploadCallback;\n  fallback?: string;\n  upgrade?: (key: string) => void;\n}\n```\n\n### core.start\n初始化操作：\n```typescript\nexport function start(): void {\n  status = true;\n  time.start();    // 时间打点开始\n  task.reset();    // 重置任务队列\n  event.reset();   // 移除所有事件绑定\n  report.reset();  // 清除缓存的上报数据\n  history.start(); // 开始记录url的history state\n}\n```\n这里其他的方法都好理解，关键来看看最后的``history.start``。\n\n总共做了两件事：\n\n1、绑定``window.popstate``事件\n```flow\nst=>start: 绑定window.popstate事件\ncond=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond\ncond(yes)->sub1->sub2->e\ncond(no)->e\n```\n\n2、代理``history.pushState``和``history.replaceState``事件\n```flow\nst=>start: 代理pushState、replaceState事件\nop1=>operation: 正常执行pushState、replaceState事件\ncond1=>condition: 调用堆栈是否小于20？\ncond2=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond1\ncond1(yes)->op1->cond2\ncond1(no)->e\ncond2(yes)->sub1->sub2->e\ncond2(no)->e\n```\n这样就能确保当url地址发生变化时，能及时重启clarity实例，保证跟踪到每个页面的状态。\n\n## data\n\n```typescript\nexport function start(): void {\n  metric.start(); // 初始化所有与性能相关的信息\n  modules.forEach(x => measure(x.start)()); // 初始化数据，并且测量耗时\n}\n```\n\n这里的主要目的就是初始化所有数据，包括了一系列需要记录的信息：如页面浏览器、页面来源、userid、页面长宽、鼠标指针等等。数据非常繁多，同时也支持自定义，总之是尽可能地去收集页面数据，方便之后的日志分析。\n\n但看到这里同时引入一个问题：这么庞大的数据是怎么保存和上传分析的呢？别急，之后会拿来专门分析。\n\n## modules\n这里加载了一些模块，然后进行初始化。模块包括：\n\n`diagnostic, layout, interaction, performance`\n\n那么这些模块在初始化时又做了些什么呢，来看看他们的操作。\n\n### diagnostic\n通过代码发现，主要做了两件事：\n\n1、绑定`window.error`事件，记录一些错误堆栈和相关信息。\n\n2、初始化历史缓存，用来之后打log\n\n### layout\n这个模块跟页面元素的变化息息相关，又细分了很多模块。\n\n首先看源码：\n```typescript\nexport function start(): void {\n  // 这里的执行顺序非常重要\n  doc.start();\n  region.start();\n  dom.start();\n  mutation.start();\n  discover.start();\n  box.start();\n}\n```\n\n通过源码分析，可以得到各个模块的大概作用：\n\n**doc**：记录整个页面的最大宽度和高度。\n\n**region**：利用了`IntersectionObserver`，来观察元素的变化，记录元素的交互状态，方便之后的数据重放与还原。\n\n**dom**：遍历所有元素，记录需要遮罩的元素和监听记录所有元素的属性、状态、性能变化。\n\n**mutation**：利用`MutationObserver`，监听DOM树和CSS的变化。\n\n**discover**：记录dom和region变化函数的耗时。\n\n**box**：利用`ResizeObserver`监听元素size的变化。\n\n### interaction\n这个模块主要是做一些跟交互有关的操作，先看代码：\n```typescript\nexport function start(): void {\n  timeline.start();\n  click.start();\n  clipboard.start();\n  pointer.start();\n  input.start();\n  resize.start();\n  visibility.start();\n  scroll.start();\n  selection.start();\n  submit.start();\n  unload.start();\n}\n```\n\n分别做了以下事情：\n\n**timeline**：记录跟踪click事件的时间线。\n\n**click**：监听点击事件，记录点击元素相关信息。这里要着重看下记录了哪些信息，来看这段关键代码。\n```typescript\nif (x !== null && y !== null) {\n  state.push({\n    time: time(), event, data: {\n      target: t,  // 当前元素\n      x,          // pageX\n      y,          // pageY\n      eX,         // 点击时相对元素坐标X\n      eY,         // 点击时相对元素坐标 Y\n      button: evt.button,      // 点击按钮元素\n      reaction: reaction(t),   // 是否是点击无交互元素，比如纯文本，或者非\"input\", \"textarea\", \"radio\", \"button\", \"canvas\"元素\n      context: context(a),     // link标签a元素的target类型，比如：blank、parent、top\n      text: text(t),           // 点击文本，截取前25个非空字符\n      link: a ? a.href : null, // 跳转链接\n      hash: null\n    }\n  });\n  schedule(encode.bind(this, event));\n}\n```\n\n这样一来，就能相对完整地记录点击的元素信息，方便之后还原。\n\n**clipboard**：监听`cut、copy、paste`事件，并记录相应的event对象。\n\n**pointer**：监听所有跟鼠标指针交互相关的事件：`mousedown、mouseup、mousemove、mousewheel、dblclick、touchstart、touchend、touchmove、touchcancel`，并记录指针位置。\n\n**input**：监听`input`事件，包括`value、attr、placeholder`等方面的隐私处理，主要记录value。\n\n**resize**：监听`window.resize`事件，记录window视窗变化。\n\n**visibility**：监听`visibilitychange`事件，记录`document.visibilityState`。\n\n**scroll**：监听元素的`scroll`事件，记录当前滚动元素和滚动位置。\n\n**selection**：监听元素`selectstart、selectionchange`事件，记录选区起始和结束锚点和元素。\n\n**submit**：监听元素`submit`事件，记录当前元素。\n\n**unload**：监听`window.pagehide`事件，记录事件，停止clarity实例。\n\n\n\n### performance\n这里的模块很容易理解，就是记录页面的各种性能，主要包括以下两部分：\n\n**navigation**：利用`PerformanceNavigationTiming`记录页面首屏性能指标，包括：DNS解析时间、请求时间、DOM解析时间、重定向时间等等。\n\n**observer**：利用`PerformanceObserver`观测页面性能指标，包括：浏览器、资源、长任务、首次输入延迟、累积布局偏移、最大内容绘制。\n\n# 总结\n到此，我们分析了clarity的代码结构，和初始化时各个模块的分工。\n\n下一篇，我将着重分析关键的数据存储和上报方式，并且回顾整个系统架构，整体分析clarity的设计理念。","slug":"clarity-source-analysis-1","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05dj003ira4ka07r1bqj","content":"<p>前端监控一直是前端不可或缺的一部分，这里我调研了微软的<a href=\"https://github.com/microsoft/clarity\">clarity</a>，它们主要是针对用户的行为监控进行录制回放，并且能生成热力图分析。为了彻底搞清楚其中的原理，对<code>clarity-js</code>进行了源码分析。</p>\n<p>话不多说，直接开始！</p>\n<span id=\"more\"></span>\n<h1 id=\"整体代码结构\"><a href=\"#整体代码结构\" class=\"headerlink\" title=\"整体代码结构\"></a>整体代码结构</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clarity-js</span><br><span class=\"line\">    -- src</span><br><span class=\"line\">        -- core</span><br><span class=\"line\">        -- data</span><br><span class=\"line\">        -- diagnostic</span><br><span class=\"line\">        -- interaction</span><br><span class=\"line\">        -- layout</span><br><span class=\"line\">        -- performance</span><br><span class=\"line\">        clarity.ts</span><br><span class=\"line\">        global.ts</span><br><span class=\"line\">        index.ts</span><br></pre></td></tr></table></figure>\n<p>下面围绕入口文件<code>index.ts</code>开始逐步分析。</p>\n<h1 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h1><h2 id=\"index-ts\"><a href=\"#index-ts\" class=\"headerlink\" title=\"index.ts\"></a>index.ts</h2><p>入口文件，主要导出三个对象：<code>export &#123; clarity, version, helper &#125;;</code>。</p>\n<p>这里我们主要关注<code>clarity</code>对象。</p>\n<p><code>clarity</code>关键导出四个方法：<code>start、pause、resume、stop</code>，从字面上也能猜出他们分别代表的功能：开始、暂停、继续、停止。</p>\n<p>先来看源码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\">config: Config = <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先检查浏览器是否支持相关api</span></span><br><span class=\"line\">  <span class=\"comment\">// 保证不会多次执行start</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">check</span>()) &#123;</span><br><span class=\"line\">    core.<span class=\"title function_\">config</span>(config);</span><br><span class=\"line\">    core.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">    data.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">    modules.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"title function_\">measure</span>(x.<span class=\"property\">start</span>)());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">pause</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">active</span>()) &#123;</span><br><span class=\"line\">    data.<span class=\"title function_\">event</span>(<span class=\"title class_\">Constant</span>.<span class=\"property\">Clarity</span>, <span class=\"title class_\">Constant</span>.<span class=\"property\">Pause</span>);</span><br><span class=\"line\">    task.<span class=\"title function_\">pause</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">resume</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">active</span>()) &#123;</span><br><span class=\"line\">    task.<span class=\"title function_\">resume</span>();</span><br><span class=\"line\">    data.<span class=\"title function_\">event</span>(<span class=\"title class_\">Constant</span>.<span class=\"property\">Clarity</span>, <span class=\"title class_\">Constant</span>.<span class=\"property\">Resume</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stop</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">active</span>()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以与modules初始化相反的顺序去停止</span></span><br><span class=\"line\">    modules.<span class=\"title function_\">slice</span>().<span class=\"title function_\">reverse</span>().<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"title function_\">measure</span>(x.<span class=\"property\">stop</span>)());</span><br><span class=\"line\">    data.<span class=\"title function_\">stop</span>();</span><br><span class=\"line\">    core.<span class=\"title function_\">stop</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码很容易看出，这里主要就是针对整个监控流程的一个生命周期操作。主要是对<code>core、data、modules</code>这几个对象进行操作，其实最关键的部分就是初始化，我们来分模块看下。</p>\n<h2 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core</h2><h3 id=\"core-config\"><a href=\"#core-config\" class=\"headerlink\" title=\"core.config\"></a>core.config</h3><p>说白了就是支持自定义配置项，具体配置内容先不深入讲，之后用到的时候再讨论。这里给出<code>Config</code>实例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  projectId?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  delay?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  lean?: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  track?: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  content?: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  mask?: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  unmask?: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  regions?: <span class=\"title class_\">Region</span>[];</span><br><span class=\"line\">  metrics?: <span class=\"title class_\">Metric</span>[];</span><br><span class=\"line\">  dimensions?: <span class=\"title class_\">Dimension</span>[];</span><br><span class=\"line\">  cookies?: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  report?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  upload?: <span class=\"built_in\">string</span> | <span class=\"title class_\">UploadCallback</span>;</span><br><span class=\"line\">  fallback?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  upgrade?: <span class=\"function\">(<span class=\"params\">key: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"core-start\"><a href=\"#core-start\" class=\"headerlink\" title=\"core.start\"></a>core.start</h3><p>初始化操作：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  status = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  time.<span class=\"title function_\">start</span>();    <span class=\"comment\">// 时间打点开始</span></span><br><span class=\"line\">  task.<span class=\"title function_\">reset</span>();    <span class=\"comment\">// 重置任务队列</span></span><br><span class=\"line\">  event.<span class=\"title function_\">reset</span>();   <span class=\"comment\">// 移除所有事件绑定</span></span><br><span class=\"line\">  report.<span class=\"title function_\">reset</span>();  <span class=\"comment\">// 清除缓存的上报数据</span></span><br><span class=\"line\">  history.<span class=\"title function_\">start</span>(); <span class=\"comment\">// 开始记录url的history state</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其他的方法都好理解，关键来看看最后的<code>history.start</code>。</p>\n<p>总共做了两件事：</p>\n<p>1、绑定<code>window.popstate</code>事件</p>\n<div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n<p>2、代理<code>history.pushState</code>和<code>history.replaceState</code>事件</p>\n<div id=\"flowchart-1\" class=\"flow-chart\"></div>\n这样就能确保当url地址发生变化时，能及时重启clarity实例，保证跟踪到每个页面的状态。\n\n<h2 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  metric.<span class=\"title function_\">start</span>(); <span class=\"comment\">// 初始化所有与性能相关的信息</span></span><br><span class=\"line\">  modules.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"title function_\">measure</span>(x.<span class=\"property\">start</span>)()); <span class=\"comment\">// 初始化数据，并且测量耗时</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的主要目的就是初始化所有数据，包括了一系列需要记录的信息：如页面浏览器、页面来源、userid、页面长宽、鼠标指针等等。数据非常繁多，同时也支持自定义，总之是尽可能地去收集页面数据，方便之后的日志分析。</p>\n<p>但看到这里同时引入一个问题：这么庞大的数据是怎么保存和上传分析的呢？别急，之后会拿来专门分析。</p>\n<h2 id=\"modules\"><a href=\"#modules\" class=\"headerlink\" title=\"modules\"></a>modules</h2><p>这里加载了一些模块，然后进行初始化。模块包括：</p>\n<p><code>diagnostic, layout, interaction, performance</code></p>\n<p>那么这些模块在初始化时又做了些什么呢，来看看他们的操作。</p>\n<h3 id=\"diagnostic\"><a href=\"#diagnostic\" class=\"headerlink\" title=\"diagnostic\"></a>diagnostic</h3><p>通过代码发现，主要做了两件事：</p>\n<p>1、绑定<code>window.error</code>事件，记录一些错误堆栈和相关信息。</p>\n<p>2、初始化历史缓存，用来之后打log</p>\n<h3 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h3><p>这个模块跟页面元素的变化息息相关，又细分了很多模块。</p>\n<p>首先看源码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的执行顺序非常重要</span></span><br><span class=\"line\">  doc.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  region.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  dom.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  mutation.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  discover.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  box.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码分析，可以得到各个模块的大概作用：</p>\n<p><strong>doc</strong>：记录整个页面的最大宽度和高度。</p>\n<p><strong>region</strong>：利用了<code>IntersectionObserver</code>，来观察元素的变化，记录元素的交互状态，方便之后的数据重放与还原。</p>\n<p><strong>dom</strong>：遍历所有元素，记录需要遮罩的元素和监听记录所有元素的属性、状态、性能变化。</p>\n<p><strong>mutation</strong>：利用<code>MutationObserver</code>，监听DOM树和CSS的变化。</p>\n<p><strong>discover</strong>：记录dom和region变化函数的耗时。</p>\n<p><strong>box</strong>：利用<code>ResizeObserver</code>监听元素size的变化。</p>\n<h3 id=\"interaction\"><a href=\"#interaction\" class=\"headerlink\" title=\"interaction\"></a>interaction</h3><p>这个模块主要是做一些跟交互有关的操作，先看代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  timeline.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  click.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  clipboard.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  pointer.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  input.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  resize.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  visibility.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  scroll.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  selection.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  submit.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  unload.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分别做了以下事情：</p>\n<p><strong>timeline</strong>：记录跟踪click事件的时间线。</p>\n<p><strong>click</strong>：监听点击事件，记录点击元素相关信息。这里要着重看下记录了哪些信息，来看这段关键代码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; y !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  state.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">time</span>: <span class=\"title function_\">time</span>(), event, <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">target</span>: t,  <span class=\"comment\">// 当前元素</span></span><br><span class=\"line\">      x,          <span class=\"comment\">// pageX</span></span><br><span class=\"line\">      y,          <span class=\"comment\">// pageY</span></span><br><span class=\"line\">      eX,         <span class=\"comment\">// 点击时相对元素坐标X</span></span><br><span class=\"line\">      eY,         <span class=\"comment\">// 点击时相对元素坐标 Y</span></span><br><span class=\"line\">      <span class=\"attr\">button</span>: evt.<span class=\"property\">button</span>,      <span class=\"comment\">// 点击按钮元素</span></span><br><span class=\"line\">      <span class=\"attr\">reaction</span>: <span class=\"title function_\">reaction</span>(t),   <span class=\"comment\">// 是否是点击无交互元素，比如纯文本，或者非&quot;input&quot;, &quot;textarea&quot;, &quot;radio&quot;, &quot;button&quot;, &quot;canvas&quot;元素</span></span><br><span class=\"line\">      <span class=\"attr\">context</span>: <span class=\"title function_\">context</span>(a),     <span class=\"comment\">// link标签a元素的target类型，比如：blank、parent、top</span></span><br><span class=\"line\">      <span class=\"attr\">text</span>: <span class=\"title function_\">text</span>(t),           <span class=\"comment\">// 点击文本，截取前25个非空字符</span></span><br><span class=\"line\">      <span class=\"attr\">link</span>: a ? a.<span class=\"property\">href</span> : <span class=\"literal\">null</span>, <span class=\"comment\">// 跳转链接</span></span><br><span class=\"line\">      <span class=\"attr\">hash</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"title function_\">schedule</span>(encode.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>, event));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，就能相对完整地记录点击的元素信息，方便之后还原。</p>\n<p><strong>clipboard</strong>：监听<code>cut、copy、paste</code>事件，并记录相应的event对象。</p>\n<p><strong>pointer</strong>：监听所有跟鼠标指针交互相关的事件：<code>mousedown、mouseup、mousemove、mousewheel、dblclick、touchstart、touchend、touchmove、touchcancel</code>，并记录指针位置。</p>\n<p><strong>input</strong>：监听<code>input</code>事件，包括<code>value、attr、placeholder</code>等方面的隐私处理，主要记录value。</p>\n<p><strong>resize</strong>：监听<code>window.resize</code>事件，记录window视窗变化。</p>\n<p><strong>visibility</strong>：监听<code>visibilitychange</code>事件，记录<code>document.visibilityState</code>。</p>\n<p><strong>scroll</strong>：监听元素的<code>scroll</code>事件，记录当前滚动元素和滚动位置。</p>\n<p><strong>selection</strong>：监听元素<code>selectstart、selectionchange</code>事件，记录选区起始和结束锚点和元素。</p>\n<p><strong>submit</strong>：监听元素<code>submit</code>事件，记录当前元素。</p>\n<p><strong>unload</strong>：监听<code>window.pagehide</code>事件，记录事件，停止clarity实例。</p>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><p>这里的模块很容易理解，就是记录页面的各种性能，主要包括以下两部分：</p>\n<p><strong>navigation</strong>：利用<code>PerformanceNavigationTiming</code>记录页面首屏性能指标，包括：DNS解析时间、请求时间、DOM解析时间、重定向时间等等。</p>\n<p><strong>observer</strong>：利用<code>PerformanceObserver</code>观测页面性能指标，包括：浏览器、资源、长任务、首次输入延迟、累积布局偏移、最大内容绘制。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>到此，我们分析了clarity的代码结构，和初始化时各个模块的分工。</p>\n<p>下一篇，我将着重分析关键的数据存储和上报方式，并且回顾整个系统架构，整体分析clarity的设计理念。<script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 绑定window.popstate事件\ncond=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond\ncond(yes)->sub1->sub2->e\ncond(no)->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script><textarea id=\"flowchart-1-code\" style=\"display: none\">st=>start: 代理pushState、replaceState事件\nop1=>operation: 正常执行pushState、replaceState事件\ncond1=>condition: 调用堆栈是否小于20？\ncond2=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond1\ncond1(yes)->op1->cond2\ncond1(no)->e\ncond2(yes)->sub1->sub2->e\ncond2(no)->e</textarea><textarea id=\"flowchart-1-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-1-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-1\", options);</script></p>\n","site":{"data":{}},"excerpt":"<p>前端监控一直是前端不可或缺的一部分，这里我调研了微软的<a href=\"https://github.com/microsoft/clarity\">clarity</a>，它们主要是针对用户的行为监控进行录制回放，并且能生成热力图分析。为了彻底搞清楚其中的原理，对<code>clarity-js</code>进行了源码分析。</p>\n<p>话不多说，直接开始！</p>","more":"<h1 id=\"整体代码结构\"><a href=\"#整体代码结构\" class=\"headerlink\" title=\"整体代码结构\"></a>整体代码结构</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clarity-js</span><br><span class=\"line\">    -- src</span><br><span class=\"line\">        -- core</span><br><span class=\"line\">        -- data</span><br><span class=\"line\">        -- diagnostic</span><br><span class=\"line\">        -- interaction</span><br><span class=\"line\">        -- layout</span><br><span class=\"line\">        -- performance</span><br><span class=\"line\">        clarity.ts</span><br><span class=\"line\">        global.ts</span><br><span class=\"line\">        index.ts</span><br></pre></td></tr></table></figure>\n<p>下面围绕入口文件<code>index.ts</code>开始逐步分析。</p>\n<h1 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h1><h2 id=\"index-ts\"><a href=\"#index-ts\" class=\"headerlink\" title=\"index.ts\"></a>index.ts</h2><p>入口文件，主要导出三个对象：<code>export &#123; clarity, version, helper &#125;;</code>。</p>\n<p>这里我们主要关注<code>clarity</code>对象。</p>\n<p><code>clarity</code>关键导出四个方法：<code>start、pause、resume、stop</code>，从字面上也能猜出他们分别代表的功能：开始、暂停、继续、停止。</p>\n<p>先来看源码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\">config: Config = <span class=\"literal\">null</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 先检查浏览器是否支持相关api</span></span><br><span class=\"line\">  <span class=\"comment\">// 保证不会多次执行start</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">check</span>()) &#123;</span><br><span class=\"line\">    core.<span class=\"title function_\">config</span>(config);</span><br><span class=\"line\">    core.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">    data.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">    modules.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"title function_\">measure</span>(x.<span class=\"property\">start</span>)());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">pause</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">active</span>()) &#123;</span><br><span class=\"line\">    data.<span class=\"title function_\">event</span>(<span class=\"title class_\">Constant</span>.<span class=\"property\">Clarity</span>, <span class=\"title class_\">Constant</span>.<span class=\"property\">Pause</span>);</span><br><span class=\"line\">    task.<span class=\"title function_\">pause</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">resume</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">active</span>()) &#123;</span><br><span class=\"line\">    task.<span class=\"title function_\">resume</span>();</span><br><span class=\"line\">    data.<span class=\"title function_\">event</span>(<span class=\"title class_\">Constant</span>.<span class=\"property\">Clarity</span>, <span class=\"title class_\">Constant</span>.<span class=\"property\">Resume</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">stop</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (core.<span class=\"title function_\">active</span>()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以与modules初始化相反的顺序去停止</span></span><br><span class=\"line\">    modules.<span class=\"title function_\">slice</span>().<span class=\"title function_\">reverse</span>().<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"title function_\">measure</span>(x.<span class=\"property\">stop</span>)());</span><br><span class=\"line\">    data.<span class=\"title function_\">stop</span>();</span><br><span class=\"line\">    core.<span class=\"title function_\">stop</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码很容易看出，这里主要就是针对整个监控流程的一个生命周期操作。主要是对<code>core、data、modules</code>这几个对象进行操作，其实最关键的部分就是初始化，我们来分模块看下。</p>\n<h2 id=\"core\"><a href=\"#core\" class=\"headerlink\" title=\"core\"></a>core</h2><h3 id=\"core-config\"><a href=\"#core-config\" class=\"headerlink\" title=\"core.config\"></a>core.config</h3><p>说白了就是支持自定义配置项，具体配置内容先不深入讲，之后用到的时候再讨论。这里给出<code>Config</code>实例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">  projectId?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  delay?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  lean?: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  track?: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  content?: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  mask?: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  unmask?: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  regions?: <span class=\"title class_\">Region</span>[];</span><br><span class=\"line\">  metrics?: <span class=\"title class_\">Metric</span>[];</span><br><span class=\"line\">  dimensions?: <span class=\"title class_\">Dimension</span>[];</span><br><span class=\"line\">  cookies?: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  report?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  upload?: <span class=\"built_in\">string</span> | <span class=\"title class_\">UploadCallback</span>;</span><br><span class=\"line\">  fallback?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  upgrade?: <span class=\"function\">(<span class=\"params\">key: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"core-start\"><a href=\"#core-start\" class=\"headerlink\" title=\"core.start\"></a>core.start</h3><p>初始化操作：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  status = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  time.<span class=\"title function_\">start</span>();    <span class=\"comment\">// 时间打点开始</span></span><br><span class=\"line\">  task.<span class=\"title function_\">reset</span>();    <span class=\"comment\">// 重置任务队列</span></span><br><span class=\"line\">  event.<span class=\"title function_\">reset</span>();   <span class=\"comment\">// 移除所有事件绑定</span></span><br><span class=\"line\">  report.<span class=\"title function_\">reset</span>();  <span class=\"comment\">// 清除缓存的上报数据</span></span><br><span class=\"line\">  history.<span class=\"title function_\">start</span>(); <span class=\"comment\">// 开始记录url的history state</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里其他的方法都好理解，关键来看看最后的<code>history.start</code>。</p>\n<p>总共做了两件事：</p>\n<p>1、绑定<code>window.popstate</code>事件</p>\n<div id=\"flowchart-0\" class=\"flow-chart\"></div>\n\n<p>2、代理<code>history.pushState</code>和<code>history.replaceState</code>事件</p>\n<div id=\"flowchart-1\" class=\"flow-chart\"></div>\n这样就能确保当url地址发生变化时，能及时重启clarity实例，保证跟踪到每个页面的状态。\n\n<h2 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h2><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  metric.<span class=\"title function_\">start</span>(); <span class=\"comment\">// 初始化所有与性能相关的信息</span></span><br><span class=\"line\">  modules.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"title function_\">measure</span>(x.<span class=\"property\">start</span>)()); <span class=\"comment\">// 初始化数据，并且测量耗时</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的主要目的就是初始化所有数据，包括了一系列需要记录的信息：如页面浏览器、页面来源、userid、页面长宽、鼠标指针等等。数据非常繁多，同时也支持自定义，总之是尽可能地去收集页面数据，方便之后的日志分析。</p>\n<p>但看到这里同时引入一个问题：这么庞大的数据是怎么保存和上传分析的呢？别急，之后会拿来专门分析。</p>\n<h2 id=\"modules\"><a href=\"#modules\" class=\"headerlink\" title=\"modules\"></a>modules</h2><p>这里加载了一些模块，然后进行初始化。模块包括：</p>\n<p><code>diagnostic, layout, interaction, performance</code></p>\n<p>那么这些模块在初始化时又做了些什么呢，来看看他们的操作。</p>\n<h3 id=\"diagnostic\"><a href=\"#diagnostic\" class=\"headerlink\" title=\"diagnostic\"></a>diagnostic</h3><p>通过代码发现，主要做了两件事：</p>\n<p>1、绑定<code>window.error</code>事件，记录一些错误堆栈和相关信息。</p>\n<p>2、初始化历史缓存，用来之后打log</p>\n<h3 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h3><p>这个模块跟页面元素的变化息息相关，又细分了很多模块。</p>\n<p>首先看源码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里的执行顺序非常重要</span></span><br><span class=\"line\">  doc.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  region.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  dom.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  mutation.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  discover.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  box.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码分析，可以得到各个模块的大概作用：</p>\n<p><strong>doc</strong>：记录整个页面的最大宽度和高度。</p>\n<p><strong>region</strong>：利用了<code>IntersectionObserver</code>，来观察元素的变化，记录元素的交互状态，方便之后的数据重放与还原。</p>\n<p><strong>dom</strong>：遍历所有元素，记录需要遮罩的元素和监听记录所有元素的属性、状态、性能变化。</p>\n<p><strong>mutation</strong>：利用<code>MutationObserver</code>，监听DOM树和CSS的变化。</p>\n<p><strong>discover</strong>：记录dom和region变化函数的耗时。</p>\n<p><strong>box</strong>：利用<code>ResizeObserver</code>监听元素size的变化。</p>\n<h3 id=\"interaction\"><a href=\"#interaction\" class=\"headerlink\" title=\"interaction\"></a>interaction</h3><p>这个模块主要是做一些跟交互有关的操作，先看代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">start</span>(<span class=\"params\"></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  timeline.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  click.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  clipboard.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  pointer.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  input.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  resize.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  visibility.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  scroll.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  selection.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  submit.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">  unload.<span class=\"title function_\">start</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分别做了以下事情：</p>\n<p><strong>timeline</strong>：记录跟踪click事件的时间线。</p>\n<p><strong>click</strong>：监听点击事件，记录点击元素相关信息。这里要着重看下记录了哪些信息，来看这段关键代码。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; y !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  state.<span class=\"title function_\">push</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">time</span>: <span class=\"title function_\">time</span>(), event, <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">target</span>: t,  <span class=\"comment\">// 当前元素</span></span><br><span class=\"line\">      x,          <span class=\"comment\">// pageX</span></span><br><span class=\"line\">      y,          <span class=\"comment\">// pageY</span></span><br><span class=\"line\">      eX,         <span class=\"comment\">// 点击时相对元素坐标X</span></span><br><span class=\"line\">      eY,         <span class=\"comment\">// 点击时相对元素坐标 Y</span></span><br><span class=\"line\">      <span class=\"attr\">button</span>: evt.<span class=\"property\">button</span>,      <span class=\"comment\">// 点击按钮元素</span></span><br><span class=\"line\">      <span class=\"attr\">reaction</span>: <span class=\"title function_\">reaction</span>(t),   <span class=\"comment\">// 是否是点击无交互元素，比如纯文本，或者非&quot;input&quot;, &quot;textarea&quot;, &quot;radio&quot;, &quot;button&quot;, &quot;canvas&quot;元素</span></span><br><span class=\"line\">      <span class=\"attr\">context</span>: <span class=\"title function_\">context</span>(a),     <span class=\"comment\">// link标签a元素的target类型，比如：blank、parent、top</span></span><br><span class=\"line\">      <span class=\"attr\">text</span>: <span class=\"title function_\">text</span>(t),           <span class=\"comment\">// 点击文本，截取前25个非空字符</span></span><br><span class=\"line\">      <span class=\"attr\">link</span>: a ? a.<span class=\"property\">href</span> : <span class=\"literal\">null</span>, <span class=\"comment\">// 跳转链接</span></span><br><span class=\"line\">      <span class=\"attr\">hash</span>: <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"title function_\">schedule</span>(encode.<span class=\"title function_\">bind</span>(<span class=\"variable language_\">this</span>, event));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，就能相对完整地记录点击的元素信息，方便之后还原。</p>\n<p><strong>clipboard</strong>：监听<code>cut、copy、paste</code>事件，并记录相应的event对象。</p>\n<p><strong>pointer</strong>：监听所有跟鼠标指针交互相关的事件：<code>mousedown、mouseup、mousemove、mousewheel、dblclick、touchstart、touchend、touchmove、touchcancel</code>，并记录指针位置。</p>\n<p><strong>input</strong>：监听<code>input</code>事件，包括<code>value、attr、placeholder</code>等方面的隐私处理，主要记录value。</p>\n<p><strong>resize</strong>：监听<code>window.resize</code>事件，记录window视窗变化。</p>\n<p><strong>visibility</strong>：监听<code>visibilitychange</code>事件，记录<code>document.visibilityState</code>。</p>\n<p><strong>scroll</strong>：监听元素的<code>scroll</code>事件，记录当前滚动元素和滚动位置。</p>\n<p><strong>selection</strong>：监听元素<code>selectstart、selectionchange</code>事件，记录选区起始和结束锚点和元素。</p>\n<p><strong>submit</strong>：监听元素<code>submit</code>事件，记录当前元素。</p>\n<p><strong>unload</strong>：监听<code>window.pagehide</code>事件，记录事件，停止clarity实例。</p>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><p>这里的模块很容易理解，就是记录页面的各种性能，主要包括以下两部分：</p>\n<p><strong>navigation</strong>：利用<code>PerformanceNavigationTiming</code>记录页面首屏性能指标，包括：DNS解析时间、请求时间、DOM解析时间、重定向时间等等。</p>\n<p><strong>observer</strong>：利用<code>PerformanceObserver</code>观测页面性能指标，包括：浏览器、资源、长任务、首次输入延迟、累积布局偏移、最大内容绘制。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>到此，我们分析了clarity的代码结构，和初始化时各个模块的分工。</p>\n<p>下一篇，我将着重分析关键的数据存储和上报方式，并且回顾整个系统架构，整体分析clarity的设计理念。<script src=\"https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js\"></script><script src=\"https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js\"></script><textarea id=\"flowchart-0-code\" style=\"display: none\">st=>start: 绑定window.popstate事件\ncond=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond\ncond(yes)->sub1->sub2->e\ncond(no)->e</textarea><textarea id=\"flowchart-0-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-0-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-0\", options);</script><textarea id=\"flowchart-1-code\" style=\"display: none\">st=>start: 代理pushState、replaceState事件\nop1=>operation: 正常执行pushState、replaceState事件\ncond1=>condition: 调用堆栈是否小于20？\ncond2=>condition: url是否发生变化？\nsub1=>subroutine: 停止当前clarity实例\nsub2=>subroutine: 250ms后重新开启clarity实例\ne=>end: 结束\nst->cond1\ncond1(yes)->op1->cond2\ncond1(no)->e\ncond2(yes)->sub1->sub2->e\ncond2(no)->e</textarea><textarea id=\"flowchart-1-options\" style=\"display: none\">{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}</textarea><script>  var code = document.getElementById(\"flowchart-1-code\").value;  var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value));  var diagram = flowchart.parse(code);  diagram.drawSVG(\"flowchart-1\", options);</script></p>"},{"title":"clarity-js源码分析系列（二）","date":"2022-02-26T12:20:47.000Z","toc":true,"_content":"\n上一篇我们大概介绍了clarity各个模块的作用，本篇我想着重来了解下`clarity`在数据存储、日志上报、性能优化方面做的事情，并试着理清clarity整个的架构。\n<!--more-->\n\n# 数据存储\n对于前端监控，特别是需要录制回放功能的时候，数据就是生命。没有了监控数据，一切都免谈。\n\n但是，为了尽可能收集用户的行为特征，和方便之后的行为分析和日志定位，肯定需要监控许多数据，光我一下子想到的就有这些方面：DOM元素信息、鼠标交互信息、页面状态、用户停留时长等等。\n\n面对这么多的数据，首先想到的就是怎么去存储。我以为这么多数据，clarity肯定会用indexDB去存储在本地，但是通过源码发现，并没有。那么clarity是怎么做的呢？\n\n## 队列缓存\nclarity直接用js数组来缓存数据对象，每当有新的数据加入，通过`encode`函数统一分发处理，然后塞到数组队列里去：\n```typescript\nexport function queue(tokens: Token[], transmit: boolean = true): void {\n  if (active) {\n    let now = time();\n    let type = tokens.length > 1 ? tokens[1] : null;\n    let event = JSON.stringify(tokens);\n\n    switch (type) {\n      case Event.Discover:\n        discoverBytes += event.length;\n      case Event.Box:\n      case Event.Mutation:\n        playbackBytes += event.length;\n        playback.push(event);\n        break;\n      default:\n        analysis.push(event);\n        break;\n    }\n\n    metric.count(Metric.EventCount);\n\n    let gap = delay();\n    if (now - queuedTime > (gap * 2)) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n\n    if (transmit && timeout === null) {\n      if (type !== Event.Ping) { ping.reset(); }\n      timeout = setTimeout(upload, gap);\n      queuedTime = now;\n      limit.check(playbackBytes);\n    }\n  }\n}\n```\n\n根据这段代码，我们可以知道`queue`主要做了两件事：\n\n1、根据数据类型分类塞到不同的队列，供之后上传使用。\n\n2、部分数据利用`setTimeout`延时上报。\n\n注意的是，大部分数据在延时100～3000ms后都会立即上报，也是为了及时释放数据，不至于堆积得太多。除了某些场景，比如`metric`模块相关的性能指标，需要一直关注，会在最后结束的时候统一再上传。\n\n## 数据检测\n这里还进行了数据的检测：`limit.check(playbackBytes)`。主要是进行三种检测：\n\n1、payload不能超过128个，也就是`envelope`对象的个数。\n\n2、页面实例开启不能超过2个小时，也就是说最多能监测在页面停留两个小时的数据。\n\n3、数据大小不能超过10MB。\n\n如果不满足其中任何一种限制，则立即停止clarity实例。\n\n经过这些限制，有效地保证了数据的大小，不至于内存过高，导致页面崩溃或者是上传过多不必要的数据。\n\n# 日志上报\n## 上报时机\n日志上报的时机有两个：\n\n1、在数据刚进入队列时，延时几百毫秒立即上报。\n\n2、在实例`stop`的时候上报，比如`pagehide`。\n\n## 数据压缩\n上报的操作其实就是把当前收集到的所有数据集中起来，打包成一个`payload`。由于数据会很大，需要对`payload`进行压缩操作：\n```typescript\nexport default async function(input: string): Promise<Uint8Array> {\n  try {\n    if (supported) {\n      const stream = new ReadableStream({async start(controller) {\n        controller.enqueue(input);\n        controller.close();\n      }}).pipeThrough(new TextEncoderStream()).pipeThrough(new window[Constant.CompressionStream](\"gzip\"));\n      return new Uint8Array(await read(stream));\n    }\n  } catch { /* do nothing */ }\n  return null;\n}\n```\n\n通过源码得知这里的压缩原理：创建`ReadableStream`管道，将数据字符串塞进去，通过`TextEncoderStream`和`CompressionStream`对其进行`gzip`压缩。\n\n## 上报方式\n数据压缩完毕，下一步就是发起上报请求。常用的前端监控上报可以通过三种方式上报：\n\n1、`(new Image()).src = ${uploadUrl}`，这里一般适合数据小，并且需要跨域的请求。\n\n2、`ajax`请求，这个也是最常见的上报方式。\n\n3、`sendBeacon`，一般用在`unload`或者页面关闭的时候，用于发送统计数据。因为在页面关闭时，正常的`ajax`异步请求经常会出现丢失情况，而同步请求又会阻塞页面的关闭跳转，有了`sendBeacon`，会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。不过要要注意的是，这里使用的是`POST`请求，而且无法设置`HTTP headers`，所以不能用压缩的数据，只能用字符串。\n\n这里`clarity`使用了三种策略：\n\n1、正常上报使用`ajax`请求，并且优先上报压缩过的数据（考虑到CompressionStream的浏览器兼容性，如果不支持则用原始字符串数据）。\n\n2、如果是在页面关闭或者停止`clarity`实例时，优先用`sendBeacon`，如果不支持则用回`ajax`。\n\n3、支持配置`upload`参数，利用用户自定义的`upload`函数来上传。\n\n当然，这里的上报还做了保护机制，支持上报失败自动重试，并且在首次上报后还会更新`session`，保持会话状态。\n\n# 性能优化\n对于一个前端监控SDK来说，性能非常重要。因为我们的目的是监控页面，但是不能影响到用户的正常操作，而是以一个观察者的角色在旁边看着。如果监控代码影响到页面性能，甚至引发页面卡顿、或者出bug，阻塞用户正常页面操作，那就得不偿失了。\n\n为了检测clarity的性能，我在我的博客加上了`claritySDK`，看看性能表现如何。\n\n通过几天的观察，目前性能还算良好，每次交互完都会立即上报。不过因为博客页面比较简单，没有什么复杂的交互，主要是点击和滚动页面，每次上报的数据一般都是几十B，内存损耗比较小。\n\n但同样的，通过Chrome本身的性能指标监控，发现每次交互完JS的堆内存都会暴涨一波，等上报完内存就会释放。虽然说内存及时释放了，但是如果是更复杂的页面，需要大量的交互操作，比如编辑器，那内存可能会居高不下，所以这方面的性能还有待提高。\n\n从SDK代码本身来说，没有什么高耗时的函数运算，其风险主要还是在内存爆栈上。\n\n# 总结\n`clarity`总体上还是从以下几个方面去做监控：\n\n页面信息采集 -> 事件监听 -> 数据分类 -> 批量上报。\n\n其中我认为做的比较好的部分是页面信息采集和数据分类，尽可能多的去收集页面信息，并且记录元素对象和id，同时采用了一些数据压缩方式，来保证数据的完整性和可用性。\n\n但同时，对于DOM结构复杂或者交互复杂的页面，`clarity`会占用大量的内存，由于是采用纯数组和对象存储，导致JS堆栈在某些时刻会飙升，非常有可能影响到页面性能，这方面的性能损耗还需进一步评测。\n\n总的来说，在数据采集端`clarity`对数据的收集还是比较完备，不足的是性能优化方面，但对于大部分普通HTML页面，没有多少交互来说也能够支持。而`clarity`的模块分类和数据收集方式也是值得我们好好学习的。\n","source":"_posts/2022-02-26-clarity-source-analysis-2.md","raw":"---\ntitle: clarity-js源码分析系列（二）\ndate: 2022-02-26 20:20:47\ntoc: true\ncategories:\n- JS相关\ntags:\n- 源码分析\n- 前端监控\n- 录制回放\n---\n\n上一篇我们大概介绍了clarity各个模块的作用，本篇我想着重来了解下`clarity`在数据存储、日志上报、性能优化方面做的事情，并试着理清clarity整个的架构。\n<!--more-->\n\n# 数据存储\n对于前端监控，特别是需要录制回放功能的时候，数据就是生命。没有了监控数据，一切都免谈。\n\n但是，为了尽可能收集用户的行为特征，和方便之后的行为分析和日志定位，肯定需要监控许多数据，光我一下子想到的就有这些方面：DOM元素信息、鼠标交互信息、页面状态、用户停留时长等等。\n\n面对这么多的数据，首先想到的就是怎么去存储。我以为这么多数据，clarity肯定会用indexDB去存储在本地，但是通过源码发现，并没有。那么clarity是怎么做的呢？\n\n## 队列缓存\nclarity直接用js数组来缓存数据对象，每当有新的数据加入，通过`encode`函数统一分发处理，然后塞到数组队列里去：\n```typescript\nexport function queue(tokens: Token[], transmit: boolean = true): void {\n  if (active) {\n    let now = time();\n    let type = tokens.length > 1 ? tokens[1] : null;\n    let event = JSON.stringify(tokens);\n\n    switch (type) {\n      case Event.Discover:\n        discoverBytes += event.length;\n      case Event.Box:\n      case Event.Mutation:\n        playbackBytes += event.length;\n        playback.push(event);\n        break;\n      default:\n        analysis.push(event);\n        break;\n    }\n\n    metric.count(Metric.EventCount);\n\n    let gap = delay();\n    if (now - queuedTime > (gap * 2)) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n\n    if (transmit && timeout === null) {\n      if (type !== Event.Ping) { ping.reset(); }\n      timeout = setTimeout(upload, gap);\n      queuedTime = now;\n      limit.check(playbackBytes);\n    }\n  }\n}\n```\n\n根据这段代码，我们可以知道`queue`主要做了两件事：\n\n1、根据数据类型分类塞到不同的队列，供之后上传使用。\n\n2、部分数据利用`setTimeout`延时上报。\n\n注意的是，大部分数据在延时100～3000ms后都会立即上报，也是为了及时释放数据，不至于堆积得太多。除了某些场景，比如`metric`模块相关的性能指标，需要一直关注，会在最后结束的时候统一再上传。\n\n## 数据检测\n这里还进行了数据的检测：`limit.check(playbackBytes)`。主要是进行三种检测：\n\n1、payload不能超过128个，也就是`envelope`对象的个数。\n\n2、页面实例开启不能超过2个小时，也就是说最多能监测在页面停留两个小时的数据。\n\n3、数据大小不能超过10MB。\n\n如果不满足其中任何一种限制，则立即停止clarity实例。\n\n经过这些限制，有效地保证了数据的大小，不至于内存过高，导致页面崩溃或者是上传过多不必要的数据。\n\n# 日志上报\n## 上报时机\n日志上报的时机有两个：\n\n1、在数据刚进入队列时，延时几百毫秒立即上报。\n\n2、在实例`stop`的时候上报，比如`pagehide`。\n\n## 数据压缩\n上报的操作其实就是把当前收集到的所有数据集中起来，打包成一个`payload`。由于数据会很大，需要对`payload`进行压缩操作：\n```typescript\nexport default async function(input: string): Promise<Uint8Array> {\n  try {\n    if (supported) {\n      const stream = new ReadableStream({async start(controller) {\n        controller.enqueue(input);\n        controller.close();\n      }}).pipeThrough(new TextEncoderStream()).pipeThrough(new window[Constant.CompressionStream](\"gzip\"));\n      return new Uint8Array(await read(stream));\n    }\n  } catch { /* do nothing */ }\n  return null;\n}\n```\n\n通过源码得知这里的压缩原理：创建`ReadableStream`管道，将数据字符串塞进去，通过`TextEncoderStream`和`CompressionStream`对其进行`gzip`压缩。\n\n## 上报方式\n数据压缩完毕，下一步就是发起上报请求。常用的前端监控上报可以通过三种方式上报：\n\n1、`(new Image()).src = ${uploadUrl}`，这里一般适合数据小，并且需要跨域的请求。\n\n2、`ajax`请求，这个也是最常见的上报方式。\n\n3、`sendBeacon`，一般用在`unload`或者页面关闭的时候，用于发送统计数据。因为在页面关闭时，正常的`ajax`异步请求经常会出现丢失情况，而同步请求又会阻塞页面的关闭跳转，有了`sendBeacon`，会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。不过要要注意的是，这里使用的是`POST`请求，而且无法设置`HTTP headers`，所以不能用压缩的数据，只能用字符串。\n\n这里`clarity`使用了三种策略：\n\n1、正常上报使用`ajax`请求，并且优先上报压缩过的数据（考虑到CompressionStream的浏览器兼容性，如果不支持则用原始字符串数据）。\n\n2、如果是在页面关闭或者停止`clarity`实例时，优先用`sendBeacon`，如果不支持则用回`ajax`。\n\n3、支持配置`upload`参数，利用用户自定义的`upload`函数来上传。\n\n当然，这里的上报还做了保护机制，支持上报失败自动重试，并且在首次上报后还会更新`session`，保持会话状态。\n\n# 性能优化\n对于一个前端监控SDK来说，性能非常重要。因为我们的目的是监控页面，但是不能影响到用户的正常操作，而是以一个观察者的角色在旁边看着。如果监控代码影响到页面性能，甚至引发页面卡顿、或者出bug，阻塞用户正常页面操作，那就得不偿失了。\n\n为了检测clarity的性能，我在我的博客加上了`claritySDK`，看看性能表现如何。\n\n通过几天的观察，目前性能还算良好，每次交互完都会立即上报。不过因为博客页面比较简单，没有什么复杂的交互，主要是点击和滚动页面，每次上报的数据一般都是几十B，内存损耗比较小。\n\n但同样的，通过Chrome本身的性能指标监控，发现每次交互完JS的堆内存都会暴涨一波，等上报完内存就会释放。虽然说内存及时释放了，但是如果是更复杂的页面，需要大量的交互操作，比如编辑器，那内存可能会居高不下，所以这方面的性能还有待提高。\n\n从SDK代码本身来说，没有什么高耗时的函数运算，其风险主要还是在内存爆栈上。\n\n# 总结\n`clarity`总体上还是从以下几个方面去做监控：\n\n页面信息采集 -> 事件监听 -> 数据分类 -> 批量上报。\n\n其中我认为做的比较好的部分是页面信息采集和数据分类，尽可能多的去收集页面信息，并且记录元素对象和id，同时采用了一些数据压缩方式，来保证数据的完整性和可用性。\n\n但同时，对于DOM结构复杂或者交互复杂的页面，`clarity`会占用大量的内存，由于是采用纯数组和对象存储，导致JS堆栈在某些时刻会飙升，非常有可能影响到页面性能，这方面的性能损耗还需进一步评测。\n\n总的来说，在数据采集端`clarity`对数据的收集还是比较完备，不足的是性能优化方面，但对于大部分普通HTML页面，没有多少交互来说也能够支持。而`clarity`的模块分类和数据收集方式也是值得我们好好学习的。\n","slug":"clarity-source-analysis-2","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0kp05dk003lra4kejh08owz","content":"<p>上一篇我们大概介绍了clarity各个模块的作用，本篇我想着重来了解下<code>clarity</code>在数据存储、日志上报、性能优化方面做的事情，并试着理清clarity整个的架构。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h1><p>对于前端监控，特别是需要录制回放功能的时候，数据就是生命。没有了监控数据，一切都免谈。</p>\n<p>但是，为了尽可能收集用户的行为特征，和方便之后的行为分析和日志定位，肯定需要监控许多数据，光我一下子想到的就有这些方面：DOM元素信息、鼠标交互信息、页面状态、用户停留时长等等。</p>\n<p>面对这么多的数据，首先想到的就是怎么去存储。我以为这么多数据，clarity肯定会用indexDB去存储在本地，但是通过源码发现，并没有。那么clarity是怎么做的呢？</p>\n<h2 id=\"队列缓存\"><a href=\"#队列缓存\" class=\"headerlink\" title=\"队列缓存\"></a>队列缓存</h2><p>clarity直接用js数组来缓存数据对象，每当有新的数据加入，通过<code>encode</code>函数统一分发处理，然后塞到数组队列里去：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">queue</span>(<span class=\"params\">tokens: Token[], transmit: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (active) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> now = <span class=\"title function_\">time</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">type</span> = tokens.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span> ? tokens[<span class=\"number\">1</span>] : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> event = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(tokens);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">Event</span>.<span class=\"property\">Discover</span>:</span><br><span class=\"line\">        discoverBytes += event.<span class=\"property\">length</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">Event</span>.<span class=\"property\">Box</span>:</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">Event</span>.<span class=\"property\">Mutation</span>:</span><br><span class=\"line\">        playbackBytes += event.<span class=\"property\">length</span>;</span><br><span class=\"line\">        playback.<span class=\"title function_\">push</span>(event);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"attr\">default</span>:</span><br><span class=\"line\">        analysis.<span class=\"title function_\">push</span>(event);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    metric.<span class=\"title function_\">count</span>(<span class=\"title class_\">Metric</span>.<span class=\"property\">EventCount</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> gap = <span class=\"title function_\">delay</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - queuedTime &gt; (gap * <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">      timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transmit &amp;&amp; timeout === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">type</span> !== <span class=\"title class_\">Event</span>.<span class=\"property\">Ping</span>) &#123; ping.<span class=\"title function_\">reset</span>(); &#125;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(upload, gap);</span><br><span class=\"line\">      queuedTime = now;</span><br><span class=\"line\">      limit.<span class=\"title function_\">check</span>(playbackBytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据这段代码，我们可以知道<code>queue</code>主要做了两件事：</p>\n<p>1、根据数据类型分类塞到不同的队列，供之后上传使用。</p>\n<p>2、部分数据利用<code>setTimeout</code>延时上报。</p>\n<p>注意的是，大部分数据在延时100～3000ms后都会立即上报，也是为了及时释放数据，不至于堆积得太多。除了某些场景，比如<code>metric</code>模块相关的性能指标，需要一直关注，会在最后结束的时候统一再上传。</p>\n<h2 id=\"数据检测\"><a href=\"#数据检测\" class=\"headerlink\" title=\"数据检测\"></a>数据检测</h2><p>这里还进行了数据的检测：<code>limit.check(playbackBytes)</code>。主要是进行三种检测：</p>\n<p>1、payload不能超过128个，也就是<code>envelope</code>对象的个数。</p>\n<p>2、页面实例开启不能超过2个小时，也就是说最多能监测在页面停留两个小时的数据。</p>\n<p>3、数据大小不能超过10MB。</p>\n<p>如果不满足其中任何一种限制，则立即停止clarity实例。</p>\n<p>经过这些限制，有效地保证了数据的大小，不至于内存过高，导致页面崩溃或者是上传过多不必要的数据。</p>\n<h1 id=\"日志上报\"><a href=\"#日志上报\" class=\"headerlink\" title=\"日志上报\"></a>日志上报</h1><h2 id=\"上报时机\"><a href=\"#上报时机\" class=\"headerlink\" title=\"上报时机\"></a>上报时机</h2><p>日志上报的时机有两个：</p>\n<p>1、在数据刚进入队列时，延时几百毫秒立即上报。</p>\n<p>2、在实例<code>stop</code>的时候上报，比如<code>pagehide</code>。</p>\n<h2 id=\"数据压缩\"><a href=\"#数据压缩\" class=\"headerlink\" title=\"数据压缩\"></a>数据压缩</h2><p>上报的操作其实就是把当前收集到的所有数据集中起来，打包成一个<code>payload</code>。由于数据会很大，需要对<code>payload</code>进行压缩操作：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\">input: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">Promise</span>&lt;<span class=\"title class_\">Uint8Array</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (supported) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> stream = <span class=\"keyword\">new</span> <span class=\"title class_\">ReadableStream</span>(&#123;<span class=\"keyword\">async</span> <span class=\"title function_\">start</span>(<span class=\"params\">controller</span>) &#123;</span><br><span class=\"line\">        controller.<span class=\"title function_\">enqueue</span>(input);</span><br><span class=\"line\">        controller.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">      &#125;&#125;).<span class=\"title function_\">pipeThrough</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TextEncoderStream</span>()).<span class=\"title function_\">pipeThrough</span>(<span class=\"keyword\">new</span> <span class=\"variable language_\">window</span>[<span class=\"title class_\">Constant</span>.<span class=\"property\">CompressionStream</span>](<span class=\"string\">&quot;gzip&quot;</span>));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Uint8Array</span>(<span class=\"keyword\">await</span> <span class=\"title function_\">read</span>(stream));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> &#123; <span class=\"comment\">/* do nothing */</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码得知这里的压缩原理：创建<code>ReadableStream</code>管道，将数据字符串塞进去，通过<code>TextEncoderStream</code>和<code>CompressionStream</code>对其进行<code>gzip</code>压缩。</p>\n<h2 id=\"上报方式\"><a href=\"#上报方式\" class=\"headerlink\" title=\"上报方式\"></a>上报方式</h2><p>数据压缩完毕，下一步就是发起上报请求。常用的前端监控上报可以通过三种方式上报：</p>\n<p>1、<code>(new Image()).src = $&#123;uploadUrl&#125;</code>，这里一般适合数据小，并且需要跨域的请求。</p>\n<p>2、<code>ajax</code>请求，这个也是最常见的上报方式。</p>\n<p>3、<code>sendBeacon</code>，一般用在<code>unload</code>或者页面关闭的时候，用于发送统计数据。因为在页面关闭时，正常的<code>ajax</code>异步请求经常会出现丢失情况，而同步请求又会阻塞页面的关闭跳转，有了<code>sendBeacon</code>，会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。不过要要注意的是，这里使用的是<code>POST</code>请求，而且无法设置<code>HTTP headers</code>，所以不能用压缩的数据，只能用字符串。</p>\n<p>这里<code>clarity</code>使用了三种策略：</p>\n<p>1、正常上报使用<code>ajax</code>请求，并且优先上报压缩过的数据（考虑到CompressionStream的浏览器兼容性，如果不支持则用原始字符串数据）。</p>\n<p>2、如果是在页面关闭或者停止<code>clarity</code>实例时，优先用<code>sendBeacon</code>，如果不支持则用回<code>ajax</code>。</p>\n<p>3、支持配置<code>upload</code>参数，利用用户自定义的<code>upload</code>函数来上传。</p>\n<p>当然，这里的上报还做了保护机制，支持上报失败自动重试，并且在首次上报后还会更新<code>session</code>，保持会话状态。</p>\n<h1 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h1><p>对于一个前端监控SDK来说，性能非常重要。因为我们的目的是监控页面，但是不能影响到用户的正常操作，而是以一个观察者的角色在旁边看着。如果监控代码影响到页面性能，甚至引发页面卡顿、或者出bug，阻塞用户正常页面操作，那就得不偿失了。</p>\n<p>为了检测clarity的性能，我在我的博客加上了<code>claritySDK</code>，看看性能表现如何。</p>\n<p>通过几天的观察，目前性能还算良好，每次交互完都会立即上报。不过因为博客页面比较简单，没有什么复杂的交互，主要是点击和滚动页面，每次上报的数据一般都是几十B，内存损耗比较小。</p>\n<p>但同样的，通过Chrome本身的性能指标监控，发现每次交互完JS的堆内存都会暴涨一波，等上报完内存就会释放。虽然说内存及时释放了，但是如果是更复杂的页面，需要大量的交互操作，比如编辑器，那内存可能会居高不下，所以这方面的性能还有待提高。</p>\n<p>从SDK代码本身来说，没有什么高耗时的函数运算，其风险主要还是在内存爆栈上。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><code>clarity</code>总体上还是从以下几个方面去做监控：</p>\n<p>页面信息采集 -&gt; 事件监听 -&gt; 数据分类 -&gt; 批量上报。</p>\n<p>其中我认为做的比较好的部分是页面信息采集和数据分类，尽可能多的去收集页面信息，并且记录元素对象和id，同时采用了一些数据压缩方式，来保证数据的完整性和可用性。</p>\n<p>但同时，对于DOM结构复杂或者交互复杂的页面，<code>clarity</code>会占用大量的内存，由于是采用纯数组和对象存储，导致JS堆栈在某些时刻会飙升，非常有可能影响到页面性能，这方面的性能损耗还需进一步评测。</p>\n<p>总的来说，在数据采集端<code>clarity</code>对数据的收集还是比较完备，不足的是性能优化方面，但对于大部分普通HTML页面，没有多少交互来说也能够支持。而<code>clarity</code>的模块分类和数据收集方式也是值得我们好好学习的。</p>\n","site":{"data":{}},"excerpt":"<p>上一篇我们大概介绍了clarity各个模块的作用，本篇我想着重来了解下<code>clarity</code>在数据存储、日志上报、性能优化方面做的事情，并试着理清clarity整个的架构。</p>","more":"<h1 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h1><p>对于前端监控，特别是需要录制回放功能的时候，数据就是生命。没有了监控数据，一切都免谈。</p>\n<p>但是，为了尽可能收集用户的行为特征，和方便之后的行为分析和日志定位，肯定需要监控许多数据，光我一下子想到的就有这些方面：DOM元素信息、鼠标交互信息、页面状态、用户停留时长等等。</p>\n<p>面对这么多的数据，首先想到的就是怎么去存储。我以为这么多数据，clarity肯定会用indexDB去存储在本地，但是通过源码发现，并没有。那么clarity是怎么做的呢？</p>\n<h2 id=\"队列缓存\"><a href=\"#队列缓存\" class=\"headerlink\" title=\"队列缓存\"></a>队列缓存</h2><p>clarity直接用js数组来缓存数据对象，每当有新的数据加入，通过<code>encode</code>函数统一分发处理，然后塞到数组队列里去：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">queue</span>(<span class=\"params\">tokens: Token[], transmit: <span class=\"built_in\">boolean</span> = <span class=\"literal\">true</span></span>): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (active) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> now = <span class=\"title function_\">time</span>();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">type</span> = tokens.<span class=\"property\">length</span> &gt; <span class=\"number\">1</span> ? tokens[<span class=\"number\">1</span>] : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> event = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(tokens);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">Event</span>.<span class=\"property\">Discover</span>:</span><br><span class=\"line\">        discoverBytes += event.<span class=\"property\">length</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">Event</span>.<span class=\"property\">Box</span>:</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"title class_\">Event</span>.<span class=\"property\">Mutation</span>:</span><br><span class=\"line\">        playbackBytes += event.<span class=\"property\">length</span>;</span><br><span class=\"line\">        playback.<span class=\"title function_\">push</span>(event);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"attr\">default</span>:</span><br><span class=\"line\">        analysis.<span class=\"title function_\">push</span>(event);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    metric.<span class=\"title function_\">count</span>(<span class=\"title class_\">Metric</span>.<span class=\"property\">EventCount</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> gap = <span class=\"title function_\">delay</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - queuedTime &gt; (gap * <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">      timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transmit &amp;&amp; timeout === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">type</span> !== <span class=\"title class_\">Event</span>.<span class=\"property\">Ping</span>) &#123; ping.<span class=\"title function_\">reset</span>(); &#125;</span><br><span class=\"line\">      timeout = <span class=\"built_in\">setTimeout</span>(upload, gap);</span><br><span class=\"line\">      queuedTime = now;</span><br><span class=\"line\">      limit.<span class=\"title function_\">check</span>(playbackBytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据这段代码，我们可以知道<code>queue</code>主要做了两件事：</p>\n<p>1、根据数据类型分类塞到不同的队列，供之后上传使用。</p>\n<p>2、部分数据利用<code>setTimeout</code>延时上报。</p>\n<p>注意的是，大部分数据在延时100～3000ms后都会立即上报，也是为了及时释放数据，不至于堆积得太多。除了某些场景，比如<code>metric</code>模块相关的性能指标，需要一直关注，会在最后结束的时候统一再上传。</p>\n<h2 id=\"数据检测\"><a href=\"#数据检测\" class=\"headerlink\" title=\"数据检测\"></a>数据检测</h2><p>这里还进行了数据的检测：<code>limit.check(playbackBytes)</code>。主要是进行三种检测：</p>\n<p>1、payload不能超过128个，也就是<code>envelope</code>对象的个数。</p>\n<p>2、页面实例开启不能超过2个小时，也就是说最多能监测在页面停留两个小时的数据。</p>\n<p>3、数据大小不能超过10MB。</p>\n<p>如果不满足其中任何一种限制，则立即停止clarity实例。</p>\n<p>经过这些限制，有效地保证了数据的大小，不至于内存过高，导致页面崩溃或者是上传过多不必要的数据。</p>\n<h1 id=\"日志上报\"><a href=\"#日志上报\" class=\"headerlink\" title=\"日志上报\"></a>日志上报</h1><h2 id=\"上报时机\"><a href=\"#上报时机\" class=\"headerlink\" title=\"上报时机\"></a>上报时机</h2><p>日志上报的时机有两个：</p>\n<p>1、在数据刚进入队列时，延时几百毫秒立即上报。</p>\n<p>2、在实例<code>stop</code>的时候上报，比如<code>pagehide</code>。</p>\n<h2 id=\"数据压缩\"><a href=\"#数据压缩\" class=\"headerlink\" title=\"数据压缩\"></a>数据压缩</h2><p>上报的操作其实就是把当前收集到的所有数据集中起来，打包成一个<code>payload</code>。由于数据会很大，需要对<code>payload</code>进行压缩操作：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span>(<span class=\"params\">input: <span class=\"built_in\">string</span></span>): <span class=\"title class_\">Promise</span>&lt;<span class=\"title class_\">Uint8Array</span>&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (supported) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> stream = <span class=\"keyword\">new</span> <span class=\"title class_\">ReadableStream</span>(&#123;<span class=\"keyword\">async</span> <span class=\"title function_\">start</span>(<span class=\"params\">controller</span>) &#123;</span><br><span class=\"line\">        controller.<span class=\"title function_\">enqueue</span>(input);</span><br><span class=\"line\">        controller.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">      &#125;&#125;).<span class=\"title function_\">pipeThrough</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">TextEncoderStream</span>()).<span class=\"title function_\">pipeThrough</span>(<span class=\"keyword\">new</span> <span class=\"variable language_\">window</span>[<span class=\"title class_\">Constant</span>.<span class=\"property\">CompressionStream</span>](<span class=\"string\">&quot;gzip&quot;</span>));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Uint8Array</span>(<span class=\"keyword\">await</span> <span class=\"title function_\">read</span>(stream));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> &#123; <span class=\"comment\">/* do nothing */</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码得知这里的压缩原理：创建<code>ReadableStream</code>管道，将数据字符串塞进去，通过<code>TextEncoderStream</code>和<code>CompressionStream</code>对其进行<code>gzip</code>压缩。</p>\n<h2 id=\"上报方式\"><a href=\"#上报方式\" class=\"headerlink\" title=\"上报方式\"></a>上报方式</h2><p>数据压缩完毕，下一步就是发起上报请求。常用的前端监控上报可以通过三种方式上报：</p>\n<p>1、<code>(new Image()).src = $&#123;uploadUrl&#125;</code>，这里一般适合数据小，并且需要跨域的请求。</p>\n<p>2、<code>ajax</code>请求，这个也是最常见的上报方式。</p>\n<p>3、<code>sendBeacon</code>，一般用在<code>unload</code>或者页面关闭的时候，用于发送统计数据。因为在页面关闭时，正常的<code>ajax</code>异步请求经常会出现丢失情况，而同步请求又会阻塞页面的关闭跳转，有了<code>sendBeacon</code>，会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。不过要要注意的是，这里使用的是<code>POST</code>请求，而且无法设置<code>HTTP headers</code>，所以不能用压缩的数据，只能用字符串。</p>\n<p>这里<code>clarity</code>使用了三种策略：</p>\n<p>1、正常上报使用<code>ajax</code>请求，并且优先上报压缩过的数据（考虑到CompressionStream的浏览器兼容性，如果不支持则用原始字符串数据）。</p>\n<p>2、如果是在页面关闭或者停止<code>clarity</code>实例时，优先用<code>sendBeacon</code>，如果不支持则用回<code>ajax</code>。</p>\n<p>3、支持配置<code>upload</code>参数，利用用户自定义的<code>upload</code>函数来上传。</p>\n<p>当然，这里的上报还做了保护机制，支持上报失败自动重试，并且在首次上报后还会更新<code>session</code>，保持会话状态。</p>\n<h1 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h1><p>对于一个前端监控SDK来说，性能非常重要。因为我们的目的是监控页面，但是不能影响到用户的正常操作，而是以一个观察者的角色在旁边看着。如果监控代码影响到页面性能，甚至引发页面卡顿、或者出bug，阻塞用户正常页面操作，那就得不偿失了。</p>\n<p>为了检测clarity的性能，我在我的博客加上了<code>claritySDK</code>，看看性能表现如何。</p>\n<p>通过几天的观察，目前性能还算良好，每次交互完都会立即上报。不过因为博客页面比较简单，没有什么复杂的交互，主要是点击和滚动页面，每次上报的数据一般都是几十B，内存损耗比较小。</p>\n<p>但同样的，通过Chrome本身的性能指标监控，发现每次交互完JS的堆内存都会暴涨一波，等上报完内存就会释放。虽然说内存及时释放了，但是如果是更复杂的页面，需要大量的交互操作，比如编辑器，那内存可能会居高不下，所以这方面的性能还有待提高。</p>\n<p>从SDK代码本身来说，没有什么高耗时的函数运算，其风险主要还是在内存爆栈上。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><code>clarity</code>总体上还是从以下几个方面去做监控：</p>\n<p>页面信息采集 -&gt; 事件监听 -&gt; 数据分类 -&gt; 批量上报。</p>\n<p>其中我认为做的比较好的部分是页面信息采集和数据分类，尽可能多的去收集页面信息，并且记录元素对象和id，同时采用了一些数据压缩方式，来保证数据的完整性和可用性。</p>\n<p>但同时，对于DOM结构复杂或者交互复杂的页面，<code>clarity</code>会占用大量的内存，由于是采用纯数组和对象存储，导致JS堆栈在某些时刻会飙升，非常有可能影响到页面性能，这方面的性能损耗还需进一步评测。</p>\n<p>总的来说，在数据采集端<code>clarity</code>对数据的收集还是比较完备，不足的是性能优化方面，但对于大部分普通HTML页面，没有多少交互来说也能够支持。而<code>clarity</code>的模块分类和数据收集方式也是值得我们好好学习的。</p>"},{"layout":"post","title":"我的博客终于搭好了！","date":"2017-04-02T16:17:51.000Z","_content":"\n**花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。\n希望能在记录自己的生活中成长吧！**\n\n今天很晚了。。。就先写到这吧～\n","source":"_posts/thoughts.md","raw":"layout: post\ntitle: 我的博客终于搭好了！\ndate: 2017-04-03 00:17:51\ntags: thoughts\ncategories: 随笔\n---\n\n**花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。\n希望能在记录自己的生活中成长吧！**\n\n今天很晚了。。。就先写到这吧～\n","slug":"thoughts","published":1,"updated":"2022-03-10T07:44:32.628Z","comments":1,"photos":[],"link":"","_id":"cl0kp05dl003ora4k16fr6xbi","content":"<p><strong>花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。<br>希望能在记录自己的生活中成长吧！</strong></p>\n<p>今天很晚了。。。就先写到这吧～</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。<br>希望能在记录自己的生活中成长吧！</strong></p>\n<p>今天很晚了。。。就先写到这吧～</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0kp05c20009ra4kg7mr9uca","category_id":"cl0kp05by0004ra4kf88u16vn","_id":"cl0kp05c6000gra4k3qcbbjz3"},{"post_id":"cl0kp05bs0001ra4k5hnja2li","category_id":"cl0kp05by0004ra4kf88u16vn","_id":"cl0kp05c9000kra4k3kogau10"},{"post_id":"cl0kp05bw0003ra4k9kluhwxm","category_id":"cl0kp05c3000bra4k4di03ky5","_id":"cl0kp05ca000nra4kbbt84uo4"},{"post_id":"cl0kp05c00007ra4k3df914cl","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05cd000tra4k0iox3r22"},{"post_id":"cl0kp05cb000qra4khw8n6hsc","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05ci000zra4k3qitaw9u"},{"post_id":"cl0kp05c3000ara4k4cgf54fc","category_id":"cl0kp05ca000ora4ke0edek3h","_id":"cl0kp05cj0012ra4kca8n1dnr"},{"post_id":"cl0kp05cc000sra4kfwqs9wpd","category_id":"cl0kp05c3000bra4k4di03ky5","_id":"cl0kp05ck0016ra4k4m9c247a"},{"post_id":"cl0kp05ce000wra4ka8m3c69p","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05cn0018ra4ke0d6eh6n"},{"post_id":"cl0kp05c5000era4keq5y4m62","category_id":"cl0kp05ca000ora4ke0edek3h","_id":"cl0kp05cp001cra4kb3x2000t"},{"post_id":"cl0kp05c6000fra4ke30p4m6t","category_id":"cl0kp05ci0010ra4kcod3ev1d","_id":"cl0kp05cq001gra4kdqx4661u"},{"post_id":"cl0kp05cl0017ra4kefykhb91","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05cs001jra4khyxvfaff"},{"post_id":"cl0kp05co001bra4k1hv605yz","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05ct001nra4ka0q993po"},{"post_id":"cl0kp05c7000jra4k2s924e91","category_id":"cl0kp05ci0010ra4kcod3ev1d","_id":"cl0kp05cv001qra4k3oy796hi"},{"post_id":"cl0kp05cp001era4k8sp2f050","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05cw001tra4ketvfbbgh"},{"post_id":"cl0kp05cr001ira4k4zzh6jcy","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05cx001xra4k0mn02aeh"},{"post_id":"cl0kp05c9000mra4k53vb9tm3","category_id":"cl0kp05ci0010ra4kcod3ev1d","_id":"cl0kp05cz0020ra4k5kf1d38c"},{"post_id":"cl0kp05cs001lra4khyml6unf","category_id":"cl0kp05ci0010ra4kcod3ev1d","_id":"cl0kp05d00024ra4k8j910zkj"},{"post_id":"cl0kp05cu001pra4k5etb55kv","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05d10027ra4k48xf4g03"},{"post_id":"cl0kp05ch000yra4k7b0q89fv","category_id":"cl0kp05ct001mra4kh20qfor7","_id":"cl0kp05d2002ara4k9wyw4v4k"},{"post_id":"cl0kp05cv001sra4k5efca4x5","category_id":"cl0kp05c3000bra4k4di03ky5","_id":"cl0kp05d4002era4k4og2asxo"},{"post_id":"cl0kp05cj0011ra4k38uva625","category_id":"cl0kp05cw001ura4kb14wftj7","_id":"cl0kp05d5002hra4kcf63a7d8"},{"post_id":"cl0kp05cy001zra4kaxhe9y3m","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05d6002kra4k4lgfa4zv"},{"post_id":"cl0kp05d00023ra4kejp2brfr","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05d7002mra4k40vu7o23"},{"post_id":"cl0kp05ck0015ra4k399t7n3n","category_id":"cl0kp05cw001ura4kb14wftj7","_id":"cl0kp05d8002pra4k7zuxg0vv"},{"post_id":"cl0kp05d10026ra4k102kedza","category_id":"cl0kp05by0004ra4kf88u16vn","_id":"cl0kp05d9002sra4k8fkiejmt"},{"post_id":"cl0kp05d20029ra4kdzs079j1","category_id":"cl0kp05cw001ura4kb14wftj7","_id":"cl0kp05da002wra4kduolct9v"},{"post_id":"cl0kp05cx001wra4kb75452z6","category_id":"cl0kp05d10028ra4k1kh33s3b","_id":"cl0kp05db002zra4k550qg7d7"},{"post_id":"cl0kp05d3002dra4kc92w0qyf","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05dc0031ra4kczek4xwe"},{"post_id":"cl0kp05d4002gra4k0z4k6yom","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05de0035ra4kfrrn5d42"},{"post_id":"cl0kp05d5002jra4kbdcd4r4q","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05df0038ra4kdjcghy6t"},{"post_id":"cl0kp05d6002lra4k1pi19hte","category_id":"cl0kp05ct001mra4kh20qfor7","_id":"cl0kp05dh003cra4k9tidah19"},{"post_id":"cl0kp05d8002ora4khr954jkp","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05di003fra4kh6bh3ey5"},{"post_id":"cl0kp05d9002rra4kddhy0qxj","category_id":"cl0kp05cw001ura4kb14wftj7","_id":"cl0kp05dj003jra4kcz261iwz"},{"post_id":"cl0kp05da002vra4ke27y8a5i","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05dk003mra4k528714a6"},{"post_id":"cl0kp05db002yra4k9bgrbaoc","category_id":"cl0kp05cw001ura4kb14wftj7","_id":"cl0kp05dm003pra4k8rlv55gh"},{"post_id":"cl0kp05dc0030ra4ke3x82d7w","category_id":"cl0kp05by0004ra4kf88u16vn","_id":"cl0kp05dm003qra4k90il876h"},{"post_id":"cl0kp05dd0034ra4kc8kxcw71","category_id":"cl0kp05ct001mra4kh20qfor7","_id":"cl0kp05dn003sra4kgmjfhh7w"},{"post_id":"cl0kp05de0037ra4k8jxi071n","category_id":"cl0kp05ci0010ra4kcod3ev1d","_id":"cl0kp05dn003tra4kd8fo53ck"},{"post_id":"cl0kp05dg003bra4kcfeb623c","category_id":"cl0kp05ci0010ra4kcod3ev1d","_id":"cl0kp05dn003vra4k40n6gmtv"},{"post_id":"cl0kp05di003era4k2v7ybpxg","category_id":"cl0kp05d10028ra4k1kh33s3b","_id":"cl0kp05do003xra4k46dya7da"},{"post_id":"cl0kp05dj003ira4ka07r1bqj","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05do003zra4kaocqeahn"},{"post_id":"cl0kp05dk003lra4kejh08owz","category_id":"cl0kp05c7000hra4k4qls3fc0","_id":"cl0kp05do0042ra4kcwew3tlh"},{"post_id":"cl0kp05dl003ora4k16fr6xbi","category_id":"cl0kp05ct001mra4kh20qfor7","_id":"cl0kp05do0044ra4k6zrf7sod"}],"PostTag":[{"post_id":"cl0kp05bs0001ra4k5hnja2li","tag_id":"cl0kp05bz0005ra4k5s5ma0nm","_id":"cl0kp05c4000dra4k5767ew06"},{"post_id":"cl0kp05bw0003ra4k9kluhwxm","tag_id":"cl0kp05c4000cra4kbabwbv81","_id":"cl0kp05c9000lra4k5vg79d6y"},{"post_id":"cl0kp05c00007ra4k3df914cl","tag_id":"cl0kp05c7000ira4kc4d21it0","_id":"cl0kp05cc000rra4k00pqgts9"},{"post_id":"cl0kp05c20009ra4kg7mr9uca","tag_id":"cl0kp05ca000pra4k1d91dkp7","_id":"cl0kp05ch000xra4kdoot66yl"},{"post_id":"cl0kp05c3000ara4k4cgf54fc","tag_id":"cl0kp05ce000vra4k1rzj4sc8","_id":"cl0kp05ck0014ra4k5yqh4gk0"},{"post_id":"cl0kp05c5000era4keq5y4m62","tag_id":"cl0kp05cj0013ra4k1c107djy","_id":"cl0kp05cp001dra4kefw0gakk"},{"post_id":"cl0kp05c6000fra4ke30p4m6t","tag_id":"cl0kp05co001ara4kg78xb4ra","_id":"cl0kp05cs001kra4kh2223myf"},{"post_id":"cl0kp05c7000jra4k2s924e91","tag_id":"cl0kp05co001ara4kg78xb4ra","_id":"cl0kp05cv001rra4k5iyj0yua"},{"post_id":"cl0kp05c9000mra4k53vb9tm3","tag_id":"cl0kp05co001ara4kg78xb4ra","_id":"cl0kp05cy001yra4k47rfhd6o"},{"post_id":"cl0kp05cb000qra4khw8n6hsc","tag_id":"cl0kp05cw001vra4kf5da1poz","_id":"cl0kp05d00025ra4kcwhu1us2"},{"post_id":"cl0kp05cc000sra4kfwqs9wpd","tag_id":"cl0kp05c4000cra4kbabwbv81","_id":"cl0kp05d3002cra4kh05kesqj"},{"post_id":"cl0kp05cc000sra4kfwqs9wpd","tag_id":"cl0kp05cz0022ra4k4vu26yhq","_id":"cl0kp05d4002fra4kej025lbv"},{"post_id":"cl0kp05ce000wra4ka8m3c69p","tag_id":"cl0kp05d3002bra4k7rkq4x0t","_id":"cl0kp05d8002qra4khihp6fmo"},{"post_id":"cl0kp05ce000wra4ka8m3c69p","tag_id":"cl0kp05d5002ira4k7ocuhlze","_id":"cl0kp05d9002tra4kap0c8lse"},{"post_id":"cl0kp05ch000yra4k7b0q89fv","tag_id":"cl0kp05d7002nra4k6ni9ho9w","_id":"cl0kp05db002xra4k4q0ue9lw"},{"post_id":"cl0kp05db002yra4k9bgrbaoc","tag_id":"cl0kp05d9002ura4k01431ug2","_id":"cl0kp05dd0033ra4keoiu56sw"},{"post_id":"cl0kp05cj0011ra4k38uva625","tag_id":"cl0kp05d9002ura4k01431ug2","_id":"cl0kp05de0036ra4k70ui0qrf"},{"post_id":"cl0kp05dc0030ra4ke3x82d7w","tag_id":"cl0kp05ca000pra4k1d91dkp7","_id":"cl0kp05dg003ara4k5cbghria"},{"post_id":"cl0kp05dd0034ra4kc8kxcw71","tag_id":"cl0kp05d7002nra4k6ni9ho9w","_id":"cl0kp05dh003dra4kewb396bk"},{"post_id":"cl0kp05ck0015ra4k399t7n3n","tag_id":"cl0kp05d9002ura4k01431ug2","_id":"cl0kp05dj003hra4kfzhyf9m9"},{"post_id":"cl0kp05cl0017ra4kefykhb91","tag_id":"cl0kp05cw001vra4kf5da1poz","_id":"cl0kp05dk003kra4ke3ci32bc"},{"post_id":"cl0kp05co001bra4k1hv605yz","tag_id":"cl0kp05di003gra4kd99s3kuv","_id":"cl0kp05do003wra4kgrcm4yuf"},{"post_id":"cl0kp05co001bra4k1hv605yz","tag_id":"cl0kp05dl003nra4k45nbcgn6","_id":"cl0kp05do003yra4khlrtgx2n"},{"post_id":"cl0kp05co001bra4k1hv605yz","tag_id":"cl0kp05dn003rra4ka3ujgc65","_id":"cl0kp05do0041ra4kenk370sc"},{"post_id":"cl0kp05cp001era4k8sp2f050","tag_id":"cl0kp05dn003ura4kfvgxf487","_id":"cl0kp05do0043ra4k3wqjbrdz"},{"post_id":"cl0kp05cr001ira4k4zzh6jcy","tag_id":"cl0kp05do0040ra4k4c2p3tf7","_id":"cl0kp05dp0046ra4k26dcgja3"},{"post_id":"cl0kp05cs001lra4khyml6unf","tag_id":"cl0kp05d7002nra4k6ni9ho9w","_id":"cl0kp05dp0048ra4khuyq23ky"},{"post_id":"cl0kp05cu001pra4k5etb55kv","tag_id":"cl0kp05dp0047ra4k01ko39xo","_id":"cl0kp05dq004ara4kd4h680ca"},{"post_id":"cl0kp05cv001sra4k5efca4x5","tag_id":"cl0kp05dq0049ra4kg2u74lxf","_id":"cl0kp05dq004cra4kchu7fuq5"},{"post_id":"cl0kp05cx001wra4kb75452z6","tag_id":"cl0kp05dq004bra4k9p3a0546","_id":"cl0kp05dr004era4kc3jg457r"},{"post_id":"cl0kp05cy001zra4kaxhe9y3m","tag_id":"cl0kp05do0040ra4k4c2p3tf7","_id":"cl0kp05dr004gra4k53op4nnm"},{"post_id":"cl0kp05d00023ra4kejp2brfr","tag_id":"cl0kp05do0040ra4k4c2p3tf7","_id":"cl0kp05ds004ira4k4dld9wt5"},{"post_id":"cl0kp05d10026ra4k102kedza","tag_id":"cl0kp05dr004hra4kd30i2cjw","_id":"cl0kp05ds004kra4k2s9k7if9"},{"post_id":"cl0kp05d20029ra4kdzs079j1","tag_id":"cl0kp05d9002ura4k01431ug2","_id":"cl0kp05dt004mra4k7htx01mt"},{"post_id":"cl0kp05d3002dra4kc92w0qyf","tag_id":"cl0kp05do0040ra4k4c2p3tf7","_id":"cl0kp05du004ora4k3hqf4aqp"},{"post_id":"cl0kp05d4002gra4k0z4k6yom","tag_id":"cl0kp05dt004nra4kezy3gtmc","_id":"cl0kp05dv004rra4k9x91hsqi"},{"post_id":"cl0kp05d4002gra4k0z4k6yom","tag_id":"cl0kp05du004pra4kb8agfc4v","_id":"cl0kp05dv004sra4kgsjp0m4o"},{"post_id":"cl0kp05d5002jra4kbdcd4r4q","tag_id":"cl0kp05dt004nra4kezy3gtmc","_id":"cl0kp05dw004vra4k05xkh2kb"},{"post_id":"cl0kp05d5002jra4kbdcd4r4q","tag_id":"cl0kp05du004pra4kb8agfc4v","_id":"cl0kp05dw004wra4kevpubxxc"},{"post_id":"cl0kp05d6002lra4k1pi19hte","tag_id":"cl0kp05d7002nra4k6ni9ho9w","_id":"cl0kp05dx004yra4k1wxhemon"},{"post_id":"cl0kp05d8002ora4khr954jkp","tag_id":"cl0kp05do0040ra4k4c2p3tf7","_id":"cl0kp05dx0050ra4kgvsfdq2u"},{"post_id":"cl0kp05d9002rra4kddhy0qxj","tag_id":"cl0kp05d9002ura4k01431ug2","_id":"cl0kp05dy0052ra4k74wl10on"},{"post_id":"cl0kp05da002vra4ke27y8a5i","tag_id":"cl0kp05dy0051ra4k9w3afbcv","_id":"cl0kp05dy0054ra4kh6t27qiq"},{"post_id":"cl0kp05de0037ra4k8jxi071n","tag_id":"cl0kp05dy0053ra4kg2zfatcm","_id":"cl0kp05dz0056ra4k2dth0d2t"},{"post_id":"cl0kp05dg003bra4kcfeb623c","tag_id":"cl0kp05dy0053ra4kg2zfatcm","_id":"cl0kp05dz0058ra4kehl2ho74"},{"post_id":"cl0kp05di003era4k2v7ybpxg","tag_id":"cl0kp05dz0057ra4kg6op15s7","_id":"cl0kp05e0005ara4k7nhk26nq"},{"post_id":"cl0kp05dj003ira4ka07r1bqj","tag_id":"cl0kp05e00059ra4khw8aa8qn","_id":"cl0kp05e1005era4kbh832bbs"},{"post_id":"cl0kp05dj003ira4ka07r1bqj","tag_id":"cl0kp05e0005bra4kbo8hbj07","_id":"cl0kp05e1005fra4k9xw57o38"},{"post_id":"cl0kp05dj003ira4ka07r1bqj","tag_id":"cl0kp05e0005cra4k8ptaf9bn","_id":"cl0kp05e2005hra4kgf2tclb8"},{"post_id":"cl0kp05dk003lra4kejh08owz","tag_id":"cl0kp05e00059ra4khw8aa8qn","_id":"cl0kp05e3005kra4k6jqae9dx"},{"post_id":"cl0kp05dk003lra4kejh08owz","tag_id":"cl0kp05e0005bra4kbo8hbj07","_id":"cl0kp05e3005lra4k76yh6o3h"},{"post_id":"cl0kp05dk003lra4kejh08owz","tag_id":"cl0kp05e0005cra4k8ptaf9bn","_id":"cl0kp05e3005mra4k64v9ajzz"},{"post_id":"cl0kp05dl003ora4k16fr6xbi","tag_id":"cl0kp05e2005jra4k6nlhal6s","_id":"cl0kp05e3005nra4k5x5bdbat"}],"Tag":[{"name":"二叉树","_id":"cl0kp05bz0005ra4k5s5ma0nm"},{"name":"http","_id":"cl0kp05c4000cra4kbabwbv81"},{"name":"闭包","_id":"cl0kp05c7000ira4kc4d21it0"},{"name":"leetcode","_id":"cl0kp05ca000pra4k1d91dkp7"},{"name":"跨域","_id":"cl0kp05ce000vra4k1rzj4sc8"},{"name":"性能优化","_id":"cl0kp05cj0013ra4k1c107djy"},{"name":"实习面试","_id":"cl0kp05co001ara4kg78xb4ra"},{"name":"JS原理","_id":"cl0kp05cw001vra4kf5da1poz"},{"name":"状态码","_id":"cl0kp05cz0022ra4k4vu26yhq"},{"name":"throttle","_id":"cl0kp05d3002bra4k7rkq4x0t"},{"name":"debounce","_id":"cl0kp05d5002ira4k7ocuhlze"},{"name":"思考感悟","_id":"cl0kp05d7002nra4k6ni9ho9w"},{"name":"CSS技巧","_id":"cl0kp05d9002ura4k01431ug2"},{"name":"React","_id":"cl0kp05di003gra4kd99s3kuv"},{"name":"前端框架","_id":"cl0kp05dl003nra4k45nbcgn6"},{"name":"state","_id":"cl0kp05dn003rra4ka3ujgc65"},{"name":"对象","_id":"cl0kp05dn003ura4kfvgxf487"},{"name":"JS技巧","_id":"cl0kp05do0040ra4k4c2p3tf7"},{"name":"类","_id":"cl0kp05dp0047ra4k01ko39xo"},{"name":"Cookies","_id":"cl0kp05dq0049ra4kg2u74lxf"},{"name":"VSCode","_id":"cl0kp05dq004bra4k9p3a0546"},{"name":"排序","_id":"cl0kp05dr004hra4kd30i2cjw"},{"name":"编辑器","_id":"cl0kp05dt004nra4kezy3gtmc"},{"name":"markdown","_id":"cl0kp05du004pra4kb8agfc4v"},{"name":"nodejs","_id":"cl0kp05dy0051ra4k9w3afbcv"},{"name":"职业规划","_id":"cl0kp05dy0053ra4kg2zfatcm"},{"name":"git","_id":"cl0kp05dz0057ra4kg6op15s7"},{"name":"源码分析","_id":"cl0kp05e00059ra4khw8aa8qn"},{"name":"前端监控","_id":"cl0kp05e0005bra4kbo8hbj07"},{"name":"录制回放","_id":"cl0kp05e0005cra4k8ptaf9bn"},{"name":"thoughts","_id":"cl0kp05e2005jra4k6nlhal6s"}]}}