{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/images/WechatQR.png","path":"images/WechatQR.png","modified":1,"renderable":0},{"_id":"source/images/ip-group.jpg","path":"images/ip-group.jpg","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/copycode.css","path":"css/copycode.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/copyright.css","path":"css/copyright.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/search.css","path":"css/search.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/copycode.js","path":"js/copycode.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/copyright.js","path":"js/copyright.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/love.js","path":"js/love.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/favicon.ico","hash":"f92d0773e9634ed052f9934e48aed4a362bdc746","modified":1645680256406},{"_id":"source/_posts/2017-04-03-achieve-binary-search-tree.md","hash":"8f15fd389f7018e548270a13c4f5414aa884d908","modified":1645668867662},{"_id":"source/_posts/2017-04-04-http-learning-1.md","hash":"4a8b1022f07b3688814765a6dfc72aee20f44755","modified":1645668867622},{"_id":"source/_posts/2017-04-06-Closures-learning.md","hash":"7c74acc520bcb972fe38ecdae5f858268dc966f8","modified":1645668864612},{"_id":"source/_posts/2017-04-09-leetcode-week1.md","hash":"abe0442c3174d3e028cd0f9d226747f4592bb6e9","modified":1645668864574},{"_id":"source/_posts/2017-04-10-cross-origin.md","hash":"ba43847cb8bc851c95aa787c1b87c180b198d1ed","modified":1645668864609},{"_id":"source/_posts/2017-04-12-webpage-optimize.md","hash":"f6c980da22d27fd8058420c19de28a55a19c6dbc","modified":1645668864574},{"_id":"source/_posts/2017-04-13-Tecent-Interview-one.md","hash":"c9ee5799adc220bde3242429e77399c07a5bb54c","modified":1645668862020},{"_id":"source/_posts/2017-04-16-Internship-interviews.md","hash":"c8f54c6ec82688ba66277e9f62e4a205df75887b","modified":1645670800935},{"_id":"source/_posts/2017-04-16-Tecent-Interview-Second.md","hash":"5ae834d4286725b87fa3257aa9c2a24fe35adf5a","modified":1645668861926},{"_id":"source/_posts/2017-04-19-GetToKnow-this-call-apply.md","hash":"268aad28643a9780eff6ea930470e8df40ea0d4f","modified":1645668861895},{"_id":"source/_posts/2017-04-23-http-status-codes-marks.md","hash":"22f1269231ba29e02634d7c6cd630742739271e0","modified":1645668858244},{"_id":"source/_posts/2017-05-01-throttle-debounce.md","hash":"1851fb4aa4e652412a83cef97d7e487911d7358a","modified":1645668858211},{"_id":"source/_posts/2017-05-10-Summary.md","hash":"0f0247a5e4b7443d01c9c0f13b7e38ad50e3f62e","modified":1645668858197},{"_id":"source/_posts/2017-07-24-csssecrets-border.md","hash":"759f97f1cdc78e71ceafddb0ea4c61bbb15750ee","modified":1645681393759},{"_id":"source/_posts/2017-08-02-js-value-coercions.md","hash":"035f37e690ad5b83fc306238fbf6b55707561e08","modified":1645684063083},{"_id":"source/_posts/2017-08-04-react-setState-update.md","hash":"1eddebc296460f88971e79934d1c99e526c1d8f5","modified":1645682000293},{"_id":"source/_posts/2019-08-18-how-can-i-be-a-programmer-1.md","hash":"f361cdedd4672a0c842f3d3416152da86d89ed9d","modified":1645684328608},{"_id":"source/_posts/2019-08-25-how-can-i-be-a-programmer-2.md","hash":"a4c962b7d6a8794de4666f3a77ef5c91d0d4b13c","modified":1645684463024},{"_id":"source/_posts/thoughts.md","hash":"ec72748f6b7faca5219a18729d7d833d2ca04ed1","modified":1645668858166},{"_id":"source/categories/index.md","hash":"980902f8d2ca46760a46087064985ffe123c6086","modified":1645668869774},{"_id":"source/guestbook/index.md","hash":"df0bfeca43614c65ea414cd4e3290e2210aafc1c","modified":1645668869716},{"_id":"source/images/ip-group.jpg","hash":"6d6fbafa1d5ed8893df83b63248a44a5529152dc","modified":1645668867795},{"_id":"source/tags/index.md","hash":"b29c3d07ad96641c1955407b6e139170970ce3db","modified":1645668858688},{"_id":"source/images/WechatQR.png","hash":"c3c9f25958413a4652e98d98413deb1b0382865c","modified":1645681603592},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1645607203000},{"_id":"themes/maupassant/README.md","hash":"8cc8e522e7b0b9bf41bfe54f447213737134370b","modified":1645607203000},{"_id":"themes/maupassant/_config.yml","hash":"ffe0ce6f2e7677877840020d6ae542e4f07c10f8","modified":1645685241681},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1645607203000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1645607203000},{"_id":"themes/maupassant/languages/en.yml","hash":"9c979a2f107536399bbe2be572c2d0bebcdd9d95","modified":1645607203000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1645607203000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1645607203000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1645607203000},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1645607203000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"78cc1794a3ce3e186c462c1a70f097d0c05cd210","modified":1645607203000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"e9747f9b3ec1314a3cae44a9a90e7649af739633","modified":1645607203000},{"_id":"themes/maupassant/layout/archive.pug","hash":"749028e57a2eaad8c92ce2a2426c98605ab746a7","modified":1645607203000},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"80995eadfd89ee9aa36f4672f8d405e03f13af15","modified":1645607203000},{"_id":"themes/maupassant/layout/base.pug","hash":"bf8c6eda72f9190dd2d46065924840958c57619e","modified":1645607203000},{"_id":"themes/maupassant/.DS_Store","hash":"6cf34b6a6bd7ffbfcb45e3e08e161f9a0ae5b83f","modified":1645678256086},{"_id":"themes/maupassant/layout/index.pug","hash":"162fe3fa695e8bea5a77916aefbb7ce98cd227bf","modified":1645607203000},{"_id":"themes/maupassant/layout/page.pug","hash":"a285a76950bb1b91f482ef9c473472bd0ede601d","modified":1645607203000},{"_id":"themes/maupassant/layout/post.pug","hash":"9fbbc4ca1394f99dccdd972c3db9105d3cf5066e","modified":1645607203000},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1645607203000},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"4aa57b41e919a12b6d7691cd4a36d3a531b55fcb","modified":1645607203000},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"aefb67bac8fcef9cb3027f8622923b392f79f51e","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"b49f4e2cd9f77456230a5508d0bbe9a362668712","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/darkmode.pug","hash":"82567449d68025cc7fee5259d4769f5ee015aa26","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"4ad77026d3f2b6845b955dd7ce0d33b4e3479b1a","modified":1645685090448},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"53d721ea4c93564cb0bdde065572ff6128574d36","modified":1645607203000},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"b3c846a2e0ac79933e32c343029b769f2865a27f","modified":1645607203000},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1645679733488},{"_id":"themes/maupassant/layout/_widget/copyright.pug","hash":"32701dcba9c52d4bc73badaf8afe91af3f87b6a0","modified":1645607203000},{"_id":"themes/maupassant/layout/_widget/donate.pug","hash":"50855ce17af4298ce0f15236e2308c4a1760e7e3","modified":1645607203000},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1645607203000},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"1ef7a333ab9bfa169276d0ad48aecf5166ab63cb","modified":1645607203000},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1645607203000},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1645607203000},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1645607203000},{"_id":"themes/maupassant/source/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1645607203000},{"_id":"themes/maupassant/source/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1645607203000},{"_id":"themes/maupassant/source/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1645607203000},{"_id":"themes/maupassant/source/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1645607203000},{"_id":"themes/maupassant/source/css/style.scss","hash":"e6d1b74b620b27b480f76a4998a6cb279dc01772","modified":1645607203000},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1645607203000},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1645607203000},{"_id":"themes/maupassant/source/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1645607203000},{"_id":"themes/maupassant/source/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1645607203000},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1645607203000},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1645607203000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1645607203000},{"_id":"themes/maupassant/source/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1645607203000},{"_id":"themes/maupassant/source/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1645607203000},{"_id":"themes/maupassant/source/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1645607203000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1645607203000},{"_id":"themes/maupassant/source/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1645607203000},{"_id":"themes/maupassant/source/js/search.js","hash":"6fdfd143646d12b8dbef9b5809cea768192f08aa","modified":1645607203000},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1645607203000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1645607203000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1645607203000}],"Category":[{"name":"算法","_id":"cl00miz3200040hp38eyc8u14"},{"name":"网络","_id":"cl00miz39000a0hp3e3q718zs"},{"name":"JS基础","_id":"cl00miz3g000f0hp3f8tvc1hf"},{"name":"Web相关","_id":"cl00miz3t000t0hp3gw84fkgr"},{"name":"面经","_id":"cl00miz3x00100hp355m22lz8"},{"name":"随笔","_id":"cl00miz4f001j0hp37i982tup"},{"name":"CSS","_id":"cl00miz4h001o0hp3g9un7iqz"},{"name":"JavaScript","_id":"cl00miz4j001r0hp30h289fyp"},{"name":"前端框架","_id":"cl00miz4k001u0hp34wag9g66"},{"name":"经验分享","_id":"cl00miz4l001y0hp319w1bskb"}],"Data":[],"Page":[{"title":"categories","date":"2017-04-06T15:24:58.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-04-06 23:24:58\ntype: categories\ncomments: false\n---\n","updated":"2022-02-24T02:14:29.774Z","path":"categories/index.html","layout":"page","_id":"cl00miz2q00000hp362g53aw4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"guestbook","date":"2017-04-03T05:46:52.000Z","_content":"","source":"guestbook/index.md","raw":"---\ntitle: guestbook\ndate: 2017-04-03 13:46:52\n---\n","updated":"2022-02-24T02:14:29.716Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"cl00miz2x00020hp3496ydp1c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-04-06T15:32:50.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-04-06 23:32:50\ntype: tags\ncomments: false\n---\n","updated":"2022-02-24T02:14:18.688Z","path":"tags/index.html","layout":"page","_id":"cl00miz3400060hp32vb6b6ll","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"二叉搜索树JavaScript实现","date":"2017-04-03T06:24:32.000Z","_content":"\n### 什么是二叉搜索树\n其形式就是二叉树，对于每个节点x，其左子树的值<=x.value，右子树的值>=x.value。\n<!--more-->\n### 二叉搜索树的遍历与查询\n\n对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。\n```\nfunction inorderTreeWalk(x) {\n  if(x!== null) {\n    inorderTreeWalk(x.left);\n    print(x.key);\n    inorderTreeWalk(x.right);\n  }  \n}\n```\n\n当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：\n```\nfunction treeSearch(x,k) {  //最开始x代表根节点\n  if(x === null || x.key === k) {\n    return x;\n  }\n  if(k < x.key) {\n    return treeSearch(x.left, k);\n  } else {\n    return treeSearch(x.right, k);\n  }\n}\n```\n我们还可以写出循环版本（一般比递归更高效）:\n```\nfunction treeSearch(x, k) {\n  while(x !== null || k !== x.key) {\n    if(k < x.key) {\n      x = x.left;\n    } else {\n      x = x.right;\n    }\n  }\n  return x;\n}\n```\n我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：\n```\nfunction treeMinimum(x) {\n  while(x.left !== null) {\n    x = x.left;\n  }\n  return x;\n}\n\nfunction treeMaximum(x) {\n  while(x.right !== null) {\n    x = x.right;\n  }\n  return x;\n}\n```\n有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：\n```\nfunction treeSuccessor(x) {  //后继查找\n  if(x.right !== null) {\n    return treeMinimum(x.right);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.right) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n\nfunction treeSuccessor(x) {  //前驱查找\n  if(x.left !== null) {\n    return treeMaximum(x.left);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.left) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n```\n### 二叉搜索树实现插入和删除操作。\n　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。\n　　```\n        function treeInsert(tree, newNode) {\n          let y = null;\n          while(tree !== null) {\n            y = tree;\n            if(newNode.key < tree.key) {\n              tree = tree.left;\n            } else {\n              tree = tree.right;\n            }\n          }\n          newNode.parent = y;\n          if(y === null) {  // 树为空\n            tree.root = newNode;\n          } else {\n            if(newNode.key < y.key) {\n              y.left = newNode;\n            } else {\n              y.right = newNode;\n            }\n          }\n        }\n        ```\n　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。\n　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。\n　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。\n　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。\n        ```\n        function transplant(tree, u, v) {  //子树替换父节点方法\n          if(u.p === null) {\n            tree.root = v;\n          } else if(u === u.parent.left) {\n            u.parent.left = v;\n          } else {\n            u.parent.right = v;\n          }\n          if(v !== null) {\n            v.parent = u.parent;\n          }\n        }\n\n        function treeDelete(tree, z) {\n          if(z.left === null) {\n            transplant(tree, z, z.right);\n          } else if(z.right === null) {\n            transplant(tree, z, z.left);\n          } else {\n            let y = treeMinimum(z.right);\n            if(y.parent !== z) {\n              transplant(tree, y, y.right);\n              y.right = z.right;\n              y.right.parent = y;\n            }\n            transplant(tree, z, y);\n            y.left = z.left;\n            y.left.parent = y;\n          }\n        }\n        ```\n**至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》**\n","source":"_posts/2017-04-03-achieve-binary-search-tree.md","raw":"---\ntitle: 二叉搜索树JavaScript实现\ndate: 2017-04-03 14:24:32\ntags: \n- Tree\n- JavaScript\ncategories: 算法\n---\n\n### 什么是二叉搜索树\n其形式就是二叉树，对于每个节点x，其左子树的值<=x.value，右子树的值>=x.value。\n<!--more-->\n### 二叉搜索树的遍历与查询\n\n对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。\n```\nfunction inorderTreeWalk(x) {\n  if(x!== null) {\n    inorderTreeWalk(x.left);\n    print(x.key);\n    inorderTreeWalk(x.right);\n  }  \n}\n```\n\n当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：\n```\nfunction treeSearch(x,k) {  //最开始x代表根节点\n  if(x === null || x.key === k) {\n    return x;\n  }\n  if(k < x.key) {\n    return treeSearch(x.left, k);\n  } else {\n    return treeSearch(x.right, k);\n  }\n}\n```\n我们还可以写出循环版本（一般比递归更高效）:\n```\nfunction treeSearch(x, k) {\n  while(x !== null || k !== x.key) {\n    if(k < x.key) {\n      x = x.left;\n    } else {\n      x = x.right;\n    }\n  }\n  return x;\n}\n```\n我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：\n```\nfunction treeMinimum(x) {\n  while(x.left !== null) {\n    x = x.left;\n  }\n  return x;\n}\n\nfunction treeMaximum(x) {\n  while(x.right !== null) {\n    x = x.right;\n  }\n  return x;\n}\n```\n有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：\n```\nfunction treeSuccessor(x) {  //后继查找\n  if(x.right !== null) {\n    return treeMinimum(x.right);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.right) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n\nfunction treeSuccessor(x) {  //前驱查找\n  if(x.left !== null) {\n    return treeMaximum(x.left);\n  } else {\n    let y = x.parent;\n    while(y !== null && x === y.left) {\n      x = y;\n      y = y.parent;\n    }\n    return y;\n  }\n}\n```\n### 二叉搜索树实现插入和删除操作。\n　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。\n　　```\n        function treeInsert(tree, newNode) {\n          let y = null;\n          while(tree !== null) {\n            y = tree;\n            if(newNode.key < tree.key) {\n              tree = tree.left;\n            } else {\n              tree = tree.right;\n            }\n          }\n          newNode.parent = y;\n          if(y === null) {  // 树为空\n            tree.root = newNode;\n          } else {\n            if(newNode.key < y.key) {\n              y.left = newNode;\n            } else {\n              y.right = newNode;\n            }\n          }\n        }\n        ```\n　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。\n　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。\n　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。\n　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。\n        ```\n        function transplant(tree, u, v) {  //子树替换父节点方法\n          if(u.p === null) {\n            tree.root = v;\n          } else if(u === u.parent.left) {\n            u.parent.left = v;\n          } else {\n            u.parent.right = v;\n          }\n          if(v !== null) {\n            v.parent = u.parent;\n          }\n        }\n\n        function treeDelete(tree, z) {\n          if(z.left === null) {\n            transplant(tree, z, z.right);\n          } else if(z.right === null) {\n            transplant(tree, z, z.left);\n          } else {\n            let y = treeMinimum(z.right);\n            if(y.parent !== z) {\n              transplant(tree, y, y.right);\n              y.right = z.right;\n              y.right.parent = y;\n            }\n            transplant(tree, z, y);\n            y.left = z.left;\n            y.left.parent = y;\n          }\n        }\n        ```\n**至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》**\n","slug":"achieve-binary-search-tree","published":1,"updated":"2022-02-24T02:14:27.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz2t00010hp3gbzt0lzu","content":"<h3 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h3><p>其形式就是二叉树，对于每个节点x，其左子树的值&lt;&#x3D;x.value，右子树的值&gt;&#x3D;x.value。</p>\n<span id=\"more\"></span>\n<h3 id=\"二叉搜索树的遍历与查询\"><a href=\"#二叉搜索树的遍历与查询\" class=\"headerlink\" title=\"二叉搜索树的遍历与查询\"></a>二叉搜索树的遍历与查询</h3><p>对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inorderTreeWalk(x) &#123;</span><br><span class=\"line\">  if(x!== null) &#123;</span><br><span class=\"line\">    inorderTreeWalk(x.left);</span><br><span class=\"line\">    print(x.key);</span><br><span class=\"line\">    inorderTreeWalk(x.right);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x,k) &#123;  //最开始x代表根节点</span><br><span class=\"line\">  if(x === null || x.key === k) &#123;</span><br><span class=\"line\">    return x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(k &lt; x.key) &#123;</span><br><span class=\"line\">    return treeSearch(x.left, k);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return treeSearch(x.right, k);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以写出循环版本（一般比递归更高效）:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x, k) &#123;</span><br><span class=\"line\">  while(x !== null || k !== x.key) &#123;</span><br><span class=\"line\">    if(k &lt; x.key) &#123;</span><br><span class=\"line\">      x = x.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      x = x.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeMinimum(x) &#123;</span><br><span class=\"line\">  while(x.left !== null) &#123;</span><br><span class=\"line\">    x = x.left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeMaximum(x) &#123;</span><br><span class=\"line\">  while(x.right !== null) &#123;</span><br><span class=\"line\">    x = x.right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSuccessor(x) &#123;  //后继查找</span><br><span class=\"line\">  if(x.right !== null) &#123;</span><br><span class=\"line\">    return treeMinimum(x.right);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.right) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeSuccessor(x) &#123;  //前驱查找</span><br><span class=\"line\">  if(x.left !== null) &#123;</span><br><span class=\"line\">    return treeMaximum(x.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.left) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉搜索树实现插入和删除操作。\"><a href=\"#二叉搜索树实现插入和删除操作。\" class=\"headerlink\" title=\"二叉搜索树实现插入和删除操作。\"></a>二叉搜索树实现插入和删除操作。</h3><p>　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。<br>　　<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeInsert(tree, newNode) &#123;</span><br><span class=\"line\">  let y = null;</span><br><span class=\"line\">  while(tree !== null) &#123;</span><br><span class=\"line\">    y = tree;</span><br><span class=\"line\">    if(newNode.key &lt; tree.key) &#123;</span><br><span class=\"line\">      tree = tree.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      tree = tree.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  newNode.parent = y;</span><br><span class=\"line\">  if(y === null) &#123;  // 树为空</span><br><span class=\"line\">    tree.root = newNode;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    if(newNode.key &lt; y.key) &#123;</span><br><span class=\"line\">      y.left = newNode;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      y.right = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。<br>　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。<br>　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。<br>　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。<br>        <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transplant(tree, u, v) &#123;  //子树替换父节点方法</span><br><span class=\"line\">  if(u.p === null) &#123;</span><br><span class=\"line\">    tree.root = v;</span><br><span class=\"line\">  &#125; else if(u === u.parent.left) &#123;</span><br><span class=\"line\">    u.parent.left = v;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    u.parent.right = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(v !== null) &#123;</span><br><span class=\"line\">    v.parent = u.parent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeDelete(tree, z) &#123;</span><br><span class=\"line\">  if(z.left === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.right);</span><br><span class=\"line\">  &#125; else if(z.right === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = treeMinimum(z.right);</span><br><span class=\"line\">    if(y.parent !== z) &#123;</span><br><span class=\"line\">      transplant(tree, y, y.right);</span><br><span class=\"line\">      y.right = z.right;</span><br><span class=\"line\">      y.right.parent = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    transplant(tree, z, y);</span><br><span class=\"line\">    y.left = z.left;</span><br><span class=\"line\">    y.left.parent = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》</strong></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是二叉搜索树\"><a href=\"#什么是二叉搜索树\" class=\"headerlink\" title=\"什么是二叉搜索树\"></a>什么是二叉搜索树</h3><p>其形式就是二叉树，对于每个节点x，其左子树的值&lt;&#x3D;x.value，右子树的值&gt;&#x3D;x.value。</p>","more":"<h3 id=\"二叉搜索树的遍历与查询\"><a href=\"#二叉搜索树的遍历与查询\" class=\"headerlink\" title=\"二叉搜索树的遍历与查询\"></a>二叉搜索树的遍历与查询</h3><p>对于二叉搜索树，我们可以使用中序遍历，得到树上从小到大所有的元素。时间复杂度平均为O(n)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inorderTreeWalk(x) &#123;</span><br><span class=\"line\">  if(x!== null) &#123;</span><br><span class=\"line\">    inorderTreeWalk(x.left);</span><br><span class=\"line\">    print(x.key);</span><br><span class=\"line\">    inorderTreeWalk(x.right);</span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们想要查询二叉搜索树中某个关键字应该怎么做呢？由于二叉搜索树左子树和右子树的特点，我们很容易写出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x,k) &#123;  //最开始x代表根节点</span><br><span class=\"line\">  if(x === null || x.key === k) &#123;</span><br><span class=\"line\">    return x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(k &lt; x.key) &#123;</span><br><span class=\"line\">    return treeSearch(x.left, k);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return treeSearch(x.right, k);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还可以写出循环版本（一般比递归更高效）:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSearch(x, k) &#123;</span><br><span class=\"line\">  while(x !== null || k !== x.key) &#123;</span><br><span class=\"line\">    if(k &lt; x.key) &#123;</span><br><span class=\"line\">      x = x.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      x = x.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们很容易可以找到二叉搜索树中的最小元素和最大元素，其查找时间复杂度为O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeMinimum(x) &#123;</span><br><span class=\"line\">  while(x.left !== null) &#123;</span><br><span class=\"line\">    x = x.left;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeMaximum(x) &#123;</span><br><span class=\"line\">  while(x.right !== null) &#123;</span><br><span class=\"line\">    x = x.right;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时候我们需要按中序遍历查找二叉搜索树某个节点的后继和前驱。分析二叉搜索树性质可知，如果该节点右子树不为空，则它的后继应该是右子树中的最小元素；若右子树为空，则该节点的后继应该是其双亲有左子树的父节点。前驱则与其对称.时间复杂度O(lgn)：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeSuccessor(x) &#123;  //后继查找</span><br><span class=\"line\">  if(x.right !== null) &#123;</span><br><span class=\"line\">    return treeMinimum(x.right);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.right) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeSuccessor(x) &#123;  //前驱查找</span><br><span class=\"line\">  if(x.left !== null) &#123;</span><br><span class=\"line\">    return treeMaximum(x.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = x.parent;</span><br><span class=\"line\">    while(y !== null &amp;&amp; x === y.left) &#123;</span><br><span class=\"line\">      x = y;</span><br><span class=\"line\">      y = y.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉搜索树实现插入和删除操作。\"><a href=\"#二叉搜索树实现插入和删除操作。\" class=\"headerlink\" title=\"二叉搜索树实现插入和删除操作。\"></a>二叉搜索树实现插入和删除操作。</h3><p>　　1. 插入相对比较简单，我们只要遍历二叉树把值插入到合适的位置就行了。<br>　　<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function treeInsert(tree, newNode) &#123;</span><br><span class=\"line\">  let y = null;</span><br><span class=\"line\">  while(tree !== null) &#123;</span><br><span class=\"line\">    y = tree;</span><br><span class=\"line\">    if(newNode.key &lt; tree.key) &#123;</span><br><span class=\"line\">      tree = tree.left;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      tree = tree.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  newNode.parent = y;</span><br><span class=\"line\">  if(y === null) &#123;  // 树为空</span><br><span class=\"line\">    tree.root = newNode;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    if(newNode.key &lt; y.key) &#123;</span><br><span class=\"line\">      y.left = newNode;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      y.right = newNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>　　2. 删除操作相对较复杂。假如删除z节点，我们考虑三种情况：z没有子节点、z有一个子节点、z有两个子节点。<br>　　　　- 第一种情况：z没有子节点，则直接删除z，修改父节点属性，用null代替z。<br>　　　　- 第二种情况：z只有一个子节点，则用子节点代替z。<br>　　　　- 第三种情况：z有两个子节点，我们需要找到z的后继y，y肯定在z的右子树并且没有左孩子，当y恰好是z的右子节点，则直接用y替代z，并留下y的右孩子；否则先用y的右子节点替代y，再用y替代z。<br>        <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function transplant(tree, u, v) &#123;  //子树替换父节点方法</span><br><span class=\"line\">  if(u.p === null) &#123;</span><br><span class=\"line\">    tree.root = v;</span><br><span class=\"line\">  &#125; else if(u === u.parent.left) &#123;</span><br><span class=\"line\">    u.parent.left = v;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    u.parent.right = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if(v !== null) &#123;</span><br><span class=\"line\">    v.parent = u.parent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function treeDelete(tree, z) &#123;</span><br><span class=\"line\">  if(z.left === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.right);</span><br><span class=\"line\">  &#125; else if(z.right === null) &#123;</span><br><span class=\"line\">    transplant(tree, z, z.left);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    let y = treeMinimum(z.right);</span><br><span class=\"line\">    if(y.parent !== z) &#123;</span><br><span class=\"line\">      transplant(tree, y, y.right);</span><br><span class=\"line\">      y.right = z.right;</span><br><span class=\"line\">      y.right.parent = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    transplant(tree, z, y);</span><br><span class=\"line\">    y.left = z.left;</span><br><span class=\"line\">    y.left.parent = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>至此，我们完成了二叉搜索树的js实现。具体算法证明参考《算法导论》</strong></p>"},{"title":"深入学习HTTP连接","date":"2017-04-04T12:43:32.000Z","_content":"\n## 什么是HTTP协议？\n---\nHTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。\n只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。\n<!--more-->\n### 为什么说HTTP是无状态的？\n---\n无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。\n缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。\n\n## HTTP连接\n在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP/IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：\n\n - 浏览器从URL中解析出服务器的主机名;\n - 浏览器通过DNS将主机名转换成服务器的IP地址;\n - 浏览器将端口号(默认80)从URL中解析出来;\n - 浏览器建立一条与Web服务器的TCP连接;\n - 浏览器向服务器发送一条HTTP请求报文;\n - 服务器向浏览器回送一条HTTP响应报文;\n - 关闭连接，浏览器渲染文档并显示;\n\n当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。\n\n### TCP连接\n---\n我们知道，HTTP协议依赖TCP/IP来进行通信。那么什么是TCP/IP呢？TCP/IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。\n#### TCP数据传输\n- TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。\n- 传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：\n    * 一个IP分组首部（通常为20字节）;\n    * 一个TCP段首部（通常为20字节）;\n    * 一个TCP数据块（0个或多个字节）;\n    ![ip分组](/images/ip-group.jpg \"IP分组\")\n- TCP连接通过4个值来识别：<源IP地址、源端口号、目的IP地址、目的端口号>，这4个值一起唯一地定义了一条连接。\n### TCP性能考虑\n- **HTTP事务的时延**：一般影响HTTP事务的时延主要有以下几点原因：\n    1. 解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。\n    2. 发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。\n    3. 连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间\n    总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。\n- **TCP握手时延**：TCP连接需要经过三次握手，一般步骤如下：\n    1. 请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。\n    2. 服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。\n    3. 客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）\n- **TCP延迟确认**：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。\n- **TCP慢启动**：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。\n由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。\n- **Nagle算法问题**：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。\nNagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。\n所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。\n- **TIME_WAIT、端口耗尽**：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。\n","source":"_posts/2017-04-04-http-learning-1.md","raw":"---\ntitle: 深入学习HTTP连接\ndate: 2017-04-04 20:43:32\ntags: HTTP\ncategories: 网络\n---\n\n## 什么是HTTP协议？\n---\nHTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。\n只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。\n<!--more-->\n### 为什么说HTTP是无状态的？\n---\n无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。\n缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。\n\n## HTTP连接\n在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP/IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：\n\n - 浏览器从URL中解析出服务器的主机名;\n - 浏览器通过DNS将主机名转换成服务器的IP地址;\n - 浏览器将端口号(默认80)从URL中解析出来;\n - 浏览器建立一条与Web服务器的TCP连接;\n - 浏览器向服务器发送一条HTTP请求报文;\n - 服务器向浏览器回送一条HTTP响应报文;\n - 关闭连接，浏览器渲染文档并显示;\n\n当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。\n\n### TCP连接\n---\n我们知道，HTTP协议依赖TCP/IP来进行通信。那么什么是TCP/IP呢？TCP/IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。\n#### TCP数据传输\n- TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。\n- 传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：\n    * 一个IP分组首部（通常为20字节）;\n    * 一个TCP段首部（通常为20字节）;\n    * 一个TCP数据块（0个或多个字节）;\n    ![ip分组](/images/ip-group.jpg \"IP分组\")\n- TCP连接通过4个值来识别：<源IP地址、源端口号、目的IP地址、目的端口号>，这4个值一起唯一地定义了一条连接。\n### TCP性能考虑\n- **HTTP事务的时延**：一般影响HTTP事务的时延主要有以下几点原因：\n    1. 解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。\n    2. 发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。\n    3. 连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间\n    总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。\n- **TCP握手时延**：TCP连接需要经过三次握手，一般步骤如下：\n    1. 请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。\n    2. 服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。\n    3. 客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）\n- **TCP延迟确认**：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。\n- **TCP慢启动**：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。\n由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。\n- **Nagle算法问题**：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。\nNagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。\n所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。\n- **TIME_WAIT、端口耗尽**：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。\n","slug":"http-learning-1","published":1,"updated":"2022-02-24T02:14:27.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz2y00030hp37dzvdco0","content":"<h2 id=\"什么是HTTP协议？\"><a href=\"#什么是HTTP协议？\" class=\"headerlink\" title=\"什么是HTTP协议？\"></a>什么是HTTP协议？</h2><hr>\n<p>HTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP&#x2F;IP。<br>只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。</p>\n<span id=\"more\"></span>\n<h3 id=\"为什么说HTTP是无状态的？\"><a href=\"#为什么说HTTP是无状态的？\" class=\"headerlink\" title=\"为什么说HTTP是无状态的？\"></a>为什么说HTTP是无状态的？</h3><hr>\n<p>无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。<br>缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。</p>\n<h2 id=\"HTTP连接\"><a href=\"#HTTP连接\" class=\"headerlink\" title=\"HTTP连接\"></a>HTTP连接</h2><p>在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP&#x2F;IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：</p>\n<ul>\n<li>浏览器从URL中解析出服务器的主机名;</li>\n<li>浏览器通过DNS将主机名转换成服务器的IP地址;</li>\n<li>浏览器将端口号(默认80)从URL中解析出来;</li>\n<li>浏览器建立一条与Web服务器的TCP连接;</li>\n<li>浏览器向服务器发送一条HTTP请求报文;</li>\n<li>服务器向浏览器回送一条HTTP响应报文;</li>\n<li>关闭连接，浏览器渲染文档并显示;</li>\n</ul>\n<p>当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。</p>\n<h3 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h3><hr>\n<p>我们知道，HTTP协议依赖TCP&#x2F;IP来进行通信。那么什么是TCP&#x2F;IP呢？TCP&#x2F;IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。</p>\n<h4 id=\"TCP数据传输\"><a href=\"#TCP数据传输\" class=\"headerlink\" title=\"TCP数据传输\"></a>TCP数据传输</h4><ul>\n<li>TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。</li>\n<li>传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：<ul>\n<li>一个IP分组首部（通常为20字节）;</li>\n<li>一个TCP段首部（通常为20字节）;</li>\n<li>一个TCP数据块（0个或多个字节）;<br>  <img src=\"/images/ip-group.jpg\" alt=\"ip分组\" title=\"IP分组\"></li>\n</ul>\n</li>\n<li>TCP连接通过4个值来识别：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;，这4个值一起唯一地定义了一条连接。<h3 id=\"TCP性能考虑\"><a href=\"#TCP性能考虑\" class=\"headerlink\" title=\"TCP性能考虑\"></a>TCP性能考虑</h3></li>\n<li><strong>HTTP事务的时延</strong>：一般影响HTTP事务的时延主要有以下几点原因：<ol>\n<li>解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。</li>\n<li>发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。</li>\n<li>连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间<br>  总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。</li>\n</ol>\n</li>\n<li><strong>TCP握手时延</strong>：TCP连接需要经过三次握手，一般步骤如下：<ol>\n<li>请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。</li>\n<li>服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。</li>\n<li>客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）</li>\n</ol>\n</li>\n<li><strong>TCP延迟确认</strong>：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。</li>\n<li><strong>TCP慢启动</strong>：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。<br>由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。</li>\n<li><strong>Nagle算法问题</strong>：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。<br>Nagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。<br>所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。</li>\n<li><strong>TIME_WAIT、端口耗尽</strong>：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是HTTP协议？\"><a href=\"#什么是HTTP协议？\" class=\"headerlink\" title=\"什么是HTTP协议？\"></a>什么是HTTP协议？</h2><hr>\n<p>HTTP协议是可靠的数据传输无状态协议，它属于应用层。HTTP把联网的细节都交给了通用、可靠的因特网传输协议TCP&#x2F;IP。<br>只要建立了TCP连接，客户端和服务端之间的报文交换就不会丢失、不会被破坏。</p>","more":"<h3 id=\"为什么说HTTP是无状态的？\"><a href=\"#为什么说HTTP是无状态的？\" class=\"headerlink\" title=\"为什么说HTTP是无状态的？\"></a>为什么说HTTP是无状态的？</h3><hr>\n<p>无状态的意思就是说每一次请求都与之前的请求无关，每一次请求包含的cookie、url、首部等有状态的数据都是一个完整的文档，不需要请求其上下文。<br>缺点就是每一次请求都需要重新发送状态，也就是说服务器不会主动保存之前的状态。一般如果想让应用有状态，会在http协议中加上cookie、session等缓存机制。</p>\n<h2 id=\"HTTP连接\"><a href=\"#HTTP连接\" class=\"headerlink\" title=\"HTTP连接\"></a>HTTP连接</h2><p>在HTTP客户端向服务器发送报文之前，需要用IP地址和端口号在客户端和服务器之间建立一条TCP&#x2F;IP连接。一般浏览器通过HTTP获取服务器中某个HTML资源过程如下：</p>\n<ul>\n<li>浏览器从URL中解析出服务器的主机名;</li>\n<li>浏览器通过DNS将主机名转换成服务器的IP地址;</li>\n<li>浏览器将端口号(默认80)从URL中解析出来;</li>\n<li>浏览器建立一条与Web服务器的TCP连接;</li>\n<li>浏览器向服务器发送一条HTTP请求报文;</li>\n<li>服务器向浏览器回送一条HTTP响应报文;</li>\n<li>关闭连接，浏览器渲染文档并显示;</li>\n</ul>\n<p>当然上述只是简单的描述，其中还有很多具体的步骤我们以后再说。</p>\n<h3 id=\"TCP连接\"><a href=\"#TCP连接\" class=\"headerlink\" title=\"TCP连接\"></a>TCP连接</h3><hr>\n<p>我们知道，HTTP协议依赖TCP&#x2F;IP来进行通信。那么什么是TCP&#x2F;IP呢？TCP&#x2F;IP是全球计算机网络都在使用的一种常用的分组交换网络分层协议集。</p>\n<h4 id=\"TCP数据传输\"><a href=\"#TCP数据传输\" class=\"headerlink\" title=\"TCP数据传输\"></a>TCP数据传输</h4><ul>\n<li>TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来。</li>\n<li>传输的数据是通过称为IP分组的小数据块来发送的。每个IP分组都包括：<ul>\n<li>一个IP分组首部（通常为20字节）;</li>\n<li>一个TCP段首部（通常为20字节）;</li>\n<li>一个TCP数据块（0个或多个字节）;<br>  <img src=\"/images/ip-group.jpg\" alt=\"ip分组\" title=\"IP分组\"></li>\n</ul>\n</li>\n<li>TCP连接通过4个值来识别：&lt;源IP地址、源端口号、目的IP地址、目的端口号&gt;，这4个值一起唯一地定义了一条连接。<h3 id=\"TCP性能考虑\"><a href=\"#TCP性能考虑\" class=\"headerlink\" title=\"TCP性能考虑\"></a>TCP性能考虑</h3></li>\n<li><strong>HTTP事务的时延</strong>：一般影响HTTP事务的时延主要有以下几点原因：<ol>\n<li>解析主机名：首次解析主机名需要通过DNS解析系统将URI中的主机名转换成一个IP地址，这可能要花费不少时间;如果没有缓存DNS，则以后的每次访问都需要重新解析DNS，带来巨大时间消耗。</li>\n<li>发送TCP连接请求：每条新的TCP连接都会有连接建立时延，如果同时发送上百条连接，则所耗时间大大增加。</li>\n<li>连接建立完后，客户端会通过新建立的TCP管道发送HTTP请求报文，服务器接收到报文后会对请求进行处理。这其中传输报文、处理报文都需要花费时间;服务器处理完报文后回送响应报文也需要传输时间<br>  总的来说，硬件速度、客户端和服务器的负载量、客户端与服务器之间的距离、报文的大小等会对时延产生巨大影响。</li>\n</ol>\n</li>\n<li><strong>TCP握手时延</strong>：TCP连接需要经过三次握手，一般步骤如下：<ol>\n<li>请求新的TCP连接，客户端向服务器发送一个TCP分组（通常40～60字节）。分组中设置了一个特殊的SYN标记，说明是连接请求。</li>\n<li>服务器接受连接，对连接参数进行计算，向客户端回送一个TCP分组，分组中的SYN和ACK标记都被置位，告诉客户端请求已接受。</li>\n<li>客户端向服务器回送一条确认信息的TCP分组，包含ACK标记，告诉服务器连接已成功建立。（现代的TCP栈允许客户端在这个确认分组中发送数据）</li>\n</ol>\n</li>\n<li><strong>TCP延迟确认</strong>：TCP有自己的确认机制来确保数据成功传输。每个TCP段都有一个序列号和数据完整性校验和。一般确认报文很小，所以TCP允许将确认报文和输出的数据分组组合在一起传输，这里就引入了一个“延迟确认”算法。“延迟确认”算法会在一个特定的窗口时间（通常100～200ms）内将输出确认存放在缓存区，以寻找能携带它的输出数据分组，如果在特定时间内没有输出数据分组，就将确认信息放在单独的分组进行传输。但这样一般会引入比较大的时延，所以不一定完全要用延迟算法。</li>\n<li><strong>TCP慢启动</strong>：为了防止网络负载过大和阻塞，TCP连接会采取慢启动，也就是说一开始限制连接的最大速度，随着数据的传输成功，慢慢增大传输速度。例如建立一个新连接，先发送一个分组，等确认成功后，才可以发送两个分组，等都被确认后，就可以发送四个分组，以此类推。。。<br>由于这种特性，新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。</li>\n<li><strong>Nagle算法问题</strong>：由于TCP允许将任意尺寸数据放入TCP栈中传输，所以如果TCP发送了大量包含少量数据的分组，则网络性能就会很低，浪费很多流量。Nagle算法就是用来解决此类问题。该算法试图在发送一个分组之前，将大量TCP数据绑定在一起来提高网络效率。<br>Nagle算法希望发送全尺寸（LAN上最大尺寸的分组大约1500字节，Internet上是几百字节）的段。如果其他分组任然在传输过程中，就将那部分数据缓存起来，只有当挂起分组被确认，或者缓存中积累了足够发送一个全尺寸的分组后才将缓存的数据传输出去。这样就会带来性能问题，如果HTTP报文很小，一直达不到全尺寸，就会一直在等待那些永远不会到来的数据而引起时延;而且Nagle算法会阻止数据传输直到有确认分组抵达，但确认分组自身又有延迟。<br>所以HTTP应用程序可以通过设置参数TCP_NODELAY来禁用Nagle算法，但是这样要确保会向TCP写入大块数据，而避免传输数量多的小分组。</li>\n<li><strong>TIME_WAIT、端口耗尽</strong>：TCP关闭某个连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的IP地址和端口号，通常维持2MSL（2分钟）左右。这样可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。但这样就会限制可用端口号的数量，降低连接率。要确保不会遇到TIME_WAIT端口耗尽问题，可以增加客户端负载生成机器的数量，或者确保客户端和服务器在循环使用几个虚拟IP地址以增加更多的连接组合。</li>\n</ul>"},{"title":"深刻理解闭包","date":"2017-04-06T12:45:59.000Z","_content":"\n### 变量的知识\n---\n- 变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。\n- 变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。\n<!--more-->\n### 什么是闭包？\n---\n我们先来看个例子\n```javascript\nvar func = function() {\n    var a = 0;\n    return function() {\n        a++;\n        console.log(a);\n    };\n};\nvar f = func();\nf();    // 1\nf();    // 2\nf();    // 3\n```\n当退出函数后，变量a并没有消失，因为调用var f = func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。\n我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。\n\n### 闭包的作用\n---\n- 封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。\n- 延长局部变量寿命：使其不会在退出函数时就立即销毁。\n- 将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。\n\n### 闭包与面向对象设计\n---\n- 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。\n- 闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:\n```javascript\nvar createCommand = function(receiver){\n    var excute = function(){\n        return receiver.open();\n    };\n    var undo = function(){\n        return receiver.close();\n    };\n    return {\n        excute: excute,\n        undo: undo\n    };\n};\n```\n- 闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。\n\n### 闭包的应用\n---\n在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：\n```javascript\nfunction wait(message) {\n    setTimeout( function timer() {\n        console.log( message );\n    }, 1000 );\n}\n\nwait(\"This is a closure!\");\n```\n在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(...)作用域的闭包，因此包含对变量message的引用。wait(...)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(...)作用域的闭包。\n\n### 经典闭包问题\n---\n考虑如下代码：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？\n我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。\n怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i * 1000);\n    })(i);\n}\n```\n这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。\n其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：\n```javascript\nfor(let i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n\n### 闭包在模块中的应用\n---\n考虑以下代码：\n```javascript\nfunction CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n}\n\nvar foo = CoolModule();\nfoo.doSth();\nfoo.doAnother();\n```\n这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。\n简单地说，模块模式需要具备两个必要条件：\n    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）\n    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态\n当只需要一个实例时，我们可以用如下方法实现单例模式：\n```javascript\nvar foo = (function CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n})();\n\nfoo.doSth();\nfoo.doAnother();\n```\n我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。\n","source":"_posts/2017-04-06-Closures-learning.md","raw":"---\ntitle: 深刻理解闭包\ndate: 2017-04-06 20:45:59\ntags: 闭包\ncategories: JS基础\n---\n\n### 变量的知识\n---\n- 变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。\n- 变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。\n<!--more-->\n### 什么是闭包？\n---\n我们先来看个例子\n```javascript\nvar func = function() {\n    var a = 0;\n    return function() {\n        a++;\n        console.log(a);\n    };\n};\nvar f = func();\nf();    // 1\nf();    // 2\nf();    // 3\n```\n当退出函数后，变量a并没有消失，因为调用var f = func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。\n我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。\n\n### 闭包的作用\n---\n- 封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。\n- 延长局部变量寿命：使其不会在退出函数时就立即销毁。\n- 将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。\n\n### 闭包与面向对象设计\n---\n- 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。\n- 闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:\n```javascript\nvar createCommand = function(receiver){\n    var excute = function(){\n        return receiver.open();\n    };\n    var undo = function(){\n        return receiver.close();\n    };\n    return {\n        excute: excute,\n        undo: undo\n    };\n};\n```\n- 闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。\n\n### 闭包的应用\n---\n在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：\n```javascript\nfunction wait(message) {\n    setTimeout( function timer() {\n        console.log( message );\n    }, 1000 );\n}\n\nwait(\"This is a closure!\");\n```\n在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(...)作用域的闭包，因此包含对变量message的引用。wait(...)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(...)作用域的闭包。\n\n### 经典闭包问题\n---\n考虑如下代码：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？\n我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。\n怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：\n```javascript\nfor(var i = 0; i < 5; i++) {\n    (function(i) {\n        setTimeout(function timer() {\n            console.log(i);\n        }, i * 1000);\n    })(i);\n}\n```\n这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。\n其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：\n```javascript\nfor(let i = 0; i < 5; i++) {\n    setTimeout(function timer() {\n        console.log(i);\n    }, i * 1000);\n}\n```\n因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n\n### 闭包在模块中的应用\n---\n考虑以下代码：\n```javascript\nfunction CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n}\n\nvar foo = CoolModule();\nfoo.doSth();\nfoo.doAnother();\n```\n这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。\n简单地说，模块模式需要具备两个必要条件：\n    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）\n    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态\n当只需要一个实例时，我们可以用如下方法实现单例模式：\n```javascript\nvar foo = (function CoolModule() {\n    var sth = 1;\n    var another = [1,2,3];\n    function doSth() {\n        console.log(sth);\n    }\n    function doAnother() {\n        console.log(another.join(','));\n    }\n\n    return {\n        doSth: doSth,\n        doAnother: doAnother\n    };\n})();\n\nfoo.doSth();\nfoo.doAnother();\n```\n我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。\n","slug":"Closures-learning","published":1,"updated":"2022-02-24T02:14:24.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3500070hp38i7oeadb","content":"<h3 id=\"变量的知识\"><a href=\"#变量的知识\" class=\"headerlink\" title=\"变量的知识\"></a>变量的知识</h3><hr>\n<ul>\n<li>变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。</li>\n<li>变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。<span id=\"more\"></span>\n<h3 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h3></li>\n</ul>\n<hr>\n<p>我们先来看个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"title function_\">func</span>();</span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当退出函数后，变量a并没有消失，因为调用var f &#x3D; func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。<br>我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。</p>\n<h3 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h3><hr>\n<ul>\n<li>封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。</li>\n<li>延长局部变量寿命：使其不会在退出函数时就立即销毁。</li>\n<li>将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。</li>\n</ul>\n<h3 id=\"闭包与面向对象设计\"><a href=\"#闭包与面向对象设计\" class=\"headerlink\" title=\"闭包与面向对象设计\"></a>闭包与面向对象设计</h3><hr>\n<ul>\n<li>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。</li>\n<li>闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCommand = <span class=\"keyword\">function</span>(<span class=\"params\">receiver</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> excute = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">open</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> undo = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">excute</span>: excute,</span><br><span class=\"line\">        <span class=\"attr\">undo</span>: undo</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。</li>\n</ul>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><hr>\n<p>在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">wait</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( message );</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">wait</span>(<span class=\"string\">&quot;This is a closure!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(…)作用域的闭包，因此包含对变量message的引用。wait(…)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(…)作用域的闭包。</p>\n<h3 id=\"经典闭包问题\"><a href=\"#经典闭包问题\" class=\"headerlink\" title=\"经典闭包问题\"></a>经典闭包问题</h3><hr>\n<p>考虑如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？<br>我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。<br>怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"keyword\">function</span>(<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">        &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。<br>其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>\n<h3 id=\"闭包在模块中的应用\"><a href=\"#闭包在模块中的应用\" class=\"headerlink\" title=\"闭包在模块中的应用\"></a>闭包在模块中的应用</h3><hr>\n<p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"title class_\">CoolModule</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。<br>简单地说，模块模式需要具备两个必要条件：<br>    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）<br>    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态<br>当只需要一个实例时，我们可以用如下方法实现单例模式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"变量的知识\"><a href=\"#变量的知识\" class=\"headerlink\" title=\"变量的知识\"></a>变量的知识</h3><hr>\n<ul>\n<li>变量的作用域：js里可以用函数来创造函数作用域，ES6中有块作用域，作用域里的变量是局部变量，作用域外面访问不到该变量，但在作用域里可以访问到作用域外面的变量。</li>\n<li>变量的生存周期：全局变量的生存周期是永久的，除非主动销毁该全局变量。作用域里的变量当离开该作用域或者离开函数时，局部变量就会被垃圾回收装置自动销毁。","more":"<h3 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h3></li>\n</ul>\n<hr>\n<p>我们先来看个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        a++;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"title function_\">func</span>();</span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"title function_\">f</span>();    <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>当退出函数后，变量a并没有消失，因为调用var f &#x3D; func();时，f返回了一个匿名函数的引用，而它可以访问到func()被调用时执行的环境，局部变量a则处在这个环境中，所以a可以被外界访问。这里就产生了所谓的闭包，局部变量a的生命周期被延长了。<br>我们知道，当func()执行后，通常会期待func()内部作用域全部被销毁，因为JS引擎有垃圾回收器用来释放不再使用的内存空间。当某个函数执行完后，一般我们都认为它已经不再使用了，自然会考虑对其回收。而闭包的作用就是让内部作用域依然存在，f()就是对该作用域的引用，而这个引用就叫做闭包。</p>\n<h3 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h3><hr>\n<ul>\n<li>封装变量：把一些不需要暴露在全局的变量封装成“私有变量”。</li>\n<li>延长局部变量寿命：使其不会在退出函数时就立即销毁。</li>\n<li>将函数在定义时的词法作用域以外的地方调用使其可以继续访问定义时的词法作用域。</li>\n</ul>\n<h3 id=\"闭包与面向对象设计\"><a href=\"#闭包与面向对象设计\" class=\"headerlink\" title=\"闭包与面向对象设计\"></a>闭包与面向对象设计</h3><hr>\n<ul>\n<li>对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。</li>\n<li>闭包实现命令模式:命令模式的意图是把请求封装为对象，从而分离请求的发起者和请求的接收者之间的耦合关系。用闭包实现命令模式如下:<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createCommand = <span class=\"keyword\">function</span>(<span class=\"params\">receiver</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> excute = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">open</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> undo = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> receiver.<span class=\"title function_\">close</span>();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">excute</span>: excute,</span><br><span class=\"line\">        <span class=\"attr\">undo</span>: undo</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>闭包与内存管理:使用闭包的一部分原因是我们选择主动把一些变量封装在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域中对内存方面的影响是一致的。如果在将来需要回收这些变量，可以手动把变量设置为null。</li>\n</ul>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><hr>\n<p>在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workders或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">wait</span>(<span class=\"params\">message</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>( message );</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">wait</span>(<span class=\"string\">&quot;This is a closure!&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>在这里我们将一个内部函数timer传递给setTimeou，timer具有涵盖wait(…)作用域的闭包，因此包含对变量message的引用。wait(…)执行1000毫秒后，它的内部作用域并不会消失，timer依然保有wait(…)作用域的闭包。</p>\n<h3 id=\"经典闭包问题\"><a href=\"#经典闭包问题\" class=\"headerlink\" title=\"经典闭包问题\"></a>经典闭包问题</h3><hr>\n<p>考虑如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们期待是输出0～5，每隔一秒输出一个数字。但实际上这段代码运行结果是每隔一秒输出一个5。想想就知道，setTimeout设置的延迟函数相当于异步调用，在循环后才执行，而循环结束后i为5,所以输出也就为5。那么问题出在哪呢？<br>我们以为循环时每个迭代都会“捕获”一个i的副本，但是根据作用域工作原理，尽管循环中的五个函数是在不同的迭代定义的，但它们共享一个全局作用域，因此只有一个全局变量i。<br>怎么解决？在循环的每个迭代创建一个闭包作用域。这里就用到IIFE函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    (<span class=\"keyword\">function</span>(<span class=\"params\">i</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">        &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样问题就解决了，我们在每个循环创造一个IIFE匿名函数，并传入全局变量i，使得每个作用域都收到不同的局部变量i并用闭包保存下来，最后输出时就能正确输出i值了。<br>其实我们的解决方法本质上就是每次迭代都需要一个块作用域。在ES6里用let就能很好解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span> <span class=\"title function_\">timer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    &#125;, i * <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为let声明在每次迭代都会声明i，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>\n<h3 id=\"闭包在模块中的应用\"><a href=\"#闭包在模块中的应用\" class=\"headerlink\" title=\"闭包在模块中的应用\"></a>闭包在模块中的应用</h3><hr>\n<p>考虑以下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"title class_\">CoolModule</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>这个模式在js中被称为模块。CoolModule()是一个函数，我们必须通过调用它来创建一个模块实例。该函数返回的是一个对象，这个对象包含了对内部函数的引用，也就是一个闭包，而内部数据变量仍然是隐藏且私有状态。可以说这个对象的返回值就是模块的公共API。每次调用CoolModule()函数相当于创建了一个新的模块实例，然后可以用这个实例调用其内部函数API。<br>简单地说，模块模式需要具备两个必要条件：<br>    1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用创建一个新的模块实例）<br>    2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态<br>当只需要一个实例时，我们可以用如下方法实现单例模式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = (<span class=\"keyword\">function</span> <span class=\"title function_\">CoolModule</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sth = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doSth</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">doAnother</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(another.<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;,&#x27;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"attr\">doSth</span>: doSth,</span><br><span class=\"line\">        <span class=\"attr\">doAnother</span>: doAnother</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">foo.<span class=\"title function_\">doSth</span>();</span><br><span class=\"line\">foo.<span class=\"title function_\">doAnother</span>();</span><br></pre></td></tr></table></figure>\n<p>我们通过一个IIFE立即执行模块函数并返回赋值给foo。通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>"},{"title":"leetcode刷题ing(week-one)","date":"2017-04-09T12:58:30.000Z","_content":"\n前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。\n其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。\n<!--more-->\n### [Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description)\n> 题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说\"abcad\", \"abcda\"这两个字符串的最大不同子字符串就是它们自己任何一个。\n\n开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。\n\n### [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/#/description)\n> 题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如\"abba\"和\"cddc\"就是同构，\"abcde\"和\"abcdf\"就不是同构。\n\n一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。\n\n### [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/#/description)\n> 题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。\n\n其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。\n\n### [Assign Cookies](https://leetcode.com/problems/assign-cookies/#/description)\n> 题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。\n\n又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。\n\n### [Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/#/description)\n> 题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。\n\n简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)/2个等差数列，然后把结果累加就行了。\n\n### [Counting Bits](https://leetcode.com/problems/counting-bits/#/description)\n> 给定一个数字n统计0～n里每个数字的二进制中1的个数。\n\n主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：\n```javascript\nvar count = 0;\nwhile(n) {\n  count++;\n  n = n & (n-1);\n}\n```\n因为n & (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。\n\n### [Add Digits](https://leetcode.com/problems/add-digits/#/description)\n> 给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num = 38, 3 + 8 = 11, 1 + 1 = 2. 返回2。\n\n这里有一个数学公式，wiki上有[digital_root](https://en.wikipedia.org/wiki/Digital_root#Congruence_formula)，具体我就没推了，直接用结论：dr(n) = 1 + (n - 1) % 9\n","source":"_posts/2017-04-09-leetcode-week1.md","raw":"---\ntitle: leetcode刷题ing(week-one)\ndate: 2017-04-09 20:58:30\ncategories: \n- 算法\ntags: \n- leetcode\n---\n\n前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。\n其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。\n<!--more-->\n### [Longest Uncommon Subsequence I](https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description)\n> 题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说\"abcad\", \"abcda\"这两个字符串的最大不同子字符串就是它们自己任何一个。\n\n开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。\n\n### [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/#/description)\n> 题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如\"abba\"和\"cddc\"就是同构，\"abcde\"和\"abcdf\"就不是同构。\n\n一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。\n\n### [Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height/#/description)\n> 题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。\n\n其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。\n\n### [Assign Cookies](https://leetcode.com/problems/assign-cookies/#/description)\n> 题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。\n\n又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。\n\n### [Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/#/description)\n> 题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。\n\n简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)/2个等差数列，然后把结果累加就行了。\n\n### [Counting Bits](https://leetcode.com/problems/counting-bits/#/description)\n> 给定一个数字n统计0～n里每个数字的二进制中1的个数。\n\n主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：\n```javascript\nvar count = 0;\nwhile(n) {\n  count++;\n  n = n & (n-1);\n}\n```\n因为n & (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。\n\n### [Add Digits](https://leetcode.com/problems/add-digits/#/description)\n> 给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num = 38, 3 + 8 = 11, 1 + 1 = 2. 返回2。\n\n这里有一个数学公式，wiki上有[digital_root](https://en.wikipedia.org/wiki/Digital_root#Congruence_formula)，具体我就没推了，直接用结论：dr(n) = 1 + (n - 1) % 9\n","slug":"leetcode-week1","published":1,"updated":"2022-02-24T02:14:24.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3700080hp300z4a6a0","content":"<p>前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。<br>其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。</p>\n<span id=\"more\"></span>\n<h3 id=\"Longest-Uncommon-Subsequence-I\"><a href=\"#Longest-Uncommon-Subsequence-I\" class=\"headerlink\" title=\"Longest Uncommon Subsequence I\"></a><a href=\"https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description\">Longest Uncommon Subsequence I</a></h3><blockquote>\n<p>题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说”abcad”, “abcda”这两个字符串的最大不同子字符串就是它们自己任何一个。</p>\n</blockquote>\n<p>开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。</p>\n<h3 id=\"Isomorphic-Strings\"><a href=\"#Isomorphic-Strings\" class=\"headerlink\" title=\"Isomorphic Strings\"></a><a href=\"https://leetcode.com/problems/isomorphic-strings/#/description\">Isomorphic Strings</a></h3><blockquote>\n<p>题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如”abba”和”cddc”就是同构，”abcde”和”abcdf”就不是同构。</p>\n</blockquote>\n<p>一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。</p>\n<h3 id=\"Queue-Reconstruction-by-Height\"><a href=\"#Queue-Reconstruction-by-Height\" class=\"headerlink\" title=\"Queue Reconstruction by Height\"></a><a href=\"https://leetcode.com/problems/queue-reconstruction-by-height/#/description\">Queue Reconstruction by Height</a></h3><blockquote>\n<p>题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。</p>\n</blockquote>\n<p>其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。</p>\n<h3 id=\"Assign-Cookies\"><a href=\"#Assign-Cookies\" class=\"headerlink\" title=\"Assign Cookies\"></a><a href=\"https://leetcode.com/problems/assign-cookies/#/description\">Assign Cookies</a></h3><blockquote>\n<p>题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。</p>\n</blockquote>\n<p>又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。</p>\n<h3 id=\"Arithmetic-Slices\"><a href=\"#Arithmetic-Slices\" class=\"headerlink\" title=\"Arithmetic Slices\"></a><a href=\"https://leetcode.com/problems/arithmetic-slices/#/description\">Arithmetic Slices</a></h3><blockquote>\n<p>题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。</p>\n</blockquote>\n<p>简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)&#x2F;2个等差数列，然后把结果累加就行了。</p>\n<h3 id=\"Counting-Bits\"><a href=\"#Counting-Bits\" class=\"headerlink\" title=\"Counting Bits\"></a><a href=\"https://leetcode.com/problems/counting-bits/#/description\">Counting Bits</a></h3><blockquote>\n<p>给定一个数字n统计0～n里每个数字的二进制中1的个数。</p>\n</blockquote>\n<p>主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">  count++;</span><br><span class=\"line\">  n = n &amp; (n-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为n &amp; (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。</p>\n<h3 id=\"Add-Digits\"><a href=\"#Add-Digits\" class=\"headerlink\" title=\"Add Digits\"></a><a href=\"https://leetcode.com/problems/add-digits/#/description\">Add Digits</a></h3><blockquote>\n<p>给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num &#x3D; 38, 3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2. 返回2。</p>\n</blockquote>\n<p>这里有一个数学公式，wiki上有<a href=\"https://en.wikipedia.org/wiki/Digital_root#Congruence_formula\">digital_root</a>，具体我就没推了，直接用结论：dr(n) &#x3D; 1 + (n - 1) % 9</p>\n","site":{"data":{}},"excerpt":"<p>前段时间面试时算法题做的一塌糊涂，深感自己算法还有很大的不足，所以这周开始在leetcode刷题了。<br>其实早就知道leetcode这个网站，以前大一时都是在OJ刷题，当时都是用C++，后来发现leetcode的题也很全，而且支持Javascript，这点让我很开心，于是就转战leetcode吧！以后基本每天都会刷刷题，练练算法，每周总结一些有意思的题目的思路，也当给自己复习～代码就不贴了。。。</p>","more":"<h3 id=\"Longest-Uncommon-Subsequence-I\"><a href=\"#Longest-Uncommon-Subsequence-I\" class=\"headerlink\" title=\"Longest Uncommon Subsequence I\"></a><a href=\"https://leetcode.com/problems/longest-uncommon-subsequence-i/#/description\">Longest Uncommon Subsequence I</a></h3><blockquote>\n<p>题目描述大概是这样的:给定两个字符串，让你找出两个字符串中的最大不同子字符串的长度。最大不同子字符串的定义是：属于某一个字符串的最大子字符串并且不属于另一个字符串的子字符串。比如说”abcad”, “abcda”这两个字符串的最大不同子字符串就是它们自己任何一个。</p>\n</blockquote>\n<p>开始想着是找最大子字符串用动态规划或者什么的，后来在草稿纸上研究了一下，发现原来就是个简单的找规律：当两个字符串的长度不一样时，最大不同子字符串肯定是二者中长度更长的那个;如果两个字符串长度相同，则判断一下二者是否相等，不等则就是它们的长度，相等则没有。</p>\n<h3 id=\"Isomorphic-Strings\"><a href=\"#Isomorphic-Strings\" class=\"headerlink\" title=\"Isomorphic Strings\"></a><a href=\"https://leetcode.com/problems/isomorphic-strings/#/description\">Isomorphic Strings</a></h3><blockquote>\n<p>题目大意是：给两个字符串，判断二者是否同构。同构的意思就是二者的形式是否相同。比如”abba”和”cddc”就是同构，”abcde”和”abcdf”就不是同构。</p>\n</blockquote>\n<p>一开始没完全理解题意，以为光形式相同就行了，只要用一个数组统计字符串1出现的连续字母长度然后与字符串2比较看字符长度是否相同且顺序一样就行了。但后来发现没有考虑前后字母是否一样，即使长度一样但字母不一样也算匹配失败。后来想了半天才找到一个好的方法：首先二者长度肯定要相同，然后直接O(n)循环一次，用两个类似hashmap数组统计字符串1和字符串2每个字母的最新坐标，如果字符串1和字符串2的第i个字母的坐标不一样则代表匹配失败。</p>\n<h3 id=\"Queue-Reconstruction-by-Height\"><a href=\"#Queue-Reconstruction-by-Height\" class=\"headerlink\" title=\"Queue Reconstruction by Height\"></a><a href=\"https://leetcode.com/problems/queue-reconstruction-by-height/#/description\">Queue Reconstruction by Height</a></h3><blockquote>\n<p>题目大意：给定一个数组，数组中每一个元素都有h,k两个值。h代表该元素的大小，k代表大于等于该元素的h值的元素有多少个。让你重新构造队列使其符合逻辑。</p>\n</blockquote>\n<p>其实这就是一个贪心策略：我们先对整个数组people排序，按h值从高到低来排，如果h值相同，则k值从低到高来排。这样我们向结果数组依次从数组people取剩余最大的元素插入到与该元素的k值相同的位置。这样我们保证了结果数组里面总是剩下的里面最大的，剩下的只要依次按照k值插入合适的位置就行了，因为结果数组里面保证了大于等于每次插入的元素的h值。</p>\n<h3 id=\"Assign-Cookies\"><a href=\"#Assign-Cookies\" class=\"headerlink\" title=\"Assign Cookies\"></a><a href=\"https://leetcode.com/problems/assign-cookies/#/description\">Assign Cookies</a></h3><blockquote>\n<p>题目大意：给两个数组g和s，g[i]代表每个孩子想要吃的蛋糕大小，s[i]代表每个蛋糕的大小，问你怎么分才能使尽可能多的孩子吃到蛋糕。</p>\n</blockquote>\n<p>又是贪心策略：我们先对两个数组排序，然后从g中最小的元素开始，找到s里满足大于等于该元素的最小值，然后从该值的位置接着循环g中下一个元素，直到找不到满足条件或者遍历整个s数组为止，统计满足条件的次数。</p>\n<h3 id=\"Arithmetic-Slices\"><a href=\"#Arithmetic-Slices\" class=\"headerlink\" title=\"Arithmetic Slices\"></a><a href=\"https://leetcode.com/problems/arithmetic-slices/#/description\">Arithmetic Slices</a></h3><blockquote>\n<p>题目大意：给一个数组让你找到里面最多能有几个连续的等差数列。</p>\n</blockquote>\n<p>简单的数学题：我们扫一遍数组，统计每个连续出现的等差数列元素个数，然后该等差数列可以划分成(n-1)*(n-2)&#x2F;2个等差数列，然后把结果累加就行了。</p>\n<h3 id=\"Counting-Bits\"><a href=\"#Counting-Bits\" class=\"headerlink\" title=\"Counting Bits\"></a><a href=\"https://leetcode.com/problems/counting-bits/#/description\">Counting Bits</a></h3><blockquote>\n<p>给定一个数字n统计0～n里每个数字的二进制中1的个数。</p>\n</blockquote>\n<p>主要用到的就是位运算，关键是统计数字的二进制中1的个数，剑指Offer中看到过一个方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(n) &#123;</span><br><span class=\"line\">  count++;</span><br><span class=\"line\">  n = n &amp; (n-<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为n &amp; (n-1)是把n最右边的1去掉，循环多少次，则代表n有多少个1。</p>\n<h3 id=\"Add-Digits\"><a href=\"#Add-Digits\" class=\"headerlink\" title=\"Add Digits\"></a><a href=\"https://leetcode.com/problems/add-digits/#/description\">Add Digits</a></h3><blockquote>\n<p>给一个数字，返回它的每一位相加循环直到结果为个位数的值。例如：num &#x3D; 38, 3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2. 返回2。</p>\n</blockquote>\n<p>这里有一个数学公式，wiki上有<a href=\"https://en.wikipedia.org/wiki/Digital_root#Congruence_formula\">digital_root</a>，具体我就没推了，直接用结论：dr(n) &#x3D; 1 + (n - 1) % 9</p>"},{"title":"浏览器跨域问题","date":"2017-04-10T15:05:26.000Z","_content":"\n最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。\n由于浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：\n<!--more-->\n## document.domain\n我们可以在要传输数据的两个页面设置相同的document.domain=\"www.example.com\"，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如\"www.a.com\"和\"bt.a.com\"，但\"a.com\"和\"b.com\"就不行。\n\n## window.name\n因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。\n\n## CORS\nHTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。\n\n## JSONP\n利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。\n\n## postMessage方法\nHTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。\n接受端通过监听message事件，调用event.data来获取数据。\n","source":"_posts/2017-04-10-cross-origin.md","raw":"---\ntitle: 浏览器跨域问题\ndate: 2017-04-10 23:05:26\ncategories:\n- 网络\ntags:\n- 跨域\n---\n\n最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。\n由于浏览器的[同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：\n<!--more-->\n## document.domain\n我们可以在要传输数据的两个页面设置相同的document.domain=\"www.example.com\"，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如\"www.a.com\"和\"bt.a.com\"，但\"a.com\"和\"b.com\"就不行。\n\n## window.name\n因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。\n\n## CORS\nHTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。\n\n## JSONP\n利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。\n\n## postMessage方法\nHTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。\n接受端通过监听message事件，调用event.data来获取数据。\n","slug":"cross-origin","published":1,"updated":"2022-02-24T02:14:24.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3800090hp3akdy8n1o","content":"<p>最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。<br>由于浏览器的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a>，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：</p>\n<span id=\"more\"></span>\n<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>我们可以在要传输数据的两个页面设置相同的document.domain&#x3D;”<a href=\"http://www.example.com&quot;,使其主域相同.但这只有当两个页面的主域相同时才能设置.比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;,但&quot;a.com&quot;和&quot;b.com&quot;就不行./\">www.example.com&quot;，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;，但&quot;a.com&quot;和&quot;b.com&quot;就不行。</a></p>\n<h2 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a>window.name</h2><p>因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。</p>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>HTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。</p>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p>利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。</p>\n<h2 id=\"postMessage方法\"><a href=\"#postMessage方法\" class=\"headerlink\" title=\"postMessage方法\"></a>postMessage方法</h2><p>HTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。<br>接受端通过监听message事件，调用event.data来获取数据。</p>\n","site":{"data":{}},"excerpt":"<p>最近经常看到有关浏览器跨域的问题，查了很多资料，所以在这总结一下。<br>由于浏览器的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy\">同源策略</a>，当我们想要进行一个ajax请求或者获取其他域名的数据时就会出现跨域问题。避免跨域问题可以有以下几种方法：</p>","more":"<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>我们可以在要传输数据的两个页面设置相同的document.domain&#x3D;”<a href=\"http://www.example.com&quot;,使其主域相同.但这只有当两个页面的主域相同时才能设置.比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;,但&quot;a.com&quot;和&quot;b.com&quot;就不行./\">www.example.com&quot;，使其主域相同。但这只有当两个页面的主域相同时才能设置。比如&quot;www.a.com&quot;和&quot;bt.a.com&quot;，但&quot;a.com&quot;和&quot;b.com&quot;就不行。</a></p>\n<h2 id=\"window-name\"><a href=\"#window-name\" class=\"headerlink\" title=\"window.name\"></a>window.name</h2><p>因为浏览器窗口共用一个window.name，利用这种hack设置window.name为传输的数据，可以在同一个窗口页面内进行数据传输。但缺陷是数据量不会太大，并且只能传输字符串。</p>\n<h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p>HTML5新增的CORS方案。简单来说就是在服务器端设置Access-Control-Allow-Origin：*则代表允许任何域连接，也可以设置为想要连接的域地址。</p>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p>利用script标签的src获取url可以实现跨域，通过在url中设置callback参数，url返回的是json数据，然后在客户端设置回调函数处理数据，就可以实现跨域。但缺点是只能用于get方法。</p>\n<h2 id=\"postMessage方法\"><a href=\"#postMessage方法\" class=\"headerlink\" title=\"postMessage方法\"></a>postMessage方法</h2><p>HTML5新增window.postMessage(message, targetOrigin, [transfer)方法，message代表传输的数据，targetOrigin代表接受的目标域，transfer是可选变量，代表跟随message一起传输的数据，且传输过去后在发送端不再可用。<br>接受端通过监听message事件，调用event.data来获取数据。</p>"},{"title":"Web性能优化方案","date":"2017-04-12T15:05:47.000Z","_content":"\n最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：\n<!--more-->\n* 压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积\n* 合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求\n\n* 使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存\n延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。\n* css放在页面头部，js放在页面底部\n* 能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。\n* 异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。\n* 因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。\n* 第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。\n* 使用localStorage缓存一些静态数据，避免去服务器查询。\n* 静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。\n* 减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。\n","source":"_posts/2017-04-12-webpage-optimize.md","raw":"---\ntitle: Web性能优化方案\ndate: 2017-04-12 23:05:47\ncategories:\n- Web相关\ntags:\n- 性能优化\n---\n\n最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：\n<!--more-->\n* 压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积\n* 合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求\n\n* 使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存\n延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。\n* css放在页面头部，js放在页面底部\n* 能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。\n* 异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。\n* 因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。\n* 第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。\n* 使用localStorage缓存一些静态数据，避免去服务器查询。\n* 静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。\n* 减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。\n","slug":"webpage-optimize","published":1,"updated":"2022-02-24T02:14:24.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3d000c0hp3h21a3niz","content":"<p>最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：</p>\n<span id=\"more\"></span>\n<ul>\n<li><p>压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积</p>\n</li>\n<li><p>合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求</p>\n</li>\n<li><p>使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存<br>延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。</p>\n</li>\n<li><p>css放在页面头部，js放在页面底部</p>\n</li>\n<li><p>能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。</p>\n</li>\n<li><p>异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。</p>\n</li>\n<li><p>因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。</p>\n</li>\n<li><p>第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。</p>\n</li>\n<li><p>使用localStorage缓存一些静态数据，避免去服务器查询。</p>\n</li>\n<li><p>静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。</p>\n</li>\n<li><p>减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近在准备面试，就看了许多关于web性能优化方面的内容，现在先把它们大概记下来，以后还会补充：</p>","more":"<ul>\n<li><p>压缩源码和图片：选择合适图片格式：图片颜色较多就用jpg格式，颜色数较少就用png格式，能通过服务器端判断浏览器支持webP，就用WebP格式和svg格式;开启服务器端Gzip压缩，尽量减少每一个资源的体积</p>\n</li>\n<li><p>合并静态资源：包括css、javascript和小图片，如雪碧图，减少http请求</p>\n</li>\n<li><p>使用CDN：使用第三方提供的静态资源地址。一方面增加并发下载量，另一方面能够和其他网站共享缓存<br>延长静态缓存时间，设置expires、cache-control时间、etag标签，尽量使用强缓存。</p>\n</li>\n<li><p>css放在页面头部，js放在页面底部</p>\n</li>\n<li><p>能使用原生css实现的样式就尽量使用原生css，避免使用雪碧图增加请求。</p>\n</li>\n<li><p>异步加载js，提高首屏加载速度，其他静态资源等到用户需要时再加载。js异步加载可以设置script标签async。</p>\n</li>\n<li><p>因为事件冒泡机制，最好使用事件代理，减少注册监听事件的dom数量，提高性能。</p>\n</li>\n<li><p>第一次加载dom元素后将其用变量缓存，避免下次使用时再重新获取dom元素。</p>\n</li>\n<li><p>使用localStorage缓存一些静态数据，避免去服务器查询。</p>\n</li>\n<li><p>静态资源缓存更新，在更新的文件名后面加上hash值使其url不同而发起新的连接使其缓存更新。</p>\n</li>\n<li><p>减少dom元素，可用到虚拟dom思想，用对象缓存dom树，通过diff算法得到一个 patch，然后最后再渲染真正的dom。</p>\n</li>\n</ul>"},{"title":"2017腾讯前端实习生一面总结","date":"2017-04-13T13:56:46.000Z","_content":"\n> 今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。\n到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：\n<!--more-->\n> 首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。\n然后面试官又问我一些问题：\n  1. 前端路由怎么控制？\n  2. SPA如何管理内存\n  3. 浏览器发送Cookie服务器接收不到什么原因？\n  4. 了解过web性能优化有哪些吗？\n  5. web存储有哪些？\n  6. 跨域方法有哪些？\n  7. 了解哪些web安全问题？\n  8. 如何防止恶意广告、脚本注入？\n  9. CORS方法跨域数据被劫持怎么办？\n  10. 移动端适配怎么做？\n  11. 了解哪些MVVM框架？\n  12. 手机webApp如何与原生App通信？\n  13. Http状态码了解哪些？\n  14. 浏览器缓存问题     \n  中间还问了几个算法问题：\n  1. 写出一个字符串反转函数\n  2. 5分钟内手写二分查找\n  3. 有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。\n\n> 问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。\n之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。\n最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。\n与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。\n\n不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！\n","source":"_posts/2017-04-13-Tecent-Interview-one.md","raw":"---\ntitle: 2017腾讯前端实习生一面总结\ndate: 2017-04-13 21:56:46\ncategories:\n- 面经\ntags:\n- 实习面试\n---\n\n> 今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。\n到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：\n<!--more-->\n> 首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。\n然后面试官又问我一些问题：\n  1. 前端路由怎么控制？\n  2. SPA如何管理内存\n  3. 浏览器发送Cookie服务器接收不到什么原因？\n  4. 了解过web性能优化有哪些吗？\n  5. web存储有哪些？\n  6. 跨域方法有哪些？\n  7. 了解哪些web安全问题？\n  8. 如何防止恶意广告、脚本注入？\n  9. CORS方法跨域数据被劫持怎么办？\n  10. 移动端适配怎么做？\n  11. 了解哪些MVVM框架？\n  12. 手机webApp如何与原生App通信？\n  13. Http状态码了解哪些？\n  14. 浏览器缓存问题     \n  中间还问了几个算法问题：\n  1. 写出一个字符串反转函数\n  2. 5分钟内手写二分查找\n  3. 有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。\n\n> 问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。\n之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。\n最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。\n与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。\n\n不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！\n","slug":"Tecent-Interview-one","published":1,"updated":"2022-02-24T02:14:22.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3f000d0hp34ula6ccr","content":"<blockquote>\n<p>今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。<br>到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。<br>然后面试官又问我一些问题：</p>\n</blockquote>\n<ol>\n<li>前端路由怎么控制？</li>\n<li>SPA如何管理内存</li>\n<li>浏览器发送Cookie服务器接收不到什么原因？</li>\n<li>了解过web性能优化有哪些吗？</li>\n<li>web存储有哪些？</li>\n<li>跨域方法有哪些？</li>\n<li>了解哪些web安全问题？</li>\n<li>如何防止恶意广告、脚本注入？</li>\n<li>CORS方法跨域数据被劫持怎么办？</li>\n<li>移动端适配怎么做？</li>\n<li>了解哪些MVVM框架？</li>\n<li>手机webApp如何与原生App通信？</li>\n<li>Http状态码了解哪些？</li>\n<li>浏览器缓存问题<br>  中间还问了几个算法问题：</li>\n<li>写出一个字符串反转函数</li>\n<li>5分钟内手写二分查找</li>\n<li>有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。</li>\n</ol>\n<blockquote>\n<p>问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。<br>之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。<br>最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。<br>与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。</p>\n</blockquote>\n<p>不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>今天下午赶去参加了腾讯面试。说实话，去之前很紧张，这是我现场面试的第一个大厂，心里还是十分忐忑的。<br>到了后先签到，等了十几分钟后就被叫到了。进去后是一个小哥，先问声好，递上简历，正式开始面试：</p>\n</blockquote>","more":"<blockquote>\n<p>首先让我自我介绍，介绍一下专业、怎么学前端、项目等。我聊到一半后提到JSON，突然打断我让我手写一个原生Ajax，我一时有点懵。。。可能是刚开始没有状态，有点紧张，写的很烂，有些地方还不记得了。。。<br>然后面试官又问我一些问题：</p>\n</blockquote>\n<ol>\n<li>前端路由怎么控制？</li>\n<li>SPA如何管理内存</li>\n<li>浏览器发送Cookie服务器接收不到什么原因？</li>\n<li>了解过web性能优化有哪些吗？</li>\n<li>web存储有哪些？</li>\n<li>跨域方法有哪些？</li>\n<li>了解哪些web安全问题？</li>\n<li>如何防止恶意广告、脚本注入？</li>\n<li>CORS方法跨域数据被劫持怎么办？</li>\n<li>移动端适配怎么做？</li>\n<li>了解哪些MVVM框架？</li>\n<li>手机webApp如何与原生App通信？</li>\n<li>Http状态码了解哪些？</li>\n<li>浏览器缓存问题<br>  中间还问了几个算法问题：</li>\n<li>写出一个字符串反转函数</li>\n<li>5分钟内手写二分查找</li>\n<li>有12个大小一样的球，其中有一个球重量不一样，给你一个天平，保证天平是好的，问最少能称几次找到这个重量不一样的球。我直接想到利用二分的思想，但面试官提醒我不知道这个球是重还是轻，于是我又加一次比较，回答最少4次。</li>\n</ol>\n<blockquote>\n<p>问完这些问题我已经处于懵逼状态了。。。中间有几次都没答出来，考到了很多web安全、移动端的内容，自己了解的还不够。<br>之后面试官又友好的问我老家是哪里的，如果来实习最少能实习多久，突然画风转变让我还有点不适应。<br>最后面试官让我可以问他一个与面试无关的问题，这里我问得不够好，直接问他腾讯主要用的什么技术栈、腾讯前端主要做哪些方面。。。感觉问了相当于白问，每个部门肯定不一样，而且得分不同的情况。总之没有利用好这次提问的机会，有点遗憾。<br>与面试小哥友好的道别后结束了面试。总体来说面试官的态度还是很好的，很多时候很耐心的和我讲清问题，自己还是经验不够，有点紧张了。</p>\n</blockquote>\n<p>不管最后结果如何，让我增长了一次经验，知道了自己的不足，继续努力吧！</p>"},{"title":"浅谈this和call、apply","date":"2017-04-19T13:46:45.000Z","_content":"\nthis的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考\n<!--more-->\n## this的指向\n 一般可分为四种情况：\n   1. 作为普通函数调用：此时this总是指向全局对象，比如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    var getMyName = func.getName;\n    getMyName();  // 输出'Yuk'\n    ```\n   2. 作为对象方法调用：此时this指向该对象，如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    func.getName();  // 输出'Simon'\n    ```\n   3. 构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。\n   4. bind、call、apply方法调用：此时this指向方法中指定的obj。\n\n---\n## call和apply\n  1. call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。\n  2. 当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。\n  3. call和apply的用途：\n   * 改变this的指向\n   * Function.prototype.bind的实现：\n```javascript\nFunction.prototype.bind = function() {\n   var _this = this,   // 保存原函数\n       context = [].shift.call(arguments), // 需要绑定的this的上下文\n       args = [].slice.call(arguments);  // 剩余的参数转成数组\n   return function() {     // 返回一个新的函数\n       return _this.apply(context, [].concat.call(args, [].slice.call(arguments) ) );\n           //执行新的函数的时候，会把之前传入的context当做新函数体内的this\n           //并且组合两次分别传入的参数，作为新函数的参数 \n   };\n};\n```\n   * 借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。\n```javascript\n[].slice.call(arguments);   // 将arguments转换为数组\n[].shift.call(arguments);   // 截去arguments列表中的头一个元素\n[].push.call(arguments, item); // 向arguments里添加新元素\n```\n\n\n","source":"_posts/2017-04-19-GetToKnow-this-call-apply.md","raw":"---\ntitle: 浅谈this和call、apply\ndate: 2017-04-19 21:46:45\ncategories:\n- JS基础\ntags:\n- this\n- call\n- apply\n---\n\nthis的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考\n<!--more-->\n## this的指向\n 一般可分为四种情况：\n   1. 作为普通函数调用：此时this总是指向全局对象，比如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    var getMyName = func.getName;\n    getMyName();  // 输出'Yuk'\n    ```\n   2. 作为对象方法调用：此时this指向该对象，如\n    ```\n    var func = {\n        name: 'Simon',\n        getName: function() {\n            console.log(this.name);\n        }\n    };\n    var name = 'Yuk';\n    func.getName();  // 输出'Simon'\n    ```\n   3. 构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。\n   4. bind、call、apply方法调用：此时this指向方法中指定的obj。\n\n---\n## call和apply\n  1. call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。\n  2. 当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。\n  3. call和apply的用途：\n   * 改变this的指向\n   * Function.prototype.bind的实现：\n```javascript\nFunction.prototype.bind = function() {\n   var _this = this,   // 保存原函数\n       context = [].shift.call(arguments), // 需要绑定的this的上下文\n       args = [].slice.call(arguments);  // 剩余的参数转成数组\n   return function() {     // 返回一个新的函数\n       return _this.apply(context, [].concat.call(args, [].slice.call(arguments) ) );\n           //执行新的函数的时候，会把之前传入的context当做新函数体内的this\n           //并且组合两次分别传入的参数，作为新函数的参数 \n   };\n};\n```\n   * 借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。\n```javascript\n[].slice.call(arguments);   // 将arguments转换为数组\n[].shift.call(arguments);   // 截去arguments列表中的头一个元素\n[].push.call(arguments, item); // 向arguments里添加新元素\n```\n\n\n","slug":"GetToKnow-this-call-apply","published":1,"updated":"2022-02-24T02:14:21.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3g000h0hp35qtbbj9g","content":"<p>this的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考</p>\n<span id=\"more\"></span>\n<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p> 一般可分为四种情况：</p>\n<ol>\n<li>作为普通函数调用：此时this总是指向全局对象，比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">var getMyName = func.getName;</span><br><span class=\"line\">getMyName();  // 输出&#x27;Yuk&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>作为对象方法调用：此时this指向该对象，如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">func.getName();  // 输出&#x27;Simon&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。</li>\n<li>bind、call、apply方法调用：此时this指向方法中指定的obj。</li>\n</ol>\n<hr>\n<h2 id=\"call和apply\"><a href=\"#call和apply\" class=\"headerlink\" title=\"call和apply\"></a>call和apply</h2><ol>\n<li>call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。</li>\n<li>当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。</li>\n<li>call和apply的用途：</li>\n</ol>\n<ul>\n<li>改变this的指向</li>\n<li>Function.prototype.bind的实现：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bind</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> _this = <span class=\"variable language_\">this</span>,   <span class=\"comment\">// 保存原函数</span></span><br><span class=\"line\">       context = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>), <span class=\"comment\">// 需要绑定的this的上下文</span></span><br><span class=\"line\">       args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);  <span class=\"comment\">// 剩余的参数转成数组</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;     <span class=\"comment\">// 返回一个新的函数</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> _this.<span class=\"title function_\">apply</span>(context, [].<span class=\"property\">concat</span>.<span class=\"title function_\">call</span>(args, [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>) ) );</span><br><span class=\"line\">           <span class=\"comment\">//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span></span><br><span class=\"line\">           <span class=\"comment\">//并且组合两次分别传入的参数，作为新函数的参数 </span></span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 将arguments转换为数组</span></span><br><span class=\"line\">[].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 截去arguments列表中的头一个元素</span></span><br><span class=\"line\">[].<span class=\"property\">push</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, item); <span class=\"comment\">// 向arguments里添加新元素</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>this的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考</p>","more":"<h2 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h2><p> 一般可分为四种情况：</p>\n<ol>\n<li>作为普通函数调用：此时this总是指向全局对象，比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">var getMyName = func.getName;</span><br><span class=\"line\">getMyName();  // 输出&#x27;Yuk&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>作为对象方法调用：此时this指向该对象，如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func = &#123;</span><br><span class=\"line\">    name: &#x27;Simon&#x27;,</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var name = &#x27;Yuk&#x27;;</span><br><span class=\"line\">func.getName();  // 输出&#x27;Simon&#x27;</span><br></pre></td></tr></table></figure></li>\n<li>构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。</li>\n<li>bind、call、apply方法调用：此时this指向方法中指定的obj。</li>\n</ol>\n<hr>\n<h2 id=\"call和apply\"><a href=\"#call和apply\" class=\"headerlink\" title=\"call和apply\"></a>call和apply</h2><ol>\n<li>call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。</li>\n<li>当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。</li>\n<li>call和apply的用途：</li>\n</ol>\n<ul>\n<li>改变this的指向</li>\n<li>Function.prototype.bind的实现：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">bind</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> _this = <span class=\"variable language_\">this</span>,   <span class=\"comment\">// 保存原函数</span></span><br><span class=\"line\">       context = [].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>), <span class=\"comment\">// 需要绑定的this的上下文</span></span><br><span class=\"line\">       args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);  <span class=\"comment\">// 剩余的参数转成数组</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;     <span class=\"comment\">// 返回一个新的函数</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> _this.<span class=\"title function_\">apply</span>(context, [].<span class=\"property\">concat</span>.<span class=\"title function_\">call</span>(args, [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>) ) );</span><br><span class=\"line\">           <span class=\"comment\">//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span></span><br><span class=\"line\">           <span class=\"comment\">//并且组合两次分别传入的参数，作为新函数的参数 </span></span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 将arguments转换为数组</span></span><br><span class=\"line\">[].<span class=\"property\">shift</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);   <span class=\"comment\">// 截去arguments列表中的头一个元素</span></span><br><span class=\"line\">[].<span class=\"property\">push</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>, item); <span class=\"comment\">// 向arguments里添加新元素</span></span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"CVTE、阿里一面、去哪儿一面总结","date":"2017-04-16T12:47:22.000Z","copyright":true,"_content":"\n最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。\n<!--more-->\n## CVTE一面、二面（3.28）\n> 上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。\n进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。\n\n> 二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。\n\n> 然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。\n\n## 阿里电话一面（3.28）\n> 没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。\n> 电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。\n> 然后又问了我一些问题：\n    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。\n    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。\n    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。\n    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。\n    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。\n    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。\n    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。\n    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。\n> 然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。\n\n3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！\n总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！\n\n## 去哪儿一面(4.14)\n> 接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。\n> 很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？\n> 我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。\n> 回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。\n","source":"_posts/2017-04-16-Internship-interviews.md","raw":"---\ntitle: CVTE、阿里一面、去哪儿一面总结\ndate: 2017-04-16 20:47:22\ncategories:\n- 面经\ntags:\n- 实习面试\ncopyright: true\n---\n\n最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。\n<!--more-->\n## CVTE一面、二面（3.28）\n> 上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。\n进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。\n\n> 二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。\n\n> 然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。\n\n## 阿里电话一面（3.28）\n> 没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。\n> 电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。\n> 然后又问了我一些问题：\n    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。\n    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。\n    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。\n    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。\n    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。\n    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。\n    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。\n    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。\n> 然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。\n\n3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！\n总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！\n\n## 去哪儿一面(4.14)\n> 接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。\n> 很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？\n> 我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。\n> 回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。\n","slug":"Internship-interviews","published":1,"updated":"2022-02-24T02:46:40.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3i000k0hp3hprghr26","content":"<p>最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。</p>\n<span id=\"more\"></span>\n<h2 id=\"CVTE一面、二面（3-28）\"><a href=\"#CVTE一面、二面（3-28）\" class=\"headerlink\" title=\"CVTE一面、二面（3.28）\"></a>CVTE一面、二面（3.28）</h2><blockquote>\n<p>上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。<br>进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。</p>\n</blockquote>\n<blockquote>\n<p>二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。</p>\n</blockquote>\n<blockquote>\n<p>然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。</p>\n</blockquote>\n<h2 id=\"阿里电话一面（3-28）\"><a href=\"#阿里电话一面（3-28）\" class=\"headerlink\" title=\"阿里电话一面（3.28）\"></a>阿里电话一面（3.28）</h2><blockquote>\n<p>没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。<br>电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。<br>然后又问了我一些问题：<br>    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。<br>    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。<br>    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。<br>    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。<br>    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。<br>    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。<br>    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。<br>    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。<br>然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。</p>\n</blockquote>\n<p>3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！<br>总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！</p>\n<h2 id=\"去哪儿一面-4-14\"><a href=\"#去哪儿一面-4-14\" class=\"headerlink\" title=\"去哪儿一面(4.14)\"></a>去哪儿一面(4.14)</h2><blockquote>\n<p>接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。<br>很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？<br>我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。<br>回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。</p>","more":"<h2 id=\"CVTE一面、二面（3-28）\"><a href=\"#CVTE一面、二面（3-28）\" class=\"headerlink\" title=\"CVTE一面、二面（3.28）\"></a>CVTE一面、二面（3.28）</h2><blockquote>\n<p>上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。<br>进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。</p>\n</blockquote>\n<blockquote>\n<p>二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。</p>\n</blockquote>\n<blockquote>\n<p>然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。</p>\n</blockquote>\n<h2 id=\"阿里电话一面（3-28）\"><a href=\"#阿里电话一面（3-28）\" class=\"headerlink\" title=\"阿里电话一面（3.28）\"></a>阿里电话一面（3.28）</h2><blockquote>\n<p>没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。<br>电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。<br>然后又问了我一些问题：<br>    1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。<br>    2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。<br>    3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。<br>    4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。<br>    5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。<br>    6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。<br>    7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。<br>    8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。<br>然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。</p>\n</blockquote>\n<p>3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！<br>总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！</p>\n<h2 id=\"去哪儿一面-4-14\"><a href=\"#去哪儿一面-4-14\" class=\"headerlink\" title=\"去哪儿一面(4.14)\"></a>去哪儿一面(4.14)</h2><blockquote>\n<p>接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。<br>很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？<br>我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。<br>回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。</p>\n</blockquote>"},{"title":"2017腾讯前端实习生二面+HR面总结","date":"2017-04-16T11:16:23.000Z","_content":"## 二面（4.15）\n> 很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。\n<!--more-->\n> 终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~\n介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。接着面试官开始问我一些基础知识：\n  1. 了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对\n  2. 操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。\n  3. 递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。\n  4. 了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。\n  5. 了解TCP有什么延迟机制吗？我就说了TCP的慢启动。\n> 问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。\n> 回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。\n> 希望自己能进入HR面吧！焦急等待中。。。\n\n## HR面（4.16）\n> 今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。\n> 去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。\n到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：\n    1. 你是哪里人？\n    2. 你最想去哪个城市工作？回答当然是深圳。\n    3. 你是怎么学习前端的？\n    4. 你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。\n    5. 你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。\n    6. 你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。\n    7. 你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。\n    8. 你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。\n    9. 你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。\n    10. 实习时间可以从什么时候开始？\n> 问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。\n\n## 总结\n经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！\n","source":"_posts/2017-04-16-Tecent-Interview-Second.md","raw":"---\ntitle: 2017腾讯前端实习生二面+HR面总结\ndate: 2017-04-16 19:16:23\ncategories:\n- 面经\ntags:\n- 实习面试\n---\n## 二面（4.15）\n> 很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。\n<!--more-->\n> 终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~\n介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。接着面试官开始问我一些基础知识：\n  1. 了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对\n  2. 操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。\n  3. 递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。\n  4. 了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。\n  5. 了解TCP有什么延迟机制吗？我就说了TCP的慢启动。\n> 问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。\n> 回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。\n> 希望自己能进入HR面吧！焦急等待中。。。\n\n## HR面（4.16）\n> 今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。\n> 去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。\n到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：\n    1. 你是哪里人？\n    2. 你最想去哪个城市工作？回答当然是深圳。\n    3. 你是怎么学习前端的？\n    4. 你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。\n    5. 你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。\n    6. 你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。\n    7. 你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。\n    8. 你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。\n    9. 你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。\n    10. 实习时间可以从什么时候开始？\n> 问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。\n\n## 总结\n经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！\n","slug":"Tecent-Interview-Second","published":1,"updated":"2022-02-24T02:14:21.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3o000p0hp3e4t112bk","content":"<h2 id=\"二面（4-15）\"><a href=\"#二面（4-15）\" class=\"headerlink\" title=\"二面（4.15）\"></a>二面（4.15）</h2><blockquote>\n<p>很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。</p>\n</blockquote>\n<span id=\"more\"></span>\n<blockquote>\n<p>终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~<br>介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。接着面试官开始问我一些基础知识：</p>\n</blockquote>\n<ol>\n<li>了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对</li>\n<li>操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。</li>\n<li>递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。</li>\n<li>了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。</li>\n<li>了解TCP有什么延迟机制吗？我就说了TCP的慢启动。<blockquote>\n<p>问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。<br>回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。<br>希望自己能进入HR面吧！焦急等待中。。。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"HR面（4-16）\"><a href=\"#HR面（4-16）\" class=\"headerlink\" title=\"HR面（4.16）\"></a>HR面（4.16）</h2><blockquote>\n<p>今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。<br>去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。<br>到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：<br>    1. 你是哪里人？<br>    2. 你最想去哪个城市工作？回答当然是深圳。<br>    3. 你是怎么学习前端的？<br>    4. 你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。<br>    5. 你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。<br>    6. 你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。<br>    7. 你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。<br>    8. 你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。<br>    9. 你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。<br>    10. 实习时间可以从什么时候开始？<br>问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"二面（4-15）\"><a href=\"#二面（4-15）\" class=\"headerlink\" title=\"二面（4.15）\"></a>二面（4.15）</h2><blockquote>\n<p>很幸运过了一面，二面之前异常紧张，中午又吃错东西了。。。导致下午开始胃疼。火急火燎地在规定的15:20之前赶到了面试地点，签了到后就在那等。没想到等了一个小时。。期间的心情非常难熬。</p>\n</blockquote>","more":"<blockquote>\n<p>终于到我了，上楼去面试。先敲门，面试官说请进后走了进去。发现是一个略胖的中年大哥，之前就听说过二面一般是总监面，会比较严格。一进去果然领略到了。面试官先看了看他手中的简历，可能是一面的面试官给他的我的介绍。然后让我介绍一下自己的学习过程和做过的项目。于是我就开始滔滔不绝地讲起来，期间面试官不时地点头让我觉得是赞许，信心也增加了不少，越说越来劲~~<br>介绍完项目后，面试官直接问我你搞过ACM是吧，我说是的。于是他直接让我做两道算法题：一道是二叉排序树的插入算法，这个比较简单，之前也写过很多次了，但谨慎起见，我还是认真地在纸上手写代码，检查无误后才给面试官看。面试官看完后让我讲讲思路，我又给他讲了，估计讲的还不错。他又给了我一个算法题：找出二叉树中两个节点间的最大距离。我愣着头写了十分钟左右，写完后给面试官看，他提示我不一定经过根节点，我没考虑到这层，他让我直接讲怎么改，这里我突然有点慌，因为之前没考虑到这种情况，简单的说了一下，面试官说好吧，你的思路大致没问题，就是有些情况没考虑到，稍微完善一下就好了。我感觉他的语气还算和蔼，心里放松了一大半。面试官突然说你的算法能力在前端里算不错的了，听到这句我心里高兴了不少，看来算法没白学。他让我介绍一下当初是怎么想到学算法的，我简单的说了一下。接着面试官开始问我一些基础知识：</p>\n</blockquote>\n<ol>\n<li>了解虚函数吗？我想这不是C++的内容吗。。。早忘了~~于是就坦白地说自己不怎么记得了，面试官说没事知道多少说多少，我也就随便说了一些，估计也没说对</li>\n<li>操作系统中的堆和栈是怎么分配的，我先解释了一下什么是堆和栈，然后面试官说具体是怎么分配变量之类的。我回答变量一般是存储到栈里面，而函数、对象、指针等引用类型则是存到堆里面。</li>\n<li>递归和循环哪个性能更好？这个很多书上都说过，就直接回答了。</li>\n<li>了解NodeJS吗？它的优势是什么？我说实话，了解不多，但还是扯了一些，并说NodeJS是用JavaScript写的，与前端所用的语言一样，这样利于前后端通信和接口调用之类的。</li>\n<li>了解TCP有什么延迟机制吗？我就说了TCP的慢启动。<blockquote>\n<p>问完这些问题，面试官又问了我去实习能实习多久，我回答了之后就说今天的面试结束了，明天上午出结果，让我回去等。我连说谢谢，然后离开了。<br>回去以后心情还是不错的。感觉这次面试是我几次面试以来发挥最好的一次，基本上问到的内容都回答上来了。但很奇怪的是二面没有想象中的什么压力面，问的东西和前端的内容关系也不是很大，问的都是算法、操作系统等内容，还好我之前也了解过这方面。看来腾讯对前端的计算机基础要求还是挺高的。总体感觉还是不错的，就是想吐槽一下面试官全程毫无表情让我有点难受。。。<br>希望自己能进入HR面吧！焦急等待中。。。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"HR面（4-16）\"><a href=\"#HR面（4-16）\" class=\"headerlink\" title=\"HR面（4.16）\"></a>HR面（4.16）</h2><blockquote>\n<p>今天上午收到通知，下午14：30去面试，让我兴奋不已，二面好歹是过了。听说HR面不会刷人，但我还是不能掉以轻心，随便应付了事，毕竟都到这了，心里还是有些小期待的。但是自己之前没有HR面的经验，也不知道问什么。。。在网上看了几篇面经就匆匆赶去面试了。<br>去到面试休息区，人比之前又少了一半，我大概估计了一下，不到二十人，感觉自己真是幸运的！签到后等了快半个小时终于轮到我了。<br>到了房间后敲门进去，发现是一个年轻小哥坐在那（说好的HR小姐姐呢～～），跟预期的不一样，不过也只好硬着头皮上了。上去先递简历，面试官看了看，开始问我问题：<br>    1. 你是哪里人？<br>    2. 你最想去哪个城市工作？回答当然是深圳。<br>    3. 你是怎么学习前端的？<br>    4. 你在校的成绩怎么样？排名多少？我只能老实告诉中等水平。。。又问我你觉得为什么成绩不是特别好呢？这个就根据自己的想法回答了。<br>    5. 你认为前端需要掌握哪些技能？回答了硬技能和软技能之类的。<br>    6. 你自己或者别人对你的形容词有哪些？这个我也没怎么准备，就边想边说了，扯的内容也比较多，能想到的都说了。<br>    7. 你也看到了一面那么多人，到最后只有这么少人，你认为是什么让你能够脱颖而出走到这里的？这个问题很尖锐，我也没敢去怎么吹嘘自己，就实话实说，实力加运气吧。<br>    8. 你还有拿到其他offer吗？老实说这让我有点尴尬，我也就实话实说还没有，并如实地告诉还投了哪些公司，面试官着重问了有没有投阿里。。。<br>    9. 你有想过考研吗？为什么？这个问题我自己也想过很多，所以就脱口而出了。<br>    10. 实习时间可以从什么时候开始？<br>问得差不多了，面试官让我可以问他几个问题，我开始还没准备好，就随便问了几个：我面的是哪个部门？（面试官表示很惊讶，面了这么久还不知道自己面的是哪个事业群，我可能是第一人。。。告诉了我是SNG）腾讯的实习生工作环境是怎样的？住宿方面如何？作为过来人对我们新人有什么建议？问了这些，我又作死问了一下对我今天面试的评价如何？问完就感觉不该问，面试官还是友好的告诉了我，说我太实诚了，告诉了他很多东西。。。我也不知道这是夸奖还是什么，只能跟着笑了笑。。。最后问多久能知道结果，HR告诉我大概两周之内。HR面就这么结束了。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>经过了三天的面试，感觉整个人都脱了一层皮，每天都是不停奔波，总算是结束了，但收获也很多。首先技术面让我知道了自己还有哪些不足，以后的发展方向也更加明确，当然也给了自己信心，至少自己还是有一定实力的～～HR面则就相当于聊天一样，我也没想太多，有什么说什么了。。。我不知道这样是否好，但我也不会那些所谓的面试套路。不管怎样，腾讯的面试结束了，从笔试到面试，经历了最开始的不在意，到后来焦急地准备面试，到后来慢慢心态放松，以平常心去面对。不管结果怎样，这次面试是一次很好的经历。之后的事情就是最难熬的等结果了，我也尽量不去想太多吧，得之我幸，失之我命！</p>"},{"title":"http状态码记录","date":"2017-04-23T09:57:31.000Z","_content":"\n近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。\n<!--more-->\n## 100～199：信息性状态码\n* 100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。\n\n## 200～299：成功状态码\n* 200 OK，代表请求没问题，返回的主体包含请求资源\n* 202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。\n* 204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面\n\n## 300～399：重定向状态码\n* 301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL\n* 302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP/1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。\n* 303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求\n* 304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。\n* 307 Temporary Redirect，HTTP1.1客户端用307状态码取代302\n\n## 400～499：客户端错误状态码\n* 400 Bad Request，客户端发送了错误请求\n* 401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。\n* 403 Forbidden，说明请求被服务器拒绝了\n* 404 Not Found，说明服务器无法找到所请求的URL\n* 405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。\n* 406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源\n* 408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。\n\n## 500～599：服务器错误状态码\n* 500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误\n* 501 Not Implemented，客户端发起的请求超出服务器的能力范围\n* 502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误\n* 503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务\n","source":"_posts/2017-04-23-http-status-codes-marks.md","raw":"---\ntitle: http状态码记录\ndate: 2017-04-23 17:57:31\ncategories:\n- 网络\ntags:\n- http状态码\n---\n\n近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。\n<!--more-->\n## 100～199：信息性状态码\n* 100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。\n\n## 200～299：成功状态码\n* 200 OK，代表请求没问题，返回的主体包含请求资源\n* 202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。\n* 204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面\n\n## 300～399：重定向状态码\n* 301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL\n* 302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP/1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。\n* 303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求\n* 304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。\n* 307 Temporary Redirect，HTTP1.1客户端用307状态码取代302\n\n## 400～499：客户端错误状态码\n* 400 Bad Request，客户端发送了错误请求\n* 401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。\n* 403 Forbidden，说明请求被服务器拒绝了\n* 404 Not Found，说明服务器无法找到所请求的URL\n* 405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。\n* 406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源\n* 408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。\n\n## 500～599：服务器错误状态码\n* 500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误\n* 501 Not Implemented，客户端发起的请求超出服务器的能力范围\n* 502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误\n* 503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务\n","slug":"http-status-codes-marks","published":1,"updated":"2022-02-24T02:14:18.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3r000r0hp3fyuxgud0","content":"<p>近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。</p>\n<span id=\"more\"></span>\n<h2 id=\"100～199：信息性状态码\"><a href=\"#100～199：信息性状态码\" class=\"headerlink\" title=\"100～199：信息性状态码\"></a>100～199：信息性状态码</h2><ul>\n<li>100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。</li>\n</ul>\n<h2 id=\"200～299：成功状态码\"><a href=\"#200～299：成功状态码\" class=\"headerlink\" title=\"200～299：成功状态码\"></a>200～299：成功状态码</h2><ul>\n<li>200 OK，代表请求没问题，返回的主体包含请求资源</li>\n<li>202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。</li>\n<li>204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面</li>\n</ul>\n<h2 id=\"300～399：重定向状态码\"><a href=\"#300～399：重定向状态码\" class=\"headerlink\" title=\"300～399：重定向状态码\"></a>300～399：重定向状态码</h2><ul>\n<li>301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL</li>\n<li>302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP&#x2F;1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。</li>\n<li>303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求</li>\n<li>304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。</li>\n<li>307 Temporary Redirect，HTTP1.1客户端用307状态码取代302</li>\n</ul>\n<h2 id=\"400～499：客户端错误状态码\"><a href=\"#400～499：客户端错误状态码\" class=\"headerlink\" title=\"400～499：客户端错误状态码\"></a>400～499：客户端错误状态码</h2><ul>\n<li>400 Bad Request，客户端发送了错误请求</li>\n<li>401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</li>\n<li>403 Forbidden，说明请求被服务器拒绝了</li>\n<li>404 Not Found，说明服务器无法找到所请求的URL</li>\n<li>405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。</li>\n<li>406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源</li>\n<li>408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。</li>\n</ul>\n<h2 id=\"500～599：服务器错误状态码\"><a href=\"#500～599：服务器错误状态码\" class=\"headerlink\" title=\"500～599：服务器错误状态码\"></a>500～599：服务器错误状态码</h2><ul>\n<li>500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误</li>\n<li>501 Not Implemented，客户端发起的请求超出服务器的能力范围</li>\n<li>502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误</li>\n<li>503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。</p>","more":"<h2 id=\"100～199：信息性状态码\"><a href=\"#100～199：信息性状态码\" class=\"headerlink\" title=\"100～199：信息性状态码\"></a>100～199：信息性状态码</h2><ul>\n<li>100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。</li>\n</ul>\n<h2 id=\"200～299：成功状态码\"><a href=\"#200～299：成功状态码\" class=\"headerlink\" title=\"200～299：成功状态码\"></a>200～299：成功状态码</h2><ul>\n<li>200 OK，代表请求没问题，返回的主体包含请求资源</li>\n<li>202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。</li>\n<li>204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面</li>\n</ul>\n<h2 id=\"300～399：重定向状态码\"><a href=\"#300～399：重定向状态码\" class=\"headerlink\" title=\"300～399：重定向状态码\"></a>300～399：重定向状态码</h2><ul>\n<li>301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL</li>\n<li>302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP&#x2F;1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。</li>\n<li>303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求</li>\n<li>304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。</li>\n<li>307 Temporary Redirect，HTTP1.1客户端用307状态码取代302</li>\n</ul>\n<h2 id=\"400～499：客户端错误状态码\"><a href=\"#400～499：客户端错误状态码\" class=\"headerlink\" title=\"400～499：客户端错误状态码\"></a>400～499：客户端错误状态码</h2><ul>\n<li>400 Bad Request，客户端发送了错误请求</li>\n<li>401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</li>\n<li>403 Forbidden，说明请求被服务器拒绝了</li>\n<li>404 Not Found，说明服务器无法找到所请求的URL</li>\n<li>405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。</li>\n<li>406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源</li>\n<li>408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。</li>\n</ul>\n<h2 id=\"500～599：服务器错误状态码\"><a href=\"#500～599：服务器错误状态码\" class=\"headerlink\" title=\"500～599：服务器错误状态码\"></a>500～599：服务器错误状态码</h2><ul>\n<li>500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误</li>\n<li>501 Not Implemented，客户端发起的请求超出服务器的能力范围</li>\n<li>502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误</li>\n<li>503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务</li>\n</ul>"},{"title":"浅谈函数节流与函数去抖","date":"2017-05-01T11:37:31.000Z","_content":"\n函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\n---\n<!--more-->\n# 函数节流:throttle\n## 函数节流的目的\n有些函数不是由用户直接控制触发的，函数有可能被**频繁地调用**而导致性能问题。一些常见的函数被频繁调用场景：\n- window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。\n- mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。\n- 键盘keydown监听\n> 我们的目的就是减少函数触发的频率\n\n## 函数节流原理\n我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。\n```javascript\nvar throttle = function ( fn, delay ) {\n    var _self = fn,             // 保存将要延迟执行的函数\n          timer,                    // 定时器\n          first_time = true;  // 是否第一次调用\n\n    return function () {\n        var args = [].slice.call(arguments),\n              _me = this;\n        if ( first_time ) {     // 如果第一次执行则直接调用\n            _self.apply( _me, args );\n            return first_time = false;\n        }\n        if( timer ) {           // 如果timer存在说明之前延迟的函数还没有执行\n            return false;\n        }\n        timer = setTimeout( function () {\n            clearTimeout( timer );\n            timer = null;\n            _self.apply( _me, args );\n        }, delay );\n    };\n};\n\nwindow.onscroll = throttle( function () {\n    console.log(\"has changed\");\n}, 500 );\n```\n\n# 函数去抖:debounce\n## 函数去抖的目的\n函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：\n- 文字输入监听\n- onscroll事件\n- onresize事件。\n## 函数去抖原理\n也是利用setTimeout和闭包的原理。\n```javascript\nvar debounce = function ( fn, delay ) {\n    var context,\n          args,\n          timer;\n    return function () {\n        context = this, args = [].slice.call(arguments);\n        if( timer ) {\n            clearTimeout( timer );\n        }\n        timer = setTimeout( function () {\n            fn.apply( context, args );\n        }, delay );\n    };\n};\n\nwindow.onresize = debounce( function () {\n    console.log(\"has changed\");\n}, 600 );\n```\n# underscore源码\nunderscore里对throttle和debounce有更完整的实现，这里把代码贴出来\n- throttle\n```javascript\n_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n };\n```\n\n- debounce\n```javascript\n_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;       // 上一次函数触发的时间\n\n      if (last < wait && last >= 0) {       // 如果没有到达规定的wait时间则继续延迟，相当于计时器\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {        // 如果是立即调用或者上一次函数已经调用完毕\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n };\n```\n","source":"_posts/2017-05-01-throttle-debounce.md","raw":"---\ntitle: 浅谈函数节流与函数去抖\ndate: 2017-05-01 19:37:31\ncategories:\n- JS基础\ntags:\n- Function\n- throttle\n- debounce\n---\n\n函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\n---\n<!--more-->\n# 函数节流:throttle\n## 函数节流的目的\n有些函数不是由用户直接控制触发的，函数有可能被**频繁地调用**而导致性能问题。一些常见的函数被频繁调用场景：\n- window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。\n- mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。\n- 键盘keydown监听\n> 我们的目的就是减少函数触发的频率\n\n## 函数节流原理\n我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。\n```javascript\nvar throttle = function ( fn, delay ) {\n    var _self = fn,             // 保存将要延迟执行的函数\n          timer,                    // 定时器\n          first_time = true;  // 是否第一次调用\n\n    return function () {\n        var args = [].slice.call(arguments),\n              _me = this;\n        if ( first_time ) {     // 如果第一次执行则直接调用\n            _self.apply( _me, args );\n            return first_time = false;\n        }\n        if( timer ) {           // 如果timer存在说明之前延迟的函数还没有执行\n            return false;\n        }\n        timer = setTimeout( function () {\n            clearTimeout( timer );\n            timer = null;\n            _self.apply( _me, args );\n        }, delay );\n    };\n};\n\nwindow.onscroll = throttle( function () {\n    console.log(\"has changed\");\n}, 500 );\n```\n\n# 函数去抖:debounce\n## 函数去抖的目的\n函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：\n- 文字输入监听\n- onscroll事件\n- onresize事件。\n## 函数去抖原理\n也是利用setTimeout和闭包的原理。\n```javascript\nvar debounce = function ( fn, delay ) {\n    var context,\n          args,\n          timer;\n    return function () {\n        context = this, args = [].slice.call(arguments);\n        if( timer ) {\n            clearTimeout( timer );\n        }\n        timer = setTimeout( function () {\n            fn.apply( context, args );\n        }, delay );\n    };\n};\n\nwindow.onresize = debounce( function () {\n    console.log(\"has changed\");\n}, 600 );\n```\n# underscore源码\nunderscore里对throttle和debounce有更完整的实现，这里把代码贴出来\n- throttle\n```javascript\n_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n };\n```\n\n- debounce\n```javascript\n_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;       // 上一次函数触发的时间\n\n      if (last < wait && last >= 0) {       // 如果没有到达规定的wait时间则继续延迟，相当于计时器\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {        // 如果是立即调用或者上一次函数已经调用完毕\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n };\n```\n","slug":"throttle-debounce","published":1,"updated":"2022-02-24T02:14:18.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3u000v0hp3exzs3l1x","content":"<h2 id=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"><a href=\"#函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\" class=\"headerlink\" title=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"></a>函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。</h2><span id=\"more\"></span>\n<h1 id=\"函数节流-throttle\"><a href=\"#函数节流-throttle\" class=\"headerlink\" title=\"函数节流:throttle\"></a>函数节流:throttle</h1><h2 id=\"函数节流的目的\"><a href=\"#函数节流的目的\" class=\"headerlink\" title=\"函数节流的目的\"></a>函数节流的目的</h2><p>有些函数不是由用户直接控制触发的，函数有可能被<strong>频繁地调用</strong>而导致性能问题。一些常见的函数被频繁调用场景：</p>\n<ul>\n<li>window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。</li>\n<li>mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。</li>\n<li>键盘keydown监听<blockquote>\n<p>我们的目的就是减少函数触发的频率</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"函数节流原理\"><a href=\"#函数节流原理\" class=\"headerlink\" title=\"函数节流原理\"></a>函数节流原理</h2><p>我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _self = fn,             <span class=\"comment\">// 保存将要延迟执行的函数</span></span><br><span class=\"line\">          timer,                    <span class=\"comment\">// 定时器</span></span><br><span class=\"line\">          first_time = <span class=\"literal\">true</span>;  <span class=\"comment\">// 是否第一次调用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>),</span><br><span class=\"line\">              _me = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( first_time ) &#123;     <span class=\"comment\">// 如果第一次执行则直接调用</span></span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_time = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;           <span class=\"comment\">// 如果timer存在说明之前延迟的函数还没有执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"title function_\">throttle</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span> );</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数去抖-debounce\"><a href=\"#函数去抖-debounce\" class=\"headerlink\" title=\"函数去抖:debounce\"></a>函数去抖:debounce</h1><h2 id=\"函数去抖的目的\"><a href=\"#函数去抖的目的\" class=\"headerlink\" title=\"函数去抖的目的\"></a>函数去抖的目的</h2><p>函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：</p>\n<ul>\n<li><p>文字输入监听</p>\n</li>\n<li><p>onscroll事件</p>\n</li>\n<li><p>onresize事件。</p>\n<h2 id=\"函数去抖原理\"><a href=\"#函数去抖原理\" class=\"headerlink\" title=\"函数去抖原理\"></a>函数去抖原理</h2><p>也是利用setTimeout和闭包的原理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context,</span><br><span class=\"line\">          args,</span><br><span class=\"line\">          timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        context = <span class=\"variable language_\">this</span>, args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>( context, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onresize</span> = <span class=\"title function_\">debounce</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">600</span> );</span><br></pre></td></tr></table></figure>\n<h1 id=\"underscore源码\"><a href=\"#underscore源码\" class=\"headerlink\" title=\"underscore源码\"></a>underscore源码</h1><p>underscore里对throttle和debounce有更完整的实现，这里把代码贴出来</p>\n</li>\n<li><p>throttle</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">throttle</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context, args, result;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      previous = options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> now = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!previous &amp;&amp; options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">          timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = now;</span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.<span class=\"property\">trailing</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>debounce</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">debounce</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> last = _.<span class=\"title function_\">now</span>() - timestamp;       <span class=\"comment\">// 上一次函数触发的时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class=\"number\">0</span>) &#123;       <span class=\"comment\">// 如果没有到达规定的wait时间则继续延迟，相当于计时器</span></span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, wait - last);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">          result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      timestamp = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) &#123;        <span class=\"comment\">// 如果是立即调用或者上一次函数已经调用完毕</span></span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"><a href=\"#函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\" class=\"headerlink\" title=\"函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。\"></a>函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。</h2>","more":"<h1 id=\"函数节流-throttle\"><a href=\"#函数节流-throttle\" class=\"headerlink\" title=\"函数节流:throttle\"></a>函数节流:throttle</h1><h2 id=\"函数节流的目的\"><a href=\"#函数节流的目的\" class=\"headerlink\" title=\"函数节流的目的\"></a>函数节流的目的</h2><p>有些函数不是由用户直接控制触发的，函数有可能被<strong>频繁地调用</strong>而导致性能问题。一些常见的函数被频繁调用场景：</p>\n<ul>\n<li>window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。</li>\n<li>mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。</li>\n<li>键盘keydown监听<blockquote>\n<p>我们的目的就是减少函数触发的频率</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"函数节流原理\"><a href=\"#函数节流原理\" class=\"headerlink\" title=\"函数节流原理\"></a>函数节流原理</h2><p>我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _self = fn,             <span class=\"comment\">// 保存将要延迟执行的函数</span></span><br><span class=\"line\">          timer,                    <span class=\"comment\">// 定时器</span></span><br><span class=\"line\">          first_time = <span class=\"literal\">true</span>;  <span class=\"comment\">// 是否第一次调用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>),</span><br><span class=\"line\">              _me = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( first_time ) &#123;     <span class=\"comment\">// 如果第一次执行则直接调用</span></span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first_time = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;           <span class=\"comment\">// 如果timer存在说明之前延迟的函数还没有执行</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            _self.<span class=\"title function_\">apply</span>( _me, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onscroll</span> = <span class=\"title function_\">throttle</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span> );</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"函数去抖-debounce\"><a href=\"#函数去抖-debounce\" class=\"headerlink\" title=\"函数去抖:debounce\"></a>函数去抖:debounce</h1><h2 id=\"函数去抖的目的\"><a href=\"#函数去抖的目的\" class=\"headerlink\" title=\"函数去抖的目的\"></a>函数去抖的目的</h2><p>函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：</p>\n<ul>\n<li><p>文字输入监听</p>\n</li>\n<li><p>onscroll事件</p>\n</li>\n<li><p>onresize事件。</p>\n<h2 id=\"函数去抖原理\"><a href=\"#函数去抖原理\" class=\"headerlink\" title=\"函数去抖原理\"></a>函数去抖原理</h2><p>也是利用setTimeout和闭包的原理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> debounce = <span class=\"keyword\">function</span> (<span class=\"params\"> fn, delay </span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context,</span><br><span class=\"line\">          args,</span><br><span class=\"line\">          timer;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        context = <span class=\"variable language_\">this</span>, args = [].<span class=\"property\">slice</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( timer ) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>( timer );</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = <span class=\"built_in\">setTimeout</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            fn.<span class=\"title function_\">apply</span>( context, args );</span><br><span class=\"line\">        &#125;, delay );</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">onresize</span> = <span class=\"title function_\">debounce</span>( <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;has changed&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">600</span> );</span><br></pre></td></tr></table></figure>\n<h1 id=\"underscore源码\"><a href=\"#underscore源码\" class=\"headerlink\" title=\"underscore源码\"></a>underscore源码</h1><p>underscore里对throttle和debounce有更完整的实现，这里把代码贴出来</p>\n</li>\n<li><p>throttle</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">throttle</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context, args, result;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      previous = options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> now = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!previous &amp;&amp; options.<span class=\"property\">leading</span> === <span class=\"literal\">false</span>) previous = now;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> remaining = wait - (now - previous);</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timeout) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">          timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        previous = now;</span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.<span class=\"property\">trailing</span> !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>debounce</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.<span class=\"property\">debounce</span> = <span class=\"keyword\">function</span>(<span class=\"params\">func, wait, immediate</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout, args, context, timestamp, result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> later = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> last = _.<span class=\"title function_\">now</span>() - timestamp;       <span class=\"comment\">// 上一次函数触发的时间</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class=\"number\">0</span>) &#123;       <span class=\"comment\">// 如果没有到达规定的wait时间则继续延迟，相当于计时器</span></span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(later, wait - last);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">          result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!timeout) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      context = <span class=\"variable language_\">this</span>;</span><br><span class=\"line\">      args = <span class=\"variable language_\">arguments</span>;</span><br><span class=\"line\">      timestamp = _.<span class=\"title function_\">now</span>();</span><br><span class=\"line\">      <span class=\"keyword\">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timeout) timeout = <span class=\"built_in\">setTimeout</span>(later, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) &#123;        <span class=\"comment\">// 如果是立即调用或者上一次函数已经调用完毕</span></span><br><span class=\"line\">        result = func.<span class=\"title function_\">apply</span>(context, args);</span><br><span class=\"line\">        context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"最近一段时间的总结","date":"2017-05-10T12:53:14.000Z","_content":"\n最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。\n<!--more-->\n\n# 前端学习\n> 自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。\n> 不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：\n\n## JS基础\n- 继续阅读《You don't know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图\n- 完成FreeCodeCamp项目练习\n- 练习百度前端学院有关项目\n\n## CSS基础\n- 阅读《CSS揭秘》\n- 阅读图书馆借阅的设计方面相关书籍\n- 在项目中模仿别人的页面设计\n- 掌握bootstrap\n\n## 工程化\n- 掌握webpack的基本使用和配置\n- 会用gulp\n- 了解mocha测试工具\n- 多了解前端性能优化\n- 学会如何测试、发布上线项目\n- 学会写文档\n\n## 计算机基础\n- leetcode刷题\n- 阅读算法导论\n- 阅读http、tcp有关书籍\n\n## 框架学习\n- 通过阅读别人的React项目学习React基本结构和方法\n- 自己开始用React+Redux+React-router模仿着写小组件\n- 掌握React、Vue框架核心思想和区别\n- 最好能阅读React源码分析\n\n## 阅读源码\n- 阅读underscore源码\n- 阅读jQuery源码\n- 阅读Backbone源码\n---\n\n# 规划生活\n感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。\n- 首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。\n- 上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。\n- 下午联系驾校练车，争取半个多月拿到证。\n- 练完车后去锻炼锻炼，跑步或者打球。\n- 晚上是码代码时间。\n- 22：00后写博客总结一下当天的心得。\n- 23：30上床\n\n> 总之，让生活充实起来，做到学习娱乐两不误！\n","source":"_posts/2017-05-10-Summary.md","raw":"---\ntitle: 最近一段时间的总结\ndate: 2017-05-10 20:53:14\ncategories:\n- 随笔\ntags:\n- thoughts\n---\n\n最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。\n<!--more-->\n\n# 前端学习\n> 自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。\n> 不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：\n\n## JS基础\n- 继续阅读《You don't know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图\n- 完成FreeCodeCamp项目练习\n- 练习百度前端学院有关项目\n\n## CSS基础\n- 阅读《CSS揭秘》\n- 阅读图书馆借阅的设计方面相关书籍\n- 在项目中模仿别人的页面设计\n- 掌握bootstrap\n\n## 工程化\n- 掌握webpack的基本使用和配置\n- 会用gulp\n- 了解mocha测试工具\n- 多了解前端性能优化\n- 学会如何测试、发布上线项目\n- 学会写文档\n\n## 计算机基础\n- leetcode刷题\n- 阅读算法导论\n- 阅读http、tcp有关书籍\n\n## 框架学习\n- 通过阅读别人的React项目学习React基本结构和方法\n- 自己开始用React+Redux+React-router模仿着写小组件\n- 掌握React、Vue框架核心思想和区别\n- 最好能阅读React源码分析\n\n## 阅读源码\n- 阅读underscore源码\n- 阅读jQuery源码\n- 阅读Backbone源码\n---\n\n# 规划生活\n感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。\n- 首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。\n- 上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。\n- 下午联系驾校练车，争取半个多月拿到证。\n- 练完车后去锻炼锻炼，跑步或者打球。\n- 晚上是码代码时间。\n- 22：00后写博客总结一下当天的心得。\n- 23：30上床\n\n> 总之，让生活充实起来，做到学习娱乐两不误！\n","slug":"Summary","published":1,"updated":"2022-02-24T02:14:18.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3v000y0hp3b2ry8rac","content":"<p>最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"前端学习\"><a href=\"#前端学习\" class=\"headerlink\" title=\"前端学习\"></a>前端学习</h1><blockquote>\n<p>自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。<br>不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：</p>\n</blockquote>\n<h2 id=\"JS基础\"><a href=\"#JS基础\" class=\"headerlink\" title=\"JS基础\"></a>JS基础</h2><ul>\n<li>继续阅读《You don’t know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图</li>\n<li>完成FreeCodeCamp项目练习</li>\n<li>练习百度前端学院有关项目</li>\n</ul>\n<h2 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h2><ul>\n<li>阅读《CSS揭秘》</li>\n<li>阅读图书馆借阅的设计方面相关书籍</li>\n<li>在项目中模仿别人的页面设计</li>\n<li>掌握bootstrap</li>\n</ul>\n<h2 id=\"工程化\"><a href=\"#工程化\" class=\"headerlink\" title=\"工程化\"></a>工程化</h2><ul>\n<li>掌握webpack的基本使用和配置</li>\n<li>会用gulp</li>\n<li>了解mocha测试工具</li>\n<li>多了解前端性能优化</li>\n<li>学会如何测试、发布上线项目</li>\n<li>学会写文档</li>\n</ul>\n<h2 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h2><ul>\n<li>leetcode刷题</li>\n<li>阅读算法导论</li>\n<li>阅读http、tcp有关书籍</li>\n</ul>\n<h2 id=\"框架学习\"><a href=\"#框架学习\" class=\"headerlink\" title=\"框架学习\"></a>框架学习</h2><ul>\n<li>通过阅读别人的React项目学习React基本结构和方法</li>\n<li>自己开始用React+Redux+React-router模仿着写小组件</li>\n<li>掌握React、Vue框架核心思想和区别</li>\n<li>最好能阅读React源码分析</li>\n</ul>\n<h2 id=\"阅读源码\"><a href=\"#阅读源码\" class=\"headerlink\" title=\"阅读源码\"></a>阅读源码</h2><ul>\n<li>阅读underscore源码</li>\n<li>阅读jQuery源码</li>\n<li>阅读Backbone源码</li>\n</ul>\n<hr>\n<h1 id=\"规划生活\"><a href=\"#规划生活\" class=\"headerlink\" title=\"规划生活\"></a>规划生活</h1><p>感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。</p>\n<ul>\n<li>首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。</li>\n<li>上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。</li>\n<li>下午联系驾校练车，争取半个多月拿到证。</li>\n<li>练完车后去锻炼锻炼，跑步或者打球。</li>\n<li>晚上是码代码时间。</li>\n<li>22：00后写博客总结一下当天的心得。</li>\n<li>23：30上床</li>\n</ul>\n<blockquote>\n<p>总之，让生活充实起来，做到学习娱乐两不误！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。</p>","more":"<h1 id=\"前端学习\"><a href=\"#前端学习\" class=\"headerlink\" title=\"前端学习\"></a>前端学习</h1><blockquote>\n<p>自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。<br>不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：</p>\n</blockquote>\n<h2 id=\"JS基础\"><a href=\"#JS基础\" class=\"headerlink\" title=\"JS基础\"></a>JS基础</h2><ul>\n<li>继续阅读《You don’t know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图</li>\n<li>完成FreeCodeCamp项目练习</li>\n<li>练习百度前端学院有关项目</li>\n</ul>\n<h2 id=\"CSS基础\"><a href=\"#CSS基础\" class=\"headerlink\" title=\"CSS基础\"></a>CSS基础</h2><ul>\n<li>阅读《CSS揭秘》</li>\n<li>阅读图书馆借阅的设计方面相关书籍</li>\n<li>在项目中模仿别人的页面设计</li>\n<li>掌握bootstrap</li>\n</ul>\n<h2 id=\"工程化\"><a href=\"#工程化\" class=\"headerlink\" title=\"工程化\"></a>工程化</h2><ul>\n<li>掌握webpack的基本使用和配置</li>\n<li>会用gulp</li>\n<li>了解mocha测试工具</li>\n<li>多了解前端性能优化</li>\n<li>学会如何测试、发布上线项目</li>\n<li>学会写文档</li>\n</ul>\n<h2 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h2><ul>\n<li>leetcode刷题</li>\n<li>阅读算法导论</li>\n<li>阅读http、tcp有关书籍</li>\n</ul>\n<h2 id=\"框架学习\"><a href=\"#框架学习\" class=\"headerlink\" title=\"框架学习\"></a>框架学习</h2><ul>\n<li>通过阅读别人的React项目学习React基本结构和方法</li>\n<li>自己开始用React+Redux+React-router模仿着写小组件</li>\n<li>掌握React、Vue框架核心思想和区别</li>\n<li>最好能阅读React源码分析</li>\n</ul>\n<h2 id=\"阅读源码\"><a href=\"#阅读源码\" class=\"headerlink\" title=\"阅读源码\"></a>阅读源码</h2><ul>\n<li>阅读underscore源码</li>\n<li>阅读jQuery源码</li>\n<li>阅读Backbone源码</li>\n</ul>\n<hr>\n<h1 id=\"规划生活\"><a href=\"#规划生活\" class=\"headerlink\" title=\"规划生活\"></a>规划生活</h1><p>感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。</p>\n<ul>\n<li>首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。</li>\n<li>上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。</li>\n<li>下午联系驾校练车，争取半个多月拿到证。</li>\n<li>练完车后去锻炼锻炼，跑步或者打球。</li>\n<li>晚上是码代码时间。</li>\n<li>22：00后写博客总结一下当天的心得。</li>\n<li>23：30上床</li>\n</ul>\n<blockquote>\n<p>总之，让生活充实起来，做到学习娱乐两不误！</p>\n</blockquote>"},{"title":"CSS边框的应用","date":"2017-07-24T05:34:47.000Z","toc":true,"_content":"\nCSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？\n\n<!--more-->\n# CSS实现多重边框\n一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。\n\n## box-shadow方案\n我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：\n\n> Specify a single box-shadow using:\n> - Two, three, or four values.\n> - If only two values are given, they are interpreted as values.\n> - If a third value is given, it is interpreted as a .\n> - If a fourth value is given, it is interpreted as a .\n> - Optionally, the inset keyword.\n> - Optionally, a value.\n\n我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533;\n```\n\n当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533, 0 0 0 15px #2f4, 0 2px 5px 15px rgba(0, 0, 0, .6);\n```\n\n注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。\n\n需要注意的是：\n\n- 投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。\n- box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。\n\n## outline方案\n某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。\n\n```css\nbackground: lightblue;\nborder: 10px solid #533;\noutline: 5px solid #2f4;\n```\n\n需要注意的是：\n\n它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。\n\n# 边框内圆角实现\n有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。\n\n```html\n<div class='container'>\n  <div>This is a box</div>\n</div>\n```\n\n```css\n.container {\n  background: #655;\n  padding: .6em;\n}\n\n.container > div {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n}\n```\n\n但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。\n\n```css\n.container {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n  box-shadow: 0 0 0 .5em #655\n  outline: .6em solid #655;\n}\n```\n实现的效果和之前一样。\n\n因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。\n\n注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&radic;2-1)*border-radius，为了方便，一般取border-radius的一半。","source":"_posts/2017-07-24-csssecrets-border.md","raw":"---\ntitle: CSS边框的应用\ndate: 2017-07-24 13:34:47\ntoc: true\ncategories:\n- CSS\ntags:\n- CSS技巧\n---\n\nCSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？\n\n<!--more-->\n# CSS实现多重边框\n一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。\n\n## box-shadow方案\n我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：\n\n> Specify a single box-shadow using:\n> - Two, three, or four values.\n> - If only two values are given, they are interpreted as values.\n> - If a third value is given, it is interpreted as a .\n> - If a fourth value is given, it is interpreted as a .\n> - Optionally, the inset keyword.\n> - Optionally, a value.\n\n我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533;\n```\n\n当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：\n```css\nbackground: lightblue;\nbox-shadow: 0 0 0 10px #533, 0 0 0 15px #2f4, 0 2px 5px 15px rgba(0, 0, 0, .6);\n```\n\n注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。\n\n需要注意的是：\n\n- 投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。\n- box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。\n\n## outline方案\n某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。\n\n```css\nbackground: lightblue;\nborder: 10px solid #533;\noutline: 5px solid #2f4;\n```\n\n需要注意的是：\n\n它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。\n\n# 边框内圆角实现\n有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。\n\n```html\n<div class='container'>\n  <div>This is a box</div>\n</div>\n```\n\n```css\n.container {\n  background: #655;\n  padding: .6em;\n}\n\n.container > div {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n}\n```\n\n但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。\n\n```css\n.container {\n  background: tan;\n  padding: 1em;\n  border-radius: .8em;\n  box-shadow: 0 0 0 .5em #655\n  outline: .6em solid #655;\n}\n```\n实现的效果和之前一样。\n\n因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。\n\n注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&radic;2-1)*border-radius，为了方便，一般取border-radius的一半。","slug":"csssecrets-border","published":1,"updated":"2022-02-24T05:43:13.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz3y00110hp31mot1wws","content":"<p>CSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？</p>\n<span id=\"more\"></span>\n<h1 id=\"CSS实现多重边框\"><a href=\"#CSS实现多重边框\" class=\"headerlink\" title=\"CSS实现多重边框\"></a>CSS实现多重边框</h1><p>一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。</p>\n<h2 id=\"box-shadow方案\"><a href=\"#box-shadow方案\" class=\"headerlink\" title=\"box-shadow方案\"></a>box-shadow方案</h2><p>我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：</p>\n<blockquote>\n<p>Specify a single box-shadow using:</p>\n<ul>\n<li>Two, three, or four values.</li>\n<li>If only two values are given, they are interpreted as values.</li>\n<li>If a third value is given, it is interpreted as a .</li>\n<li>If a fourth value is given, it is interpreted as a .</li>\n<li>Optionally, the inset keyword.</li>\n<li>Optionally, a value.</li>\n</ul>\n</blockquote>\n<p>我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>, <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> <span class=\"number\">#2f4</span>, <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">5px</span> <span class=\"number\">15px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, .<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。</p>\n<p>需要注意的是：</p>\n<ul>\n<li>投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。</li>\n<li>box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。</li>\n</ul>\n<h2 id=\"outline方案\"><a href=\"#outline方案\" class=\"headerlink\" title=\"outline方案\"></a>outline方案</h2><p>某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid <span class=\"number\">#533</span>;</span><br><span class=\"line\"><span class=\"attribute\">outline</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#2f4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：</p>\n<p>它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。</p>\n<h1 id=\"边框内圆角实现\"><a href=\"#边框内圆角实现\" class=\"headerlink\" title=\"边框内圆角实现\"></a>边框内圆角实现</h1><p>有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;container&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>This is a box<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#655</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: .<span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &gt; <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> .<span class=\"number\">5em</span> <span class=\"number\">#655</span></span><br><span class=\"line\">  outline: .<span class=\"number\">6em</span> solid <span class=\"number\">#655</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的效果和之前一样。</p>\n<p>因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。</p>\n<p>注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&amp;radic;2-1)*border-radius，为了方便，一般取border-radius的一半。</p>\n","site":{"data":{}},"excerpt":"<p>CSS中盒模型里重要的一个部分就是border，常见的border方法就是设置一重边框：border: 1px solid #494949，但如果我们想实现其他效果，该怎么用呢？</p>","more":"<h1 id=\"CSS实现多重边框\"><a href=\"#CSS实现多重边框\" class=\"headerlink\" title=\"CSS实现多重边框\"></a>CSS实现多重边框</h1><p>一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。</p>\n<h2 id=\"box-shadow方案\"><a href=\"#box-shadow方案\" class=\"headerlink\" title=\"box-shadow方案\"></a>box-shadow方案</h2><p>我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：</p>\n<blockquote>\n<p>Specify a single box-shadow using:</p>\n<ul>\n<li>Two, three, or four values.</li>\n<li>If only two values are given, they are interpreted as values.</li>\n<li>If a third value is given, it is interpreted as a .</li>\n<li>If a fourth value is given, it is interpreted as a .</li>\n<li>Optionally, the inset keyword.</li>\n<li>Optionally, a value.</li>\n</ul>\n</blockquote>\n<p>我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>;</span><br></pre></td></tr></table></figure>\n\n<p>当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">#533</span>, <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">15px</span> <span class=\"number\">#2f4</span>, <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">5px</span> <span class=\"number\">15px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, .<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。</p>\n<p>需要注意的是：</p>\n<ul>\n<li>投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。</li>\n<li>box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。</li>\n</ul>\n<h2 id=\"outline方案\"><a href=\"#outline方案\" class=\"headerlink\" title=\"outline方案\"></a>outline方案</h2><p>某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\"><span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid <span class=\"number\">#533</span>;</span><br><span class=\"line\"><span class=\"attribute\">outline</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#2f4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是：</p>\n<p>它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。</p>\n<h1 id=\"边框内圆角实现\"><a href=\"#边框内圆角实现\" class=\"headerlink\" title=\"边框内圆角实现\"></a>边框内圆角实现</h1><p>有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;container&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>This is a box<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#655</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: .<span class=\"number\">6em</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.container</span> &gt; <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: tan;</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: .<span class=\"number\">8em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> .<span class=\"number\">5em</span> <span class=\"number\">#655</span></span><br><span class=\"line\">  outline: .<span class=\"number\">6em</span> solid <span class=\"number\">#655</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的效果和之前一样。</p>\n<p>因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。</p>\n<p>注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于(&amp;radic;2-1)*border-radius，为了方便，一般取border-radius的一半。</p>"},{"title":"javascript类型转换","date":"2017-08-02T05:55:02.000Z","toc":true,"_content":"\nJavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。\n<!--more-->\n\n# JavaScript类型\n## 类型种类\n在JS中，有6种基本类型和一种引用类型，分别是：\n\n基本类型：\n\n- null\n- undefined\n- boolean\n- number\n- string\n- symbol(ES6新增)\n\n引用类型：\n\nobject\n\n## 类型检测\n一般来说，我们可以用typeof来检测某个值的数据类型，比如：\n\n```javascript\ntypeof undefined     === \"undefined\"; // true\ntypeof true          === \"boolean\";   // true\ntypeof 24            === \"number\";    // true\ntypeof \"24\"          === \"string\";    // true\ntypeof { age: 24 }  === \"object\";    // true\n\n// added in ES6!\ntypeof Symbol()      === \"symbol\";    // true\n```\n\n但是有一个例外: null,这也是一个bug\n\n```javascript\ntypeof null === \"object\"; // true\n```\n\n如果想检测某个值是否是null，则可以这样：\n\n```javascript\nvar a = null;\n(!a && typeof a === \"object\"); // true\n```\n\n需要注意的是，function和array其实也是object，但它们有所区别：\n\n```javascript\ntypeof function a(){ /* .. */ } === \"function\"; // true\ntypeof [1,2,3] === \"object\"; // true\n```\n\n如果要检测a是否是数组，可以用instanceof\n\n```javascript\nvar a = [123];\na instanceof Array; // true\n```\n\n# 类型转换抽象操作\n## ToString\n当一个非String类型的值要转换为String，我们可以用`ToString`操作。\n\n### toString()\n对于基本类型来说，它们有自然的转换关系。如：null变成\"null\",undefined变成\"undefined\",true变成\"true\",number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。\n\n对于object来说，`toString()`(代表着`Object.prototype.toString()`)将会返回`[[class]]`原型，比如说\"object Object\";但如果是数组，则重写了`toString()`方法，会返回一个以逗号分隔数组值的字符串。比如：\n\n```javascript\nvar a = [1,2,3];\na.toString(); // \"1,2,3\"\n```\n### JSON.stringify()\n另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：\n\n1\n2\n3\n4\n```javascript\nJSON.stringify( 42 );\t// \"42\"\nJSON.stringify( \"42\" );\t// \"\"42\"\" (外面多加一层引号)\nJSON.stringify( null );\t// \"null\"\nJSON.stringify( true );\t// \"true\"\n```\n\n但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：\n\n```javascript\nJSON.stringify( undefined );\t// undefined\nJSON.stringify( function(){} );\t// undefined\n\nJSON.stringify( [1,undefined,function(){},4] );\t// \"[1,null,null,4]\"\nJSON.stringify( { a:2, b:function(){} } );\t// \"{\"a\":2}\"\n```\n\n如果JSON.stringify调用了循环引用的object，则会抛出`Error`。如果JSON.stringify调用的对象有`toJSON()`方法，则会对toJSON()的返回值再进行stringify。\n\n```javascript\nvar a = {\n  b: 111\n};\na.toJSON = function() {\n\treturn { b: this.b };\n};\n\nJSON.stringify( a ); // \"{\"b\":111}\"\n\nvar c = {\n\tval: [1,2,3],\n\n\ttoJSON: function(){\n\t\treturn this.val.slice( 1 );\n\t}\n};\nJSON.stringify( c ); // \"[2,3]\"\n```\n\n## ToNumber\n转换为number，我们可以用ToNumber操作。\n\n### Number()\n对于基本类型，转换规则为：true -> 1,false -> 0,undefined -> NaN,null -> 0，字符串如果包含字母则转换为NaN。\n\n对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。\n\n比如：\n\n```javascript\nvar a = {\n\tvalueOf: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar b = {\n\ttoString: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar c = [1,2];\nc.toString = function(){\n\treturn this.join( \"\" );\t// \"12\"\n};\n\nNumber( a );\t\t\t// 12\nNumber( b );\t\t\t// 12\nNumber( c );\t\t\t// 12\nNumber( \"\" );\t\t\t// 0\nNumber( [] );\t\t\t// 0\nNumber( [ \"abc\" ] );\t// NaN\n```\n\n## ToBoolean\n将一个值转换为Boolean值，我们先看一个false表：\n\n```\nundefined\nnull\nfalse\n+0, -0, and NaN\n“”\n```\n\n任何不在这个表上的值都为true。\n比如：\n\n```javascript\nvar a = new Boolean( false );\nvar b = new Number( 0 );\nvar c = new String( \"\" );\nBoolean( a && b && c );  // true\n/***************/\nvar a = \"false\";\nvar b = \"0\";\nvar c = \"''\";\nBoolean( a && b && c );  // true\n/***************/\nvar a = [];\t\t\nvar b = {};\t\t\t\nvar c = function(){};\nBoolean( a && b && c );  // true\n```\n\n# 显式转换\n之前提到过一些显式转换，但其实还有以下几种：\n\n## 字符串与数字的转换\n\n```javascript\nvar a = 42;\nvar b = a.toString();\n\nvar c = \"3.14\";\nvar d = +c;\n\nb; // \"42\"\nd; // 3.14\n```\n\n## 日期转换为数字\nDate转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。\n\n```javascript\nvar d = new Date( \"Wed, 2 Aug 2017 08:53:06 CDT\" );\n\n+d; // 1501681986000\n```\n\nDate.now()方法就是用的这种转换：\n\n```javascript\nif (!Date.now) {\n\tDate.now = function() {\n\t\treturn +new Date();\n\t};\n}\n```\n\n## ~操作符\nJs里有\"\\~\"操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，\"\\~x\"相当于\"-(x+1)\"。\n\n于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：\n\n```javascript\nvar a = \"Hello World\";\n\n~a.indexOf( \"lo\" );\t\t\t// -4   <-- truthy!\n\nif (~a.indexOf( \"lo\" )) {\t// true\n  // 找到了\n}\n\n~a.indexOf( \"ol\" );\t\t\t// 0    <-- falsy!\n!~a.indexOf( \"ol\" );\t\t// true\n\nif (!~a.indexOf( \"ol\" )) {\t// true\n\t// 没有找到\n}\n```\n\n除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：\n\n```javascript\nMath.floor( -49.6 );\t// -50\nMath.ceil(-49.6);  // -49\n~~-49.6;\t\t   // -49\n```\n## parseInt()方法\n该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：\n\n```javascript\nparseInt( 0.000008 );\t\t// 0   (\"0\" from \"0.000008\")\nparseInt( 0.0000008 );\t\t// 8   (\"8\" from \"8e-7\")\nparseInt( false, 16 );\t\t// 250 (\"fa\" from \"false\")\nparseInt( parseInt, 16 );\t// 15  (\"f\" from \"function..\")\n\nparseInt( \"0x10\" );\t\t\t// 16\nparseInt( \"103\", 2 );\t\t// 2\n```\n\n所以，要谨慎使用parseInt。\n\n## 转换为Boolean\n我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：\n\n```javascript\nvar a = \"0\";\nvar b = [];\nvar c = {};\n\nvar d = \"\";\nvar e = 0;\nvar f = null;\nvar g;\n\n!!a;\t// true\n!!b;\t// true\n!!c;\t// true\n\n!!d;\t// false\n!!e;\t// false\n!!f;\t// false\n!!g;\t// false\n```\n\n# 隐式转换\n## 数字转换为字符串\n因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：\n\n```javascript\nvar a = 122;\nvar b = a + '';  \nb;  // \"122\"\n```\n\n## 字符串转换为数字\n因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：\n\n```javascript\nvar a = \"122\";\nvar b = a - 0;  \nb;  // 122\n```\n\n## 数组转换为数字\n同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：\n\n```javascript\nvar a = [3];\nvar b = [1];\na - b; // 2\n```\n\n# 操作符的妙用\n## 操作符||和&&\n我们都知道||代表‘或’，&&代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：\n\n```javascript\nvar a = 42;\nvar b = \"abc\";\nvar c = null;\n\na || b;\t\t// 42\na && b;\t\t// \"abc\"\n\nc || b;\t\t// \"abc\"\nc && b;\t\t// null\n```\n\n于是我们就可以利用这两个操作符进行一些赋值操作：\n\n```javascript\na || b;\n// 等价于：\na ? a : b;\n\na && b;\n// 等价于：\na ? b : a;\n```\n\n## 操作符==与===\n这两个符号我们应该很熟悉了，==代表值的比较，如果二者类型不同，会进行强制转换；===则是二者值与类型都相同才为true。这里需要注意一些问题：\n\n> NaN不等于它本身\n> +0等于-0\n\n### 字符串与数字比较\n二者比较时，使用===结果肯定为false，因为二者类型不同，但如果使用==，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：\n\n```javascript\nvar a = 22;\nvar b = \"22\";\n\na === b;\t// false\na == b;\t\t// true\n```\n### 任何值与Boolean比较\n当任何值与Boolean使用==比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：\n\n```javascript\nvar x = true;\nvar y = \"42\";\n\nx == y; // false\n```\n\n所以，在任何时候，都不要使用== true或者== false这样的语句。\n\n### null与undefined比较\n当使用==比较null和undefined时，结果总为true。\n\n### Object与非Object比较\n当object/function/array与String或者Number进行==比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。\n\n### 一些值得注意的比较\n\n```javascript\n\"\" == [null];\t// true\n[] == ![]; // true\n0 == \"\\n\"; // true\n\"0\" == false;\t// true\nfalse == 0;\t\t// true\nfalse == \"\";\t// true\nfalse == [];\t// true\n\"\" == 0;\t\t// true\n\"\" == [];\t\t// true\n0 == [];\t\t// true\n```\n\n# 总结\n需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用`valueOf()`方法，没有才调用`toString()`方法，如果我们给自定义的对象添加`valueOf()`方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用===比较安全。\n\n> 参考资料： [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS/)","source":"_posts/2017-08-02-js-value-coercions.md","raw":"---\ntitle: javascript类型转换\ndate: 2017-08-02 13:55:02\ntoc: true\ncategories:\n- JavaScript\ntags:\n- JS基础\n---\n\nJavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。\n<!--more-->\n\n# JavaScript类型\n## 类型种类\n在JS中，有6种基本类型和一种引用类型，分别是：\n\n基本类型：\n\n- null\n- undefined\n- boolean\n- number\n- string\n- symbol(ES6新增)\n\n引用类型：\n\nobject\n\n## 类型检测\n一般来说，我们可以用typeof来检测某个值的数据类型，比如：\n\n```javascript\ntypeof undefined     === \"undefined\"; // true\ntypeof true          === \"boolean\";   // true\ntypeof 24            === \"number\";    // true\ntypeof \"24\"          === \"string\";    // true\ntypeof { age: 24 }  === \"object\";    // true\n\n// added in ES6!\ntypeof Symbol()      === \"symbol\";    // true\n```\n\n但是有一个例外: null,这也是一个bug\n\n```javascript\ntypeof null === \"object\"; // true\n```\n\n如果想检测某个值是否是null，则可以这样：\n\n```javascript\nvar a = null;\n(!a && typeof a === \"object\"); // true\n```\n\n需要注意的是，function和array其实也是object，但它们有所区别：\n\n```javascript\ntypeof function a(){ /* .. */ } === \"function\"; // true\ntypeof [1,2,3] === \"object\"; // true\n```\n\n如果要检测a是否是数组，可以用instanceof\n\n```javascript\nvar a = [123];\na instanceof Array; // true\n```\n\n# 类型转换抽象操作\n## ToString\n当一个非String类型的值要转换为String，我们可以用`ToString`操作。\n\n### toString()\n对于基本类型来说，它们有自然的转换关系。如：null变成\"null\",undefined变成\"undefined\",true变成\"true\",number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。\n\n对于object来说，`toString()`(代表着`Object.prototype.toString()`)将会返回`[[class]]`原型，比如说\"object Object\";但如果是数组，则重写了`toString()`方法，会返回一个以逗号分隔数组值的字符串。比如：\n\n```javascript\nvar a = [1,2,3];\na.toString(); // \"1,2,3\"\n```\n### JSON.stringify()\n另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：\n\n1\n2\n3\n4\n```javascript\nJSON.stringify( 42 );\t// \"42\"\nJSON.stringify( \"42\" );\t// \"\"42\"\" (外面多加一层引号)\nJSON.stringify( null );\t// \"null\"\nJSON.stringify( true );\t// \"true\"\n```\n\n但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：\n\n```javascript\nJSON.stringify( undefined );\t// undefined\nJSON.stringify( function(){} );\t// undefined\n\nJSON.stringify( [1,undefined,function(){},4] );\t// \"[1,null,null,4]\"\nJSON.stringify( { a:2, b:function(){} } );\t// \"{\"a\":2}\"\n```\n\n如果JSON.stringify调用了循环引用的object，则会抛出`Error`。如果JSON.stringify调用的对象有`toJSON()`方法，则会对toJSON()的返回值再进行stringify。\n\n```javascript\nvar a = {\n  b: 111\n};\na.toJSON = function() {\n\treturn { b: this.b };\n};\n\nJSON.stringify( a ); // \"{\"b\":111}\"\n\nvar c = {\n\tval: [1,2,3],\n\n\ttoJSON: function(){\n\t\treturn this.val.slice( 1 );\n\t}\n};\nJSON.stringify( c ); // \"[2,3]\"\n```\n\n## ToNumber\n转换为number，我们可以用ToNumber操作。\n\n### Number()\n对于基本类型，转换规则为：true -> 1,false -> 0,undefined -> NaN,null -> 0，字符串如果包含字母则转换为NaN。\n\n对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。\n\n比如：\n\n```javascript\nvar a = {\n\tvalueOf: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar b = {\n\ttoString: function(){\n\t\treturn \"12\";\n\t}\n};\n\nvar c = [1,2];\nc.toString = function(){\n\treturn this.join( \"\" );\t// \"12\"\n};\n\nNumber( a );\t\t\t// 12\nNumber( b );\t\t\t// 12\nNumber( c );\t\t\t// 12\nNumber( \"\" );\t\t\t// 0\nNumber( [] );\t\t\t// 0\nNumber( [ \"abc\" ] );\t// NaN\n```\n\n## ToBoolean\n将一个值转换为Boolean值，我们先看一个false表：\n\n```\nundefined\nnull\nfalse\n+0, -0, and NaN\n“”\n```\n\n任何不在这个表上的值都为true。\n比如：\n\n```javascript\nvar a = new Boolean( false );\nvar b = new Number( 0 );\nvar c = new String( \"\" );\nBoolean( a && b && c );  // true\n/***************/\nvar a = \"false\";\nvar b = \"0\";\nvar c = \"''\";\nBoolean( a && b && c );  // true\n/***************/\nvar a = [];\t\t\nvar b = {};\t\t\t\nvar c = function(){};\nBoolean( a && b && c );  // true\n```\n\n# 显式转换\n之前提到过一些显式转换，但其实还有以下几种：\n\n## 字符串与数字的转换\n\n```javascript\nvar a = 42;\nvar b = a.toString();\n\nvar c = \"3.14\";\nvar d = +c;\n\nb; // \"42\"\nd; // 3.14\n```\n\n## 日期转换为数字\nDate转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。\n\n```javascript\nvar d = new Date( \"Wed, 2 Aug 2017 08:53:06 CDT\" );\n\n+d; // 1501681986000\n```\n\nDate.now()方法就是用的这种转换：\n\n```javascript\nif (!Date.now) {\n\tDate.now = function() {\n\t\treturn +new Date();\n\t};\n}\n```\n\n## ~操作符\nJs里有\"\\~\"操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，\"\\~x\"相当于\"-(x+1)\"。\n\n于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：\n\n```javascript\nvar a = \"Hello World\";\n\n~a.indexOf( \"lo\" );\t\t\t// -4   <-- truthy!\n\nif (~a.indexOf( \"lo\" )) {\t// true\n  // 找到了\n}\n\n~a.indexOf( \"ol\" );\t\t\t// 0    <-- falsy!\n!~a.indexOf( \"ol\" );\t\t// true\n\nif (!~a.indexOf( \"ol\" )) {\t// true\n\t// 没有找到\n}\n```\n\n除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：\n\n```javascript\nMath.floor( -49.6 );\t// -50\nMath.ceil(-49.6);  // -49\n~~-49.6;\t\t   // -49\n```\n## parseInt()方法\n该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：\n\n```javascript\nparseInt( 0.000008 );\t\t// 0   (\"0\" from \"0.000008\")\nparseInt( 0.0000008 );\t\t// 8   (\"8\" from \"8e-7\")\nparseInt( false, 16 );\t\t// 250 (\"fa\" from \"false\")\nparseInt( parseInt, 16 );\t// 15  (\"f\" from \"function..\")\n\nparseInt( \"0x10\" );\t\t\t// 16\nparseInt( \"103\", 2 );\t\t// 2\n```\n\n所以，要谨慎使用parseInt。\n\n## 转换为Boolean\n我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：\n\n```javascript\nvar a = \"0\";\nvar b = [];\nvar c = {};\n\nvar d = \"\";\nvar e = 0;\nvar f = null;\nvar g;\n\n!!a;\t// true\n!!b;\t// true\n!!c;\t// true\n\n!!d;\t// false\n!!e;\t// false\n!!f;\t// false\n!!g;\t// false\n```\n\n# 隐式转换\n## 数字转换为字符串\n因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：\n\n```javascript\nvar a = 122;\nvar b = a + '';  \nb;  // \"122\"\n```\n\n## 字符串转换为数字\n因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：\n\n```javascript\nvar a = \"122\";\nvar b = a - 0;  \nb;  // 122\n```\n\n## 数组转换为数字\n同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：\n\n```javascript\nvar a = [3];\nvar b = [1];\na - b; // 2\n```\n\n# 操作符的妙用\n## 操作符||和&&\n我们都知道||代表‘或’，&&代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：\n\n```javascript\nvar a = 42;\nvar b = \"abc\";\nvar c = null;\n\na || b;\t\t// 42\na && b;\t\t// \"abc\"\n\nc || b;\t\t// \"abc\"\nc && b;\t\t// null\n```\n\n于是我们就可以利用这两个操作符进行一些赋值操作：\n\n```javascript\na || b;\n// 等价于：\na ? a : b;\n\na && b;\n// 等价于：\na ? b : a;\n```\n\n## 操作符==与===\n这两个符号我们应该很熟悉了，==代表值的比较，如果二者类型不同，会进行强制转换；===则是二者值与类型都相同才为true。这里需要注意一些问题：\n\n> NaN不等于它本身\n> +0等于-0\n\n### 字符串与数字比较\n二者比较时，使用===结果肯定为false，因为二者类型不同，但如果使用==，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：\n\n```javascript\nvar a = 22;\nvar b = \"22\";\n\na === b;\t// false\na == b;\t\t// true\n```\n### 任何值与Boolean比较\n当任何值与Boolean使用==比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：\n\n```javascript\nvar x = true;\nvar y = \"42\";\n\nx == y; // false\n```\n\n所以，在任何时候，都不要使用== true或者== false这样的语句。\n\n### null与undefined比较\n当使用==比较null和undefined时，结果总为true。\n\n### Object与非Object比较\n当object/function/array与String或者Number进行==比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。\n\n### 一些值得注意的比较\n\n```javascript\n\"\" == [null];\t// true\n[] == ![]; // true\n0 == \"\\n\"; // true\n\"0\" == false;\t// true\nfalse == 0;\t\t// true\nfalse == \"\";\t// true\nfalse == [];\t// true\n\"\" == 0;\t\t// true\n\"\" == [];\t\t// true\n0 == [];\t\t// true\n```\n\n# 总结\n需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用`valueOf()`方法，没有才调用`toString()`方法，如果我们给自定义的对象添加`valueOf()`方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用===比较安全。\n\n> 参考资料： [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS/)","slug":"js-value-coercions","published":1,"updated":"2022-02-24T06:27:43.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz4000150hp3c94t6ynw","content":"<p>JavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"JavaScript类型\"><a href=\"#JavaScript类型\" class=\"headerlink\" title=\"JavaScript类型\"></a>JavaScript类型</h1><h2 id=\"类型种类\"><a href=\"#类型种类\" class=\"headerlink\" title=\"类型种类\"></a>类型种类</h2><p>在JS中，有6种基本类型和一种引用类型，分别是：</p>\n<p>基本类型：</p>\n<ul>\n<li>null</li>\n<li>undefined</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>symbol(ES6新增)</li>\n</ul>\n<p>引用类型：</p>\n<p>object</p>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><p>一般来说，我们可以用typeof来检测某个值的数据类型，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>     === <span class=\"string\">&quot;undefined&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>          === <span class=\"string\">&quot;boolean&quot;</span>;   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">24</span>            === <span class=\"string\">&quot;number&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;24&quot;</span>          === <span class=\"string\">&quot;string&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123; <span class=\"attr\">age</span>: <span class=\"number\">24</span> &#125;  === <span class=\"string\">&quot;object&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// added in ES6!</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>()      === <span class=\"string\">&quot;symbol&quot;</span>;    <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但是有一个例外: null,这也是一个bug</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果想检测某个值是否是null，则可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(!a &amp;&amp; <span class=\"keyword\">typeof</span> a === <span class=\"string\">&quot;object&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，function和array其实也是object，但它们有所区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123; <span class=\"comment\">/* .. */</span> &#125; === <span class=\"string\">&quot;function&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要检测a是否是数组，可以用instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">123</span>];</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类型转换抽象操作\"><a href=\"#类型转换抽象操作\" class=\"headerlink\" title=\"类型转换抽象操作\"></a>类型转换抽象操作</h1><h2 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString\"></a>ToString</h2><p>当一个非String类型的值要转换为String，我们可以用<code>ToString</code>操作。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>对于基本类型来说，它们有自然的转换关系。如：null变成”null”,undefined变成”undefined”,true变成”true”,number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。</p>\n<p>对于object来说，<code>toString()</code>(代表着<code>Object.prototype.toString()</code>)将会返回<code>[[class]]</code>原型，比如说”object Object”;但如果是数组，则重写了<code>toString()</code>方法，会返回一个以逗号分隔数组值的字符串。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">a.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify()\"></a>JSON.stringify()</h3><p>另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：</p>\n<p>1<br>2<br>3<br>4</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"number\">42</span> );\t<span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"string\">&quot;42&quot;</span> );\t<span class=\"comment\">// &quot;&quot;42&quot;&quot; (外面多加一层引号)</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">null</span> );\t<span class=\"comment\">// &quot;null&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">true</span> );\t<span class=\"comment\">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">undefined</span> );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( [<span class=\"number\">1</span>,<span class=\"literal\">undefined</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;,<span class=\"number\">4</span>] );\t<span class=\"comment\">// &quot;[1,null,null,4]&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( &#123; <span class=\"attr\">a</span>:<span class=\"number\">2</span>, <span class=\"attr\">b</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; &#125; );\t<span class=\"comment\">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果JSON.stringify调用了循环引用的object，则会抛出<code>Error</code>。如果JSON.stringify调用的对象有<code>toJSON()</code>方法，则会对toJSON()的返回值再进行stringify。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">111</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a.<span class=\"property\">toJSON</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123; <span class=\"attr\">b</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( a ); <span class=\"comment\">// &quot;&#123;&quot;b&quot;:111&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">val</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">toJSON</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">val</span>.<span class=\"title function_\">slice</span>( <span class=\"number\">1</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( c ); <span class=\"comment\">// &quot;[2,3]&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h2><p>转换为number，我们可以用ToNumber操作。</p>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number()\"></a>Number()</h3><p>对于基本类型，转换规则为：true -&gt; 1,false -&gt; 0,undefined -&gt; NaN,null -&gt; 0，字符串如果包含字母则转换为NaN。</p>\n<p>对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。</p>\n<p>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">valueOf</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">c.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">join</span>( <span class=\"string\">&quot;&quot;</span> );\t<span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( a );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( b );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( c );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( <span class=\"string\">&quot;&quot;</span> );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [] );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [ <span class=\"string\">&quot;abc&quot;</span> ] );\t<span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h2><p>将一个值转换为Boolean值，我们先看一个false表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undefined</span><br><span class=\"line\">null</span><br><span class=\"line\">false</span><br><span class=\"line\">+0, -0, and NaN</span><br><span class=\"line\">“”</span><br></pre></td></tr></table></figure>\n\n<p>任何不在这个表上的值都为true。<br>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>( <span class=\"literal\">false</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>( <span class=\"number\">0</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>( <span class=\"string\">&quot;&quot;</span> );</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;false&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;&#x27;&#x27;&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h1><p>之前提到过一些显式转换，但其实还有以下几种：</p>\n<h2 id=\"字符串与数字的转换\"><a href=\"#字符串与数字的转换\" class=\"headerlink\" title=\"字符串与数字的转换\"></a>字符串与数字的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;3.14&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = +c;</span><br><span class=\"line\"></span><br><span class=\"line\">b; <span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\">d; <span class=\"comment\">// 3.14</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期转换为数字\"><a href=\"#日期转换为数字\" class=\"headerlink\" title=\"日期转换为数字\"></a>日期转换为数字</h2><p>Date转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>( <span class=\"string\">&quot;Wed, 2 Aug 2017 08:53:06 CDT&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">+d; <span class=\"comment\">// 1501681986000</span></span><br></pre></td></tr></table></figure>\n\n<p>Date.now()方法就是用的这种转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Date</span>.<span class=\"property\">now</span>) &#123;</span><br><span class=\"line\">\t<span class=\"title class_\">Date</span>.<span class=\"property\">now</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> +<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"~操作符\"></a>~操作符</h2><p>Js里有”~“操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，”~x”相当于”-(x+1)”。</p>\n<p>于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> );\t\t\t<span class=\"comment\">// -4   &lt;-- truthy!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"comment\">// 找到了</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t\t<span class=\"comment\">// 0    &lt;-- falsy!</span></span><br><span class=\"line\">!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">\t<span class=\"comment\">// 没有找到</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>( -<span class=\"number\">49.6</span> );\t<span class=\"comment\">// -50</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(-<span class=\"number\">49.6</span>);  <span class=\"comment\">// -49</span></span><br><span class=\"line\">~~-<span class=\"number\">49.6</span>;\t\t   <span class=\"comment\">// -49</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"parseInt-方法\"><a href=\"#parseInt-方法\" class=\"headerlink\" title=\"parseInt()方法\"></a>parseInt()方法</h2><p>该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.000008</span> );\t\t<span class=\"comment\">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.0000008</span> );\t\t<span class=\"comment\">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"literal\">false</span>, <span class=\"number\">16</span> );\t\t<span class=\"comment\">// 250 (&quot;fa&quot; from &quot;false&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"built_in\">parseInt</span>, <span class=\"number\">16</span> );\t<span class=\"comment\">// 15  (&quot;f&quot; from &quot;function..&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;0x10&quot;</span> );\t\t\t<span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;103&quot;</span>, <span class=\"number\">2</span> );\t\t<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，要谨慎使用parseInt。</p>\n<h2 id=\"转换为Boolean\"><a href=\"#转换为Boolean\" class=\"headerlink\" title=\"转换为Boolean\"></a>转换为Boolean</h2><p>我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g;</span><br><span class=\"line\"></span><br><span class=\"line\">!!a;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!b;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!c;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!!d;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!e;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!f;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!g;\t<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h1><h2 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h2><p>因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">122</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a + <span class=\"string\">&#x27;&#x27;</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// &quot;122&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串转换为数字\"><a href=\"#字符串转换为数字\" class=\"headerlink\" title=\"字符串转换为数字\"></a>字符串转换为数字</h2><p>因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;122&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a - <span class=\"number\">0</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// 122</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组转换为数字\"><a href=\"#数组转换为数字\" class=\"headerlink\" title=\"数组转换为数字\"></a>数组转换为数字</h2><p>同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>];</span><br><span class=\"line\">a - b; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"操作符的妙用\"><a href=\"#操作符的妙用\" class=\"headerlink\" title=\"操作符的妙用\"></a>操作符的妙用</h1><h2 id=\"操作符-和-amp-amp\"><a href=\"#操作符-和-amp-amp\" class=\"headerlink\" title=\"操作符||和&amp;&amp;\"></a>操作符||和&amp;&amp;</h2><p>我们都知道||代表‘或’，&amp;&amp;代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a || b;\t\t<span class=\"comment\">// 42</span></span><br><span class=\"line\">a &amp;&amp; b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">c || b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\">c &amp;&amp; b;\t\t<span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以利用这两个操作符进行一些赋值操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a || b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? a : b;</span><br><span class=\"line\"></span><br><span class=\"line\">a &amp;&amp; b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? b : a;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符-x3D-x3D-与-x3D-x3D-x3D\"><a href=\"#操作符-x3D-x3D-与-x3D-x3D-x3D\" class=\"headerlink\" title=\"操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;\"></a>操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</h2><p>这两个符号我们应该很熟悉了，&#x3D;&#x3D;代表值的比较，如果二者类型不同，会进行强制转换；&#x3D;&#x3D;&#x3D;则是二者值与类型都相同才为true。这里需要注意一些问题：</p>\n<blockquote>\n<p>NaN不等于它本身<br>+0等于-0</p>\n</blockquote>\n<h3 id=\"字符串与数字比较\"><a href=\"#字符串与数字比较\" class=\"headerlink\" title=\"字符串与数字比较\"></a>字符串与数字比较</h3><p>二者比较时，使用&#x3D;&#x3D;&#x3D;结果肯定为false，因为二者类型不同，但如果使用&#x3D;&#x3D;，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;22&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a === b;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">a == b;\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"任何值与Boolean比较\"><a href=\"#任何值与Boolean比较\" class=\"headerlink\" title=\"任何值与Boolean比较\"></a>任何值与Boolean比较</h3><p>当任何值与Boolean使用&#x3D;&#x3D;比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"string\">&quot;42&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x == y; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，在任何时候，都不要使用&#x3D;&#x3D; true或者&#x3D;&#x3D; false这样的语句。</p>\n<h3 id=\"null与undefined比较\"><a href=\"#null与undefined比较\" class=\"headerlink\" title=\"null与undefined比较\"></a>null与undefined比较</h3><p>当使用&#x3D;&#x3D;比较null和undefined时，结果总为true。</p>\n<h3 id=\"Object与非Object比较\"><a href=\"#Object与非Object比较\" class=\"headerlink\" title=\"Object与非Object比较\"></a>Object与非Object比较</h3><p>当object&#x2F;function&#x2F;array与String或者Number进行&#x3D;&#x3D;比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。</p>\n<h3 id=\"一些值得注意的比较\"><a href=\"#一些值得注意的比较\" class=\"headerlink\" title=\"一些值得注意的比较\"></a>一些值得注意的比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [<span class=\"literal\">null</span>];\t<span class=\"comment\">// true</span></span><br><span class=\"line\">[] == ![]; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">&quot;\\n&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;0&quot;</span> == <span class=\"literal\">false</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"string\">&quot;&quot;</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == [];\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [];\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == [];\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用<code>valueOf()</code>方法，没有才调用<code>toString()</code>方法，如果我们给自定义的对象添加<code>valueOf()</code>方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用&#x3D;&#x3D;&#x3D;比较安全。</p>\n<blockquote>\n<p>参考资料： <a href=\"https://github.com/getify/You-Dont-Know-JS/\">You-Dont-Know-JS</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>JavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。</p>","more":"<h1 id=\"JavaScript类型\"><a href=\"#JavaScript类型\" class=\"headerlink\" title=\"JavaScript类型\"></a>JavaScript类型</h1><h2 id=\"类型种类\"><a href=\"#类型种类\" class=\"headerlink\" title=\"类型种类\"></a>类型种类</h2><p>在JS中，有6种基本类型和一种引用类型，分别是：</p>\n<p>基本类型：</p>\n<ul>\n<li>null</li>\n<li>undefined</li>\n<li>boolean</li>\n<li>number</li>\n<li>string</li>\n<li>symbol(ES6新增)</li>\n</ul>\n<p>引用类型：</p>\n<p>object</p>\n<h2 id=\"类型检测\"><a href=\"#类型检测\" class=\"headerlink\" title=\"类型检测\"></a>类型检测</h2><p>一般来说，我们可以用typeof来检测某个值的数据类型，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span>     === <span class=\"string\">&quot;undefined&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>          === <span class=\"string\">&quot;boolean&quot;</span>;   <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">24</span>            === <span class=\"string\">&quot;number&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&quot;24&quot;</span>          === <span class=\"string\">&quot;string&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123; <span class=\"attr\">age</span>: <span class=\"number\">24</span> &#125;  === <span class=\"string\">&quot;object&quot;</span>;    <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// added in ES6!</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"title class_\">Symbol</span>()      === <span class=\"string\">&quot;symbol&quot;</span>;    <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>但是有一个例外: null,这也是一个bug</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果想检测某个值是否是null，则可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\">(!a &amp;&amp; <span class=\"keyword\">typeof</span> a === <span class=\"string\">&quot;object&quot;</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，function和array其实也是object，但它们有所区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>)&#123; <span class=\"comment\">/* .. */</span> &#125; === <span class=\"string\">&quot;function&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] === <span class=\"string\">&quot;object&quot;</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要检测a是否是数组，可以用instanceof</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">123</span>];</span><br><span class=\"line\">a <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类型转换抽象操作\"><a href=\"#类型转换抽象操作\" class=\"headerlink\" title=\"类型转换抽象操作\"></a>类型转换抽象操作</h1><h2 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString\"></a>ToString</h2><p>当一个非String类型的值要转换为String，我们可以用<code>ToString</code>操作。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>对于基本类型来说，它们有自然的转换关系。如：null变成”null”,undefined变成”undefined”,true变成”true”,number自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。</p>\n<p>对于object来说，<code>toString()</code>(代表着<code>Object.prototype.toString()</code>)将会返回<code>[[class]]</code>原型，比如说”object Object”;但如果是数组，则重写了<code>toString()</code>方法，会返回一个以逗号分隔数组值的字符串。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">a.<span class=\"title function_\">toString</span>(); <span class=\"comment\">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-stringify\"><a href=\"#JSON-stringify\" class=\"headerlink\" title=\"JSON.stringify()\"></a>JSON.stringify()</h3><p>另一种转换为字符串的方法就是JSON.stringify，对大多数基本类型，它的转换方法和toString是一样的：</p>\n<p>1<br>2<br>3<br>4</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"number\">42</span> );\t<span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"string\">&quot;42&quot;</span> );\t<span class=\"comment\">// &quot;&quot;42&quot;&quot; (外面多加一层引号)</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">null</span> );\t<span class=\"comment\">// &quot;null&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">true</span> );\t<span class=\"comment\">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>但不同的是，JSON.stringify会忽略掉undefined、function和symbol。请看下面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"literal\">undefined</span> );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; );\t<span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( [<span class=\"number\">1</span>,<span class=\"literal\">undefined</span>,<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;,<span class=\"number\">4</span>] );\t<span class=\"comment\">// &quot;[1,null,null,4]&quot;</span></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( &#123; <span class=\"attr\">a</span>:<span class=\"number\">2</span>, <span class=\"attr\">b</span>:<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125; &#125; );\t<span class=\"comment\">// &quot;&#123;&quot;a&quot;:2&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果JSON.stringify调用了循环引用的object，则会抛出<code>Error</code>。如果JSON.stringify调用的对象有<code>toJSON()</code>方法，则会对toJSON()的返回值再进行stringify。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">111</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">a.<span class=\"property\">toJSON</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123; <span class=\"attr\">b</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( a ); <span class=\"comment\">// &quot;&#123;&quot;b&quot;:111&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">val</span>: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">toJSON</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">val</span>.<span class=\"title function_\">slice</span>( <span class=\"number\">1</span> );</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>( c ); <span class=\"comment\">// &quot;[2,3]&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h2><p>转换为number，我们可以用ToNumber操作。</p>\n<h3 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number()\"></a>Number()</h3><p>对于基本类型，转换规则为：true -&gt; 1,false -&gt; 0,undefined -&gt; NaN,null -&gt; 0，字符串如果包含字母则转换为NaN。</p>\n<p>对于将某值转换为基本数据类型，通常会调用ToPrimitive操作，首先看该值有没有valueof()方法，如果没有则调用toString()方法，如果二者都没有，则抛出TypeError。</p>\n<p>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">valueOf</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">toString</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;12&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">c.<span class=\"property\">toString</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">join</span>( <span class=\"string\">&quot;&quot;</span> );\t<span class=\"comment\">// &quot;12&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( a );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( b );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( c );\t\t\t<span class=\"comment\">// 12</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( <span class=\"string\">&quot;&quot;</span> );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [] );\t\t\t<span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>( [ <span class=\"string\">&quot;abc&quot;</span> ] );\t<span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ToBoolean\"><a href=\"#ToBoolean\" class=\"headerlink\" title=\"ToBoolean\"></a>ToBoolean</h2><p>将一个值转换为Boolean值，我们先看一个false表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undefined</span><br><span class=\"line\">null</span><br><span class=\"line\">false</span><br><span class=\"line\">+0, -0, and NaN</span><br><span class=\"line\">“”</span><br></pre></td></tr></table></figure>\n\n<p>任何不在这个表上的值都为true。<br>比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>( <span class=\"literal\">false</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Number</span>( <span class=\"number\">0</span> );</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>( <span class=\"string\">&quot;&quot;</span> );</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;false&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;&#x27;&#x27;&quot;</span>;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"comment\">/***************/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;&#125;;\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h1><p>之前提到过一些显式转换，但其实还有以下几种：</p>\n<h2 id=\"字符串与数字的转换\"><a href=\"#字符串与数字的转换\" class=\"headerlink\" title=\"字符串与数字的转换\"></a>字符串与数字的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a.<span class=\"title function_\">toString</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"string\">&quot;3.14&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = +c;</span><br><span class=\"line\"></span><br><span class=\"line\">b; <span class=\"comment\">// &quot;42&quot;</span></span><br><span class=\"line\">d; <span class=\"comment\">// 3.14</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期转换为数字\"><a href=\"#日期转换为数字\" class=\"headerlink\" title=\"日期转换为数字\"></a>日期转换为数字</h2><p>Date转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>( <span class=\"string\">&quot;Wed, 2 Aug 2017 08:53:06 CDT&quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">+d; <span class=\"comment\">// 1501681986000</span></span><br></pre></td></tr></table></figure>\n\n<p>Date.now()方法就是用的这种转换：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"title class_\">Date</span>.<span class=\"property\">now</span>) &#123;</span><br><span class=\"line\">\t<span class=\"title class_\">Date</span>.<span class=\"property\">now</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> +<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"~操作符\"></a>~操作符</h2><p>Js里有”~“操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，”~x”相当于”-(x+1)”。</p>\n<p>于是，~有一个用处就是判断-1，比如我们对字符串使用indexOf()时如果找不到则返回-1，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> );\t\t\t<span class=\"comment\">// -4   &lt;-- truthy!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;lo&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"comment\">// 找到了</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t\t<span class=\"comment\">// 0    &lt;-- falsy!</span></span><br><span class=\"line\">!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> );\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!~a.<span class=\"title function_\">indexOf</span>( <span class=\"string\">&quot;ol&quot;</span> )) &#123;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">\t<span class=\"comment\">// 没有找到</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除此之外，~~可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于Math.ceil()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>( -<span class=\"number\">49.6</span> );\t<span class=\"comment\">// -50</span></span><br><span class=\"line\"><span class=\"title class_\">Math</span>.<span class=\"title function_\">ceil</span>(-<span class=\"number\">49.6</span>);  <span class=\"comment\">// -49</span></span><br><span class=\"line\">~~-<span class=\"number\">49.6</span>;\t\t   <span class=\"comment\">// -49</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"parseInt-方法\"><a href=\"#parseInt-方法\" class=\"headerlink\" title=\"parseInt()方法\"></a>parseInt()方法</h2><p>该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.000008</span> );\t\t<span class=\"comment\">// 0   (&quot;0&quot; from &quot;0.000008&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"number\">0.0000008</span> );\t\t<span class=\"comment\">// 8   (&quot;8&quot; from &quot;8e-7&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"literal\">false</span>, <span class=\"number\">16</span> );\t\t<span class=\"comment\">// 250 (&quot;fa&quot; from &quot;false&quot;)</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"built_in\">parseInt</span>, <span class=\"number\">16</span> );\t<span class=\"comment\">// 15  (&quot;f&quot; from &quot;function..&quot;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;0x10&quot;</span> );\t\t\t<span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">parseInt</span>( <span class=\"string\">&quot;103&quot;</span>, <span class=\"number\">2</span> );\t\t<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，要谨慎使用parseInt。</p>\n<h2 id=\"转换为Boolean\"><a href=\"#转换为Boolean\" class=\"headerlink\" title=\"转换为Boolean\"></a>转换为Boolean</h2><p>我们已经知道Boolean()方法可以将值转换为Boolean，但还有一个更快的方法，就是使用!!操作符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g;</span><br><span class=\"line\"></span><br><span class=\"line\">!!a;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!b;\t<span class=\"comment\">// true</span></span><br><span class=\"line\">!!c;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">!!d;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!e;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!f;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">!!g;\t<span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h1><h2 id=\"数字转换为字符串\"><a href=\"#数字转换为字符串\" class=\"headerlink\" title=\"数字转换为字符串\"></a>数字转换为字符串</h2><p>因为字符串可以用+连接，所以当我们把数字和字符串用+连接时，数字会强制转换为字符串：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">122</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a + <span class=\"string\">&#x27;&#x27;</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// &quot;122&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串转换为数字\"><a href=\"#字符串转换为数字\" class=\"headerlink\" title=\"字符串转换为数字\"></a>字符串转换为数字</h2><p>因为-只在数字运算符中才有定义，所以对字符串使用-会被强制转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">&quot;122&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a - <span class=\"number\">0</span>;  </span><br><span class=\"line\">b;  <span class=\"comment\">// 122</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数组转换为数字\"><a href=\"#数组转换为数字\" class=\"headerlink\" title=\"数组转换为数字\"></a>数组转换为数字</h2><p>同样的，如果数组中只有一个值，使用-时，会先把数组转换为字符串，再转换为数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"number\">1</span>];</span><br><span class=\"line\">a - b; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"操作符的妙用\"><a href=\"#操作符的妙用\" class=\"headerlink\" title=\"操作符的妙用\"></a>操作符的妙用</h1><h2 id=\"操作符-和-amp-amp\"><a href=\"#操作符-和-amp-amp\" class=\"headerlink\" title=\"操作符||和&amp;&amp;\"></a>操作符||和&amp;&amp;</h2><p>我们都知道||代表‘或’，&amp;&amp;代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a || b;\t\t<span class=\"comment\">// 42</span></span><br><span class=\"line\">a &amp;&amp; b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">c || b;\t\t<span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\">c &amp;&amp; b;\t\t<span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以利用这两个操作符进行一些赋值操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a || b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? a : b;</span><br><span class=\"line\"></span><br><span class=\"line\">a &amp;&amp; b;</span><br><span class=\"line\"><span class=\"comment\">// 等价于：</span></span><br><span class=\"line\">a ? b : a;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"操作符-x3D-x3D-与-x3D-x3D-x3D\"><a href=\"#操作符-x3D-x3D-与-x3D-x3D-x3D\" class=\"headerlink\" title=\"操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;\"></a>操作符&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</h2><p>这两个符号我们应该很熟悉了，&#x3D;&#x3D;代表值的比较，如果二者类型不同，会进行强制转换；&#x3D;&#x3D;&#x3D;则是二者值与类型都相同才为true。这里需要注意一些问题：</p>\n<blockquote>\n<p>NaN不等于它本身<br>+0等于-0</p>\n</blockquote>\n<h3 id=\"字符串与数字比较\"><a href=\"#字符串与数字比较\" class=\"headerlink\" title=\"字符串与数字比较\"></a>字符串与数字比较</h3><p>二者比较时，使用&#x3D;&#x3D;&#x3D;结果肯定为false，因为二者类型不同，但如果使用&#x3D;&#x3D;，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"string\">&quot;22&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a === b;\t<span class=\"comment\">// false</span></span><br><span class=\"line\">a == b;\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"任何值与Boolean比较\"><a href=\"#任何值与Boolean比较\" class=\"headerlink\" title=\"任何值与Boolean比较\"></a>任何值与Boolean比较</h3><p>当任何值与Boolean使用&#x3D;&#x3D;比较时，首先会把Boolean转换为数字，然后再进行比较。也就是说：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"string\">&quot;42&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">x == y; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>所以，在任何时候，都不要使用&#x3D;&#x3D; true或者&#x3D;&#x3D; false这样的语句。</p>\n<h3 id=\"null与undefined比较\"><a href=\"#null与undefined比较\" class=\"headerlink\" title=\"null与undefined比较\"></a>null与undefined比较</h3><p>当使用&#x3D;&#x3D;比较null和undefined时，结果总为true。</p>\n<h3 id=\"Object与非Object比较\"><a href=\"#Object与非Object比较\" class=\"headerlink\" title=\"Object与非Object比较\"></a>Object与非Object比较</h3><p>当object&#x2F;function&#x2F;array与String或者Number进行&#x3D;&#x3D;比较时，会先把Object转换为String或Number，然后再对值进行比较，而Boolean值会被转换为Number再进行比较。</p>\n<h3 id=\"一些值得注意的比较\"><a href=\"#一些值得注意的比较\" class=\"headerlink\" title=\"一些值得注意的比较\"></a>一些值得注意的比较</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [<span class=\"literal\">null</span>];\t<span class=\"comment\">// true</span></span><br><span class=\"line\">[] == ![]; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == <span class=\"string\">&quot;\\n&quot;</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;0&quot;</span> == <span class=\"literal\">false</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"string\">&quot;&quot;</span>;\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == [];\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == <span class=\"number\">0</span>;\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;</span> == [];\t\t<span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> == [];\t\t<span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用<code>valueOf()</code>方法，没有才调用<code>toString()</code>方法，如果我们给自定义的对象添加<code>valueOf()</code>方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用&#x3D;&#x3D;&#x3D;比较安全。</p>\n<blockquote>\n<p>参考资料： <a href=\"https://github.com/getify/You-Dont-Know-JS/\">You-Dont-Know-JS</a></p>\n</blockquote>"},{"title":"React中如何更新state","date":"2017-08-04T12:49:46.000Z","_content":"\n我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。\n\n<!--more-->\n# setState\n首先我们来看一个React Component初始化的例子：\n```javascript\nimport React, { Component } from 'react';\n\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'flyrk',\n      sex: 'male'\n    };\n  }\n\n  render() {\n    return (\n      //....\n    );\n  }\n}\n```\n\n而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。\n\n但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：\n\n```javascript\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: ''\n    };\n  }\n\n  componentWillMount() {\n    this.props.getName().then(res => {  // 从服务器获取数据\n      const name = res.data.name;\n      this.setState({ name });\n      //...\n    });\n  }\n  render() {\n    return (\n      <div>\n        {this.state.name}\n      </div>\n    );\n  }\n}\n```\n\n后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：\n\nsetState()接受函数参数，我们可以这样写：\n\n```javascript\nthis.setState((prevState, props) => ({\n  name: prevState.name + props.name\n}));\n```\n\n这样我们就可以获取之前的state。\n\n还有一种方法，setState()第二个参数接受一个callback：\n\n```javascript\nthis.setState({ name }, callback);\n```\n\n在callback里我们可以对修改后的state进行操作。\n\n这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。\n\n","source":"_posts/2017-08-04-react-setState-update.md","raw":"---\ntitle: React中如何更新state\ndate: 2017-08-04 20:49:46\ncategories:\n- 前端框架\ntags:\n- React\n---\n\n我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。\n\n<!--more-->\n# setState\n首先我们来看一个React Component初始化的例子：\n```javascript\nimport React, { Component } from 'react';\n\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'flyrk',\n      sex: 'male'\n    };\n  }\n\n  render() {\n    return (\n      //....\n    );\n  }\n}\n```\n\n而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。\n\n但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：\n\n```javascript\nclass newComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: ''\n    };\n  }\n\n  componentWillMount() {\n    this.props.getName().then(res => {  // 从服务器获取数据\n      const name = res.data.name;\n      this.setState({ name });\n      //...\n    });\n  }\n  render() {\n    return (\n      <div>\n        {this.state.name}\n      </div>\n    );\n  }\n}\n```\n\n后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：\n\nsetState()接受函数参数，我们可以这样写：\n\n```javascript\nthis.setState((prevState, props) => ({\n  name: prevState.name + props.name\n}));\n```\n\n这样我们就可以获取之前的state。\n\n还有一种方法，setState()第二个参数接受一个callback：\n\n```javascript\nthis.setState({ name }, callback);\n```\n\n在callback里我们可以对修改后的state进行操作。\n\n这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。\n\n","slug":"react-setState-update","published":1,"updated":"2022-02-24T05:53:20.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz4300170hp38s8r9r38","content":"<p>我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。</p>\n<span id=\"more\"></span>\n<h1 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h1><p>首先我们来看一个React Component初始化的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyrk&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">//....</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。</p>\n<p>但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">componentWillMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">getName</span>().<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;  <span class=\"comment\">// 从服务器获取数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> name = res.<span class=\"property\">data</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;);</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;this.state.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：</p>\n<p>setState()接受函数参数，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(<span class=\"function\">(<span class=\"params\">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: prevState.<span class=\"property\">name</span> + props.<span class=\"property\">name</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以获取之前的state。</p>\n<p>还有一种方法，setState()第二个参数接受一个callback：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;, callback);</span><br></pre></td></tr></table></figure>\n\n<p>在callback里我们可以对修改后的state进行操作。</p>\n<p>这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。</p>\n","site":{"data":{}},"excerpt":"<p>我们知道，React中最重要的概念就是state和props，我们在写每一个组件时，都可以为该组件创建一个state，用以保存当前组件的数据。那么如何去更新state就是一个重要的问题了。</p>","more":"<h1 id=\"setState\"><a href=\"#setState\" class=\"headerlink\" title=\"setState\"></a>setState</h1><p>首先我们来看一个React Component初始化的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Component</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;flyrk&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">sex</span>: <span class=\"string\">&#x27;male&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"comment\">//....</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而当我们要更新state，不能直接赋值修改this.state，而是应该使用this.setState()方法。</p>\n<p>但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新state，更新的state再进行处理，同步显示在某个div中。当我这样写的时候，发现视图层迟迟没有更新：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">newComponent</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">componentWillMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">props</span>.<span class=\"title function_\">getName</span>().<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;  <span class=\"comment\">// 从服务器获取数据</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> name = res.<span class=\"property\">data</span>.<span class=\"property\">name</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;);</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        &#123;this.state.name&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后来上网查阅官方文档，才发现React的setState()可能是异步的。也就是说，当我们用this.setState()更新state时，state可能不会立即更新，React会将多个setState()合并在一起最后调用来提高性能，如果我们想立即使用更新后的state，有两种方法：</p>\n<p>setState()接受函数参数，我们可以这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(<span class=\"function\">(<span class=\"params\">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: prevState.<span class=\"property\">name</span> + props.<span class=\"property\">name</span></span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以获取之前的state。</p>\n<p>还有一种方法，setState()第二个参数接受一个callback：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123; name &#125;, callback);</span><br></pre></td></tr></table></figure>\n\n<p>在callback里我们可以对修改后的state进行操作。</p>\n<p>这两种方法，都可以保证操作的state是最新值，并且能在render()里展现出来。</p>"},{"title":"我是如何当上程序员的（二）","date":"2019-08-25T14:32:40.000Z","toc":true,"_content":"\n接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？\n\n# 找工作\n人生最怕没有目标，一旦有了目标，生活就有了动力。\n\n在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。\n\n接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。\n\n然而，事与愿违，那段时间成了我最痛苦的一段时间。\n\n因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。\n\n接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。\n\n调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。\n\n就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。\n\n因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。\n\n一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。\n\n但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。\n\n到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。\n\n后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。\n\n# 回顾\n回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。\n\n其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。\n\n金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。\n\n但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。\n\n程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！\n\n最后，附上自己当时校招找工作时看的部分书单：\n\n- 《JavaScript高级程序设计》——必读\n- 《你不知道的JS》——强烈推荐\n- 《CSS禅意花园》——学习CSS很有用\n- 《JavaScript设计模式》——对代码质量提升很大\n- 《高性能网站建设指南》——了解网站优化\n- 《响应式Web设计全流程解析》——响应式布局、网页设计\n","source":"_posts/2019-08-25-how-can-i-be-a-programmer-2.md","raw":"---\ntitle: 我是如何当上程序员的（二）\ndate: 2019-08-25 22:32:40\ntoc: true\ncategories:\n- 经验分享\ntags:\n- 职业规划\n---\n\n接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？\n\n# 找工作\n人生最怕没有目标，一旦有了目标，生活就有了动力。\n\n在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。\n\n接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。\n\n然而，事与愿违，那段时间成了我最痛苦的一段时间。\n\n因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。\n\n接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。\n\n调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。\n\n就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。\n\n因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。\n\n一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。\n\n但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。\n\n到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。\n\n后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。\n\n# 回顾\n回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。\n\n其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。\n\n金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。\n\n但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。\n\n程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！\n\n最后，附上自己当时校招找工作时看的部分书单：\n\n- 《JavaScript高级程序设计》——必读\n- 《你不知道的JS》——强烈推荐\n- 《CSS禅意花园》——学习CSS很有用\n- 《JavaScript设计模式》——对代码质量提升很大\n- 《高性能网站建设指南》——了解网站优化\n- 《响应式Web设计全流程解析》——响应式布局、网页设计\n","slug":"how-can-i-be-a-programmer-2","published":1,"updated":"2022-02-24T06:34:23.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz49001b0hp3c8a1ftdu","content":"<p>接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？</p>\n<h1 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h1><p>人生最怕没有目标，一旦有了目标，生活就有了动力。</p>\n<p>在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。</p>\n<p>接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。</p>\n<p>然而，事与愿违，那段时间成了我最痛苦的一段时间。</p>\n<p>因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。</p>\n<p>接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。</p>\n<p>调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。</p>\n<p>就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。</p>\n<p>因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。</p>\n<p>一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。</p>\n<p>但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。</p>\n<p>到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。</p>\n<p>后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。</p>\n<h1 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h1><p>回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。</p>\n<p>其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。</p>\n<p>金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。</p>\n<p>但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。</p>\n<p>程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！</p>\n<p>最后，附上自己当时校招找工作时看的部分书单：</p>\n<ul>\n<li>《JavaScript高级程序设计》——必读</li>\n<li>《你不知道的JS》——强烈推荐</li>\n<li>《CSS禅意花园》——学习CSS很有用</li>\n<li>《JavaScript设计模式》——对代码质量提升很大</li>\n<li>《高性能网站建设指南》——了解网站优化</li>\n<li>《响应式Web设计全流程解析》——响应式布局、网页设计</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>接上文，决定了要当一个前端开发工程师，那么应该怎么做呢？</p>\n<h1 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h1><p>人生最怕没有目标，一旦有了目标，生活就有了动力。</p>\n<p>在确定了自己要走前端开发这条路后，我反而心态放松了许多，因为自己有了明确的目标，虽然还是很迷茫。因为彼时的我才刚入门前端开发半年时间，期间完全靠自己在网上找资料自学，身边也没有其他小伙伴一起，可以说那个时候的我真的是一个人在战斗。</p>\n<p>接下来的日子，我开始边学习边找暑假实习，每天基本上只要没课就泡在图书馆了，那个时候的我对前端知识饥渴到只要看到书名和Web、JavaScript沾边的，就一定要去借来翻一翻，觉得不合适的就放回去继续下一本。每天从图书馆回来看到室友在打游戏开黑，自己心里也会有抑制不住想加入他们的冲动。但是理性告诉我不行，我和他们的目标不一样，要找到心仪的工作，我必须努力先找到实习，加强自己的经验。</p>\n<p>然而，事与愿违，那段时间成了我最痛苦的一段时间。</p>\n<p>因为之前完全没有任何项目经验，都是自己小打小闹，一个人摸索。去实习面试的时候别人一问到项目经验就懵逼了，再加上自己内向的性格，有时候语言表达不够清楚，刚开始面试的几家公司是屡战屡败。</p>\n<p>接二连三的面试失败让我萌生了想要放弃的念头，怀疑自己到底能不能找到实习，找不到怎么办？到时候校招没有实习经验别人更加不会要。但是，还好我及时调整了心态，当时也是去知乎、v2ex等论坛翻看各种前人经验和鸡汤来鼓励自己。我当时就是有一种不信邪的劲，为什么别人能找到实习我不可以，我又不比别人差。</p>\n<p>调整了心态后，我开始把面试当成打怪升级的过程，每一次面试后都进行总结，把问到的知识点都记下来，回去一个个消化。基础不好就补基础，没有项目经验就去看别人的项目怎么写。由于时间有限，短时间我不可能去生造一个项目出来。于是我采取了两步走策略：主要是看各种前端开发面经和面试题，一个一个地看，强化自己的知识点；同时，根据网上推荐的前端书籍去图书馆一本一本地借阅，慢慢补基础。</p>\n<p>就这样，我的实习面试慢慢变得越来越好，不再是一面挂、二面挂。腾讯的暑期实习面试更是走到了最后，HR面都面完了。正当我觉得腾讯的面试稳了（因为HR面基本上不会挂人），老天爷给我开了一个玩笑。</p>\n<p>因为觉得腾讯稳了，所以后来的面试我也就比较随意，也没有再去投更多的公司，现在看来是个严重的决策失误。一直等到五月底，腾讯实习面试结果都没出来，那个时候我才知道，我凉了。在那个时间点，好的公司暑假实习基本上早就招完了，有的甚至已经开始实习了。我只能匆忙投了几家小公司，甚至去学校的实习双选会碰碰运气，然而由于心态的变化，最后都渺无音讯。</p>\n<p>一般人这个时候肯定慌的不行，我也不例外。我无数次地问自己，自己的选择到底做对了吗？我是不是该和大多数人一样去考研，以我的成绩，要去考肯定能考上的。但是，我读研到底是为了什么？我问自己。首先，我不喜欢读本专业，如果要读研的话我肯定要转计算机专业，但是现在学专业课已经来不及了，很有可能考不上。再者，即使读了计算机专业，但是我想当前端开发的话，读研对我的提升真的比工作大吗？我得出的结论是，工作对我的技能提升更快。我并不是说读研不好，没有用，而是在我看来，如果读研不能更有效地帮助我提升自己，只是为了一纸文凭的话，还不如尽早工作。我不想让读研成为自己能力不行、逃避工作的借口。</p>\n<p>但是，这个时间找实习已经来不及了，我该怎么办？我仔细总结了到目前为止自己的优劣势，发现自己最大的缺陷就是缺乏实际项目经验，找实习的目的也是为了增加经验，那么，我为啥不自己写项目呢？虽然可能体验不到公司那种多人协同开发，但是总比没有经验好。于是我开始在GitHub上找项目，去YouTube上找教程，自己从零开始模仿着写。慢慢地，我开始沉下心来。</p>\n<p>到了暑假，我每天给自己安排学习计划，上午看JavaScript书，中午看会CSS、HTML，下午写项目，晚上去牛客网刷会题，对知识进行总结。就这样有条不紊地进行着，我反而没那么着急了。</p>\n<p>后来的事就开始顺理成章，我的项目经验慢慢丰富起来，简历上能说的东西也多了。到了正式校招，我陆续投了几家公司，没想到这次运气眷顾了我，我拿到了网易杭研院的提前批offer，于是我在网易开始了正式的程序员生涯。后来机缘巧合下又加入了微信。</p>\n<h1 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h1><p>回顾我是如何一步一步当上程序员，和那些拿ACM奖拿到手软、大厂实习经历丰富的大牛们来说，可能显得有点平平无奇。但我想表达的是，想当程序员并且进一家还算不错的公司其实没那么难，纵观我的经历，没有竞赛拿奖经历，没有工作室经验，没有大厂实习光环，最后一样拿到了大厂offer。</p>\n<p>其实关键在于，你有多想当程序员，你有多热爱你的事业，你有多大的决心。如果只是单纯的认为程序员工资高，觉得程序员很容易当，那我劝你还是迟早放弃这个念头。</p>\n<p>金融、销售等等行业工资一样高，做得好不会比程序员差。相比较之下，程序员反而显得更加枯燥，它需要一个人长时间坐在电脑面前思考、敲键盘，对人的精神和身体都是极大的考验，所以没有一定的毅力和热爱，很容易就会放弃。</p>\n<p>但我不是说当程序员不好，而是在当程序员之前得想清楚，自己的目标是什么，自己到底有多大的决心。不管是为了梦想也好、钱也好，都必须有个明确的目标，并且持之以恒地坚持下去。</p>\n<p>程序员是个需要终身学习的职业，或者说没有哪个行业不需要学习。所以，当你一旦确定要当程序员，最好的方法就是，确定目标、制定计划、行动起来！</p>\n<p>最后，附上自己当时校招找工作时看的部分书单：</p>\n<ul>\n<li>《JavaScript高级程序设计》——必读</li>\n<li>《你不知道的JS》——强烈推荐</li>\n<li>《CSS禅意花园》——学习CSS很有用</li>\n<li>《JavaScript设计模式》——对代码质量提升很大</li>\n<li>《高性能网站建设指南》——了解网站优化</li>\n<li>《响应式Web设计全流程解析》——响应式布局、网页设计</li>\n</ul>\n"},{"title":"我是如何当上程序员的（一）","date":"2019-08-18T13:28:46.000Z","toc":true,"_content":"\n今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？\n<!--more-->\n# 初识编程\n说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。\n\n那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。\n\n那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。\n\n后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。\n\n上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。\n\n# 再学编程\n转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。\n\n进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？\n\n接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。\n\n那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。\n\n# 接触前端\n后来，我接触到了前端开发这个职业，也就是我现在在做的工作。\n\n那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！\n\n于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。\n\n才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。\n\n大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。\n\n当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。\n\n后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。\n\n未完待续…","source":"_posts/2019-08-18-how-can-i-be-a-programmer-1.md","raw":"---\ntitle: 我是如何当上程序员的（一）\ndate: 2019-08-18 21:28:46\ntoc: true\ncategories:\n- 经验分享\ntags:\n- 职业规划\n---\n\n今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？\n<!--more-->\n# 初识编程\n说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。\n\n那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。\n\n那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。\n\n后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。\n\n上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。\n\n# 再学编程\n转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。\n\n进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？\n\n接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。\n\n那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。\n\n# 接触前端\n后来，我接触到了前端开发这个职业，也就是我现在在做的工作。\n\n那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！\n\n于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。\n\n才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。\n\n大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。\n\n当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。\n\n后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。\n\n未完待续…","slug":"how-can-i-be-a-programmer-1","published":1,"updated":"2022-02-24T06:32:08.608Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl00miz4b001d0hp3hth76u7a","content":"<p>今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？</p>\n<span id=\"more\"></span>\n<h1 id=\"初识编程\"><a href=\"#初识编程\" class=\"headerlink\" title=\"初识编程\"></a>初识编程</h1><p>说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。</p>\n<p>那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。</p>\n<p>那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。</p>\n<p>后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。</p>\n<p>上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。</p>\n<h1 id=\"再学编程\"><a href=\"#再学编程\" class=\"headerlink\" title=\"再学编程\"></a>再学编程</h1><p>转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。</p>\n<p>进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？</p>\n<p>接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。</p>\n<p>那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。</p>\n<h1 id=\"接触前端\"><a href=\"#接触前端\" class=\"headerlink\" title=\"接触前端\"></a>接触前端</h1><p>后来，我接触到了前端开发这个职业，也就是我现在在做的工作。</p>\n<p>那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！</p>\n<p>于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。</p>\n<p>才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。</p>\n<p>大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。</p>\n<p>当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。</p>\n<p>后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。</p>\n<p>未完待续…</p>\n","site":{"data":{}},"excerpt":"<p>今天来聊聊我是如何当上程序员的，有时候也在想，我一个学电子的，大学每天都是和硬件、电路板打交道，是怎么走上程序员这条路的呢？</p>","more":"<h1 id=\"初识编程\"><a href=\"#初识编程\" class=\"headerlink\" title=\"初识编程\"></a>初识编程</h1><p>说起来，我和编程也算是有过一段缘分。小学六年级的时候，刚转到新的学校，人生地不熟的，正好学校新成立一个信息学竞赛培训班，看我入学考试数学成绩不错，就把我拉进去了。</p>\n<p>那是我第一次接触计算机编程，之前倒是玩过不少网络游戏，但是对编程和代码完全一窍不通。刚进去机房，老师叫我们打开Visual Basic软件，映入眼帘的是蓝色的背景，回车符不停的闪烁，一连串的英文界面看得我眼花缭乱。从那时起，就打开了计算机编程新世界的大门。</p>\n<p>那段时间，六十几个人的班，老师每节课都会教一些基础的编程知识，现在依稀还记得什么条件语句、循环语句，do while、viod main等等。每节课都有新内容，每节课也都有小伙伴学不下去而离开。我当时纯粹是因为好奇，而且自己逻辑思维能力还比较强，再加上每节课下课还会有几分钟时间和小伙伴打几局CS1.6，所以就一直坚持下来了。</p>\n<p>后来，上了初中，编程水平慢慢熟练了，还参加过几次比赛，但其实都是基础的语法考察，涉及到了一点算法，当时用的是Pascal语言，写法约束超级多，个人感觉比C++还难写。那段信息学竞赛的日子现在回想起来还挺难忘的。每个晚自习早早写完作业后就去机房写代码，周末寒暑假也要去机房，经常趁老师没来打几局红警、CS，想想还挺欢乐的。</p>\n<p>上了初三，因为学业更加忙的原因，再加上自己的兴趣也慢慢减弱（主要是因为没有完整的寒暑假），就退出了信息学竞赛培训班，我与编程的故事也就暂时告一段落。</p>\n<h1 id=\"再学编程\"><a href=\"#再学编程\" class=\"headerlink\" title=\"再学编程\"></a>再学编程</h1><p>转眼到了高三毕业，填志愿的时候在想自己将来应该干点什么好呢？想到自己业余爱好是体育，但这个时候去搞体育肯定不现实了，又想到自己以前不是学过编程吗？刚好那个时候计算机专业算是比较热门的，于是就想填个计算机专业不错的学校。但是阴差阳错，当时以为电子信息工程也是学计算机的（信息两个字蒙蔽了我。。。），于是抱了个电子科技大学，第一志愿填的电子信息工程，第二志愿填的计算机技术，结果，入了电子的坑。</p>\n<p>进了大学，头两个月的课程学习让我感觉到，自己不是学电子的料。所有的课下来，只有C语言这门课我学的最好。当时没有按照老师给的谭浩强那本C语言教材来学，而是自己买了本“C Primer Plus”，自己开始自学编程，最后期末考试考了个100分，从那时起，心里就开始觉得，欸，好像编程还蛮不错的？</p>\n<p>接下来的日子，我开始给自己定下了目标，虽然不是计算机专业，但是我可以自学编程，我开始搜罗所有和计算机有关的知识，想着未来要做什么。大一大二那段时间，我报名了学校的ACM集训队，打过几场校内比赛；还在网上边看教程边自学python，想着能写点小游戏、爬虫。后来又接触了计算机安全，梦想着做一名黑客，再后来又去图书馆借了一大堆游戏编程，自己还用C++写了几个小游戏。</p>\n<p>那是我第一次完全靠自己的兴趣在做事，没有人逼我，完全是自学，那样纯粹学习的日子真的挺美好，让人怀念。</p>\n<h1 id=\"接触前端\"><a href=\"#接触前端\" class=\"headerlink\" title=\"接触前端\"></a>接触前端</h1><p>后来，我接触到了前端开发这个职业，也就是我现在在做的工作。</p>\n<p>那是在大二下学期的时候，当时刚用C++写完几个小游戏，就觉得用C++写起图形界面实在是太费劲了，更多的时候都是在面对控制台命令行，有没有什么语言能让我快速写出好看的界面，并且能实现炫酷的游戏效果就好了。这时，我突然看到了前端开发这个词。立即在知乎搜了半天有关话题，发现是写网页的，而且很容易就能看到自己想要的效果，只需要HTML、CSS，甚至都不需要什么JS逻辑，浏览器刷新下就能看到炫酷的静态网页，这不就是我想要的吗？！</p>\n<p>于是，我开始入坑前端，正应了那句话：一入前端深似海。真正接触前端，才发现没自己想的那么简单，前端三剑客不用说了，那时正好刚开始兴起框架，React、Vue、Angular开始慢慢流行，还有Bootstrap，jQuery。学完了静态网页，发现还有CSS3动画，Canvas。然后又发现没那么简单，还有叫单页应用的玩意，用Ajax通信，可以不用刷新网页就获取新的数据，还有前端路由跳转，等等。</p>\n<p>才发现，前端要学的东西实在是太多了，每个星期都在更新新的框架、工具库，那真是前端百花齐放的时代，但是对于一个新手来说，真的会显得手足无措。还好，我这个人有个优点，乐于接受一切新事物，虽然也会感到迷茫，但是我喜欢挑战，我到各大网站搜各种教程资料，自己不知道学什么就去学习别人的经验。我也不是什么新知识都学，因为知道自己肯定学不过来，而是先从基础开始，大三整个一年，我基本就是宿舍、教学楼、图书馆三点一线，去图书馆翻看一切有关前端开发的书籍，当然虽然借了很多本，但其实真正看完的也不是很多，因为我都是有选择地看，翻了一回发现不感兴趣或者自己暂时还没有达到那个水准看不懂，就放下看别的。所以，整个大三一年可以说我主要的经历都是放在学习前端上了。</p>\n<p>大三那个寒假，我也坚定了自己的看法，放弃考研，去找前端开发工作。</p>\n<p>当时父母家人都认为我疯了，居然不去考研，但我知道，我的目标是什么。如果去考研，我也肯定是想考计算机专业，但是前端开发这个职业很特殊，大学里没有老师专门教这个，所以我决定干脆开始找工作，去实际中锻炼自己。</p>\n<p>后来的事实证明，有自己的目标很重要，至少现在我没有后悔当时的决定。</p>\n<p>未完待续…</p>"},{"layout":"post","title":"我的博客终于搭好了！","date":"2017-04-02T16:17:51.000Z","_content":"\n**花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。\n希望能在记录自己的生活中成长吧！**\n\n今天很晚了。。。就先写到这吧～\n","source":"_posts/thoughts.md","raw":"layout: post\ntitle: 我的博客终于搭好了！\ndate: 2017-04-03 00:17:51\ntags: thoughts\ncategories: 随笔\n---\n\n**花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。\n希望能在记录自己的生活中成长吧！**\n\n今天很晚了。。。就先写到这吧～\n","slug":"thoughts","published":1,"updated":"2022-02-24T02:14:18.166Z","comments":1,"photos":[],"link":"","_id":"cl00miz4e001h0hp31irp4qyi","content":"<p><strong>花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。<br>希望能在记录自己的生活中成长吧！</strong></p>\n<p>今天很晚了。。。就先写到这吧～</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>花了一个多小时的时间，终于搭好了我的个人博客。。。虽然还很简陋，虽然还什么都没有，但我会慢慢开始记录我的生活和学习。<br>希望能在记录自己的生活中成长吧！</strong></p>\n<p>今天很晚了。。。就先写到这吧～</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl00miz3700080hp300z4a6a0","category_id":"cl00miz3200040hp38eyc8u14","_id":"cl00miz3f000e0hp39fjo9akm"},{"post_id":"cl00miz2t00010hp3gbzt0lzu","category_id":"cl00miz3200040hp38eyc8u14","_id":"cl00miz3h000i0hp30i96844f"},{"post_id":"cl00miz2y00030hp37dzvdco0","category_id":"cl00miz39000a0hp3e3q718zs","_id":"cl00miz3k000m0hp31w8ghfzo"},{"post_id":"cl00miz3g000h0hp35qtbbj9g","category_id":"cl00miz3g000f0hp3f8tvc1hf","_id":"cl00miz3s000s0hp39s7xdux8"},{"post_id":"cl00miz3500070hp38i7oeadb","category_id":"cl00miz3g000f0hp3f8tvc1hf","_id":"cl00miz3v000w0hp30p4mephi"},{"post_id":"cl00miz3800090hp3akdy8n1o","category_id":"cl00miz39000a0hp3e3q718zs","_id":"cl00miz3x000z0hp379diclnp"},{"post_id":"cl00miz3r000r0hp3fyuxgud0","category_id":"cl00miz39000a0hp3e3q718zs","_id":"cl00miz4000130hp3expwgesp"},{"post_id":"cl00miz3u000v0hp3exzs3l1x","category_id":"cl00miz3g000f0hp3f8tvc1hf","_id":"cl00miz4200160hp3a0wrfyda"},{"post_id":"cl00miz3d000c0hp3h21a3niz","category_id":"cl00miz3t000t0hp3gw84fkgr","_id":"cl00miz49001a0hp3c92gdxob"},{"post_id":"cl00miz3f000d0hp34ula6ccr","category_id":"cl00miz3x00100hp355m22lz8","_id":"cl00miz4c001f0hp3h0lr89pw"},{"post_id":"cl00miz3i000k0hp3hprghr26","category_id":"cl00miz3x00100hp355m22lz8","_id":"cl00miz4f001k0hp3dwyof4om"},{"post_id":"cl00miz3o000p0hp3e4t112bk","category_id":"cl00miz3x00100hp355m22lz8","_id":"cl00miz4h001n0hp34be9808a"},{"post_id":"cl00miz3v000y0hp3b2ry8rac","category_id":"cl00miz4f001j0hp37i982tup","_id":"cl00miz4j001q0hp3fbu0f5g4"},{"post_id":"cl00miz3y00110hp31mot1wws","category_id":"cl00miz4h001o0hp3g9un7iqz","_id":"cl00miz4k001t0hp397ki4e9u"},{"post_id":"cl00miz4000150hp3c94t6ynw","category_id":"cl00miz4j001r0hp30h289fyp","_id":"cl00miz4l001x0hp31b3hdjfl"},{"post_id":"cl00miz4300170hp38s8r9r38","category_id":"cl00miz4k001u0hp34wag9g66","_id":"cl00miz4m00220hp3ghssgsr8"},{"post_id":"cl00miz49001b0hp3c8a1ftdu","category_id":"cl00miz4l001y0hp319w1bskb","_id":"cl00miz4p00280hp3fpri1uuu"},{"post_id":"cl00miz4b001d0hp3hth76u7a","category_id":"cl00miz4l001y0hp319w1bskb","_id":"cl00miz4q002b0hp3bxl9d7ot"},{"post_id":"cl00miz4e001h0hp31irp4qyi","category_id":"cl00miz4f001j0hp37i982tup","_id":"cl00miz4r002d0hp35q8t9iqv"}],"PostTag":[{"post_id":"cl00miz2t00010hp3gbzt0lzu","tag_id":"cl00miz3300050hp33z11dh2p","_id":"cl00miz3h000j0hp39j38evhs"},{"post_id":"cl00miz2t00010hp3gbzt0lzu","tag_id":"cl00miz3c000b0hp3fwxd60g4","_id":"cl00miz3k000l0hp3am5tf27l"},{"post_id":"cl00miz2y00030hp37dzvdco0","tag_id":"cl00miz3g000g0hp3d3zxdwol","_id":"cl00miz3q000q0hp30psk4saa"},{"post_id":"cl00miz3500070hp38i7oeadb","tag_id":"cl00miz3k000o0hp35393ahwx","_id":"cl00miz3v000x0hp37xrw8zzn"},{"post_id":"cl00miz3700080hp300z4a6a0","tag_id":"cl00miz3u000u0hp360j7511d","_id":"cl00miz4000140hp32rljfdsk"},{"post_id":"cl00miz3800090hp3akdy8n1o","tag_id":"cl00miz3z00120hp3953d0la2","_id":"cl00miz4a001c0hp37286fj21"},{"post_id":"cl00miz3d000c0hp3h21a3niz","tag_id":"cl00miz4800190hp3ejyy96hw","_id":"cl00miz4f001i0hp38bzo0bz2"},{"post_id":"cl00miz3f000d0hp34ula6ccr","tag_id":"cl00miz4d001g0hp31knm0ge0","_id":"cl00miz4g001m0hp39hc36slw"},{"post_id":"cl00miz3g000h0hp35qtbbj9g","tag_id":"cl00miz4g001l0hp3dahac3qw","_id":"cl00miz4l001w0hp31oc0cvi5"},{"post_id":"cl00miz3g000h0hp35qtbbj9g","tag_id":"cl00miz4i001p0hp389i5e2g6","_id":"cl00miz4l001z0hp3bhioh4t0"},{"post_id":"cl00miz3g000h0hp35qtbbj9g","tag_id":"cl00miz4j001s0hp39laj8q6k","_id":"cl00miz4m00210hp30ug952du"},{"post_id":"cl00miz3i000k0hp3hprghr26","tag_id":"cl00miz4d001g0hp31knm0ge0","_id":"cl00miz4n00240hp33wt8hiye"},{"post_id":"cl00miz3o000p0hp3e4t112bk","tag_id":"cl00miz4d001g0hp31knm0ge0","_id":"cl00miz4o00260hp3eenge7x4"},{"post_id":"cl00miz3r000r0hp3fyuxgud0","tag_id":"cl00miz4n00250hp37kq4dqhh","_id":"cl00miz4q002a0hp30ys9hdl2"},{"post_id":"cl00miz3u000v0hp3exzs3l1x","tag_id":"cl00miz4q00290hp34rkh39mh","_id":"cl00miz4t002g0hp3bqip03i3"},{"post_id":"cl00miz3u000v0hp3exzs3l1x","tag_id":"cl00miz4r002c0hp3cqq5fodi","_id":"cl00miz4t002h0hp3euno4a4r"},{"post_id":"cl00miz3u000v0hp3exzs3l1x","tag_id":"cl00miz4s002e0hp36igp8cig","_id":"cl00miz4t002j0hp316k5da39"},{"post_id":"cl00miz3v000y0hp3b2ry8rac","tag_id":"cl00miz4s002f0hp3bzk34zzt","_id":"cl00miz4t002k0hp32ej9ew1i"},{"post_id":"cl00miz3y00110hp31mot1wws","tag_id":"cl00miz4t002i0hp3fxhk7n3h","_id":"cl00miz4u002m0hp3gn7obrd2"},{"post_id":"cl00miz4000150hp3c94t6ynw","tag_id":"cl00miz4u002l0hp3efxq72vc","_id":"cl00miz4v002o0hp32isodujl"},{"post_id":"cl00miz4300170hp38s8r9r38","tag_id":"cl00miz4v002n0hp3dln2a1hv","_id":"cl00miz4w002q0hp3d6x46aqk"},{"post_id":"cl00miz49001b0hp3c8a1ftdu","tag_id":"cl00miz4w002p0hp3frn66hq1","_id":"cl00miz4x002s0hp38vzb42sc"},{"post_id":"cl00miz4b001d0hp3hth76u7a","tag_id":"cl00miz4w002p0hp3frn66hq1","_id":"cl00miz4y002u0hp3bvsf1tn4"},{"post_id":"cl00miz4e001h0hp31irp4qyi","tag_id":"cl00miz4s002f0hp3bzk34zzt","_id":"cl00miz4z002v0hp39nv4a1ay"}],"Tag":[{"name":"Tree","_id":"cl00miz3300050hp33z11dh2p"},{"name":"JavaScript","_id":"cl00miz3c000b0hp3fwxd60g4"},{"name":"HTTP","_id":"cl00miz3g000g0hp3d3zxdwol"},{"name":"闭包","_id":"cl00miz3k000o0hp35393ahwx"},{"name":"leetcode","_id":"cl00miz3u000u0hp360j7511d"},{"name":"跨域","_id":"cl00miz3z00120hp3953d0la2"},{"name":"性能优化","_id":"cl00miz4800190hp3ejyy96hw"},{"name":"实习面试","_id":"cl00miz4d001g0hp31knm0ge0"},{"name":"this","_id":"cl00miz4g001l0hp3dahac3qw"},{"name":"call","_id":"cl00miz4i001p0hp389i5e2g6"},{"name":"apply","_id":"cl00miz4j001s0hp39laj8q6k"},{"name":"http状态码","_id":"cl00miz4n00250hp37kq4dqhh"},{"name":"Function","_id":"cl00miz4q00290hp34rkh39mh"},{"name":"throttle","_id":"cl00miz4r002c0hp3cqq5fodi"},{"name":"debounce","_id":"cl00miz4s002e0hp36igp8cig"},{"name":"thoughts","_id":"cl00miz4s002f0hp3bzk34zzt"},{"name":"CSS技巧","_id":"cl00miz4t002i0hp3fxhk7n3h"},{"name":"JS基础","_id":"cl00miz4u002l0hp3efxq72vc"},{"name":"React","_id":"cl00miz4v002n0hp3dln2a1hv"},{"name":"职业规划","_id":"cl00miz4w002p0hp3frn66hq1"}]}}