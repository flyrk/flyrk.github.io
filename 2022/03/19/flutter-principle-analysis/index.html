<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="打开思维，深度思考"><meta name="msvalidate.01" content="5CEEF6BD3C3EFB245184F63943754FA5"><title>你必须了解的Flutter原理 | 西蒙的实验室</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/rss+xml" href="/rss2.xml"><script src="https://www.googletagmanager.com/gtag/js?id=G-WL4FJB49FS" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-WL4FJB49FS');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'deaa76c48a79514034d820a7265ff8c9';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script>(function(c,l,a,r,i,t,y){
  c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
  t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
  y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "aqkh9fgrxy");
</script><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">你必须了解的Flutter原理</h1><a id="logo" href="/.">西蒙的实验室</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/rss2.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">你必须了解的Flutter原理</h1><div class="post-meta">2022-03-19<span> | </span><span class="category"><a href="/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFlutter"><span class="toc-number">1.</span> <span class="toc-text">什么是Flutter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">框架简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%B1%82"><span class="toc-number">1.1.1.</span> <span class="toc-text">嵌入层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E6%93%8E%E5%B1%82"><span class="toc-number">1.1.2.</span> <span class="toc-text">引擎层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E5%B1%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">框架层</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">渲染原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E9%81%93"><span class="toc-number">2.1.</span> <span class="toc-text">渲染管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E6%A0%91"><span class="toc-number">2.2.</span> <span class="toc-text">视图树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">创建树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">更新树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88widget%E9%83%BD%E6%98%AFimmutable%EF%BC%9F"><span class="toc-number">2.4.1.</span> <span class="toc-text">为什么widget都是immutable？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#widget%E9%87%8D%E6%96%B0%E5%88%9B%E5%BB%BA%EF%BC%8Celement%E6%A0%91%E5%92%8CrenderObject%E6%A0%91%E6%98%AF%E5%90%A6%E4%B9%9F%E9%87%8D%E6%96%B0%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">widget重新创建，element树和renderObject树是否也重新创建？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%9B%B4%E6%96%B0%E8%A7%84%E5%88%99"><span class="toc-number">2.4.3.</span> <span class="toc-text">树的更新规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E6%A0%91%E6%9B%B4%E6%96%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text">如何触发树更新</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#APP%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.</span> <span class="toc-text">APP生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC"><span class="toc-number">5.</span> <span class="toc-text">数据流转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">从上往下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A"><span class="toc-number">5.2.</span> <span class="toc-text">从下往上</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Widget"><span class="toc-number">6.</span> <span class="toc-text">Widget</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#StatefulWidget"><span class="toc-number">6.1.</span> <span class="toc-text">StatefulWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RouteObserver"><span class="toc-number">6.2.</span> <span class="toc-text">RouteObserver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StreamBuilder"><span class="toc-number">6.3.</span> <span class="toc-text">StreamBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Container"><span class="toc-number">6.4.</span> <span class="toc-text">Container</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">6.5.</span> <span class="toc-text">Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Positioned"><span class="toc-number">6.5.1.</span> <span class="toc-text">Positioned</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Column"><span class="toc-number">6.6.</span> <span class="toc-text">Column</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Row"><span class="toc-number">6.7.</span> <span class="toc-text">Row</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SizedBox"><span class="toc-number">6.8.</span> <span class="toc-text">SizedBox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Text"><span class="toc-number">6.9.</span> <span class="toc-text">Text</span></a></li></ol></li></ol></div></div><div class="post-content"><p>本文旨在记录分析Flutter的渲染原理和设计理念，参考了一些文档和博客，方便Flutter开发者学习交流。</p>
<span id="more"></span>

<h1 id="什么是Flutter"><a href="#什么是Flutter" class="headerlink" title="什么是Flutter"></a>什么是Flutter</h1><p>Flutter 是一个跨平台的 UI 工具集，帮助开发者通过一套代码库高效构建多平台精美应用。</p>
<h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h2><h3 id="嵌入层"><a href="#嵌入层" class="headerlink" title="嵌入层"></a>嵌入层</h3><p>对于底层操作系统而言，Flutter 应用程序的包装方式与其他原生应用相同。在每一个平台上，会包含一个特定的嵌入层，从而提供一个程序入口，程序由此可以与底层操作系统进行协调，访问诸如 surface 渲染、辅助功能和输入等服务，并且管理事件循环队列。该嵌入层采用了适合当前平台的语言编写，例如 Android 使用的是 Java 和 C++， iOS 和 macOS 使用的是 Objective-C 和 Objective-C++，Windows 和 Linux 使用的是 C++。 Flutter 代码可以通过嵌入层，以模块方式集成到现有的应用中，也可以作为应用的主体。 Flutter 本身包含了各个常见平台的嵌入层。</p>
<h3 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h3><p>Flutter 引擎 是 Flutter 的核心，它主要使用 C++ 编写，并提供了 Flutter 应用所需的原语。当需要绘制新一帧的内容时，引擎将负责对需要合成的场景进行栅格化。它提供了 Flutter 核心 API 的底层实现，包括图形（通过 Skia）、文本布局、文件及网络 IO、辅助功能支持、插件架构和 Dart 运行环境及编译环境的工具链。<br>引擎将底层 C++ 代码包装成 Dart 代码，通过 dart:ui 暴露给 Flutter 框架层。该库暴露了最底层的原语，包括用于驱动输入、图形、和文本渲染的子系统的类。</p>
<h3 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h3><p>通常，开发者可以通过 Flutter 框架层 与 Flutter 交互，该框架提供了以 Dart 语言编写的现代响应式框架。它包括由一系列层组成的一组丰富的平台，布局和基础库。从下层到上层，依次有：</p>
<p>基础的 foundational 类及一些基层之上的构建块服务，如 animation、 painting 和 gestures，它们可以提供上层常用的抽象。</p>
<p>渲染层：用于提供操作布局的抽象。有了渲染层，你可以构建一棵可渲染对象的树。在你动态更新这些对象时，渲染树也会自动根据你的变更来更新布局。</p>
<p>widget层： 是一种组合的抽象。每一个渲染层中的渲染对象，都在 widgets 层中有一个对应的类。此外，widgets 层让你可以自由组合你需要复用的各种类。响应式编程模型就在该层级中被引入。</p>
<p>Material 和 Cupertino 库提供了全面的 widgets 层的原语组合，这套组合分别实现了 Material 和 iOS 设计规范。</p>
<p><img src="/../images/flutter-framework.png" alt="框架简介"></p>
<h1 id="渲染原理"><a href="#渲染原理" class="headerlink" title="渲染原理"></a>渲染原理</h1><h2 id="渲染管道"><a href="#渲染管道" class="headerlink" title="渲染管道"></a>渲染管道</h2><p><img src="/../images/render-pipeline.png" alt="管道图"></p>
<h2 id="视图树"><a href="#视图树" class="headerlink" title="视图树"></a>视图树</h2><p><img src="/../images/widget-type.png" alt="Widget&amp;Element&amp;RenderObject"></p>
<h2 id="创建树"><a href="#创建树" class="headerlink" title="创建树"></a>创建树</h2><ol>
<li>创建widget树</li>
<li>调用runApp(rootWidget)，将rootWidget传给rootElement,做为rootElement的子节点,生成Element树，由Element树生成Render树。</li>
</ol>
<p><img src="/../images/render-tree.png" alt="渲染树"></p>
<ul>
<li>Widget:存放渲染内容、视图布局信息,widget的属性最好都是immutable</li>
<li>Element:存放上下文，通过Element遍历视图树，Element同时持有Widget和RenderObject</li>
<li>RenderObject:根据Widget的布局属性进行layout，paint Widget传人的内容</li>
</ul>
<h2 id="更新树"><a href="#更新树" class="headerlink" title="更新树"></a>更新树</h2><h3 id="为什么widget都是immutable？"><a href="#为什么widget都是immutable？" class="headerlink" title="为什么widget都是immutable？"></a>为什么widget都是immutable？</h3><p>flutter界面开发是一种响应式编程，主张simple is fast，flutter设计的初衷希望数据变更时发送通知到对应的可变更节点（可能是一个StatefullWidget子节点,也可以是rootWidget）,由上到下重新create widget树进行刷新，这种思路比较简单，不用关心数据变更会影响到哪些节点。</p>
<h3 id="widget重新创建，element树和renderObject树是否也重新创建？"><a href="#widget重新创建，element树和renderObject树是否也重新创建？" class="headerlink" title="widget重新创建，element树和renderObject树是否也重新创建？"></a>widget重新创建，element树和renderObject树是否也重新创建？</h3><p>widget只是一个配置数据结构，创建是非常轻量的，加上flutter团队对widget的创建&#x2F;销毁做了优化，不用担心整个widget树重新创建所带来的性能问题，但是renderobject就不一样了，renderobject涉及到layout、paint等复杂操作，是一个真正渲染的view，整个view 树重新创建开销就比较大，所以答案是否定的。</p>
<h3 id="树的更新规则"><a href="#树的更新规则" class="headerlink" title="树的更新规则"></a>树的更新规则</h3><ol>
<li>找到widget对应的element节点，设置element为dirty，触发drawframe, drawframe会调用element的performRebuild()进行树重建</li>
<li>widget.build() &#x3D;&#x3D; null, deactive element.child,删除子树，流程结束</li>
<li>element.child.widget &#x3D;&#x3D; NULL, mount 的新子树，流程结束</li>
<li>element.child.widget &#x3D;&#x3D; widget.build() 无需重建，否则进入流程5</li>
<li>Widget.canUpdate(element.child.widget, newWidget) &#x3D;&#x3D; true，更新child的slot，element.child.update(newWidget)(如果child还有子节点，则递归上面的流程进行子树更新),流程结束，否则转6</li>
<li>Widget.canUpdate(element.child.widget, newWidget) ！&#x3D; true（widget的classtype 或者 key 不相等），deactivew element.child，mount 新子树</li>
</ol>
<p>注意事项：</p>
<ol>
<li>element.child.widget &#x3D;&#x3D; widget.build(),不会触发子树的update，当触发update的时候，如果没有生效，要注意widget是否使用旧widget，没有new widget，导致update流程走到该widget就停止了</li>
<li>子树的深度变化，会引起子树重建，如果子树是一个复杂度很高的树，可以使用GlobalKey做为子树widget的key。GlobalKey具有缓存功能</li>
</ol>
<h3 id="如何触发树更新"><a href="#如何触发树更新" class="headerlink" title="如何触发树更新"></a>如何触发树更新</h3><ol>
<li>全局更新：调用runApp(rootWidget)，一般flutter启动时调用后不再会调用</li>
<li>局部子树更新, 将该子树做StatefullWidget的一个子widget，并创建对应的State类实例，通过调用state.setState() 触发该子树的刷新</li>
</ol>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>widget是immutable的，发生变化的时候需要重建，所以谈不上状态。StatefulWidget 中的状态保持其实是通过State类来实现的。State拥有一套自己的生命周期。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>initState</td>
<td>插入渲染树时调用，只调用一次</td>
</tr>
<tr>
<td>didChangeDependencies</td>
<td>state依赖的对象发生变化时调用</td>
</tr>
<tr>
<td>didUpdateWidget</td>
<td>组件状态改变时候调用，可能会调用多次</td>
</tr>
<tr>
<td>build</td>
<td>构建Widget时调用</td>
</tr>
<tr>
<td>deactivate</td>
<td>当移除渲染树的时候调用</td>
</tr>
<tr>
<td>dispose</td>
<td>组件即将销毁时调用</td>
</tr>
<tr>
<td>reassemble</td>
<td>hot reload调用</td>
</tr>
</tbody></table>
<p><img src="/../images/flutter-life-render.png" alt="生命周期图"></p>
<p>几个注意点</p>
<ul>
<li>didChangeDependencies有两种情况会被调用。<ul>
<li>创建时候在initState 之后被调用</li>
<li>在依赖的InheritedWidget发生变化的时候会被调用</li>
</ul>
</li>
<li>正常的退出流程中会执行deactivate然后执行dispose。但是也会出现deactivate以后不执行dispose，直接加入树中的另一个节点的情况。</li>
<li>这里的状态改变包括两种可能：1.通过setState内容改变 2.父节点的state状态改变，导致孩子节点的同步变化。</li>
<li>A页面push一个新的页面B,A页面的widget树中的所有state会依次调用deactivate(), didUpdateWidget(newWidget)、build()（这里怀疑是bug，A页面push一个新页面，理论上并没有将A页面进行remove操作），当然从功能上，没有看出来有什么异常</li>
<li>当ListView中的item滚动出可显示区域的时候，item会被从树中remove掉，此item子树中所有的state都会被dispose，state记录的数据都会销毁，item滚动回可显示区域时，会重新创建全新的state、element、renderobject</li>
<li>使用hot reload功能时，要特别注意state实例是没有重新创建的，如果该state中存在一下复杂的资源更新需要重新加载才能生效，那么需要在reassemble()添加处理，不然当你使用hot reload时候可能会出现一些意想不到的结果，例如，要将显示本地文件的内容到屏幕上，当你开发过程中，替换了文件中的内容，但是hot reload没有触发重新读取文件内容，页面显示还是原来的旧内容</li>
</ul>
<h1 id="APP生命周期"><a href="#APP生命周期" class="headerlink" title="APP生命周期"></a>APP生命周期</h1><p>需要通过WidgetsBindingObserver的didChangeAppLifecycleState 来获取。通过该接口可以获取是生命周期在AppLifecycleState类中。常用状态包含如下几个：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>resumed</td>
<td>可见并能响应用户的输入</td>
</tr>
<tr>
<td>inactive</td>
<td>处在并不活动状态，无法处理用户响应</td>
</tr>
<tr>
<td>paused</td>
<td>不可见并不能响应用户的输入，但是在后台继续活动中</td>
</tr>
</tbody></table>
<h1 id="数据流转"><a href="#数据流转" class="headerlink" title="数据流转"></a>数据流转</h1><h2 id="从上往下"><a href="#从上往下" class="headerlink" title="从上往下"></a>从上往下</h2><p>数据从根往下传数据，常规做法是一层层往下，当深度变大，数据的传输变的困难，flutter提供InheritedWidget用于子节点向祖先节点获取数据的机制，如下例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrogColor</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> FrogColor(&#123;</span><br><span class="line">     Key key,</span><br><span class="line">     <span class="meta">@required</span> <span class="keyword">this</span>.color,</span><br><span class="line">     <span class="meta">@required</span> Widget child,</span><br><span class="line">   &#125;) : <span class="keyword">assert</span>(color != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line">   <span class="keyword">final</span> Color color;</span><br><span class="line">   <span class="keyword">static</span> FrogColor of(BuildContext context) &#123;</span><br><span class="line">     <span class="keyword">return</span> context.inheritFromWidgetOfExactType(FrogColor);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="built_in">bool</span> updateShouldNotify(FrogColor old) =&gt; color != old.color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>child及其以下的节点可以通过调用下面的接口读取color数据<code>FrogColor.of(context).color</code></p>
<p>说明：BuildContext 就是Element的一个接口类</p>
<p><code>context.inheritFromWidgetOfExactType(FrogColor)</code>其实是通过context&#x2F;element往上遍历树，查找到第一个FrogColor的祖先节点，取该节点的widget对象。</p>
<h2 id="从下往上"><a href="#从下往上" class="headerlink" title="从下往上"></a>从下往上</h2><p>子节点状态变更，向上上报通过发送通知的方式</p>
<ul>
<li>定义通知类，继承至Notification</li>
<li>父节点使用NotificationListener 进行监听捕获通知</li>
<li>子节点有数据变更调用下面接口进行数据上报<code>Notification(data).dispatch(context)</code></li>
</ul>
<h1 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h1><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>有状态组件，一般形态：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidgetRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">        <span class="keyword">return</span> _MyWidgetRouteState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyWidgetRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyWidgetRoute</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">void</span> initState() &#123;</span><br><span class="line">        <span class="keyword">super</span>.initState();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> Scaffold(</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RouteObserver"><a href="#RouteObserver" class="headerlink" title="RouteObserver"></a>RouteObserver</h2><p>路由观察器，用来监听路由变化。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册RouteObserver.</span></span><br><span class="line"><span class="keyword">final</span> RouteObserver&lt;PageRoute&gt; routeObserver = RouteObserver&lt;PageRoute&gt;();</span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    home: Container(),</span><br><span class="line">    navigatorObservers: [routeObserver],</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在页面组件使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteAwareWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  State&lt;RouteAwareWidget&gt; createState() =&gt; RouteAwareWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement RouteAware in a widget&#x27;s state and subscribe it to the RouteObserver.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteAwareWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RouteAwareWidget</span>&gt; <span class="title">with</span> <span class="title">RouteAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    routeObserver.subscribe(<span class="keyword">this</span>, ModalRoute.of(context));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    routeObserver.unsubscribe(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didPush() &#123;</span><br><span class="line">    <span class="comment">// Route was pushed onto navigator and is now topmost route.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didPopNext() &#123;</span><br><span class="line">    <span class="comment">// Covering route was popped off the navigator.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Container();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StreamBuilder"><a href="#StreamBuilder" class="headerlink" title="StreamBuilder"></a>StreamBuilder</h2><p>流媒体</p>
<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>用来包裹widget，类似于div，可以设置背景色、大小之类的。举例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">    decoration: BoxDecoration( <span class="comment">// 盒子模型</span></span><br><span class="line">        color: <span class="keyword">const</span> Color(<span class="number">0xff7c94b6</span>),</span><br><span class="line">        border: Border.all(</span><br><span class="line">          color: Colors.black,</span><br><span class="line">          width: <span class="number">8</span>,</span><br><span class="line">        ),</span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">12</span>),</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>用于样式堆叠</p>
<h3 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h3><p>用于Stack的child样式定位。类似于<code>position: fixed;</code>举例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Stack(</span><br><span class="line">    fit: StackFit.expand,</span><br><span class="line">    alignment: Alignment.center,</span><br><span class="line">    children: [</span><br><span class="line">        Positioned(</span><br><span class="line">            child: Column(),</span><br><span class="line">            top: MediaQuery.of(context).vewPadding.top + <span class="number">100</span>, <span class="comment">// 离顶部100px</span></span><br><span class="line">        ),</span><br><span class="line">        Positioned(</span><br><span class="line">            child: Column(),</span><br><span class="line">            bottom: MediaQuery.of(context).viewPadding.bottom + <span class="number">100</span>, <span class="comment">// 离底部100px</span></span><br><span class="line">        ),</span><br><span class="line">        Positioned.fill( <span class="comment">// 创建top、right、bottom、left默认为0的widget</span></span><br><span class="line">            child: Row(),</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h2><p>垂直排列child，相当于<code>justify-content: column;</code></p>
<h2 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h2><p>水平排列child，相当于<code>justify-content: row;</code></p>
<h2 id="SizedBox"><a href="#SizedBox" class="headerlink" title="SizedBox"></a>SizedBox</h2><p>创建一个长宽固定的box</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SizedBox(</span><br><span class="line">    width: <span class="number">200</span>,</span><br><span class="line">    height: <span class="number">50</span>,</span><br><span class="line">    child: Button()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SizedBox( <span class="comment">// 长宽自动撑满父元素</span></span><br><span class="line">    width: <span class="built_in">double</span>.infinity,</span><br><span class="line">    height: <span class="built_in">double</span>.infinity,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>设置文本</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">    <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">    textAlign: TextAlign.center,</span><br><span class="line">    overflow: TextOverflow.ellipsis,</span><br><span class="line">    style: TextStyle(</span><br><span class="line">        color: Colors.black.withOpacity(<span class="number">0.9</span>),</span><br><span class="line">        fontSize: <span class="number">17</span>,</span><br><span class="line">        fontWeight: FontWeight.w500</span><br><span class="line">    ),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建能包含不同样式的inline span</span></span><br><span class="line">Text.rich(</span><br><span class="line">  TextSpan(</span><br><span class="line">    text: <span class="string">&#x27;Hello&#x27;</span>, <span class="comment">// default text style</span></span><br><span class="line">    children: &lt;TextSpan&gt;[</span><br><span class="line">      TextSpan(text: <span class="string">&#x27; beautiful &#x27;</span>, style: TextStyle(fontStyle: FontStyle.italic)),</span><br><span class="line">      TextSpan(text: <span class="string">&#x27;world&#x27;</span>, style: TextStyle(fontWeight: FontWeight.bold)),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>持续更新。。。</p>
<blockquote>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://www.yuque.com/xytech/flutter/tge705">深入了解Flutter界面开发</a><br><a target="_blank" rel="noopener" href="https://docs.flutter.dev/">Flutter Doc</a></p>
</blockquote>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css"><script type="text/javascript" src="/js/donate.js" successtext="复制成功!"></script><a class="pos-f tr3" id="github" target="_blank" rel="noopener" href="https://github.com/Kaiyuan/donate-page" arget="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="WeChat" qr="/images/WechatQR.png"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><div class="post-copyright"><script type="text/javascript" src="/js/copyright.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copyright.css"><p><span>本文标题：</span>你必须了解的Flutter原理</p><p><span>文章作者：</span>flyrk</p><p><span>发布时间：</span>2022-03-19</p><p><span>最后更新：</span>2022-03-19</p><p><span>原始链接：</span><a href="/2022/03/19/flutter-principle-analysis/">https://flyrk.github.io/2022/03/19/flutter-principle-analysis/</a><span class="copy-path"><i class="fa fa-clipboard" data-clipboard-text="https://flyrk.github.io/2022/03/19/flutter-principle-analysis/"></i></span></p><p><span>版权声明：</span>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</p></div><br><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://flyrk.github.io/2022/03/19/flutter-principle-analysis/" data-id="cl0xma0oa003q43p3ajcg6n7m" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACMklEQVR42u3aQXKDMBAEwPz/084DbFMzK0gF0ZxciSxoDuuVRj8/8fX6cr2PeR+fzHz8l9MuDAyM2zJeh1fC+PY5mX923w9UDAyMBzCOS+Hx1Pn4tuDm38LAwMA4HpM8dD4GAwMD46yCmxfiZL2JgYGBkTDaZepKqV15NSesxTEwMG7IyHfd//7zJfkGBgbGrRizzfokAGiDz7zIfpgNAwNja0Ze4FZCx/UQNNnmw8DA2JvRNmrtFn/+37y4L/WwGBgYt2LkX0g2+mcB5yzO/NDhYmBgbM1oy2t7mzyYnEWhGBgYezPaXitp8lZg600nBgbGfox8otnG/criOY8WMDAw9ma0x8Lyli6/S7uU/frDgIGBsSmjXcReV4iXIgQMDIytGcMKXcaZ7UO3rw8DA2NvRlIQ88YxfymzLbb6zBoGBsZGjPYo2EoBnQWixZkRDAyM7RhJ57hSNGeluY0WMDAwnsCow8LR8nU2/yXdLgYGxg0Z+bZXvt1/7qZbEQlgYGBszZgtIHPA7JhFsZ+GgYHxYMas7WsLdB5kfv07BgbGYxizrbHZ7ZPxRSyKgYGxKeNVXnnY2RbZ9rVGx8IwMDC2YMySwWTkLOBsl69LaS0GBsatGG2RbcviSnhZvG8MDIwHMNoFZ1uz88I6axwxMDAwZgFn8ojHDeLlBRcDA2NrxixoXCdd+LuBgYHx7xnJInblIWYhaHLIDAMD4wmMlSVocWyrfIjjbbthkImBgXE/xi8BKYmHQeChVwAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/flutter/"><i class="fa fa-tag"></i>flutter</a><a href="/tags/dart/"><i class="fa fa-tag"></i>dart</a></div><div class="post-nav"><a class="next" href="/2022/03/18/clarity-source_analysis-3/">clarity-js源码分析系列（三）之元素变化</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=1.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=1.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=1.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '083efbbbdb04471e0599',
  clientSecret: 'fcb0584c1228acd4317926b1f427051bc6b9f03c',
  repo: 'blog-comment',
  owner: 'flyrk',
  admin: ['flyrk'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS%E7%9B%B8%E5%85%B3/">CSS相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS%E7%9B%B8%E5%85%B3/">JS相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E7%9B%B8%E5%85%B3/">Web相关</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">移动端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">经验分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 15px;">二叉树</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/%E9%97%AD%E5%8C%85/" style="font-size: 15px;">闭包</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/%E8%B7%A8%E5%9F%9F/" style="font-size: 15px;">跨域</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 15px;">性能优化</a> <a href="/tags/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/" style="font-size: 15px;">实习面试</a> <a href="/tags/JS%E5%8E%9F%E7%90%86/" style="font-size: 15px;">JS原理</a> <a href="/tags/%E7%8A%B6%E6%80%81%E7%A0%81/" style="font-size: 15px;">状态码</a> <a href="/tags/throttle/" style="font-size: 15px;">throttle</a> <a href="/tags/debounce/" style="font-size: 15px;">debounce</a> <a href="/tags/%E6%80%9D%E8%80%83%E6%84%9F%E6%82%9F/" style="font-size: 15px;">思考感悟</a> <a href="/tags/CSS%E6%8A%80%E5%B7%A7/" style="font-size: 15px;">CSS技巧</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">前端框架</a> <a href="/tags/state/" style="font-size: 15px;">state</a> <a href="/tags/%E5%AF%B9%E8%B1%A1/" style="font-size: 15px;">对象</a> <a href="/tags/JS%E6%8A%80%E5%B7%A7/" style="font-size: 15px;">JS技巧</a> <a href="/tags/%E7%B1%BB/" style="font-size: 15px;">类</a> <a href="/tags/Cookies/" style="font-size: 15px;">Cookies</a> <a href="/tags/VSCode/" style="font-size: 15px;">VSCode</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 15px;">排序</a> <a href="/tags/%E7%BC%96%E8%BE%91%E5%99%A8/" style="font-size: 15px;">编辑器</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" style="font-size: 15px;">职业规划</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 15px;">源码分析</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/" style="font-size: 15px;">前端监控</a> <a href="/tags/%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE/" style="font-size: 15px;">录制回放</a> <a href="/tags/flutter/" style="font-size: 15px;">flutter</a> <a href="/tags/dart/" style="font-size: 15px;">dart</a> <a href="/tags/thoughts/" style="font-size: 15px;">thoughts</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2022/03/19/flutter-principle-analysis/">你必须了解的Flutter原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/03/18/clarity-source_analysis-3/">clarity-js源码分析系列（三）之元素变化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/26/clarity-source-analysis-2/">clarity-js源码分析系列（二）之数据处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/02/24/clarity-source-analysis-1/">clarity-js源码分析系列（一）之代码模块</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/25/git-commend-list/">git命令手册（持续更新）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/25/how-can-i-be-a-programmer-2/">我是如何当上程序员的（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/18/how-can-i-be-a-programmer-1/">我是如何当上程序员的（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/11/half-year-summary/">写作能带给我什么</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/27/leetcode-sum-of-even-numbers-after-queries-solution/">有意思的leetcode算法题——巧用数学知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/15/fast-achieve-tabpane-effect/">快速实现标签条切换效果</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">西蒙的实验室.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=1.0.0"><script type="text/javascript" src="/js/search.js?v=1.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>