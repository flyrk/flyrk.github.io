<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡客</title>
  
  <subtitle>Flyrk&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xmflyrk.com/"/>
  <updated>2019-08-11T13:44:38.175Z</updated>
  <id>https://xmflyrk.com/</id>
  
  <author>
    <name>Flyrk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写作能带给我什么</title>
    <link href="https://xmflyrk.com/2019/08/11/half-year-summary/"/>
    <id>https://xmflyrk.com/2019/08/11/half-year-summary/</id>
    <published>2019-08-11T13:01:33.000Z</published>
    <updated>2019-08-11T13:44:38.175Z</updated>
    
    <content type="html"><![CDATA[<p>差不多有半年没更过博客了，自己差点都快把它忘了，最近偶尔翻到自己以前写的文章，突然又有了写的冲动。虽然文笔依然很烂，但还是想把写博客捡起来，有空写点什么。</p><p>这半年来，其实生活上经历的挺多的，生活的城市从杭州又回到了广州，工作、生活都发生了巨大的变化，自己也忙于处理各种事情，但这不应该成为我没有更博的借口。最近这个月，感觉生活总算是稍微稳定下来了，可以安心去做点事，于是就想把写作这块捡起来。</p><p>说实话，身为理科生，自己的写作水平的确不怎么样，女票还为此嘲笑过我好几次。但是，我还是想写点什么，微博也好知乎也好，还是自己的博客，目的不是为了吸引关注博眼球，（目前自己也没那个本事），而是觉得，写作这件事，其实是很值得去做的。每次写作时，不管是写什么内容，都是一个自我思考的过程，在写作中不断反思、不断总结，对自己的思维是一个很好的锻炼，语言组织表达能力也是一个大大的提升，要是能够引起大家的讨论和交流，那是再好不过了。</p><p>以前大家总觉得写作是件很麻烦的事，只有作家、专业写手才能干得来，但是现在，有了微博、有了知乎、有了微信公众号，让自媒体兴起了，让大家有了发声的渠道。我们每一个人都可以表达我们的观点，并且借助平台让它传播开来，大家一起讨论，碰撞知识的火花。</p><p>所以，我要开始写起来，不管文笔多烂，写得再不好，至少，我能表达出自己的想法，这就够了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;差不多有半年没更过博客了，自己差点都快把它忘了，最近偶尔翻到自己以前写的文章，突然又有了写的冲动。虽然文笔依然很烂，但还是想把写博客捡起来，有空写点什么。&lt;/p&gt;
&lt;p&gt;这半年来，其实生活上经历的挺多的，生活的城市从杭州又回到了广州，工作、生活都发生了巨大的变化，自己也忙于
      
    
    </summary>
    
      <category term="生活杂谈" scheme="https://xmflyrk.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="思考" scheme="https://xmflyrk.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>有意思的leetcode算法题——巧用数学知识</title>
    <link href="https://xmflyrk.com/2019/02/27/leetcode-sum-of-even-numbers-after-queries-solution/"/>
    <id>https://xmflyrk.com/2019/02/27/leetcode-sum-of-even-numbers-after-queries-solution/</id>
    <published>2019-02-27T04:42:43.000Z</published>
    <updated>2019-02-27T05:16:20.513Z</updated>
    
    <content type="html"><![CDATA[<p>最近在leetcode上刷算法题，发现了一道比较有意思的题目，虽然不难，但要想尽可能的降低时间复杂度达到最优解，还是要有点技巧的，我们来看看。<br><a id="more"></a></p><h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p><a href="https://leetcode.com/problems/sum-of-even-numbers-after-queries">sum-of-even-numbers-after-queries</a>。这道题的意思是说，给定一个包含一系列数字的数组A，和一个queries数组，对于<code>queries[i]</code>，设定<code>val=queries[i][0]</code>，<code>index=queries[i][1]</code>，使得<code>A[index]+=val</code>，求<code>ans</code>数组，使得<code>ans[i]</code>为经过<code>queries[i]</code>之后的A数组所有偶数数字之和。</p><h1 id="初步模拟"><a href="#初步模拟" class="headerlink" title="初步模拟"></a>初步模拟</h1><p>初看完题目，我马上想到这不就是个简单的模拟题吗？照着题干的意思写不就行了，再一看数据范围不超过10000，嗯，O(n^2)先试试看，应该不会超时。于是很快的就把代码写出来了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; A</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; queries</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sumEvenAfterQueries = <span class="function"><span class="keyword">function</span>(<span class="params">A, queries</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ans = [], val = <span class="literal">null</span>, index = <span class="number">0</span>, evenSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = queries.length; i &lt; l; i++) &#123;</span><br><span class="line">        val = queries[i][<span class="number">0</span>];</span><br><span class="line">        index = queries[i][<span class="number">1</span>];</span><br><span class="line">        A[index] += val;</span><br><span class="line">        evenSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, l2 = A.length; j &lt; l2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                evenSum += A[j];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(evenSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>写完提交，成功！emmmm，很简单嘛，下一题…..</p><p>等等，这时间好像有点多啊，8216ms，差一点就超时了。不行，肯定有什么更简便的方法。</p><h1 id="数学妙用"><a href="#数学妙用" class="headerlink" title="数学妙用"></a>数学妙用</h1><p>在经过别人的答案启发后，我突然发现原来利用数学的知识这道题可以这么简单！话不多说，我们来看代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumEvenAfterQueries = <span class="function"><span class="keyword">function</span>(<span class="params">A, queries</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ans = [], val = <span class="literal">null</span>, index = <span class="number">0</span>, tmpSum = <span class="number">0</span>, evenSum = <span class="number">0</span>;</span><br><span class="line">  evenSum = A.reduce(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> === <span class="number">0</span> ? p + n : p;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  queries.forEach(<span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">    val = query[<span class="number">0</span>];</span><br><span class="line">    index = query[<span class="number">1</span>];</span><br><span class="line">    tmpSum = A[index] + val;</span><br><span class="line">    tmpSum % <span class="number">2</span> === <span class="number">0</span> ?</span><br><span class="line">      (A[index] % <span class="number">2</span> === <span class="number">0</span> ? evenSum += val : evenSum += tmpSum)</span><br><span class="line">      : (A[index] % <span class="number">2</span> === <span class="number">0</span> ? evenSum -= A[index] : <span class="literal">null</span>)</span><br><span class="line">    A[index] = tmpSum;</span><br><span class="line">    ans.push(evenSum);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>写完一提交<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/leetcode-sum-of-even-number-success.jpg" alt="leetcode-result"><br>居然只用了这么短时间！！！复杂度也只有O(n)，怎么做到的呢？</p><p>我们来分析分析：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">evenSum = A.reduce(<span class="function">(<span class="params">p, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n % <span class="number">2</span> === <span class="number">0</span> ? p + n : p;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>首先我们先把原始数组所有偶数数字加起来，为了方便之后直接在上面加减。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmpSum % <span class="number">2</span> === <span class="number">0</span> ?</span><br><span class="line">      (A[index] % <span class="number">2</span> === <span class="number">0</span> ? evenSum += val : evenSum += tmpSum)</span><br><span class="line">      : (A[index] % <span class="number">2</span> === <span class="number">0</span> ? evenSum -= A[index] : <span class="literal">null</span>)</span><br><span class="line">    A[index] = tmpSum;</span><br><span class="line">    ans.push(evenSum);</span><br></pre></td></tr></table></figure><p>接着这段最关键的代码，我们对每次加完后的数字<code>tmpSum</code>进行判断，如果是偶数的话，分两种情况：<code>A[index]</code>是偶数，则代表之前的evenSum已经把<code>A[index]</code>加进去了，所以我们只用加上新的<code>val</code>，反之我们把<code>A[index]</code>和<code>val</code>都给加上；如果是奇数，我们则需要判断之前的<code>A[index]</code>是不是偶数，是的话需要把它给减去。</p><p>经过这样的处理最后得到的就是每一轮所有偶数的和，最后完美的解决了问题，时间复杂度也只有O(n)。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然这道题很简单，但我还是想记录下来，因为它代表了一种思维方法，以后做算法题或者写业务代码时都应该多问问自己，还有没有最优解？还能不能继续优化？我们很多时候都是做完结果对了就万事大吉，等到问题出现的时候才去想怎么去解决。而大多时候的问题都是有更好的解决办法的，不怕你做不到，就怕你想不到。平时做事时多拓宽自己的思路，我们在真正遇到问题的时候才不会害怕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在leetcode上刷算法题，发现了一道比较有意思的题目，虽然不难，但要想尽可能的降低时间复杂度达到最优解，还是要有点技巧的，我们来看看。&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://xmflyrk.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="leetcode" scheme="https://xmflyrk.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>快速实现标签条切换效果</title>
    <link href="https://xmflyrk.com/2019/02/15/fast-achieve-tabpane-effect/"/>
    <id>https://xmflyrk.com/2019/02/15/fast-achieve-tabpane-effect/</id>
    <published>2019-02-15T02:57:57.000Z</published>
    <updated>2019-02-15T03:29:20.036Z</updated>
    
    <content type="html"><![CDATA[<p>现在的单页应用中，我们经常需要通过切换不同的标签条显示相应的内容，一般想到的方法就是通过DOM操作给标签条添加点击事件然后加载对应内容，那么，有没有方法可以基本靠HTML和CSS就能快速实现标签条切换效果呢？我们来看一看。<br><a id="more"></a></p><h1 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h1><p>这里我先简单的把HTML结构展示出来，然后慢慢解释：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'pane-container'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'pane-item'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content'</span> <span class="attr">id</span>=<span class="string">'tab1'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tab1 Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'pane-btn'</span> <span class="attr">href</span>=<span class="string">'#tab1'</span>&gt;</span>Tab1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'pane-item'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content'</span> <span class="attr">id</span>=<span class="string">'tab2'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tab2 Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'pane-btn'</span> <span class="attr">href</span>=<span class="string">'#tab2'</span>&gt;</span>Tab2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'pane-item'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'content'</span> <span class="attr">id</span>=<span class="string">'tab3'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tab3 Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'pane-btn'</span> <span class="attr">href</span>=<span class="string">'#tab3'</span>&gt;</span>Tab3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到，每一个标签条都是一个<code>a</code>标签，对应的内容为<code>.content</code>块。这里我为什么要用<code>a</code>标签来表示标签条呢？</p><p>原因就是，<code>a</code>标签的<code>href</code>属性可以设置<code>href=&#39;#myid&#39;</code>，这样点击就能跳转到当前页面id为myid的元素。有人会说，但这里我们不需要跳转啊，别急，这样设置的目的是为了方便之后的CSS设置。</p><h1 id="关键的CSS操作"><a href="#关键的CSS操作" class="headerlink" title="关键的CSS操作"></a>关键的CSS操作</h1><h2 id="target伪类"><a href="#target伪类" class="headerlink" title=":target伪类"></a>:target伪类</h2><p>这里我们用到了一个关键的CSS选择器：<code>:target</code>伪类。<code>E:target</code>伪类选择的是匹配到URL的E元素，就是说如果我们设置了E元素的id为<code>eId</code>，并且当前URL后面有<code>#eId</code>，则E元素就被CSS选择器选中了，我们就可以设置E元素的CSS属性！来看代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#EDEDED</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们要选中的元素是class为<code>content</code>的元素，也就是要展示的内容。先对<code>content</code>设置<code>display:none;</code>，然后通过<code>.content:target</code>选择到当前选中的<code>content</code>元素，再让其可见，就达到了内容切换的目的！怎么样，是不是很简单？</p><h2 id="修改tab选中样式"><a href="#修改tab选中样式" class="headerlink" title="修改tab选中样式"></a>修改tab选中样式</h2><p>当然为了更加直观一点，我们还需要对选中的标签进行一点修饰，代表当前选中的是哪个标签，其主要也是运用了<code>:target</code>和兄弟选择器：<code>E~F</code>。这里要注意的是，<code>~</code>匹配的是E后面所有兄弟元素F，也就是说F的位置必须在E后面，我们来看代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pane-btn</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F1F1F1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">:target</span> ~ <span class="selector-class">.pane-btn</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#6EAED8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就能比较明显的显示当前选中的标签。</p><h2 id="完整CSS代码"><a href="#完整CSS代码" class="headerlink" title="完整CSS代码"></a>完整CSS代码</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pane-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pane-btn</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: none;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pane-btn</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F1F1F1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">:target</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span><span class="selector-pseudo">:target</span> ~ <span class="selector-class">.pane-btn</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#6EAED8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#EDEDED</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>你以为这样就OK了？还差最后一步。经过上面的HTML和CSS设置，我们虽然可以在标签之间进行切换并且显示对应内容，但是在页面初次加载进来后是没有显示任何内容的，因为此时没有任何标签被点击！所以我们还得用JS小小的设置一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tabPaneOne = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'pane-btn'</span>)[<span class="number">0</span>];  <span class="comment">// 这里默认显示第一个标签</span></span><br><span class="line">tabPaneOne.click();</span><br></pre></td></tr></table></figure></p><p>这样就能完美的显示啦！完整效果请看<a href="https://codepen.io/flyrk/pen/aXaBOj" target="_blank">demo</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用<code>:target</code>伪类，我们很好的实现了点击标签切换内容的效果。虽然这只是很简单的效果，但是在实际开发过程中我们也可以运用起来，在其基础上再加一些动画都是Ok的。这样实现的好处是会少很多DOM操作，从性能和代码简洁角度来说也是很大的一个提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的单页应用中，我们经常需要通过切换不同的标签条显示相应的内容，一般想到的方法就是通过DOM操作给标签条添加点击事件然后加载对应内容，那么，有没有方法可以基本靠HTML和CSS就能快速实现标签条切换效果呢？我们来看一看。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://xmflyrk.com/categories/CSS/"/>
    
    
      <category term="CSS技巧" scheme="https://xmflyrk.com/tags/CSS%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS常用的一些文件操作技巧</title>
    <link href="https://xmflyrk.com/2019/01/29/nodeJS-file-system-operation/"/>
    <id>https://xmflyrk.com/2019/01/29/nodeJS-file-system-operation/</id>
    <published>2019-01-29T10:20:04.000Z</published>
    <updated>2019-01-29T11:06:21.994Z</updated>
    
    <content type="html"><![CDATA[<p>在使用NodeJS的时候，我们经常会遇到对文件进行查找、删除、增加内容等操作，还好NodeJS内置了<code>fs</code>模块，<code>fs</code>的API提供了一系列方法，通过它我们可以实现基本的文件操作，接下来我们就来见识见识。<br><a id="more"></a></p><blockquote><p>说明:<br>本文全部使用ES6语法<br>提到的每个方法都有异步和同步的区别，同步则在方法后面加上<code>Sync</code></p></blockquote><h1 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h1><h2 id="读取文件夹内容"><a href="#读取文件夹内容" class="headerlink" title="读取文件夹内容"></a>读取文件夹内容</h2><p>很多时候我们得到一个文件夹路径，如果需要获取文件夹里有哪些文件，我们可以利用<code>fs.readdir()</code>，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> dest = <span class="string">'.../work/myFiles'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步读取文件夹内容</span></span><br><span class="line">fs.readdir(dest, (err, files) =&gt; &#123;  <span class="comment">// callback函数</span></span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> <span class="built_in">console</span>.log(file));  <span class="comment">// 返回的files是一个包含目录中所有文件名的数组</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步读取文件夹内容</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> files = fs.readdirSync(dest);</span><br><span class="line">  files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> <span class="built_in">console</span>.log(file));</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>创建文件夹利用的API是<code>fs.mkdir()</code>，这个操作我们其实很熟悉了，在bash里我们经常用<code>mkdir filedirectionName</code>这一操作来新建文件夹，这里也是一样的，但有几个方面要注意：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步创建文件夹</span></span><br><span class="line">fs.mkdir(dest, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步创建文件夹</span></span><br><span class="line">fs.mkdirSync(dest, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们看到<code>{ recursive: true }</code>这个参数，设置为true代表应该创建父文件夹。比如我们设置<code>recursive</code>为true后，要创建<code>/tmp/a/app</code>目录，则无论是否存在<code>/tmp/a</code>目录都会新建，如果不设置<code>recursive</code>，则没有父文件夹的情况下新建会不成功。</p><p><code>fs.mkdirSync()</code>返回<code>undefined</code>。</p><h2 id="确认某个文件夹是否存在"><a href="#确认某个文件夹是否存在" class="headerlink" title="确认某个文件夹是否存在"></a>确认某个文件夹是否存在</h2><p>之前我们在创建文件夹的时候可以通过设置<code>recursive</code>为true来创建父文件夹不存在的情况下的文件夹，但是有的时候我们得到一个文件夹路径，我们并不知道它的父文件夹是否存在，甚至不知道它父文件夹的父文件夹是否存在…所以，我们不想关心那么多，我们就想知道这个文件夹是否存在，怎么办呢？</p><p>这里我用到了<code>fs-extra</code>模块，它是在<code>fs</code>的基础上进行了一些扩展，有兴趣的可以去<a href="https://github.com/jprichardson/node-fs-extra">Github</a>查看。其中有一个API：<code>ensurDir()</code>，它可以用来查找文件夹是否存在，如果不存在，则新建该文件夹，且会自动把父文件夹也新建了（如果父文件夹不存在）。说白了，就是能确保你想要查找的文件夹存在，因为我们一般发现某个文件夹不存在的话肯定会想要新建这个文件夹，这个API则帮我们把操作都实现了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">fs.ensureDir(dest, err =&gt; <span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fs.ensureDirSync(dest);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h2><p>之前介绍了如何读取文件夹内容，但如果我们想要读取文件内容又如何操作呢？这里有两种方法。</p><h3 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile"></a>fs.readFile</h3><p>通过这个方法我们可以获取到文件的内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步</span></span><br><span class="line">fs.readFile(dest, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = fs.readFileSync(dest, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们options可以设置参数：<code>encoding</code>，代表返回的data内容字符串编码方式，如果不指定的话，则返回的data格式为buffer。</p><h3 id="fs-readJson"><a href="#fs-readJson" class="headerlink" title="fs.readJson"></a>fs.readJson</h3><p>除了上面那个方法，我们还可以使用<code>readJson</code>方法，当然这个是<code>fs-extra</code>里的扩展方法。因为我们现在存储数据很多时候都用JSON文件来存储，利用这个方法可以很方便的读取JSON文件，返回的是将JSON内容转化为Object的JSON对象，方便我们对数据进行操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">fs.readJson(<span class="string">'./package.json'</span>, (err, packageObj) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(packageObj.version);  <span class="comment">// 可以直接对对象的属性进行访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> packageObj = fs.readJsonSync(<span class="string">'./package.json'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="写入文件内容"><a href="#写入文件内容" class="headerlink" title="写入文件内容"></a>写入文件内容</h2><p>有了读取文件内容，我们还需要写入文件内容，同样有两种方法，一种是<code>writeFile</code>，另一种是<code>writeJson</code>。前者和<code>readFile</code>差不多，只是第二个参数变成了要写入的内容，具体可参考<a href="http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback">文档</a>。</p><p>后者则也是对JSON文件进行的写入，要注意的是，每次写入都会覆盖之前所有的内容，所以我们如果想在原有的基础上新增内容，则需要先读取修改完内容再写入，这里我就只演示异步操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">fs.readJson(<span class="string">'./package.json'</span>, (err, packageObj) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    packageObj.newProperty = <span class="string">'new Property'</span>;</span><br><span class="line">    fs.writeJson(<span class="string">'./package.json'</span>, packageObj, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="拷贝文件或者文件夹"><a href="#拷贝文件或者文件夹" class="headerlink" title="拷贝文件或者文件夹"></a>拷贝文件或者文件夹</h1><p>在<code>fs-extra</code>模块，提供了<code>copy(src, dest, [options, callback])</code>操作，其中<code>src</code>可以为文件夹也可以为文件。当<code>src</code>为文件夹，则会拷贝文件夹里的所有文件和文件夹，要注意<code>src</code>和<code>dest</code>必须同时为文件夹或者同时为文件，这样才能正确的把<code>src</code>的内容拷贝到<code>dest</code>里。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> src = <span class="string">'/tmp/srcfile'</span>;</span><br><span class="line"><span class="keyword">const</span> dest = <span class="string">'/tmp/destfile'</span>;</span><br><span class="line"></span><br><span class="line">fs.copy(src, dest, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h1><p>当我们想要获取某个文件的状态，我们可以用<code>fs.stat(path)</code>、<code>fs.lstat(path)</code>、<code>fs.fstat(path)</code>，它们都返回一个<code>fs.stats</code>类对象。区别在于，<code>fs.lstat</code>的path可以是符号链接，<code>fs.fstat</code>的path是文件描述符<code>fd</code>。</p><p>返回的<code>Stats</code>类包含许多代表文件状态的属性和方法，常用的有：</p><ul><li>stats.isDirectory()。判断是否是文件夹</li><li>stats.isFile()。判断是否是文件</li><li>stats.dev。包含改文件的设备的数字标识符</li><li>stats.size。文件的大小（字节为单位）</li><li>stats.atime。上次访问此文件的时间戳。（要注意是系统本地时间，因此如果复制到别的电脑系统时间不一样可能会造成不可预知的后果，所以慎用）</li><li>stats.mtime。上次修改此文件的时间戳。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里我只粗略地介绍了几个常用的方法，<code>fs</code>还有很多文件操作，官方文档有更加详细的解释，感兴趣的小伙伴可以戳<a href="http://nodejs.cn/api/fs.html">这里</a>了解更多，帮助自己在使用NodeJS操作文件时更加得心应手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用NodeJS的时候，我们经常会遇到对文件进行查找、删除、增加内容等操作，还好NodeJS内置了&lt;code&gt;fs&lt;/code&gt;模块，&lt;code&gt;fs&lt;/code&gt;的API提供了一系列方法，通过它我们可以实现基本的文件操作，接下来我们就来见识见识。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="NodeJS" scheme="https://xmflyrk.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>如何实现文字输入效果</title>
    <link href="https://xmflyrk.com/2019/01/23/how-to-achieve-typewriter-effect/"/>
    <id>https://xmflyrk.com/2019/01/23/how-to-achieve-typewriter-effect/</id>
    <published>2019-01-23T11:01:58.000Z</published>
    <updated>2019-01-29T08:47:52.972Z</updated>
    
    <content type="html"><![CDATA[<p>我们看到有些网站的文字会有类似于输入的效果，就好像自动打字一样，虽然这个效果用的地方可能不多，但如果用的好的话可能会有奇效，比如在博客、演讲展示等方面应用。那么，怎么实现呢？</p><a id="more"></a><h2 id="使用setTimeout实现"><a href="#使用setTimeout实现" class="headerlink" title="使用setTimeout实现"></a>使用setTimeout实现</h2><p>第一种方法是使用setTimeout进行文字控制，每一个文字都是一个<code>span</code>，利用DOM操作以一定的间隔将每个文字添加到文档中，同时设置<code>opacity:1</code>使其显示出来。光标闪烁的效果则利用<code>border-left</code>进行animation动画展示。</p><h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>先看代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"input-container"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里是需要展示的原始文字，设为display:none;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"originWords"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"typewriter-container"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里是最终有文字输入效果的文字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"typewriter-output"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释一下，我们首先把原始文字设为<code>display: none;</code>，这样不会占用文档位置，然后我们给之后添加的文字<code>span</code>块指定class为<code>word</code>。</p><h3 id="CSS设置"><a href="#CSS设置" class="headerlink" title="CSS设置"></a>CSS设置</h3><p>先看代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.input-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.typewriter-container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.word</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">2s</span> step-start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.typewriter-output</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">animation</span>: shine <span class="number">1s</span> infinite;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> shine &#123;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对<code>word</code>设置<code>transition: opacity 2s step-start;</code>。这里之所以通过<code>opacity</code>来进行transition，是因为transition不支持<code>display</code>，而<code>opacity</code>只需要设置<code>0</code>或<code>1</code>就可以使元素进行显示而不需要重排。</p><p>这里<code>transition-timing-function</code>使用<code>step-start</code>，使其有跳跃的效果，<code>step-start</code>相当于<code>steps(1, jump-start)</code>，<code>steps(n, &lt;jumpterm&gt;)</code>代表transition会停顿n次，每一次的效果为<code>&lt;jumpterm&gt;</code>，<code>jump-start</code>代表第一个跳跃发生在<code>transition</code>刚开始的时候，更多效果见<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function">文档</a>。</p><p>为什么要使用<code>:after</code>呢？因为我是逐步向<code>typewriter-output</code>添加<code>span</code>块，所以一开始宽度是不确定的，而且光标高度也不好设置，所以我想了个笨方法，使用<code>after</code>伪元素生成一个光标，并用<code>animation</code>控制其<code>border-left</code>的显示。但这里有个bug就是文字显示的间隔不能超过300ms，所以说这样处理还是有些问题，以后可能会有更好的方法。</p><h3 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h3><p>其实就是利用<code>setTimout</code>设置时间间隔，通过DOM操作进行添加文字，先看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="built_in">document</span>.querySelector(<span class="string">'.originWords'</span>).innerText;</span><br><span class="line"><span class="keyword">var</span> output = <span class="built_in">document</span>.querySelector(<span class="string">'.typewriter-output'</span>);</span><br><span class="line"><span class="keyword">var</span> word = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> lastWord = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = words.length; i&lt; l; i++) &#123;</span><br><span class="line">  setTimeout(writeWord(i), i * <span class="number">200</span>);<span class="comment">// 每隔0.2s输出一个文字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里使用闭包保存i</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeWord</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    word = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">    word.classList.add(<span class="string">'word'</span>);</span><br><span class="line">    output.appendChild(word);</span><br><span class="line">    <span class="keyword">if</span> (!lastWord) &#123;</span><br><span class="line">      lastWord = word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastWord !== word) &#123;</span><br><span class="line">     lastWord.style.opacity = <span class="string">'1'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    word.innerText = words[index];</span><br><span class="line">    lastWord = word;</span><br><span class="line">    <span class="keyword">if</span> (index === words.length - <span class="number">1</span>) &#123;</span><br><span class="line">      lastWord.style.opacity = <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码部分很简单，就是先获取需要展示的文字内容，然后每个字都通过dom操作塞进去，设置<code>opacity:1</code>，再进行一下边界判断，就实现了文字的展示。</p><hr><h2 id="纯animation实现"><a href="#纯animation实现" class="headerlink" title="纯animation实现"></a>纯animation实现</h2><p>这次我们不用<code>setTimeout</code>，所有展示的动画全部用<code>animation</code>来实现。废话不多说，我们来看一下。</p><h3 id="HTML结构-1"><a href="#HTML结构-1" class="headerlink" title="HTML结构"></a>HTML结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"typewriter"</span>&gt;</span>Hello, My friend.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方法的好处就是不用有一个隐藏的原始文字段落，直接显示想显示的内容。</p><h3 id="CSS设置-1"><a href="#CSS设置-1" class="headerlink" title="CSS设置"></a>CSS设置</h3><p>接下来我们设置CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: bold <span class="number">100%</span> monospace;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">0.1em</span> solid;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">2em</span> <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> typing &#123;</span><br><span class="line">    <span class="selector-tag">from</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> cursor-blink &#123;</span><br><span class="line">    50% &#123;</span><br><span class="line">        <span class="attribute">border-color</span>: transparent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很简单对不对？挨？说好的动画呢？别急，我们通过JS来设置<code>animation</code>。</p><h3 id="JS部分-1"><a href="#JS部分-1" class="headerlink" title="JS部分"></a>JS部分</h3><p>先看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> typewriter = <span class="built_in">document</span>.getElementById(<span class="string">'typewriter'</span>);</span><br><span class="line"><span class="keyword">var</span> words = typewriter.innerText.length;</span><br><span class="line"><span class="keyword">if</span> (words) &#123;</span><br><span class="line">    typewriter.style.width = words + <span class="string">'ch'</span>;</span><br><span class="line">    typewriter.style.animation = <span class="string">'typing 3s steps('</span> + words + <span class="string">', end), cursor-blink 0.5s step-end infinite alternate'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们所做的事就是获取文字段落字符串的长度，然后设置其宽度和动画效果。非常简单！</p><p>那么，为什么这样做可以呢？别急，我们来分析分析。</p><p>首先，在获取了文字字符串长度后，我们设置段落的宽度为<code>width: Xch;</code>，这里X代表字符串长度，<code>ch</code>是长度单位，代表数字“0”的宽度，通常也就是一个字符的宽度。</p><p>然后，我们直接设置动画：<br><code>animation: typing 3s steps(X, end), cursor-blink 0.5s step-end infinite alternate;</code><br>一切就搞定了！为啥？通过CSS我们设置了<code>@keyframe</code>typing，表示宽度从0开始，一直到设置的<code>Xch</code>，持续3s，用<code>steps</code>动画函数，分为X步，也就是有多少个字符，就停顿多少下，达到输入的效果。至于光标的效果，我们直接通过动画设定<code>50%</code>的时候<code>border-color</code>为<code>transparent</code>，则每一秒闪烁一次，因为只有<code>border-right</code>设置了宽度，所以完美达到光标的效果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两种方法比较起来，第二种方法更加实用简便，推荐大家使用。这只是简单的CSS3 animation动画应用，今后还可以开动脑筋，实现更多炫酷有趣的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们看到有些网站的文字会有类似于输入的效果，就好像自动打字一样，虽然这个效果用的地方可能不多，但如果用的好的话可能会有奇效，比如在博客、演讲展示等方面应用。那么，怎么实现呢？&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://xmflyrk.com/categories/CSS/"/>
    
    
      <category term="CSS动画" scheme="https://xmflyrk.com/tags/CSS%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>如何实现页面不同内容之间的跳转</title>
    <link href="https://xmflyrk.com/2019/01/12/use-anchor-jump-to-anywhere-in-page/"/>
    <id>https://xmflyrk.com/2019/01/12/use-anchor-jump-to-anywhere-in-page/</id>
    <published>2019-01-12T09:10:54.000Z</published>
    <updated>2019-01-29T08:47:39.712Z</updated>
    
    <content type="html"><![CDATA[<p>我们常常会碰到这样的需求：点击某个标题、某段话，跳转到页面对应的位置，并且浏览器不会刷新，相当于在页面进行内部导航，这在浏览文章、或者是内容比较多的长屏单页应用上有着迫切的需求。那么，如何实现这个简单的功能呢？</p><a id="more"></a><h1 id="利用a标签的href值"><a href="#利用a标签的href值" class="headerlink" title="利用a标签的href值"></a>利用a标签的href值</h1><p>我们知道，<code>&lt;a&gt;</code>标签的<code>href</code>属性支持绝对路径和相对路径，其实它还支持路由hash。打个比方，我们的浏览器地址是：<code>http://www.example.com</code>，HTML里有这样一个标签：<code>&lt;a href=&quot;#start&quot;&gt;click&lt;/a&gt;</code>，点击该标签后，浏览器的URL地址后面就会多出一个hash值：<code>http://www.example.com#start</code>，如果HTML里有id为<code>start</code>的元素，则浏览器窗口会自动滚动到该元素所在的位置，也就是使该元素滚动到视窗最上面。</p><p>那么，很简单的我们就可以利用这个属性实现跳转到页面任何位置，只要在想要跳转的地方设置<code>id</code>值，再通过设置<code>a</code>标签的<code>href</code>为<code>#id</code>，我们就可以实现跳转。</p><p>为什么我们可以使用<code>#id</code>实现跳转呢？我们先来看看MDN的定义：</p><blockquote><p><strong>href</strong></p><p>Contains a URL or a URL fragment that the hyperlink points to.</p><p>A URL fragment is a name preceded by a hash mark (<code>#</code>), which specifies an internal target location (an <code>id</code> of an HTML element) within the current document.</p></blockquote><p>什么意思呢？其实<code>href</code>就是给定一个超链接，它的值指向的其实是一个URL或者URL片段，而一个URL片段通常是以<code>#name</code>的形式，代表着当前文档页面内部target的位置（也就是一个HTML元素的id），所以我们就可以利用<code>id</code>来进行页面内部元素之间的跳转。</p><p>那么如果要跳转到页面顶部呢？有的人可能会说：用JS设置<code>scrollTop</code>的值不就好了，这当然可以，之前我也写过跳转到顶部的<a href="https://xmflyrk.com/2017/08/22/scroll-to-top-btn/">文章</a>。但是，如果不用JS呢？很简单，我们直接这样设置：<code>&lt;a href=&quot;#&quot;&gt;click to top&lt;/a&gt;</code>，点击就能直接跳转到页面顶部了！</p><p>这是为什么呢？我们知道<code>#</code>后面的name值代表的是某个元素的<code>id</code>，但如果没有这个name，那就代表所有元素，也就是整个页面，所以就把页面移动到视窗的最顶部了，是不是很方便呢。但是这样有一点不好，就是没有滚动动画，跳转比较生硬，对于UI动画要求不高的页面用这个非常合适。</p><h1 id="Input和Label的妙用"><a href="#Input和Label的妙用" class="headerlink" title="Input和Label的妙用"></a>Input和Label的妙用</h1><p>那么除了利用<code>a</code>标签，还有其他方法可以在不用JS的情况下实现跳转吗？答案就是利用<code>input</code>和<code>label</code>标签！</p><p>我们先在想要跳转的地方增加一个<code>input</code>标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"anchor"</span>&gt;</span>// 这是我们要跳转的位置</span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        // 假设文章很长...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后设置<code>CSS</code>令其不可见：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#anchor</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#anchor</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来做什么呢？我们知道<code>label</code>标签有一个<code>for</code>属性，它的值代表着对应<code>input</code>的<code>id</code>，当设置了<code>for</code>值为某个<code>input</code>的<code>id</code>，我们点击<code>label</code>，则会令对应的<code>&lt;input&gt;</code>变为<code>focus</code>状态，而当某个元素为focus状态时，浏览器窗口会自动使其滚动到视窗内，这样我们就实现了点击跳转功能！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"anchor"</span>&gt;</span>// 这是我们要跳转的位置</span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            LoraeraweMefawef wefaewfaw fawe fwae faw</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        // 假设文章很长...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"anchor"</span>&gt;</span>点击跳转<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里我们用到了两种方法实现页面元素跳转，都没有用到JavaScript，在对滚动动画要求不高的条件下，用这两种方法能简单有效的实现跳转需求，值得一试！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们常常会碰到这样的需求：点击某个标题、某段话，跳转到页面对应的位置，并且浏览器不会刷新，相当于在页面进行内部导航，这在浏览文章、或者是内容比较多的长屏单页应用上有着迫切的需求。那么，如何实现这个简单的功能呢？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS实战" scheme="https://xmflyrk.com/tags/JS%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>迟来的2018总结</title>
    <link href="https://xmflyrk.com/2019/01/09/2018-road-to-grow-up/"/>
    <id>https://xmflyrk.com/2019/01/09/2018-road-to-grow-up/</id>
    <published>2019-01-09T10:40:33.000Z</published>
    <updated>2019-01-10T01:53:21.805Z</updated>
    
    <content type="html"><![CDATA[<p>已经2019年了，由于最近一大堆事情，没有时间更博，现在终于有时间好好坐下来总结一下自己的2018了。</p><a id="more"></a><p>要是问我生命中最重要的年份有哪些，2018年肯定是其中之一。</p><p>这一年，我结束了学生生涯，正式踏上了工作岗位，成为了社会人。</p><p>这一年，我从成都只身一人来到杭州，没有听父母的意见去传统行业寻求稳定的工作，而是投入到互联网的浪潮当中。</p><p>这一年，我找到了我爱的那个她，希望可以和她一起走下去，我们的路，才刚刚开始。</p><p>这一年…</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>这一年最大的改变，就是我脱离了学生这个群体，走向了社会这个大熔炉。说实话，6月底刚刚毕业离开校园，心里面还是充满了对未来未知的恐惧。从小到大，生活都是按部就班，小学、中学、到大学，你可以清晰地看到前面的路，要做的就是好好学习，往前走就行了。但是，现在不同了，工作以后，前面的路一切都是未知的，走得怎么样，全取决于自己，没有人替我安排。</p><p>工作半年，其实挺困惑的，因为很多时候自己还停留在学生思维，学生时代做事，都有人推着你走，老师会帮你监督，做的好不好，更多的时候取决于你考的好不好，得到的反馈简单又明了。但是工作后才发现，所有的事情都变的不一样了。没有人帮你设定目标，没有人推着你走，即使你什么都不做也不会有人来管你，领导只看最后的结果，用数据说话，只有主动出击，才能收获成果，被动地等待，永远只能在原地打转。</p><p>所以说，作为职场新人，我还有很长的路要走，首先需要改变的就是自己的思维模式，做一个主动出击的人。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>作为一个刚入门的前端工程师，2018年也是我技术提升最快的一年。这里用一张思维导图记录下自己的前端学习之路。</p><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/front-end-learning.jpg" alt="frontend-learning"></p><p>这只是我总结的一个大概版本，之后还会不断补充。其实里面很多知识我都只是刚刚了解，还需要不断深入。</p><p>2018，对于我来说算是正式入了前端的大门，对整个前端的大架构也有了初步的了解，但是这还只是刚开始，前端要学的东西太多了，我不能停止学习的步伐，虽然工作后可能学习的时间变少了，但不管怎样都要抽时间出来自学，时刻保持好奇心和学习力。而且，前端工程师也是程序员，算法、数据结构、计算机网络等基本知识也需要巩固了解，技术的路上，学无止境。</p><p>2019我需要在巩固基础知识的同时，不断扩展自己的知识面，多写代码，多实践，只有在实践中才能真正学会运用相关知识。talk is cheap, just show the code.</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>2018最幸福的事，就是终于脱离了单身狗的队伍！撒狗粮的事就不多说了，一切才刚刚开始，我希望未来能和她一起携手度过每一天，成为我们彼此眼中那个更好的自己。</p><p>工作后，离开了父母的怀抱，生活中某种意义上成为了真正独立的个体，很多事情都需要自己来操作，我需要慢慢适应新生活的节奏，承担起更多的责任，平衡好工作与生活的时间点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>碎碎念了这么多，新的一年，新的开始，我希望未来的一年在工作、技术、生活方面都能不断成长蜕变，不停下自己的脚步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经2019年了，由于最近一大堆事情，没有时间更博，现在终于有时间好好坐下来总结一下自己的2018了。&lt;/p&gt;
    
    </summary>
    
      <category term="生活杂谈" scheme="https://xmflyrk.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="thoughts" scheme="https://xmflyrk.com/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>实现基于codemirror的markdown编辑器(二)</title>
    <link href="https://xmflyrk.com/2018/12/20/codemirror-markdown-editor-chapter2/"/>
    <id>https://xmflyrk.com/2018/12/20/codemirror-markdown-editor-chapter2/</id>
    <published>2018-12-20T10:39:16.000Z</published>
    <updated>2019-02-23T14:57:24.342Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们提到了如何加载<code>codemirror</code>组件和一些基本配置，以及如何实现实时预览。接下来才是重头戏，我们需要实现同屏滚动和添加自定义按钮。<br><a id="more"></a></p><p>这篇我们先来着重讲讲同屏滚动。</p><h1 id="同屏滚动"><a href="#同屏滚动" class="headerlink" title="同屏滚动"></a>同屏滚动</h1><p>我们写文档时，除了想要实时预览，还想要能同步滚动，这样写到哪预览页面就滚动到哪，不用鼠标移来移去，方便不少。但是如何实现呢？我们一步一步来。</p><h2 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h2><p>首先，要想滚动，肯定得监听滚动事件<code>onscroll</code>，但是这里我没有直接监听<code>scroll</code>事件，因为我们有两个区域，左边是输入文本框，右边是预览区，我想实现这样的功能：当鼠标移到左边使滚动条滚动时，这个时候先监听左边的滚动事件计算出相应的滚动高度后再修改右边的滚动高度，这样右边是跟着左边的高度滚动而滚动的。相应的，当鼠标移到右边区域使滚动条滚动时，先监听右边的滚动事件计算出滚动高度后再修改左边的滚动高度。这样滚动才能实现对应关系，但是如果直接监听滚动事件，则会出现一个问题，当右边滚动时，左边滚动事件没有移除，则又会触发，计算高度后引发右边滚动，形成一个一直滚动的死循环，最后整个页面滚动位置都是乱的。<br>所以，这里我先监听<code>mouseover</code>和<code>mouseleave</code>事件，话不多说看代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">codemirrorScroll = <span class="function">(<span class="params">doc</span>) =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.onScroll &amp;&amp; <span class="keyword">this</span>.props.onScroll(doc, <span class="keyword">this</span>.editRoot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">codemirrorScrollHandler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.on(<span class="string">'scroll'</span>, <span class="keyword">this</span>.codemirrorScroll(<span class="keyword">this</span>.codeMirror.doc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">codemirrorRemoveScroll = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.off(<span class="string">'scroll'</span>, <span class="keyword">this</span>.codemirrorScroll(<span class="keyword">this</span>.codeMirror.doc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">this</span>.editRoot.addEventListener(<span class="string">'mouseover'</span>, <span class="keyword">this</span>.codemirrorScrollHandler);</span><br><span class="line">  <span class="keyword">this</span>.editRoot.addEventListener(<span class="string">'mouseleave'</span>, <span class="keyword">this</span>.codemirrorRemoveScroll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到，我在<code>mouseover</code>的时候开始监听<code>scroll</code>事件，<code>mouseleave</code>的时候移除之前的<code>scroll</code>事件，所以这里要用<code>codemirrorScroll</code>函数封装，以便移除时是同一个函数。<br>这里我把<code>scroll</code>事件的处理通过props抛给父组件，我们来看看父组件是怎么实现<code>scroll</code>事件的。</p><p>首先考虑到性能和滚动流畅度问题，使用<code>debounce</code>函数包装一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debounceContentScroll = debounce(<span class="keyword">this</span>.handleScrollContent);</span><br></pre></td></tr></table></figure></p><p>接下来就是如何去计算当前滚动的位置并使另一边的内容自动滚动到对应高度，这里我用一幅图解释一下：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/markdown-scroll.png" alt="markdown-scroll"><br>我们主要获取的就是这三个值：<code>child.offsetHeight</code>、<code>parent.offsetHeight</code>、<code>child.scrollTop</code>。所以我们需要在展示内容外面都用<code>div</code>包一层，代表<code>parent</code>元素。先看代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">calcScrollScale = <span class="function">(<span class="params">scrollTopMax1, scrollTopMax2</span>) =&gt;</span> (scrollTopMax1 / scrollTopMax2);</span><br><span class="line"></span><br><span class="line">calcScrollTopMax = <span class="function">(<span class="params">parent, child</span>) =&gt;</span> <span class="built_in">Math</span>.abs((child.offsetHeight || child.height) - parent.offsetHeight)</span><br><span class="line"></span><br><span class="line">updateScroll = <span class="function">(<span class="params">scrollTop, target, scrollTopMax1, scrollTopMax2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> scale = <span class="keyword">this</span>.calcScrollScale(scrollTopMax1, scrollTopMax2);</span><br><span class="line">  target.scrollTop = scrollTop / scale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleScrollContent = <span class="function">(<span class="params">doc, docParent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mdPreview = <span class="keyword">this</span>.mdPreview.current;</span><br><span class="line">  <span class="keyword">const</span> previewContent = <span class="keyword">this</span>.previewContent.current;</span><br><span class="line">  <span class="keyword">const</span> scrollTopMaxFrom = <span class="keyword">this</span>.calcScrollTopMax(docParent, doc);</span><br><span class="line">  <span class="keyword">const</span> scrollTopMaxTo = <span class="keyword">this</span>.calcScrollTopMax(mdPreview, previewContent);</span><br><span class="line">  <span class="keyword">this</span>.updateScroll(doc.scrollTop, mdPreview, scrollTopMaxFrom, scrollTopMaxTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个很重要的参数：<code>scrollTopMax</code>。<br><code>scrollTopMax = |(child.offsetHeight || child.height) - parent.offsetHeight|</code>。使用<code>child.height</code>是因为codemirror的<code>doc</code>对象内容高度可以直接通过<code>height</code>属性获得。为什么要这样计算？<br>我们算的是当前内容可滚动的最大高度，为什么要计算这个？因为我们知道因为渲染的原因，左边输入的时候是单纯的文本，右边渲染出来有标题、图片等等，实际高度会比左边高得多，通过计算两边相对父容器可滚动的最大高度，再计算这两个的比值：<code>calcScrollScale = (scrollTopMax1, scrollTopMax2) =&gt; (scrollTopMax1 / scrollTopMax2);</code>，可以得到一个<code>scrollScale</code>。<br>我们有这样一个公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>，那么我们很容易得出右边的滚动高度：<code>right.scrollTop = left.scrollTop / scrollScale</code>。于是就可以使右边滚动到对应内容的高度了！</p><p>有了左边的范例，对右边预览的container同样使用一样的监听事件，这样就可以实现双向同步滚动绑定了！！！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现同步滚动的关键点其实有两个：一个是注意监听事件的变化，先监听<code>mouseover</code>和<code>mouseleave</code>，这样不会出现滚动死循环。另一个是理解公式：<code>left.scrollTop / right.scrollTop = left.scrollTopMax / right.scrollTopMax</code>。理解了这两个关键点，其实同步滚动就很容易了。<br>但要注意的是，这里的<code>debounce</code>设置延迟时间可能还需要好好斟酌，我默认使用20毫秒，实际滚动时还是会有点卡顿，可以适当改变一下数值。<br>还有就是，因为markdown语法原因，段落之间都必须有一个空行，不然渲染出来文本没换行，导致段落不一致。</p><blockquote><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop">scrollTop</a></li><li><a href="https://juejin.im/post/5a3bb40e5188252b145b38e3">原生JS控制多个滚动条同步跟随滚动</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们提到了如何加载&lt;code&gt;codemirror&lt;/code&gt;组件和一些基本配置，以及如何实现实时预览。接下来才是重头戏，我们需要实现同屏滚动和添加自定义按钮。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS实战" scheme="https://xmflyrk.com/tags/JS%E5%AE%9E%E6%88%98/"/>
    
      <category term="编辑器" scheme="https://xmflyrk.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>实现基于codemirror的markdown编辑器(一)</title>
    <link href="https://xmflyrk.com/2018/12/15/codemirror-markdown-editor-chapter1/"/>
    <id>https://xmflyrk.com/2018/12/15/codemirror-markdown-editor-chapter1/</id>
    <published>2018-12-15T14:23:57.000Z</published>
    <updated>2019-01-29T08:47:09.571Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，要实现一个Markdown编辑器，一般会想要实现这样的功能：实时预览、同步滚动、支持标签按钮添加、markdown语法高亮等等。那么如何去实现一个功能比较完整的markdown编辑器呢？</p><p>首先这里我们只讨论web端，其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，很多都可以拿来直接用，满足基本需求足够了。但是作为前端程序员来说，当然想要实现一个自己定制化的markdown编辑器比较有意思，不过通过查阅资料文档和各种框架比较，发现也不是那么容易的事。<br><a id="more"></a></p><h1 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h1><p>要实现一个markdown编辑器，首先得找到一个合适的框架，目前市面上优秀的markdown框架五花八门。由于现在自己写的项目一般都使用React，所以理所当然能找到一个比较契合React的Markdown框架是更好的。</p><p>经过前期调研，发现有几款基于React的Markdown框架还不错，<a href="https://zenoamaro.github.io/react-quill/">react-quill</a>、facebook的<a href="https://draftjs.org/docs/getting-started.html">draft</a>、<a href="https://github.com/scniro/react-codemirror2">react-codemirror2</a>，但它们其实都是富文本编辑器，定制的东西已经很完善了，我想要的框架是可支持自定义扩展，定制化自己想要的功能，找来找去，最后决定基于<a href="https://codemirror.net/doc/manual.html#api">CodeMirror</a>来自己实现一个定制化的markdown编辑器。因为CodeMirror其实相当于一个基础的框架，它有很多可配置项，可以自己添加工具栏，添加各种实用功能，这正好满足了我的需求，于是就决定用它了！</p><h1 id="CodeMirror"><a href="#CodeMirror" class="headerlink" title="CodeMirror"></a>CodeMirror</h1><p>现代很多编辑器其实都基于<code>codemirror</code>，为什么要选择它呢？这都得益于它强大的API和配置项，在不失基本功能的同时给予了开发者极大的定制空间，开发者可以基于它开发出各种功能的markdown编辑器。这里我先简单介绍一下codemirror的一些基本操作。想要了解更多有关codemirror，可以去看<a href="https://codemirror.net/doc/manual.html">官方文档</a>。</p><h2 id="如何加载codemirror"><a href="#如何加载codemirror" class="headerlink" title="如何加载codemirror"></a>如何加载codemirror</h2><p>一般我们在项目里npm下载完codemirror包后，在代码里引入<code>codemirror.js</code>，而且还会根据需要引入想要的语言模式包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> CM <span class="keyword">from</span> <span class="string">'codemirror'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'codemirror/mode/xml/xml'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'codemirror/mode/markdown/markdown'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'codemirror/addon/edit/continuelist'</span>;</span><br></pre></td></tr></table></figure></p><p>当然，我们还得在html里引入<code>codemirror.css</code>样式，也可以自己修改成想要的样式。</p><p>然后，在需要加载的地方写html标签，id为<code>codemirror</code>，这里我们用的是JSX：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"editor-root"</span> ref=&#123;(elem) =&gt; &#123; <span class="keyword">this</span>.editRoot = elem; &#125;&#125;&gt;</span><br><span class="line">  &lt;textarea id=<span class="string">"codemirror"</span> name=&#123;<span class="keyword">this</span>.props.path&#125; autoComplete=<span class="string">"off"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>我在<code>textarea</code>外面用div包了一层，是为了方便之后的滚动效果。这样，我们就已经可以使用codemirror写一个markdown编辑器了。</p><h2 id="options-可以使用的参数"><a href="#options-可以使用的参数" class="headerlink" title="options 可以使用的参数"></a>options 可以使用的参数</h2><p>  CodeMirror函数和它的fromTextArea方法都可以使用一个配置对象作为第二个参数。这个options极为重要，基本就决定了你的编辑器主要的输入语言、样式、内容。这里列一下它几个常用的可选的参数：</p><ul><li>value: string | CodeMirror.Doc<br>编辑器的初始值（文本），可以是字符串或者CodeMirror文档对象(不同于HTML文档对象)。</li><li>mode: string | object<br>通用的或者在CodeMirror中使用的与mode相关联的mime，当不设置这个值的时候，会默认使用第一个载入的mode定义文件。一般地，会使用关联的mime类型来设置这个值；除此之外，也可以使用一个带有name属性的对象来作为值（如：{name: “javascript”, json: true}）。可以通过访问CodeMirror.modes和CodeMirror.mimeModes获取定义的mode和MIME。</li><li>lineSeparator: string|null<br>明确指定编辑器使用的行分割符（换行符）。默认（值为null）情况下，文档会被 CRLF(以及单独的CR, LF)分割，单独的LF会在所有的输出中用作换行符（如：getValue）。当指定了换行字符串，行就只会被指定的串分割。</li><li>theme: string<br>配置编辑器的主题样式。要使用主题，必须保证名称为 .cm-s-[name] (name是设置的theme的值)的样式是加载上了的。当然，你也可以一次加载多个主题样式，使用方法和html和使用类一样，如： theme: foo bar，那么此时需要cm-s-foo cm-s-bar这两个样式都已经被加载上了。</li><li>indentUnit: integer<br>缩进单位，值为空格数，默认为2 。</li><li>smartIndent: boolean<br>自动缩进，设置是否根据上下文自动缩进（和上一行相同的缩进量）。默认为true。</li><li>tabSize: integer<br>tab字符的宽度，默认为4 。</li><li>indentWithTabs: boolean<br>在缩进时，是否需要把 n*tab宽度个空格替换成n个tab字符，默认为false 。</li><li>electricChars: boolean<br>在输入可能改变当前的缩进时，是否重新缩进，默认为true （仅在mode支持缩进时有效）。</li><li>keyMap: string<br>配置快捷键。默认值为default，即 codemorrir.js 内部定义。其它在key map目录下。</li><li>extraKeys: object<br>给编辑器绑定与前面keyMap配置不同的快捷键。</li><li>lineWrapping: boolean<br>在长行时文字是换行(wrap)还是滚动(scroll)，默认为滚动(scroll)。</li><li>lineNumbers: boolean<br>是否在编辑器左侧显示行号。</li><li>firstLineNumber: integer<br>行号从哪个数开始计数，默认为1 。</li><li>lineNumberFormatter: function(line: integer) → string<br>使用一个函数设置行号。</li><li>scrollbarStyle: string<br>设置滚动条。默认为”native”，显示原生的滚动条。核心库还提供了”null”样式，此样式会完全隐藏滚动条。Addons可以设置更多的滚动条模式。</li><li>inputStyle: string<br>选择CodeMirror处理输入和焦点的方式。核心库定义了textarea和contenteditable输入模式。在移动浏览器上，默认是contenteditable，在桌面浏览器上，默认是textarea。在contenteditable模式下对IME和屏幕阅读器支持更好。</li><li>readOnly: boolean|string<br>编辑器是否只读。如果设置为预设的值 “nocursor”，那么除了设置只读外，编辑区域还不能获得焦点。</li><li>showCursorWhenSelecting: boolean<br>在选择时是否显示光标，默认为false。</li><li>autofocus: boolean<br>是否在初始化时自动获取焦点。默认情况是关闭的。但是，在使用textarea并且没有明确指定值的时候会被自动设置为true。</li></ul><p>更多的配置请查看<a href="https://codemirror.net/doc/manual.html#config">相关文档</a>。</p><h1 id="实时预览"><a href="#实时预览" class="headerlink" title="实时预览"></a>实时预览</h1><p>这个需求可以说是现代markdown编辑器的基本需求，因为markdown写起来本身是没有任何样式的，纯文本的话对于有些人来说不能看到最终效果就很不习惯，自己写的效果怎么样都不知道，写的心里就会很没底（当然再花哨的样式最后还是要看内容好不好）。说白了，实时预览更多是写作时一个心理上的满足，这对于写作体验的提升来说是必不可少的。</p><p>这里的markdown渲染引擎我直接用了比较受欢迎的<a href="https://marked.js.org/#/README.md#README.md"><code>marked</code></a>库，其实markdown渲染是很考验技术的一门活，绝大部分都是用正则匹配来进行标签的替换，但由于markdown的语法相对还是较多的，要自己写一个markdown渲染引擎还是有点难度的，考虑到时间因素所以一般都会用现成的库，当然以后有时间的话我也会考虑写一个markdown渲染引擎玩玩。</p><p>这里我因为是用<code>React</code>写的markdown组件，下面我就简单的介绍下如何实现实时预览。</p><p>首先在组件渲染完后，我们在<code>componentDidMount</code>函数里对codemirror进行事件监听：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="comment">// 因为需要使用fromTextArea获取options，所以采用document.getElementById</span></span><br><span class="line">  <span class="keyword">this</span>.codeMirror = CM.fromTextArea(ReactDOM.findDOMNode(<span class="built_in">document</span>.getElementById(<span class="string">'codemirror'</span>)), <span class="keyword">this</span>.getOptions());</span><br><span class="line">  <span class="keyword">this</span>.props.init(<span class="keyword">this</span>.editRoot, <span class="keyword">this</span>.codeMirror);</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.setValue(<span class="keyword">this</span>.props.defaultValue);</span><br><span class="line">  <span class="keyword">this</span>.codeMirror.on(<span class="string">'change'</span>, <span class="keyword">this</span>.codemirrorValueChanged);</span><br><span class="line">  <span class="keyword">this</span>._currentCodemirrorValue = <span class="keyword">this</span>.props.defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们使用<code>fromTextArea</code>获取codemirror的dom节点，它支持两个参数，第一个是codemirror所挂载的dom节点，第二个是配置的options。</p><p>之后调用init函数，这里之后会讲。然后就是初始值设置<code>codemirror.setValue(defaultValue)</code>，因为是编辑器，如果想对之前的文档进行修改，肯定需要传入初始值。</p><p>然后就是关键的监听事件<code>change</code>，当输入变化时调用<code>this.codemirrorValueChanged</code>事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">codemirrorValueChanged = <span class="function">(<span class="params">cm</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newValue = cm.getValue();</span><br><span class="line">  <span class="keyword">this</span>._currentCodemirrorValue = cm.getValue();</span><br><span class="line">  <span class="keyword">this</span>.props.onChange &amp;&amp; <span class="keyword">this</span>.props.onChange(newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里说下，我们通过<code>cm.getValue()</code>获取当前输入的值，然后通过调用<code>props.onChange(newValue)</code>将值抛给父组件处理。因为这里我想把编辑部分和预览部分分开来做成两个公共组件，这样组件复用性更强，有的可能只需要编辑功能，有的只需要预览展示功能。<br>那么在父组件里，我们需要对<code>onChange</code>事件传入的值进行处理，将其渲染成html然后展示出来，其实很简单：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkdownEditor</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  handleEditChange = <span class="function">(<span class="params">newCode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.renderMarkdown &amp;&amp; <span class="keyword">this</span>.props.renderMarkdown(newCode);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      code: newCode,</span><br><span class="line">      hasChanged: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  debounceEditChange = debounce(<span class="keyword">this</span>.handleEditChange, <span class="number">500</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> preview = marked(<span class="keyword">this</span>.state.code);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;MyEditor</span><br><span class="line">          defaultValue=&#123;<span class="keyword">this</span>.state.code&#125;</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.debounceEditChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"md-preview-container"</span>&gt;</span><br><span class="line">          &lt;div className=<span class="string">"preview-content"</span> dangerouslySetInnerHTML=&#123;&#123;<span class="attr">__html</span>: preview&#125;&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是，我用到了<code>debounce</code>函数进行延迟处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay = <span class="number">20</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.call(self, ...args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为考虑到性能原因，如果输入过快的话，<code>change</code>事件频繁触发，预览页面不断重绘，性能损耗十分严重，所以我用到了<code>debounce</code>，并设置延迟时间500毫秒，当然可以更短，这里我觉得设置500毫秒已经足够了。这样就达到了实时预览的效果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于codemirror的markdown编辑器实现起来其实还有很多坑，本篇先介绍了<code>codemirror</code>的一些基本配置和如何实现markdown实时预览，接下来我将进一步介绍如何实现同屏滚动和自定义标签按钮等其他功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，要实现一个Markdown编辑器，一般会想要实现这样的功能：实时预览、同步滚动、支持标签按钮添加、markdown语法高亮等等。那么如何去实现一个功能比较完整的markdown编辑器呢？&lt;/p&gt;
&lt;p&gt;首先这里我们只讨论web端，其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，很多都可以拿来直接用，满足基本需求足够了。但是作为前端程序员来说，当然想要实现一个自己定制化的markdown编辑器比较有意思，不过通过查阅资料文档和各种框架比较，发现也不是那么容易的事。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS实战" scheme="https://xmflyrk.com/tags/JS%E5%AE%9E%E6%88%98/"/>
    
      <category term="编辑器" scheme="https://xmflyrk.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>点击按钮粘贴所选内容到剪贴板</title>
    <link href="https://xmflyrk.com/2018/12/04/copy-to-clipboard/"/>
    <id>https://xmflyrk.com/2018/12/04/copy-to-clipboard/</id>
    <published>2018-12-04T13:13:09.000Z</published>
    <updated>2019-01-29T08:46:37.250Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常可以看到这样的功能，点击某个按钮可以自动复制想要的内容到剪贴板。比如说某个图片、视频的地址，某个输入的内容，我们有的时候懒得去用键盘鼠标选中某个区域，希望只用点击一下，就能复制想要的内容。<br><a id="more"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>其实这个用原生JS实现难度不大，主要用到的是<code>document.execCommand()</code>。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> transfer = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(transfer);</span><br><span class="line">    transfer.value = target.value;  <span class="comment">// 这里表示想要复制的内容</span></span><br><span class="line">    transfer.focus();</span><br><span class="line">    transfer.select();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>)) &#123;</span><br><span class="line">        <span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    transfer.blur();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'复制成功'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(transfer);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'#copyBtn'</span>).addEventListener(<span class="string">'click'</span>, copy);</span><br></pre></td></tr></table></figure><p>这里我们其实就是新创建了一个<code>input</code>DOM元素，然后选中该元素，把要复制的内容赋给<code>input.value</code>，这个时候执行<code>document.execCommand(&#39;copy&#39;)</code>，会把当前页面所有选中的内容复制到剪贴板，也就实现了复制的操作，最后再把新建的DOM元素移除，在不影响DOM树的情况下达到复制的目的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>document.execCommand()</code> 方法可以使当前选中的可编辑内容实现一些常用的操作，如copy、cut、paste、delete、contentReadOnly等等，具体请看<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand">document.execCommand</a>，但个人感觉一般最好不要去用里面的一些操作，因为这样可能会和用户的交互操作产生冲突，发生意想不到的结果。但是<code>document.execCommand</code>在富文本编辑器里又是个神器，值得之后慢慢研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常可以看到这样的功能，点击某个按钮可以自动复制想要的内容到剪贴板。比如说某个图片、视频的地址，某个输入的内容，我们有的时候懒得去用键盘鼠标选中某个区域，希望只用点击一下，就能复制想要的内容。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS实战" scheme="https://xmflyrk.com/tags/JS%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>纯CSS绘制不同的图形</title>
    <link href="https://xmflyrk.com/2018/12/03/draw-different-shapes-with-css/"/>
    <id>https://xmflyrk.com/2018/12/03/draw-different-shapes-with-css/</id>
    <published>2018-12-03T12:44:19.000Z</published>
    <updated>2019-01-29T08:46:22.774Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要用CSS绘制图形？我们知道，一般表示图案可以用<code>img</code>标签，直接用切好的图片，或者用<code>background</code>加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。<br><a id="more"></a></p><p>这里我列举一些比较感兴趣的图形。</p><h1 id="基本图案"><a href="#基本图案" class="headerlink" title="基本图案"></a>基本图案</h1><h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><p>圆形可以说是除了方形以外最容易表达的图形了，多亏了CSS3的<code>border-radius</code>属性：</p><h3 id="基本圆形"><a href="#基本圆形" class="headerlink" title="基本圆形"></a>基本圆形</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/circle.jpg" alt="circle"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="椭圆形"><a href="#椭圆形" class="headerlink" title="椭圆形"></a>椭圆形</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/oval.jpg" alt="oval"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.oval</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50px</span> / <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p>三角形其实利用的是<code>border</code>属性，利用不同方向的<code>border</code>宽度和颜色可以展现不同的三角形。</p><h3 id="triangle-top："><a href="#triangle-top：" class="headerlink" title="triangle-top："></a>triangle-top：</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-top.jpg" alt="triangle-top"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.top-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-bottom"><a href="#triangle-bottom" class="headerlink" title="triangle-bottom"></a>triangle-bottom</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-bottom.jpg" alt="triangle-bottom"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-left"><a href="#triangle-left" class="headerlink" title="triangle-left"></a>triangle-left</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-left.jpg" alt="triangle-left"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-right"><a href="#triangle-right" class="headerlink" title="triangle-right"></a>triangle-right</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-right.jpg" alt="triangle-right"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他的三角形也就是利用border属性进行的变形。</p><h1 id="特殊图案"><a href="#特殊图案" class="headerlink" title="特殊图案"></a>特殊图案</h1><h2 id="跳转图标"><a href="#跳转图标" class="headerlink" title="跳转图标"></a>跳转图标</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/border-top-left-radius.png" alt="border-top-left-radius"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.curvedarrow</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">26px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">26px</span> solid red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(10deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.curvedarrow</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">6px</span> solid red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要利用的属性有两个，一个是<code>border-radius: 20px 0 0 0;</code>。为什么要这样用呢？其实<code>border-radius</code>最多支持四个值：<code>border-top-left-radius</code>, <code>border-top-right-radius</code>,<code>border-bottom-right-radius</code>, and <code>border-bottom-left-radius</code>。这里我们把<code>border-top-left-radius</code>设为20px，其他的都设为0，再加上只设<code>border-top</code>的宽度，最后出来是一个尾部有弧度的长条。</p><p>第二个属性则是<code>rotate(deg)</code>，将两个图形经过不同的角度旋转后再移动长条的位置进行组合，最后达到跳转箭头的图标效果。</p><h2 id="等腰梯形"><a href="#等腰梯形" class="headerlink" title="等腰梯形"></a>等腰梯形</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/trapezoid.png" alt="trapezoid"><br>梯形其实很好理解，通过设置border的宽度和透明度就可以形成梯形：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.trapezoid</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/parallel.png" alt="parallel"><br>很简单，直接利用<code>transform: skew(deg)</code>就可以得到任意角度的平行四边形：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parallel</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五角星"><a href="#五角星" class="headerlink" title="五角星"></a>五角星</h2><p>其原理是利用三个三角形通过旋转不同的角度和绝对定位拼接而成。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-five.png" alt="star-five"><br>具体代码如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star-five</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(35deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-five</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">80px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">45px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">65px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-35deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-five</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">105px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-70deg);</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="六角星"><a href="#六角星" class="headerlink" title="六角星"></a>六角星</h2><p>利用两个三角形拼接而成。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-six.png" alt="star-six"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star-six</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-six</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="心形"><a href="#心形" class="headerlink" title="心形"></a>心形</h2><p>利用两个半圆长条形状旋转一定角度后拼装成心形。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/heart.png" alt="heart"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-45deg);</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">  <span class="attribute">transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="月亮"><a href="#月亮" class="headerlink" title="月亮"></a>月亮</h2><p>非常简单，利用了<code>box-shadow</code>属性，<code>box-shadow</code>一般支持四个值：<code>offset-x</code>、<code>offset-y</code>、<code>blur-radius</code>、<code>spread-radius</code>、<code>color</code>。还有一个值<code>inset</code>表示shadow是否内嵌。这里我们通过设置<code>border-radius</code>使其为圆形然后令<code>box-shadow</code>便宜一定值得到月亮形状。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/moon.png" alt="moon"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">15px</span> <span class="number">15px</span> <span class="number">0</span> <span class="number">0</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="阴阳图案"><a href="#阴阳图案" class="headerlink" title="阴阳图案"></a>阴阳图案</h2><p>刚一看到这个图案感觉很神奇，不知道怎么实现的，但其实很简单，分三步：</p><p>首先，利用<code>border-width</code>画出一个一半深、一半浅的圆形：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang1.png" alt="yin-yang1"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yin-yang</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">96px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: black;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">50px</span> <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，利用伪元素的<code>content</code>和<code>border</code>，生成一个小铜钱然后定位到适合的位置：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang2.png" alt="yin-yang2"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yin-yang</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">18px</span> solid black;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，在对称的位置上在生成一个小铜钱，颜色与之前的相反。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang3.png" alt="yin-yang3"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.yin-yang</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">18px</span> solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个一拼接，就形成了想要的阴阳图案：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/yin-yang.png" alt="yin-yang"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用CSS，我们可以实现很多简单甚至是较复杂的图案，这样省去了切图的烦恼，还减少了http请求，资源加载速度变快，唯一不足的可能就是基本上都是用的CSS3属性，有兼容性问题。但是，既然能直接用CSS画出图案，当然是用起来！</p><blockquote><p>更多图案参见<a href="https://css-tricks.com/the-shapes-of-css/">参考资料</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要用CSS绘制图形？我们知道，一般表示图案可以用&lt;code&gt;img&lt;/code&gt;标签，直接用切好的图片，或者用&lt;code&gt;background&lt;/code&gt;加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://xmflyrk.com/categories/CSS/"/>
    
    
      <category term="CSS技巧" scheme="https://xmflyrk.com/tags/CSS%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>什么是堆排序</title>
    <link href="https://xmflyrk.com/2017/09/05/what-is-heapSort/"/>
    <id>https://xmflyrk.com/2017/09/05/what-is-heapSort/</id>
    <published>2017-09-05T02:02:06.000Z</published>
    <updated>2019-01-29T08:46:02.346Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序是一种常见的排序算法，时间复杂度是O(nlgn)，与归并排序一样，但它又与插入排序一样具有<em>空间原址性</em> ：任何时候都只需要常数个额外的元素空间存储临时数据。<br><a id="more"></a></p><h1 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h1><p>  一般堆用数组存储，表现出近似完全二叉树形式，树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的且从左至右填充。</p><h1 id="最大堆和最小堆"><a href="#最大堆和最小堆" class="headerlink" title="最大堆和最小堆"></a>最大堆和最小堆</h1><ul><li>最大堆：除了根以外的所有节点i都要满足A[parent(i)]&gt;=A[i]，即堆中最大元素是根节点。</li><li>最小堆：除了根以外的所有节点i都要满足A[parent(i)]&lt;=A[i]，即堆中最小元素是根节点。   </li></ul><h1 id="堆中节点的高度"><a href="#堆中节点的高度" class="headerlink" title="堆中节点的高度"></a>堆中节点的高度</h1><p>  与二叉树的高度相同，定义为该节点到叶节点最长简单路径上边的数目。则包含n个元素的堆其高度为lgn。</p><h1 id="维护堆的性质与方法（数组下标都从1开始）"><a href="#维护堆的性质与方法（数组下标都从1开始）" class="headerlink" title="维护堆的性质与方法（数组下标都从1开始）"></a>维护堆的性质与方法（数组下标都从1开始）</h1><h2 id="maxHeapify"><a href="#maxHeapify" class="headerlink" title="maxHeapify"></a>maxHeapify</h2><p>  时间复杂度为O(lgn)。通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆性质。代码如下:<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxHeapify</span>(<span class="params">arr, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> largest;</span><br><span class="line">  <span class="keyword">let</span> left = i * <span class="number">2</span>; <span class="comment">// leftChild</span></span><br><span class="line">  <span class="keyword">let</span> right = i * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// rightChild</span></span><br><span class="line">  <span class="keyword">if</span>( left &lt;= arr.length &amp;&amp; arr[i] &lt; arr[left] ) &#123;</span><br><span class="line">    largest = left;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    largest = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>( right &lt;= arr.length &amp;&amp; arr[largest] &lt; arr[right] ) &#123;</span><br><span class="line">    largest = right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( largest !== i ) &#123; <span class="comment">// 把左右子节点中最大的元素与当前节点i交换</span></span><br><span class="line">    arr[i] = arr[i] + arr[largest];</span><br><span class="line">    arr[largest] = arr[i] - arr[largest];</span><br><span class="line">    arr[i] = arr[i] - arr[largest];</span><br><span class="line">    maxHeapify(arr, largest);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="buildMaxHeap"><a href="#buildMaxHeap" class="headerlink" title="buildMaxHeap"></a>buildMaxHeap</h2><p>  时间复杂度为O(n)。用<em>自底向上</em>的方法利用maxHeapify把大小为n的数组转换为最大堆。因为最后一个叶节点序号为n，则其父节点序号为n/2,所以子数组[n/2+1,….,n]都是堆的叶节点，所以循环从n/2开始递减到1，每一次都保证节点i+1,i+2…,n都是一个最大堆的根节点的性质。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    maxHeapify(arr,i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="heapSort-堆排序算法。"><a href="#heapSort-堆排序算法。" class="headerlink" title="heapSort:堆排序算法。"></a>heapSort:堆排序算法。</h1><p>  有了上述两个函数方法，我们就可以实现堆排序。</p><p>  先将数组arr建为一个最大堆，因为最大堆的根节点总是最大的，通过把它与arr[n]互换可以得到正确位置，保证arr[n]总是当前堆中最大元素，然后将arr[n]存储到新的数组中。可以算出时间复杂度为O(nlgn)。<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arrSort = [];</span><br><span class="line">  buildMaxHeap(arr);  <span class="comment">// 先建一个最大堆</span></span><br><span class="line">  <span class="keyword">let</span> length = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = length; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">    arr[<span class="number">1</span>] = arr[i];</span><br><span class="line">    arrSort.push(arr[i]);</span><br><span class="line">    maxHeapify(arr, <span class="number">1</span>); <span class="comment">// 每次交换后重新维护最大堆，复杂度为O(lgn)</span></span><br><span class="line">  &#125;</span><br><span class="line">  arrSort.push(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> arrSort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>  通过堆排序的实现，我们可以在时间复杂度为O(nlgn)的情况下对数组进行排序。而且当我们只需要找出数组中最大的几个元素，则可以用堆排序来实现，因为每次最大的元素总是当前最后一个，这样就不需要将数组全排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序是一种常见的排序算法，时间复杂度是O(nlgn)，与归并排序一样，但它又与插入排序一样具有&lt;em&gt;空间原址性&lt;/em&gt; ：任何时候都只需要常数个额外的元素空间存储临时数据。&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://xmflyrk.com/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法" scheme="https://xmflyrk.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用原生JS写轮播图</title>
    <link href="https://xmflyrk.com/2017/08/27/how-to-write-js-marquee/"/>
    <id>https://xmflyrk.com/2017/08/27/how-to-write-js-marquee/</id>
    <published>2017-08-27T08:53:36.000Z</published>
    <updated>2019-01-29T08:45:50.058Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。<br><a id="more"></a></p><h1 id="要实现的功能"><a href="#要实现的功能" class="headerlink" title="要实现的功能"></a>要实现的功能</h1><p>首先我们来看看要实现这么一个轮播图需要哪些功能，这里我把我想到的都列出来了。</p><ol><li>页面加载后轮播图自动开始播放，每张图片停几秒钟。</li><li>图片与图片之间实现平滑过渡动画效果，不显突兀。</li><li>鼠标悬停到当前图片时轮播动画停止，鼠标离开图片后继续开始轮播。</li><li>图片上有左右翻页功能按钮，点击左边按钮图片往左滑动，点击右边按钮图片右滑。</li><li>图片下端有显示图片个数的小圆点，当前图片是第几个，则第几个小圆点“点亮”。</li><li>离开当前页面后轮播动画停止，回到当前页面后轮播动画继续。</li></ol><p>我能想到的要实现的功能就这么多，接下来就一步步开始实现。</p><h1 id="HTMl结构"><a href="#HTMl结构" class="headerlink" title="HTMl结构"></a>HTMl结构</h1><p>先不管JS、CSS部分，我们先把整体结构定下来。这里直接贴上主体部分代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loop-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat5.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat1.jpg"</span> <span class="attr">alt</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat2.jpg"</span> <span class="attr">alt</span>=<span class="string">"2"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat3.jpg"</span> <span class="attr">alt</span>=<span class="string">"3"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat4.jpg"</span> <span class="attr">alt</span>=<span class="string">"4"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat5.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat1.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"buttons"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"on"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow arrow-left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pt-inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow arrow-right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pt-inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里要强调的一点就是，虽然最后显示只有5张图片，但我插入了7个<code>img</code>标签，其中第一个和最后一张图一样，最后一个和第一个图一样。为什么要这么做呢？是因为要实现平滑的动画过渡效果，后面JS部分会提到。</p><h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><p>接下来就是CSS设置：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.loop-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">700%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation</span>: left .<span class="number">6s</span> ease-out;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span><span class="selector-pseudo">:hover</span> &gt; <span class="selector-class">.arrow</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loop-container</span> <span class="selector-class">.loop-image</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我没有把全部的CSS代码贴出来，完整的代码我会在最后给出。</p><p>我只说几个要注意的地方：</p><ul><li>首先外部容器要设置<code>overflow:hidden</code>，这样才能把多余的图片遮住；</li><li>其次由于img默认是inline元素，显示出来的特性是inline-block，所以img之间会有4px的空隙，即使设置了margin和padding为0也不能消除。为此我困惑了很久。。。后来上网找资料才发现解决方案。一般有几种解决方案，这里我用的是设置父元素的font-size为0，然后img的font-size设不设置根据需要，这样就可以消除空隙。更详尽的解决方案可以参考张大神的<a href="http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">博客</a></li></ul><p>其他css设置就根据样式慢慢调整了。</p><h1 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h1><p>接下来就是重头戏，JS的实现了。我们一步一步来看。</p><p>我先创建了一个整体的“类”，里面有一些所需要用到的方法和属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Marquee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>; <span class="comment">// 保存当前是第几张图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.animate = <span class="function"><span class="keyword">function</span> (<span class="params">aimLeft</span>) </span>&#123;  <span class="comment">// 具体的动画实现</span></span><br><span class="line">  <span class="keyword">var</span> curLeft = <span class="built_in">parseInt</span>(loopContainer.style.left) || <span class="number">-600</span>, <span class="comment">// 获取当前图片的left值</span></span><br><span class="line">      speed = (aimLeft - curLeft) / <span class="number">20</span>, <span class="comment">// 每次left移动的距离</span></span><br><span class="line">      delay = <span class="number">20</span>,</span><br><span class="line">      self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> time = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 利用循环定时实现平滑移动的动画效果</span></span><br><span class="line">    curLeft += speed;</span><br><span class="line">    loopContainer.style.left = curLeft + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">if</span> (curLeft === aimLeft) &#123;  <span class="comment">// 如果移动到了下一张图片的位置，则此次移动动画结束</span></span><br><span class="line">      clearInterval(time);</span><br><span class="line">      <span class="keyword">if</span> (aimLeft &lt;= <span class="number">-3600</span>) &#123;  <span class="comment">// 特殊设置，如果是从最后一张图到第一张图，中间加一张图片实现动画过渡，当到达最后一张图后，立即设置left为第二个img的left。 </span></span><br><span class="line">        loopContainer.style.left = <span class="string">'-600px'</span>;  <span class="comment">// 第一张图实际的left为-600px，因为html里left为0的位置是最后一张图</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (aimLeft &gt;= <span class="number">0</span>) &#123; <span class="comment">// 同理，当从第一张图过渡到最后一张图，先实现动画效果，当left为实际第一张图的位置0时，设置left为倒数第二个img的位置。</span></span><br><span class="line">        loopContainer.style.left = <span class="string">'-3000px'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      self.showCurrentDot();  <span class="comment">// 动画结束后再改变小圆点的外观</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">Marquee.prototype.showCurrentDot = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 设置代表当前图片位置的小圆点class</span></span><br><span class="line">  <span class="keyword">var</span> dots = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = dots.length; i &lt; len; i++) &#123;</span><br><span class="line">    dots[i].className = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dots[<span class="keyword">this</span>.index].className = <span class="string">'on'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.changePhoto = <span class="function"><span class="keyword">function</span> (<span class="params">offset</span>) </span>&#123; <span class="comment">// 自动改变图片的函数</span></span><br><span class="line">  <span class="keyword">var</span> left = loopContainer.style.left,</span><br><span class="line">    newleft = left ? <span class="built_in">parseInt</span>(left) + offset : offset - <span class="number">600</span>;  <span class="comment">// 新的位置</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.index = offset &gt; <span class="number">0</span> ? <span class="keyword">this</span>.index - <span class="number">1</span> : <span class="keyword">this</span>.index + <span class="number">1</span>;  <span class="comment">// 判断向左还是向右滑动</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.index &gt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(left);</span></span><br><span class="line">  <span class="comment">// console.log(newleft);</span></span><br><span class="line">  <span class="comment">// console.log('------');</span></span><br><span class="line">  <span class="keyword">this</span>.animate(newleft);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.gotoPhoto = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;  <span class="comment">// 跳转到第count个图片的函数</span></span><br><span class="line">  <span class="keyword">var</span> newleft = count * <span class="number">-600</span>;</span><br><span class="line">  <span class="comment">// console.log(newleft);</span></span><br><span class="line">  <span class="keyword">this</span>.index = count - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.animate(newleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maq = <span class="keyword">new</span> Marquee();</span><br></pre></td></tr></table></figure></p><h2 id="自动播放图片"><a href="#自动播放图片" class="headerlink" title="自动播放图片"></a>自动播放图片</h2><p>轮播图，顾名思义就是轮流播放图片，所以首先要实现的功能就是自动轮流循环播放图片。 有了之前的类，我们要做的就是当页面加载完毕后开始循环播放：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'arrow-left'</span>)[<span class="number">0</span>],</span><br><span class="line">      nextBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'arrow-right'</span>)[<span class="number">0</span>],</span><br><span class="line">      loopContainer = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'loop-container'</span>)[<span class="number">0</span>],</span><br><span class="line">      btns = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'buttons'</span>)[<span class="number">0</span>],</span><br><span class="line">      wrap = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'wrap'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> stopFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">startInterval</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 开始循环动画</span></span><br><span class="line">    maq.timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// console.log(stopFlag);</span></span><br><span class="line">      <span class="keyword">if</span> (!stopFlag) &#123;</span><br><span class="line">        maq.changePhoto(<span class="number">-600</span>);</span><br><span class="line">        startInterval();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearTimeout(maq.timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">4500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  startInterval();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我循环动画没有用setInterval函数，而是用的setTimeout。因为setInterval的机制是每隔一段时间就把事件加入到队列中去，但如果之前的事件还没执行完，就会容易造成队列堵塞。比如说setInterval里的函数执行时间要4秒，如果setInterval的间隔时间少于4秒，则会造成队列里的事件越来越多，而之前的事件却没执行完，这样可能就会使队列里的事件堵塞，最后一次性全部执行，而没有达到预期的间隔效果。</p><p>所以我用setTimeout来代替setInterval，每次要加入新的事件之前都先判断一下<code>stopFlag</code>是否为0。<code>stopFlag</code>的作用就是记录是否要停止动画，为0则不停止，为1则停止。</p><p>这里记住要clearTimeout，目的是把已经在队列里但还没有执行的事件清除，这样可以达到立即停止动画的效果。</p><h2 id="鼠标悬停停止轮播动画，离开后开始动画"><a href="#鼠标悬停停止轮播动画，离开后开始动画" class="headerlink" title="鼠标悬停停止轮播动画，离开后开始动画"></a>鼠标悬停停止轮播动画，离开后开始动画</h2><p>监听mouseover和mouseout事件来达到目的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wrap.addEventListener(<span class="string">'mouseover'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  stopFlag = <span class="number">1</span>;</span><br><span class="line">  clearTimeout(maq.timer);</span><br><span class="line">&#125;);</span><br><span class="line">wrap.addEventListener(<span class="string">'mouseout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  stopFlag = <span class="number">0</span>;</span><br><span class="line">  startInterval();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="左右切换图片"><a href="#左右切换图片" class="headerlink" title="左右切换图片"></a>左右切换图片</h2><p>通过点击左右箭头按钮实现图片之间的滚动切换：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prevBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    maq.changePhoto(<span class="number">600</span>); <span class="comment">// 向左滑</span></span><br><span class="line">&#125;);</span><br><span class="line">nextBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  maq.changePhoto(<span class="number">-600</span>);  <span class="comment">// 向右滑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="点击小圆点跳转到对应图片"><a href="#点击小圆点跳转到对应图片" class="headerlink" title="点击小圆点跳转到对应图片"></a>点击小圆点跳转到对应图片</h2><p>这里我用了事件代理，不用在每个小圆点上绑定click事件，提高dom性能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btns.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="built_in">parseInt</span>(event.target.innerText);</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    maq.gotoPhoto(count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="离开当前页面动画停止"><a href="#离开当前页面动画停止" class="headerlink" title="离开当前页面动画停止"></a>离开当前页面动画停止</h2><p>这里我开始没有想到，后来是当我每次切换到别的页面后再回到当前页面，发现动画效果出现问题了。经过一番debug才发现是因为chrome浏览器设置了离开当前页面后setInterval继续执行，如果setInterval的间隔时间小于100ms，则按100ms来执行，于是回来时动画的时间就发生错误了。</p><p>所以我们需要设置离开页面时动画停止，这样也节省了不少性能。这里利用的是<code>onvisibilitychange</code>事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 离开当前页面后动画停止</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    stopFlag = <span class="number">1</span>;</span><br><span class="line">    clearTimeout(maq.timer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stopFlag = <span class="number">0</span>;</span><br><span class="line">    startInterval();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里可以直接调用<code>document.hidden</code>API判断当前页面是否被隐藏，如果document.hidden为true则代表已经切换到别的页面，于是设置<code>stopFlag</code>为1，使动画停止。也可以用<code>document.visibilityState</code>,如果不为’visible’，则代表离开了当前页面。</p><p>这里其实可以不用setTimeout、setInterval来实现动画，而是用<code>requestAnimationFrame</code>，后者的优点是自动以浏览器支持的最小刷新间隔来实现重绘，使性能得到最大化提升，而且实现了离开页面重绘停止，大大节省性能。这里我就没有实现了，要想了解requestAnimationFrame，可参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">资料</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述方法，最后实现了一个比较完善的轮播图，全部的动画效果都是用JS来实现的。其实要想实现自动轮播，也可以用CSS3的animation来实现，而且实现起来更快，这里我就不阐述了。</p><p>最后贴出实现的<a href="https://codepen.io/flyrk/full/brxQBm/">demo</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS实战" scheme="https://xmflyrk.com/tags/JS%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现回到顶部的效果</title>
    <link href="https://xmflyrk.com/2017/08/22/scroll-to-top-btn/"/>
    <id>https://xmflyrk.com/2017/08/22/scroll-to-top-btn/</id>
    <published>2017-08-22T06:31:45.000Z</published>
    <updated>2019-01-29T08:45:34.770Z</updated>
    
    <content type="html"><![CDATA[<p>我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？<br><a id="more"></a></p><h1 id="JS实现滚动"><a href="#JS实现滚动" class="headerlink" title="JS实现滚动"></a>JS实现滚动</h1><p>其实很简单，利用下列函数就可以实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * func: 实现页面滚动到顶部的效果，</span></span><br><span class="line"><span class="comment"> * 离顶部越近滚动速度越慢</span></span><br><span class="line"><span class="comment"> * @acceleration: 滑动的加速度</span></span><br><span class="line"><span class="comment"> * @time: 延迟时间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goTop</span>(<span class="params">acceleration, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xScroll = <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="built_in">window</span>.scrollLeft || <span class="number">0</span>,   <span class="comment">// 获取水平滚动坐标</span></span><br><span class="line">      yScroll = <span class="built_in">document</span>.documentElement.scrollTop ||<span class="built_in">document</span>.body.scrollTop || <span class="built_in">window</span>.scrollTop || <span class="number">0</span>,  <span class="comment">// 获取垂直滚动坐标</span></span><br><span class="line">      speed = <span class="number">1</span> + acceleration; <span class="comment">// 滚动速度</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="built_in">Math</span>.floor(xScroll / speed), <span class="built_in">Math</span>.floor(yScroll / speed)); <span class="comment">// 屏幕滚动到某个坐标，因为speed大于1，所以x、y轴的坐标越来越小</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (xScroll &gt; <span class="number">0</span> || yScroll &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果没有滚动到顶部就设置延迟time后继续滚动</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          goTop(acceleration, time);</span><br><span class="line">      &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <em>返回顶部</em> 的按钮上绑定<code>onClick=&quot;goTop();&quot;</code>就可以实现返回顶部操作。</p><p>这里用到了<code>xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0;</code>，其实这三个值的效果都差不多，都代表滚动条水平移动的像素，只是浏览器兼容性可能有所不同，所以这样写兼容性更好。</p><p>然后就是<code>window.scrollTo(x, y)</code>方法。该方法使当前窗口滚动到指定的x、y像素坐标。之所以除以speed，这样就以一定的速度慢慢减小，达到缓慢的动画效果。</p><p>之后判断如果滚动条距离顶部还有一段距离的话，就继续循环调用该函数，并设置一定的延迟时间，以达到平滑滚动的动画效果。这里的<code>time</code>值要设置的比较小，超过100就显得比较不自然了。</p><h1 id="按钮的样式设置"><a href="#按钮的样式设置" class="headerlink" title="按钮的样式设置"></a>按钮的样式设置</h1><p>滚动特效实现了，但一般我们只有当页面发生滚动并且滚动到一定距离时才想要回到顶部，我们希望回到顶部的按钮在一定情况下才出现，于是我们需要设置按钮何时出现。通过在<code>scroll</code>事件上绑定函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'scroll2Top-btn'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123; <span class="comment">// 这里用了ES6语法</span></span><br><span class="line">    <span class="keyword">let</span> contentTop = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">window</span>.innerHeight, <span class="comment">// 获取当前可视窗口的高度</span></span><br><span class="line">      scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;  <span class="comment">// 获取垂直滚动条距离页面顶部的距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (contentTop &lt; scrollTop) &#123; <span class="comment">// 如果可视窗口的高度小于垂直滚动的距离，说明已经向下滚动超过一个可视窗口的距离，也就是说看不到顶部了，于是就设置按钮可见</span></span><br><span class="line">      scrollBtn.style.display = <span class="string">"block"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      scrollBtn.style.display = <span class="string">"none"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><hr><p>通过这两个简单的函数，实现了回到顶部的滚动效果，全部用原生JS编写，简单又实用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS实战" scheme="https://xmflyrk.com/tags/JS%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>从Atom转战VSCode</title>
    <link href="https://xmflyrk.com/2017/08/20/changing-IDE-to-VSCODE/"/>
    <id>https://xmflyrk.com/2017/08/20/changing-IDE-to-VSCODE/</id>
    <published>2017-08-20T13:24:01.000Z</published>
    <updated>2017-08-20T13:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。<br><a id="more"></a></p><p>刚开始用Atom感觉的确很清爽，各种插件用得飞起。然后随着插件的增多，和项目大小的提升，感觉Atom越来越卡，打开一个文件也要很久，那种流畅感没有了。于是有了换编辑器的想法。毕竟“工欲善其事，必先利其器”，写代码还是想要一个用起来顺手的编辑器，写的时候心情都会舒畅点（可能这是个人癖好。。。真正重要的当然还是代码本身）。</p><p>正好最近半年来VSCode越来越火，许多人都开始用它，群里一些大佬也在用VSCode，于是我就下了一个瞧瞧。</p><p>说实话，打开速度比Atom快的真不是一点半点，即使装了一些插件后打开速度也还是很快。而且VSCode由于逐渐发展起来，插件也越来越丰富，一点也不输给Sublime和Atom，常用的插件应有尽有。</p><p>用了VSCode后最大感受就是写代码变得舒服了。VSCode的代码高亮和Git操作真的很赞！鼠标悬停在某个函数或者属性上时还会有相应的说明，Git的操作也比Atom更可视化，一目了然。</p><p>总之，转战VSCode后并没有什么不适应，反而更加得心应手。当然不是说Atom不好了，一切都只是个人习惯问题罢了。但不得不说，VSCode绝对是编程利器。</p><p>最后，推荐一些常用的插件：</p><ul><li>Beautify</li><li>ESLint</li><li>One Dark Pro</li><li>vscode-icons</li><li>IntelliSense for CSS</li><li>Git Lens</li><li>ES7 React/Redux/React-Native/JS snippets</li><li>Path Intellisense</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://xmflyrk.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode" scheme="https://xmflyrk.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>JS如何设置Cookies</title>
    <link href="https://xmflyrk.com/2017/08/12/how-to-set-cookie-in-js/"/>
    <id>https://xmflyrk.com/2017/08/12/how-to-set-cookie-in-js/</id>
    <published>2017-08-12T15:07:55.000Z</published>
    <updated>2018-12-07T06:31:03.559Z</updated>
    
    <content type="html"><![CDATA[<p>Cookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。<br><a id="more"></a></p><h1 id="调用浏览器的CookiesAPI"><a href="#调用浏览器的CookiesAPI" class="headerlink" title="调用浏览器的CookiesAPI"></a>调用浏览器的CookiesAPI</h1><p>为了使用浏览器的CookieAPI，我们首先要在<a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json">manifest.json</a>里设置Cookie<code>permission</code>，还要设置<code>host-permission</code>确定能获取Cookie的网址。</p><p>接下来就是调用CookieAPI方法。</p><h2 id="Cookie-set"><a href="#Cookie-set" class="headerlink" title="Cookie.set"></a>Cookie.set</h2><p>使用<code>set()</code>方法添加新的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setting = browser.cookies.set(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>是一个对象，其中有可选的几个参数：</p><ul><li><code>url</code>: 请求Cookie的url</li><li><code>name</code>: Cookie的名字</li><li><code>value</code>: Cookie的值</li><li><code>domin</code>: Cookie的作用域名</li><li><code>path</code>: Cookie的路径</li><li><code>secure</code>: Cookie是否安全（true／false）</li><li><code>httpOnly</code>: Cookie是否只能在http上（true／false）</li><li><code>expirationDate</code>: Cookie的截止时间，如果没有设置，则Cookie变为Session Cookie</li><li><code>storeId</code>: 代表Cookie的存储ID</li></ul><h2 id="Cookie-get"><a href="#Cookie-get" class="headerlink" title="Cookie.get"></a>Cookie.get</h2><p>使用<code>get()</code>方法获取已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getting = browser.cookies.get(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p><h2 id="Cookie-getAll"><a href="#Cookie-getAll" class="headerlink" title="Cookie.getAll"></a>Cookie.getAll</h2><p>使用<code>getAll()</code>方法获取Cookie集合中所有匹配details的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getting = browser.cookies.getAll(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>session</code>、<code>storeId</code>。其中<code>session</code>是bool值，代表是否要从cookies中过滤掉session cookie。</p><h2 id="Cookie-remove"><a href="#Cookie-remove" class="headerlink" title="Cookie.remove"></a>Cookie.remove</h2><p>使用<code>remove()</code>方法移除已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removing = browser.cookies.remove(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p><h2 id="Cookie-getAllCookieStores"><a href="#Cookie-getAllCookieStores" class="headerlink" title="Cookie.getAllCookieStores"></a>Cookie.getAllCookieStores</h2><p>使用<code>getAllCookieStores()</code>方法获取所有的Cookie集合，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gettingStores = browser.cookies.getAllCookieStores();</span><br></pre></td></tr></table></figure></p><p>返回的<code>Promise</code>对象中包含的数据是包括所有cookiestore对象的数组。举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logStores</span>(<span class="params">cookieStores</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(store <span class="keyword">of</span> cookieStores) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Cookie store: <span class="subst">$&#123;store.id&#125;</span>\n Tab IDs: <span class="subst">$&#123;store.tabIds&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getting = browser.cookies.getAllCookieStores();</span><br><span class="line">getting.then(logStores);</span><br></pre></td></tr></table></figure></p><h2 id="Cookie-onChanged事件"><a href="#Cookie-onChanged事件" class="headerlink" title="Cookie.onChanged事件"></a>Cookie.onChanged事件</h2><p>当Cookie改变时，我们可以为它设置onChanged事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser.cookies.onChanged.addListener(callback)</span><br><span class="line">browser.cookies.onChanged.removeListener(listener)</span><br><span class="line">browser.cookies.onChanged.hasListener(listener)</span><br></pre></td></tr></table></figure></p><p>其中 <code>addListener</code>接受一个callback，callback有一个参数<code>changeInfo</code>，<code>changeInfo</code>有三个属性：</p><ul><li>removed：bool值，代表cookie是否移除</li><li>cookie：包含添加或移除信息的cookie对象</li><li>cause：Cookie改变的原因</li></ul><hr><h1 id="使用document-cookie"><a href="#使用document-cookie" class="headerlink" title="使用document.cookie"></a>使用document.cookie</h1><p>Cookie的结构很简单，就是键-值对，一般是以<code>key-value;expiration_date;path;domain;</code>的顺序。</p><p>最简单的设置当前页面Cookie的方法就是直接给<code>document.cookie</code>赋值，例如：<code>document.cookie = &quot;username=Simon, 12 Aug 2017 19:36:00 GMT; expires=Wed, 31 Oct 2017 11:00:00 GMT;&quot;;</code>，这样就设置了Cookie。但每次都这样设置很麻烦，我们可以用函数封装赋值方法。这里借鉴了网上的一些方法：</p><h2 id="setCookie"><a href="#setCookie" class="headerlink" title="setCookie()"></a>setCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cookie = name + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value) + <span class="string">";"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expires) &#123;</span><br><span class="line">    <span class="comment">// If it's a date</span></span><br><span class="line">    <span class="keyword">if</span>(expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">      <span class="comment">// If it isn't a valid date</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isNaN</span>(expires.getTime()))</span><br><span class="line">       expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="built_in">parseInt</span>(expires) * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cookie += <span class="string">"expires="</span> + expires.toGMTString() + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    cookie += <span class="string">"path="</span> + path + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">    cookie += <span class="string">"domain="</span> + domain + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>expires</code>可以是<code>Date</code>对象，也可以是代表天数的数字。</p><p>要创建新的Cookie，可以这样：<code>setCookie(&quot;website&quot;, &quot;xmflyrk.com&quot;, new Date(new Date().getTime() + 10000));</code> 或者 <code>setCookie(&quot;author&quot;, &quot;flyrk&quot;, 30);</code></p><h2 id="getCookie"><a href="#getCookie" class="headerlink" title="getCookie()"></a>getCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cok = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>),</span><br><span class="line">        length = cok.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> pairs = cok[i].trim();</span><br><span class="line">    <span class="keyword">if</span> (~pairs.indexOf(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> pairs.substring(pairs.indexOf(name) + name.length + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getCookie()</code>的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getCookie(<span class="string">'author'</span>); <span class="comment">// "flyrk"</span></span><br><span class="line">getCookie(<span class="string">'Something'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><h2 id="removeCookie"><a href="#removeCookie" class="headerlink" title="removeCookie()"></a>removeCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">name, path, domin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getCookie(name)) &#123;</span><br><span class="line">    setCookie(name, <span class="string">""</span>, <span class="number">-1</span>, path, domin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除某个Cookie我们就可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">removeCookie(<span class="string">"author"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(getCookie(<span class="string">"author"</span>)); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了这些API和自己封装的函数，我们就能对Cookie进行操作，方便地设置Cookie数据。</p><blockquote><p>参考资料：<br><a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies">cookies</a><br><a href="https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/">How to deal with cookie</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。&lt;br&gt;
    
    </summary>
    
      <category term="Web网络" scheme="https://xmflyrk.com/categories/Web%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Cookies" scheme="https://xmflyrk.com/tags/Cookies/"/>
    
  </entry>
  
  <entry>
    <title>JS中&quot;类&quot;的构造与继承</title>
    <link href="https://xmflyrk.com/2017/08/10/javascript-class-constructor/"/>
    <id>https://xmflyrk.com/2017/08/10/javascript-class-constructor/</id>
    <published>2017-08-10T13:46:33.000Z</published>
    <updated>2019-01-29T08:45:13.572Z</updated>
    
    <content type="html"><![CDATA[<p>有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>undefined</code>、<code>Symbol</code>。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。<br><a id="more"></a></p><p>我们知道，JS里没有类似于C++、Java一样的<code>class</code>类，于是也就没有私有、公有之说。但这并不代表我们不能模拟一个类，因为类的思想在面向对象编程里是很重要的一点，对于对象的继承与方法的引用和代码的重构等等都有极大好处。所以很多人就在JS里模拟类的用法，ES6甚至官方定义了一个<code>class</code>语法，但这也不是真正的类，只是<code>class</code>的语法糖。</p><p>说了这么多，JS里到底怎么实现类呢？利用函数的特性：所有的函数默认都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，也就是原型。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>什么是构造函数？我们知道<code>function</code>也是对象的一种，而当我们想要声明一个构造函数，可以使用下列形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConstructor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Simon'</span>;</span><br><span class="line">  <span class="keyword">var</span> car = <span class="string">'BMW'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(car);</span><br><span class="line">  &#125;</span><br><span class="line">  getCar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> myConstructor();</span><br></pre></td></tr></table></figure></p><p>使用上述方法我们就声明了一个构造函数<code>myConstructor</code>，但其实构造函数也是普通的对象，它和java里类的构造函数完全不一样。当我们使用<code>new</code>创建一个对象，实际上是把myObj的[[Prototype]]链接关联到myConstructor.prototype指向的对象。</p><p>我们知道，真正的面向类的语言中，类可以被复制或者实例化很多次，每创建一个实例相当于把类的方法属性复制到新实例中。但javascript没有类似的复制机制，要想让新对象与构造的“类”对象有关系，就必须把两个对象的prototype关联起来。</p><p>实际上并不存在所谓的“构造函数”，我们只是对函数的“构造调用”。</p><p>当使用new来进行构造函数调用时，会执行以下四个步骤：</p><ol><li>创建一个全新的对象</li><li>新对象会执行[[Prototype]]链接到constructor对象的prototype</li><li>新对象会绑定到函数调用的this</li><li>如果构造函数没有返回其他对象，那么new的函数调用会返回这个新对象</li></ol><p>这样一来，我们就把新对象与构造函数对象关联起来了。所以说函数不是构造函数，只是当且仅当使用new时，函数调用会变成“构造函数调用”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">a.constructor === Foo; <span class="comment">// true</span></span><br><span class="line">Foo.prototype.constructor === Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>当我们创建了Foo函数，Foo.prototype默认有一个公有且不可枚举的属性constructor，这个属性引用的是对象关联的函数（也就是Foo）。而调用a.constructor，实际上只是通过[[Prototype]]委托给了Foo.prototype，所以指向了Foo。</p><p>如果我们创建了新的原型对象，那么新对象并不会自动获得constructor属性，比如说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123; <span class="comment">/*....*/</span> &#125;; <span class="comment">// 创建了新的原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo; <span class="comment">// false</span></span><br><span class="line">a.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但问题来了，运行以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myObj.name; <span class="comment">// "Simon"</span></span><br><span class="line">myObj.car; <span class="comment">// undefined</span></span><br><span class="line">myObj.getCar(); <span class="comment">// Uncaught TypeError: myObj.getCar is not a function</span></span><br></pre></td></tr></table></figure></p><p>为什么会这样呢？原因就是构造函数有作用域。<code>this.name = &#39;Simon&#39;</code>相当于给构造函数这个对象的<code>name</code>属性赋值<code>&quot;Simon&quot;</code>，这里的<code>this</code>指代构造函数对象原型。而在构造函数里使用<code>var</code>、<code>function</code>创建的变量和函数都相当于 <em>局部变量</em>，也就是“私有方法”，因为作用域的问题，这些变量和属性在构造函数之外是不能访问的，“私有方法”中的函数可以访问其他的私有变量，构造函数的实例却不能访问这些方法。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>那么，如果我们想要实例能继承构造函数的属性或者方法怎么办呢？JS使用的机制为 <em>原型继承</em>，请看以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myConstructor.prototype.car = <span class="string">"Farrari"</span>;</span><br><span class="line">myConstructor.prototype.getCar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.car);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.car; <span class="comment">// "Farrari"</span></span><br><span class="line">myObj.getCar(); <span class="comment">// "Farrari"</span></span><br></pre></td></tr></table></figure></p><p>一旦我们在构造函数的原型上添加了属性car，当新对象myObj调用car属性时，它本身没有这个属性，于是就通过委托，在原型链上找，最后在myConsrtuctor.prototype上找到。</p><p>但使用原型继承来实现子类继承父类更好的方法是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo,prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name, type</span>) </span>&#123;</span><br><span class="line">  Foo.call(<span class="keyword">this</span>, name); <span class="comment">// 相当于ES6的super(name);</span></span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype); <span class="comment">// 相当于ES6的extends</span></span><br><span class="line">Bar.prototype.constructor = Bar; <span class="comment">// 这里需要修复consructor</span></span><br><span class="line"></span><br><span class="line">Bar.prototype.getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.type);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>, <span class="string">'obj a'</span>);</span><br><span class="line">a.getName(); <span class="comment">// 'a'</span></span><br><span class="line">a.getType(); <span class="comment">// 'obj a'</span></span><br></pre></td></tr></table></figure></p><p>这里用到的核心语句就是<code>Bar.prototype = Object.create(Foo.prototype);</code>，调用Object.create(obj)会凭空创建一个新对象并把新对象的[[Prototype]]关联到obj上。</p><p>我们来看看Object.create()的polyfill:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">proto, propsObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(proto === <span class="literal">null</span> || <span class="keyword">typeof</span> proto === <span class="string">'object'</span> || <span class="keyword">typeof</span> proto === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Arguments must be object, or Null'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    temp.__proto__ = proto;</span><br><span class="line">    <span class="keyword">if</span> (propsObj) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(temp, propsObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有的人可能会说，为什么不能直接<code>Bar.prototype = Foo.prototype;</code>呢？这样并不会创建一个关联到Foo.prototype的新对象，只是让Bar.prototype引用Foo.prototype对象，我们执行<code>Bar.prototype.getType = ....</code>也会在Foo.prototype上修改，跟预料的结果不一样。那这样根本不需要Bar，还不如直接在Foo上修改就好了。</p><p>而之前介绍的<code>Bar.prototype = new Foo()</code>虽然也能实现原型继承，但它会有一些副作用。比如Foo如果有（写日志、修改状态、注册到其他对象、给this添加属性等等）的行为，就会影响到Bar的子类，造成无法预料的结果。</p><p>所以，要创建一个关联的“子类”对象，我们必须使用Object.create()，但这样有一个缺点是要创建一个新对象而把旧对象抛弃。</p><p>好在ES6添加了<code>Object.setPrototypeOf(...)</code>方法，可以修改关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype); <span class="comment">// ES6之前需要抛弃默认对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype, Foo.prototype); <span class="comment">// ES6可以直接修改Bar.prototype对象</span></span><br></pre></td></tr></table></figure></p><h1 id="检查“类”的关系"><a href="#检查“类”的关系" class="headerlink" title="检查“类”的关系"></a>检查“类”的关系</h1><p>考虑以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.blah = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p>我们如果想要判断a的原型是否与Foo关联起来了，我们可以有以下几种方法：</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但这样有个缺点是只能处理对象和函数之间的关系。如果我们想判断两个对象之间是否通过[[Prototype]]关联。可以用下列方法：</p><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.isPrototypeOf(a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要判断两个对象之间的关系，更直接：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.isPrototypeOf(c); <span class="comment">// 判断b是否出现在c的原型链中</span></span><br></pre></td></tr></table></figure></p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>我们可以直接用非标准的<code>__proto__</code>属性，<code>__proto__</code>实际上存在于内置的Object.prototype中，且不可枚举。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要想创建类似于“类”的对象，可以使用构造函数调用，给构造函数添加公有方法，在构造函数的<code>prototype</code>上添加属性。新对象想要继承构造函数，使用Javascript的原型继承机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Null&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;Symbol&lt;/code&gt;。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS对象及函数" scheme="https://xmflyrk.com/tags/JS%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>这些天的感想</title>
    <link href="https://xmflyrk.com/2017/08/09/thought-of-today/"/>
    <id>https://xmflyrk.com/2017/08/09/thought-of-today/</id>
    <published>2017-08-09T14:29:55.000Z</published>
    <updated>2017-08-09T15:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。<br><a id="more"></a></p><p>暑假以来，一直在找实习，然而很多公司基本人都招满了，而投的几个也了无音讯，说实话，我感受到了强烈的失落感。<br>我到底适不适合做前端？为什么没有公司要我呢？我应该怎么做？我应该坚持下去吗？</p><p>每天我都陷入深深地自省中，我学前端真的对吗？我是真心想做前端开发吗？</p><p>经过这段时间的思考，我还是决定了，继续走下去。既然选择了前端这条路，就不该放弃，即使没有公司实习，没关系，自己在家自学，写项目，看书，反正不让自己闲着。前端基础不好，补！静下心来看书、静下心来写代码！边学边准备校招。</p><p>我知道，自己严格来说前端只学了不到一年的时间，比不上别人已经学了好几年，进工作室、公司实习过的大佬，但我相信，现在仍然为时不晚。我只不过是比别人起步晚，那就比别人花的时间长呗！我以前都只是听说勤能补拙，这次，我要自己实践下去。</p><p>为什么选择前端？</p><p>一开始是在知乎看到前端的介绍，那个时候第一次听到前端这个名词，之前完全不知道它是干什么的。后来慢慢去了解，发现前端看似很简单，用HTML、CSS、JavaScript稍加组合就能写出一个网页，不像后台开发那么没头绪、可视化不强，前端是即写即见的。后来一步步去W3SCHOOL上跟着教程走，上网找各种资料，图书馆借书看，发现前端并没有想象中的那么简单，要学的东西多而杂，光学好HTML、CSS还不行，还得会响应式开发，会用<code>Sass</code>、<code>Less</code>预处理，会<code>CSS3</code>动画…光会原生JS也不行，写项目时效率太低，得学会使用各种库，比如伟大的<code>JQuery</code>、<code>underscore</code>等等，后来发现还得了解工程化，因为前端的逻辑越来越复杂，所包含的内容越来越多，需要框架的帮助和自动化工具来提高开发效率，比如三大框架：<code>React</code>、<code>Vue</code>、<code>Angular</code>，还有打包工具<code>Webpack</code>、<code>gulp</code>、<code>grunt</code>等等。这里面每一个知识都值得去深挖，去研究。这还不够，你不能光会前端写页面，你还得会移动端开发，随着页面的复杂度提高，资源的增多，你还得会性能优化，缓存处理，HTTP协议相关。因为前端既要和用户进行交互，还要与后端进行交接，所以服务器方面的知识也得略知一二，比如<code>NodeJS</code>。</p><p>当我刚了解这些我发现我头都大了一圈，前端要学的东西太多了吧！不光这样，每天关注技术博客、新闻、知乎等论坛时还会发现层出不穷的新名词，都是别人新写的库，宣传得多么多么厉害。让我这个前端小白看得眼花缭乱，不知道该不该去学。</p><p>三四月份的时候真是我陷入迷茫期的时候，感觉自己什么都想学，但又觉得学不过来，不知道先学哪一个。经历了春招实习生的挫败后，我终于发现了，我学的太浮躁了。</p><p>因为急于想要找到实习，希望学点新东西，新框架来显示自己的能力，但却忽略了最重要的一点：基础。基础不牢，学什么都白谈。基础没学好，去学那些花里胡哨的库却不能理解其中的源码、思想，只是机械地使用工具来码代码，那和最基本的劳动力有什么区别？别人凭什么招你呢？你的活完全可以找别人来替代，为什么要选你呢？</p><p>于是，我开始重新翻阅书籍，静下心来去看，看到有意思的地方、值得记忆的地方就写下来，以后随时翻阅。但同时光看书也不行，实践能力差别人一大截，于是我又使用React+Node写了一个<a href="https://github.com/flyrk/myblog">博客系统</a>，每天持续完善中。就这样，暑假过去了一个月。</p><p>这一个月来，我虽然没有找到实习，但我找到了自己的学习方向。我知道我要先打好基础，同时动手能力也不能落下。</p><p>我不知道即将到来的秋招会是怎样，但我唯有坚持下去，坚守自己的初心，不让自己后悔。</p><hr><p>说了这么多关于前端的思考和自己的打算，再说说前端之外的吧。最近身体不好，去医院做了检查，索性无大碍。但是今天又有点感冒头晕，让我很是烦躁。不管怎样，身体一定要养好，有了好身体才有好力气干活。</p><p>虽说自己没有出去找事做，但每天学习学习，码码代码，也还是过的挺充实的。加油吧，少年！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。&lt;br&gt;
    
    </summary>
    
      <category term="生活杂谈" scheme="https://xmflyrk.com/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="thoughts" scheme="https://xmflyrk.com/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>获取浏览器窗口大小</title>
    <link href="https://xmflyrk.com/2017/08/08/get-browser-size/"/>
    <id>https://xmflyrk.com/2017/08/08/get-browser-size/</id>
    <published>2017-08-08T12:57:31.000Z</published>
    <updated>2019-02-15T05:53:06.792Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？</p><p>先来看这样一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBrowserSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> de = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">'width'</span>: (</span><br><span class="line">      <span class="built_in">window</span>.innerWidth</span><br><span class="line">      || de &amp;&amp; de.clientWidth</span><br><span class="line">      || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'height'</span>: (</span><br><span class="line">      <span class="built_in">window</span>.innerHeight</span><br><span class="line">      || de &amp;&amp; de.clientHeight</span><br><span class="line">      || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。<br><a id="more"></a></p><ul><li><code>documentElement</code>:<code>document.documentElement</code>获取的是页面中的<code>&lt;html&gt;</code>元素，也就相当于整个页面。</li><li><code>innerWidth&amp;&amp;innerHeight</code>: innerWidth获取的是可视区域的宽度，但包括垂直滚动条；innerHeight则只包括可视区域高度，不包括功能框之类的。相比较之下，outerWidth和outerHeight则包含整个窗口的高度，包括功能框、滚动条之类的。</li><li><code>document.body</code>:获取页面中body元素。</li><li><code>Element.clientWidth</code>:获取元素的可视宽度（高度），它包括<code>padding</code>但不包括滚动条、<code>border</code>和<code>margin</code>。</li></ul><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>话不多说，直接上图：<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/window-inner%26outer.jpg" alt="window-inner-outer"></p><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-inner.jpg" alt="browser-size-inner"></p><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client.jpg" alt="browser-size-client"></p><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/browser-size-client-body.jpg" alt="browser-size-client-body"></p><p>我们可以得出结论：</p><ul><li><code>window.innerWidth</code>和<code>window.outerWidth</code>基本是一样的，因为innerWidth也包括了滚动条，但如果侧面有功能栏的话，innerWidth就会比outerWidth小；<code>window.innerHeight</code>和<code>window.outerHeight</code>差别较大，因为下面有调试栏。</li><li><code>document.documentElement.clientWidth(clientHeight)</code>获取的就是页面的可视窗口宽高，不包括滚动条和功能栏之类的。</li><li><code>document.body.clientWidth(clientHeight)</code>获取的是<code>body</code>元素的宽高，不包括滚动条，但因为<code>body</code>的内容高度有465px，所以比<code>document.documentElement.clientHeight</code>要高。</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><code>document.documentElement</code>几乎每个浏览器都兼容；<code>window.outerWidth</code>和<code>window.innerWidth</code>IE8及以下都不支持；<code>document.body</code>和<code>clientWidth</code>IE6之前不支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>获取浏览器当前窗口大小，一般用<code>window.innerWidth(innerHeight)</code>就好了，但如果不兼容，则次之用<code>document.documentElement.clientWidth(clientHeight)</code>，再不行就只能用<code>document.body</code>获取了。</p><p>前面提到的<code>getBrowserSize()</code>方法就是使用了这种理念。</p><blockquote><p>参考资料:<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement">documentElement</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth">innerWidth</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/outerWidth">outerWidth</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/body">document.body</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth">clientWidth</a><br>《JavaScriptDOM高级程序设计》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？&lt;/p&gt;
&lt;p&gt;先来看这样一段代码：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getBrowserSize&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; de = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.documentElement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;width&#39;&lt;/span&gt;: (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.innerWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || de &amp;amp;&amp;amp; de.clientWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.body.clientWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;height&#39;&lt;/span&gt;: (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.innerHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || de &amp;amp;&amp;amp; de.clientHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.body.clientHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS实战" scheme="https://xmflyrk.com/tags/JS%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>详解JavaScript对象</title>
    <link href="https://xmflyrk.com/2017/08/05/javascript-object/"/>
    <id>https://xmflyrk.com/2017/08/05/javascript-object/</id>
    <published>2017-08-05T06:32:12.000Z</published>
    <updated>2019-01-29T08:41:58.832Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。</p><a id="more"></a><h1 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h1><h2 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h2><p>对于 可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象来说，有一种巧妙的复制方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( someObj ));</span><br></pre></td></tr></table></figure></p><p>这种方法的好处是实现了 <strong>深复制</strong>，但必须要求原对象可以被解析成JSON字符串。</p><h2 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a><code>Object.assign()</code>方法</h2><p>ES6定义了<code>Object.assign()</code>方法实现 <strong>浅复制</strong>。该方法第一个参数是目标对象，之后可以跟若干个源对象。它会遍历源对象的所有可枚举的自有键并把它们复制到目标对象，比如说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  a: <span class="number">12</span></span><br><span class="line">  b: anotherObj,</span><br><span class="line">  c: anotherArray,</span><br><span class="line">  d: anotherFunction</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject);</span><br><span class="line">newObj.a; <span class="comment">// 12</span></span><br><span class="line">newObj.b === anotherObj; <span class="comment">// true</span></span><br><span class="line">newObj.c === anotherArray; <span class="comment">// true</span></span><br><span class="line">newObj.d === anotherFunction; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但要注意的是，浅复制只是简单的使用<code>=</code>操作符赋值，对于引用类型值来说，指向的是同一个对象。也就是说，<code>newObj.b === myObject.b</code>。</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>ES5开始，所有的属性都有属性描述符。通过<code>Object.getOwnPropertyDesciptor(obj, prop)</code>可以获取对象的某个属性的属性描述符。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObj, <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//Object &#123;</span></span><br><span class="line"><span class="comment">//  value: 12,</span></span><br><span class="line"><span class="comment">//  writable: true,</span></span><br><span class="line"><span class="comment">//  enumerable: true,</span></span><br><span class="line"><span class="comment">//  configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></p><p>一般默认值<code>writable</code>、<code>enumerable</code>、<code>configurable</code>都为<code>true</code>，我们也可以用<code>Object.defineProperty()</code>来添加一个新属性或者修改一个已有属性（如果它是<code>configurable</code>）。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><h2 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们修改<code>writable</code>为false，则该属性不可写了。</p><h2 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可配置</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a = <span class="number">5</span>;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">delete</span> myObject.a;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>一旦我们修改<code>configurable</code>为false，就无法撤销，并且不能重新配置属性，也无法删除该属性。</p><h2 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h2><p>这个属性描述符代表属性是否会出现在对象的属性枚举中，比如<code>for ..in</code>循环。如果设置<code>enumerable: false</code>，则该属性不会出现在枚举中。</p><h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>JavaScript不像其他语言，它是动态的，也就是可变的。但如果我们想属性或者对象是不可改变的，该怎么实现呢？</p><h2 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h2><p>结合<code>writable: false</code>和<code>configurable: false</code>可以创建一个常量属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"CONST_VARIABLE"</span>, &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h2><p>如果想保留对象已有的属性并禁止向对象添加新的属性，则可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions( myObject );</span><br><span class="line"></span><br><span class="line">myObject.b = <span class="number">13</span>;</span><br><span class="line">myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h2 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h2><p>使用<code>Object.seal(...)</code>会创建一个“密封”对象，相当于在对象上调用<code>Object.preventExtensions()</code>并且设置所有属性为<code>configurable: false</code>。</p><p>所以，密封之后的对象只能修改已有属性的值，而不能添加新属性，也不能重新配置或删除已有属性。</p><h2 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h2><p>使用<code>Object.freeze(...)</code>会创建一个冻结对象，相当于在对象上调用<code>Object.seal()</code>并且设置所有属性为<code>writable: false</code>。</p><p>这个方法完全使对象不可变，会禁止对于对象本身及其任意直接属性的修改。</p><blockquote><p>需要注意的是，之前所有的方法创建的都是浅不可变，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的。</p></blockquote><h1 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h1><p>当访问某个对象属性时，实际上实现了<code>[[Get]]</code>操作，对象默认的内置<code>[[Get]]</code>操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，则会遍历原型链，如果还是没找到，则返回<code>undefined</code>。</p><p>当设置某个对象属性的值，则有<code>[[Put]]</code>操作。<code>[[Put]]</code>会检查以下内容：</p><ol><li>属性是否存在setter，存在则调用setter</li><li>属性的<code>writable</code>是否是<code>false</code>，是的话则赋值失败</li><li>如果都不是，则对属性进行赋值</li></ol><p>我们可以给对象一个属性定义getter、setter，当访问或赋值对象的属性时，会忽略属性的<code>value</code>和<code>writable</code>特性，而关注<code>get</code>和<code>set</code>特性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  get a() &#123; <span class="comment">// 给属性a定义一个getter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span>; &#125;, <span class="comment">// 给属性b设置一个getter</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 11</span></span><br><span class="line">myObject.b; <span class="comment">// 22</span></span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 11</span></span><br></pre></td></tr></table></figure></p><p>当访问属性时会自动调用<code>get</code>函数，其返回值会被当作属性访问的返回值；注意的是，由于我们没有设置<code>set</code>，所以赋值操作被忽略了。而由于我们定义的<code>get</code>始终返回2，即使设置了<code>set</code>也没有意义。</p><p>我们可以这样设置<code>getter</code>和<code>setter</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  get a() &#123; <span class="comment">// 给属性a定义一个getter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a;</span><br><span class="line">  &#125;,</span><br><span class="line">  set a(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._a = val * <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span>;</span><br><span class="line">myObject.a; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><h1 id="属性的存在性"><a href="#属性的存在性" class="headerlink" title="属性的存在性"></a>属性的存在性</h1><p>当我们访问<code>object.a</code>返回的是<code>undefined</code>，可能是属性中本来存储的就是<code>undefined</code>，也可能是属性不存在，那么怎么判断属性是否存在呢？</p><p>我们可以用<code>in</code>或者<code>Object.hasOwnProperty()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">(<span class="string">"a"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"a"</span>); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"b"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>这里要注意的是，<code>in</code>会检查属性是否在对象及其原型链中，而<code>hasOwnProperty</code>只会检查属性是否在对象中，不会检查原型链。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>要检查某个属性是否可枚举，通常有两种方法：<br>第一种方法，使用<code>for...in</code>循环：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObject.b; <span class="comment">// 2</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"b"</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> myObject) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;k&#125;</span>:<span class="subst">$&#123;myObject[k]&#125;</span>`</span>); <span class="comment">// a:1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObject.propertyIsEnumerable(<span class="string">"a"</span>); <span class="comment">// true</span></span><br><span class="line">myObject.propertyIsEnumerable(<span class="string">"b"</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(myObject); <span class="comment">// ["a"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(myObject); <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure></p><p><code>propertyIsEnumerable()</code>可以判断给定的属性名是否直接存在于对象中且<code>enumerable: true</code>；<code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code>会返回一个数组，包含所有属性，无论它们是否可枚举。</p><p>要注意的是，<code>Object.keys(..)</code>和<code>hasOwnProperty()</code>和<code>Object.getOwnPropertyNames(..)</code>不会查找原型链，而<code>in</code>和<code>for...in</code>会查找原型链。</p><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>对于数组来说，最常用的遍历就是<code>for</code>循环。然而javascript内置了一些数组的迭代器，包括<code>forEach(..)</code>、<code>every(..)</code>、<code>some(..)</code>、<code>map(..)</code>。它们都接受一个回调函数并把它应用到每个元素上，区别就是它们对回调函数返回值的处理方式不同。</p><p><code>forEach(..)</code>遍历所有元素并忽略返回值；<code>every(..)</code>会一直运行直到返回值为<code>false</code>；<code>some(..)</code>会一直运行直到返回值为<code>true</code>；<code>map(..)</code>遍历所有元素并且用返回值代替当前元素。</p><p>ES6还新增了遍历数组的<code>for...of</code>循环语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p><code>for..of</code>循环首先会向被访问对象请求一个 <strong>迭代器</strong> 对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。由于数组有内置的<code>@@iterator</code>，所以<code>for..of</code>可以直接应用在数组上，如果想让对象也使用<code>for..of</code>循环，则需要自定义<code>@@iterator</code>，这里就不多展开了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JavaScript对象是引用类型，我们可以给对象添加属性并修改属性描述符来控制属性的特征，还可以用<code>get</code>和<code>set</code>来修改属性的访问和赋值操作，对象的属性还可以枚举和遍历。</p><blockquote><p>参考资料：<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch3.md">You-Dont-Know-JS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://xmflyrk.com/categories/JavaScript/"/>
    
    
      <category term="JS对象及函数" scheme="https://xmflyrk.com/tags/JS%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
