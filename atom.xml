<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Flyrk&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://flyrk.github.io/"/>
  <updated>2018-12-04T09:00:55.672Z</updated>
  <id>https://flyrk.github.io/</id>
  
  <author>
    <name>Flyrk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>纯CSS绘制不同的图形</title>
    <link href="https://flyrk.github.io/2018/12/03/draw-different-shapes-with-css/"/>
    <id>https://flyrk.github.io/2018/12/03/draw-different-shapes-with-css/</id>
    <published>2018-12-03T12:44:19.000Z</published>
    <updated>2018-12-04T09:00:55.672Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要用CSS绘制图形？我们知道，一般表示图案可以用<code>img</code>标签，直接用切好的图片，或者用<code>background</code>加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。<br><a id="more"></a></p><h1 id="基本图案"><a href="#基本图案" class="headerlink" title="基本图案"></a>基本图案</h1><h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><p>圆形可以说是除了方形以外最容易表达的图形了，多亏了CSS3的<code>border-radius</code>属性：</p><h3 id="基本圆形"><a href="#基本圆形" class="headerlink" title="基本圆形"></a>基本圆形</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/circle.jpg" alt="circle"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="椭圆形"><a href="#椭圆形" class="headerlink" title="椭圆形"></a>椭圆形</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/oval.jpg" alt="oval"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.oval</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50px</span> / <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p>三角形其实利用的是<code>border</code>属性，利用不同方向的<code>border</code>宽度和颜色可以展现不同的三角形。</p><h3 id="triangle-top："><a href="#triangle-top：" class="headerlink" title="triangle-top："></a>triangle-top：</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-top.jpg" alt="triangle-top"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.top-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-bottom"><a href="#triangle-bottom" class="headerlink" title="triangle-bottom"></a>triangle-bottom</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-bottom.jpg" alt="triangle-bottom"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-left"><a href="#triangle-left" class="headerlink" title="triangle-left"></a>triangle-left</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-left.jpg" alt="triangle-left"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="triangle-right"><a href="#triangle-right" class="headerlink" title="triangle-right"></a>triangle-right</h3><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/triangle-right.jpg" alt="triangle-right"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right-triangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他的三角形也就是利用border属性进行的变形。</p><h1 id="特殊图案"><a href="#特殊图案" class="headerlink" title="特殊图案"></a>特殊图案</h1><h2 id="跳转图标"><a href="#跳转图标" class="headerlink" title="跳转图标"></a>跳转图标</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/border-top-left-radius.png" alt="border-top-left-radius"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.curvedarrow</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">26px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">26px</span> solid red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(10deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.curvedarrow</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">6px</span> solid red;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">26px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里主要利用的属性有两个，一个是<code>border-radius: 20px 0 0 0;</code>。为什么要这样用呢？其实<code>border-radius</code>最多支持四个值：<code>border-top-left-radius</code>, <code>border-top-right-radius</code>,<code>border-bottom-right-radius</code>, and <code>border-bottom-left-radius</code>。这里我们把<code>border-top-left-radius</code>设为20px，其他的都设为0，再加上只设<code>border-top</code>的宽度，最后出来是一个尾部有弧度的长条。</p><p>第二个属性则是<code>rotate(deg)</code>，将两个图形经过不同的角度旋转后再移动长条的位置进行组合，最后达到跳转箭头的图标效果。</p><h2 id="等腰梯形"><a href="#等腰梯形" class="headerlink" title="等腰梯形"></a>等腰梯形</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/trapezoid.png" alt="trapezoid"><br>梯形其实很好理解，通过设置border的宽度和透明度就可以形成梯形：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.trapezoid</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/parallel.png" alt="parallel"><br>很简单，直接利用<code>transform: skew(deg)</code>就可以得到任意角度的平行四边形：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parallel</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">skew</span>(30deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="五角星"><a href="#五角星" class="headerlink" title="五角星"></a>五角星</h2><p>其原理是利用三个三角形通过旋转不同的角度和绝对定位拼接而成。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-five.png" alt="star-five"><br>具体代码如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star-five</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(35deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-five</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">80px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">45px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">65px</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-35deg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-five</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">3px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">105px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-70deg);</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="六角星"><a href="#六角星" class="headerlink" title="六角星"></a>六角星</h2><p>利用两个三角形拼接而成。<br><img src="https://photos-1258216033.cos.ap-shanghai.myqcloud.com/star-six.png" alt="star-six"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star-six</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-six</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要用CSS绘制图形？我们知道，一般表示图案可以用&lt;code&gt;img&lt;/code&gt;标签，直接用切好的图片，或者用&lt;code&gt;background&lt;/code&gt;加载背景图。但是，当我们遇到一些小图标，比如说三角箭头、半圆、对话框、圆形等等。这些简单的图案其实可以完全使用CSS来生成，这样可以极大的减少图片资源的请求和加载，从而使网页加载速度更快。&lt;br&gt;
    
    </summary>
    
      <category term="设计之美" scheme="https://flyrk.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="CSS" scheme="https://flyrk.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>实现基于codemirror的markdown编辑器有哪些坑</title>
    <link href="https://flyrk.github.io/2018/10/27/codemirror-markdown-editor/"/>
    <id>https://flyrk.github.io/2018/10/27/codemirror-markdown-editor/</id>
    <published>2018-10-27T00:23:57.000Z</published>
    <updated>2018-12-04T05:01:08.479Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Markdown编辑器是个大坑，特别是如果要实现实时预览、同步滚动、支持标签按钮添加。HTML本身的<code>textarea</code>标签其实就是一个简单的文本编辑框，但它的功能太简单了，无法满足markdown编辑器的需求，所以我们需要对其进行改造，实现一个可同步预览并实时滚动的markdown编辑器。</p><p>其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，但是如果想要自己添加标签定制的话，就不能直接拿这些编辑器直接用，所以没办法，还是从头开始一步一步踩坑吧。<br><a id="more"></a></p><h1 id="为什么选择CodeMirror"><a href="#为什么选择CodeMirror" class="headerlink" title="为什么选择CodeMirror"></a>为什么选择CodeMirror</h1><p>要实现一个markdown编辑器，首先得找到一个合适的框架，自己从头开始手撸也不是不可以，但那样太耗时间，以后可以考虑自己写一个，但目前市面上优秀的markdown框架也是很多的。由于现在自己写的项目一般都使用React，所以理所当然能找到一个比较契合React的Markdown框架是更好的。</p><p>经过前期调研，发现有几款基于React的Markdown框架还不错，<a href="https://zenoamaro.github.io/react-quill/">react-quill</a>、facebook的<a href="https://draftjs.org/docs/getting-started.html">draft</a>、<a href="https://github.com/scniro/react-codemirror2">react-codemirror2</a>，但它们其实都是富文本编辑器，定制的东西已经很完善了，我想要的框架是可支持自定义扩展，定制化自己想要的功能，找来找去，最后决定基于<a href="https://codemirror.net/doc/manual.html#api">CodeMirror</a>来自己实现一个定制化的markdown编辑器。因为CodeMirror其实相当于一个基础的框架，它有很多可配置项，可以自己添加工具栏，添加各种实用功能，这正好满足了我的需求，于是就决定用它了！</p><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><p>都说编辑器是个大坑，特别是web编辑器，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，Markdown编辑器是个大坑，特别是如果要实现实时预览、同步滚动、支持标签按钮添加。HTML本身的&lt;code&gt;textarea&lt;/code&gt;标签其实就是一个简单的文本编辑框，但它的功能太简单了，无法满足markdown编辑器的需求，所以我们需要对其进行改造，实现一个可同步预览并实时滚动的markdown编辑器。&lt;/p&gt;
&lt;p&gt;其实现在市面上的Markdown编辑器已经很优秀了，有道笔记、印象笔记、Cmd等等，但是如果想要自己添加标签定制的话，就不能直接拿这些编辑器直接用，所以没办法，还是从头开始一步一步踩坑吧。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>什么是堆排序</title>
    <link href="https://flyrk.github.io/2017/09/05/what-is-heapSort/"/>
    <id>https://flyrk.github.io/2017/09/05/what-is-heapSort/</id>
    <published>2017-09-05T02:02:06.000Z</published>
    <updated>2018-12-04T05:07:12.250Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />    <label for="pass">Please enter the password to read the blog.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      The article has been encrypted, please enter your password to view.&lt;br&gt;
    
    </summary>
    
      <category term="算法与数据结构" scheme="https://flyrk.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="HeapSort" scheme="https://flyrk.github.io/tags/HeapSort/"/>
    
  </entry>
  
  <entry>
    <title>用原生JS写轮播图</title>
    <link href="https://flyrk.github.io/2017/08/27/how-to-write-js-marquee/"/>
    <id>https://flyrk.github.io/2017/08/27/how-to-write-js-marquee/</id>
    <published>2017-08-27T08:53:36.000Z</published>
    <updated>2017-08-27T10:49:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。<br><a id="more"></a></p><h1 id="要实现的功能"><a href="#要实现的功能" class="headerlink" title="要实现的功能"></a>要实现的功能</h1><p>首先我们来看看要实现这么一个轮播图需要哪些功能，这里我把我想到的都列出来了。</p><ol><li>页面加载后轮播图自动开始播放，每张图片停几秒钟。</li><li>图片与图片之间实现平滑过渡动画效果，不显突兀。</li><li>鼠标悬停到当前图片时轮播动画停止，鼠标离开图片后继续开始轮播。</li><li>图片上有左右翻页功能按钮，点击左边按钮图片往左滑动，点击右边按钮图片右滑。</li><li>图片下端有显示图片个数的小圆点，当前图片是第几个，则第几个小圆点“点亮”。</li><li>离开当前页面后轮播动画停止，回到当前页面后轮播动画继续。</li></ol><p>我能想到的要实现的功能就这么多，接下来就一步步开始实现。</p><h1 id="HTMl结构"><a href="#HTMl结构" class="headerlink" title="HTMl结构"></a>HTMl结构</h1><p>先不管JS、CSS部分，我们先把整体结构定下来。这里直接贴上主体部分代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loop-container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat5.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat1.jpg"</span> <span class="attr">alt</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat2.jpg"</span> <span class="attr">alt</span>=<span class="string">"2"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat3.jpg"</span> <span class="attr">alt</span>=<span class="string">"3"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat4.jpg"</span> <span class="attr">alt</span>=<span class="string">"4"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat5.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./assets/cat1.jpg"</span> <span class="attr">alt</span>=<span class="string">"5"</span> <span class="attr">class</span>=<span class="string">"loop-image"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"buttons"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"on"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>4<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>5<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow arrow-left"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pt-inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"arrow arrow-right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pt"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"pt-inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里要强调的一点就是，虽然最后显示只有5张图片，但我插入了7个<code>img</code>标签，其中第一个和最后一张图一样，最后一个和第一个图一样。为什么要这么做呢？是因为要实现平滑的动画过渡效果，后面JS部分会提到。</p><h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><p>接下来就是CSS设置：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.loop-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">700%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">animation</span>: left .<span class="number">6s</span> ease-out;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span><span class="selector-pseudo">:hover</span> &gt; <span class="selector-class">.arrow</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loop-container</span> <span class="selector-class">.loop-image</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我没有把全部的CSS代码贴出来，完整的代码我会在最后给出。</p><p>我只说几个要注意的地方：</p><ul><li>首先外部容器要设置<code>overflow:hidden</code>，这样才能把多余的图片遮住；</li><li>其次由于img默认是inline元素，显示出来的特性是inline-block，所以img之间会有4px的空隙，即使设置了margin和padding为0也不能消除。为此我困惑了很久。。。后来上网找资料才发现解决方案。一般有几种解决方案，这里我用的是设置父元素的font-size为0，然后img的font-size设不设置根据需要，这样就可以消除空隙。更详尽的解决方案可以参考张大神的<a href="http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">博客</a></li></ul><p>其他css设置就根据样式慢慢调整了。</p><h1 id="JS部分"><a href="#JS部分" class="headerlink" title="JS部分"></a>JS部分</h1><p>接下来就是重头戏，JS的实现了。我们一步一步来看。</p><p>我先创建了一个整体的“类”，里面有一些所需要用到的方法和属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Marquee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.timer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>; <span class="comment">// 保存当前是第几张图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.animate = <span class="function"><span class="keyword">function</span> (<span class="params">aimLeft</span>) </span>&#123;  <span class="comment">// 具体的动画实现</span></span><br><span class="line">  <span class="keyword">var</span> curLeft = <span class="built_in">parseInt</span>(loopContainer.style.left) || <span class="number">-600</span>, <span class="comment">// 获取当前图片的left值</span></span><br><span class="line">      speed = (aimLeft - curLeft) / <span class="number">20</span>, <span class="comment">// 每次left移动的距离</span></span><br><span class="line">      delay = <span class="number">20</span>,</span><br><span class="line">      self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> time = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 利用循环定时实现平滑移动的动画效果</span></span><br><span class="line">    curLeft += speed;</span><br><span class="line">    loopContainer.style.left = curLeft + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">if</span> (curLeft === aimLeft) &#123;  <span class="comment">// 如果移动到了下一张图片的位置，则此次移动动画结束</span></span><br><span class="line">      clearInterval(time);</span><br><span class="line">      <span class="keyword">if</span> (aimLeft &lt;= <span class="number">-3600</span>) &#123;  <span class="comment">// 特殊设置，如果是从最后一张图到第一张图，中间加一张图片实现动画过渡，当到达最后一张图后，立即设置left为第二个img的left。 </span></span><br><span class="line">        loopContainer.style.left = <span class="string">'-600px'</span>;  <span class="comment">// 第一张图实际的left为-600px，因为html里left为0的位置是最后一张图</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (aimLeft &gt;= <span class="number">0</span>) &#123; <span class="comment">// 同理，当从第一张图过渡到最后一张图，先实现动画效果，当left为实际第一张图的位置0时，设置left为倒数第二个img的位置。</span></span><br><span class="line">        loopContainer.style.left = <span class="string">'-3000px'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      self.showCurrentDot();  <span class="comment">// 动画结束后再改变小圆点的外观</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;;</span><br><span class="line">Marquee.prototype.showCurrentDot = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 设置代表当前图片位置的小圆点class</span></span><br><span class="line">  <span class="keyword">var</span> dots = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = dots.length; i &lt; len; i++) &#123;</span><br><span class="line">    dots[i].className = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dots[<span class="keyword">this</span>.index].className = <span class="string">'on'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.changePhoto = <span class="function"><span class="keyword">function</span> (<span class="params">offset</span>) </span>&#123; <span class="comment">// 自动改变图片的函数</span></span><br><span class="line">  <span class="keyword">var</span> left = loopContainer.style.left,</span><br><span class="line">    newleft = left ? <span class="built_in">parseInt</span>(left) + offset : offset - <span class="number">600</span>;  <span class="comment">// 新的位置</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.index = offset &gt; <span class="number">0</span> ? <span class="keyword">this</span>.index - <span class="number">1</span> : <span class="keyword">this</span>.index + <span class="number">1</span>;  <span class="comment">// 判断向左还是向右滑动</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.index &gt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.index = <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// console.log(left);</span></span><br><span class="line">  <span class="comment">// console.log(newleft);</span></span><br><span class="line">  <span class="comment">// console.log('------');</span></span><br><span class="line">  <span class="keyword">this</span>.animate(newleft);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Marquee.prototype.gotoPhoto = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;  <span class="comment">// 跳转到第count个图片的函数</span></span><br><span class="line">  <span class="keyword">var</span> newleft = count * <span class="number">-600</span>;</span><br><span class="line">  <span class="comment">// console.log(newleft);</span></span><br><span class="line">  <span class="keyword">this</span>.index = count - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.animate(newleft);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maq = <span class="keyword">new</span> Marquee();</span><br></pre></td></tr></table></figure></p><h2 id="自动播放图片"><a href="#自动播放图片" class="headerlink" title="自动播放图片"></a>自动播放图片</h2><p>轮播图，顾名思义就是轮流播放图片，所以首先要实现的功能就是自动轮流循环播放图片。 有了之前的类，我们要做的就是当页面加载完毕后开始循环播放：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'arrow-left'</span>)[<span class="number">0</span>],</span><br><span class="line">      nextBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'arrow-right'</span>)[<span class="number">0</span>],</span><br><span class="line">      loopContainer = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'loop-container'</span>)[<span class="number">0</span>],</span><br><span class="line">      btns = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'buttons'</span>)[<span class="number">0</span>],</span><br><span class="line">      wrap = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'wrap'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> stopFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">startInterval</span>(<span class="params"></span>) </span>&#123;  <span class="comment">// 开始循环动画</span></span><br><span class="line">    maq.timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// console.log(stopFlag);</span></span><br><span class="line">      <span class="keyword">if</span> (!stopFlag) &#123;</span><br><span class="line">        maq.changePhoto(<span class="number">-600</span>);</span><br><span class="line">        startInterval();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearTimeout(maq.timer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">4500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  startInterval();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我循环动画没有用setInterval函数，而是用的setTimeout。因为setInterval的机制是每隔一段时间就把事件加入到队列中去，但如果之前的事件还没执行完，就会容易造成队列堵塞。比如说setInterval里的函数执行时间要4秒，如果setInterval的间隔时间少于4秒，则会造成队列里的事件越来越多，而之前的事件却没执行完，这样可能就会使队列里的事件堵塞，最后一次性全部执行，而没有达到预期的间隔效果。</p><p>所以我用setTimeout来代替setInterval，每次要加入新的事件之前都先判断一下<code>stopFlag</code>是否为0。<code>stopFlag</code>的作用就是记录是否要停止动画，为0则不停止，为1则停止。</p><p>这里记住要clearTimeout，目的是把已经在队列里但还没有执行的事件清除，这样可以达到立即停止动画的效果。</p><h2 id="鼠标悬停停止轮播动画，离开后开始动画"><a href="#鼠标悬停停止轮播动画，离开后开始动画" class="headerlink" title="鼠标悬停停止轮播动画，离开后开始动画"></a>鼠标悬停停止轮播动画，离开后开始动画</h2><p>监听mouseover和mouseout事件来达到目的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wrap.addEventListener(<span class="string">'mouseover'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  stopFlag = <span class="number">1</span>;</span><br><span class="line">  clearTimeout(maq.timer);</span><br><span class="line">&#125;);</span><br><span class="line">wrap.addEventListener(<span class="string">'mouseout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  stopFlag = <span class="number">0</span>;</span><br><span class="line">  startInterval();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="左右切换图片"><a href="#左右切换图片" class="headerlink" title="左右切换图片"></a>左右切换图片</h2><p>通过点击左右箭头按钮实现图片之间的滚动切换：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prevBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    maq.changePhoto(<span class="number">600</span>); <span class="comment">// 向左滑</span></span><br><span class="line">&#125;);</span><br><span class="line">nextBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  maq.changePhoto(<span class="number">-600</span>);  <span class="comment">// 向右滑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="点击小圆点跳转到对应图片"><a href="#点击小圆点跳转到对应图片" class="headerlink" title="点击小圆点跳转到对应图片"></a>点击小圆点跳转到对应图片</h2><p>这里我用了事件代理，不用在每个小圆点上绑定click事件，提高dom性能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btns.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="built_in">parseInt</span>(event.target.innerText);</span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    maq.gotoPhoto(count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="离开当前页面动画停止"><a href="#离开当前页面动画停止" class="headerlink" title="离开当前页面动画停止"></a>离开当前页面动画停止</h2><p>这里我开始没有想到，后来是当我每次切换到别的页面后再回到当前页面，发现动画效果出现问题了。经过一番debug才发现是因为chrome浏览器设置了离开当前页面后setInterval继续执行，如果setInterval的间隔时间小于100ms，则按100ms来执行，于是回来时动画的时间就发生错误了。</p><p>所以我们需要设置离开页面时动画停止，这样也节省了不少性能。这里利用的是<code>onvisibilitychange</code>事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 离开当前页面后动画停止</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    stopFlag = <span class="number">1</span>;</span><br><span class="line">    clearTimeout(maq.timer);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stopFlag = <span class="number">0</span>;</span><br><span class="line">    startInterval();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里可以直接调用<code>document.hidden</code>API判断当前页面是否被隐藏，如果document.hidden为true则代表已经切换到别的页面，于是设置<code>stopFlag</code>为1，使动画停止。也可以用<code>document.visibilityState</code>,如果不为’visible’，则代表离开了当前页面。</p><p>这里其实可以不用setTimeout、setInterval来实现动画，而是用<code>requestAnimationFrame</code>，后者的优点是自动以浏览器支持的最小刷新间隔来实现重绘，使性能得到最大化提升，而且实现了离开页面重绘停止，大大节省性能。这里我就没有实现了，要想了解requestAnimationFrame，可参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">资料</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上述方法，最后实现了一个比较完善的轮播图，全部的动画效果都是用JS来实现的。其实要想实现自动轮播，也可以用CSS3的animation来实现，而且实现起来更快，这里我就不阐述了。</p><p>最后贴出实现的<a href="https://codepen.io/flyrk/full/brxQBm/">demo</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常可以在网页上看到轮播图的效果，这是一个很常见的应用，但是，要想比较完美地实现这个功能，还是需要花点时间的。&lt;br&gt;
    
    </summary>
    
      <category term="实用技巧" scheme="https://flyrk.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
      <category term="Animation" scheme="https://flyrk.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现回到顶部的效果</title>
    <link href="https://flyrk.github.io/2017/08/22/scroll-to-top-btn/"/>
    <id>https://flyrk.github.io/2017/08/22/scroll-to-top-btn/</id>
    <published>2017-08-22T06:31:45.000Z</published>
    <updated>2017-08-22T06:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？<br><a id="more"></a></p><h1 id="JS实现滚动"><a href="#JS实现滚动" class="headerlink" title="JS实现滚动"></a>JS实现滚动</h1><p>其实很简单，利用下列函数就可以实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * func: 实现页面滚动到顶部的效果，</span></span><br><span class="line"><span class="comment"> * 离顶部越近滚动速度越慢</span></span><br><span class="line"><span class="comment"> * @acceleration: 滑动的加速度</span></span><br><span class="line"><span class="comment"> * @time: 延迟时间 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">goTop</span>(<span class="params">acceleration, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> xScroll = <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="built_in">window</span>.scrollLeft || <span class="number">0</span>,   <span class="comment">// 获取水平滚动坐标</span></span><br><span class="line">      yScroll = <span class="built_in">document</span>.documentElement.scrollTop ||<span class="built_in">document</span>.body.scrollTop || <span class="built_in">window</span>.scrollTop || <span class="number">0</span>,  <span class="comment">// 获取垂直滚动坐标</span></span><br><span class="line">      speed = <span class="number">1</span> + acceleration; <span class="comment">// 滚动速度</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="built_in">Math</span>.floor(xScroll / speed), <span class="built_in">Math</span>.floor(yScroll / speed)); <span class="comment">// 屏幕滚动到某个坐标，因为speed大于1，所以x、y轴的坐标越来越小</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (xScroll &gt; <span class="number">0</span> || yScroll &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果没有滚动到顶部就设置延迟time后继续滚动</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          goTop(acceleration, time);</span><br><span class="line">      &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <em>返回顶部</em> 的按钮上绑定<code>onClick=&quot;goTop();&quot;</code>就可以实现返回顶部操作。</p><p>这里用到了<code>xScroll = document.documentElement.scrollLeft || document.body.scrollLeft || window.scrollLeft || 0;</code>，其实这三个值的效果都差不多，都代表滚动条水平移动的像素，只是浏览器兼容性可能有所不同，所以这样写兼容性更好。</p><p>然后就是<code>window.scrollTo(x, y)</code>方法。该方法使当前窗口滚动到指定的x、y像素坐标。之所以除以speed，这样就以一定的速度慢慢减小，达到缓慢的动画效果。</p><p>之后判断如果滚动条距离顶部还有一段距离的话，就继续循环调用该函数，并设置一定的延迟时间，以达到平滑滚动的动画效果。这里的<code>time</code>值要设置的比较小，超过100就显得比较不自然了。</p><h1 id="按钮的样式设置"><a href="#按钮的样式设置" class="headerlink" title="按钮的样式设置"></a>按钮的样式设置</h1><p>滚动特效实现了，但一般我们只有当页面发生滚动并且滚动到一定距离时才想要回到顶部，我们希望回到顶部的按钮在一定情况下才出现，于是我们需要设置按钮何时出现。通过在<code>scroll</code>事件上绑定函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'scroll2Top-btn'</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123; <span class="comment">// 这里用了ES6语法</span></span><br><span class="line">    <span class="keyword">let</span> contentTop = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">window</span>.innerHeight, <span class="comment">// 获取当前可视窗口的高度</span></span><br><span class="line">      scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;  <span class="comment">// 获取垂直滚动条距离页面顶部的距离</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (contentTop &lt; scrollTop) &#123; <span class="comment">// 如果可视窗口的高度小于垂直滚动的距离，说明已经向下滚动超过一个可视窗口的距离，也就是说看不到顶部了，于是就设置按钮可见</span></span><br><span class="line">      scrollBtn.style.display = <span class="string">"block"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      scrollBtn.style.display = <span class="string">"none"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><hr><p>通过这两个简单的函数，实现了回到顶部的滚动效果，全部用原生JS编写，简单又实用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在浏览网页时通常会看到有返回顶部的按钮。当我们移动鼠标滑轮或者方向键时使页面开始滚动，如果我们滚动了一会想回到页面顶部时，这个时候就需要回到顶部按钮，那这个按钮是怎么实现的呢？&lt;br&gt;
    
    </summary>
    
      <category term="前端必会" scheme="https://flyrk.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从Atom转战VSCode</title>
    <link href="https://flyrk.github.io/2017/08/20/changing-IDE-to-VSCODE/"/>
    <id>https://flyrk.github.io/2017/08/20/changing-IDE-to-VSCODE/</id>
    <published>2017-08-20T13:24:01.000Z</published>
    <updated>2017-08-20T13:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。<br><a id="more"></a></p><p>刚开始用Atom感觉的确很清爽，各种插件用得飞起。然后随着插件的增多，和项目大小的提升，感觉Atom越来越卡，打开一个文件也要很久，那种流畅感没有了。于是有了换编辑器的想法。毕竟“工欲善其事，必先利其器”，写代码还是想要一个用起来顺手的编辑器，写的时候心情都会舒畅点（可能这是个人癖好。。。真正重要的当然还是代码本身）。</p><p>正好最近半年来VSCode越来越火，许多人都开始用它，群里一些大佬也在用VSCode，于是我就下了一个瞧瞧。</p><p>说实话，打开速度比Atom快的真不是一点半点，即使装了一些插件后打开速度也还是很快。而且VSCode由于逐渐发展起来，插件也越来越丰富，一点也不输给Sublime和Atom，常用的插件应有尽有。</p><p>用了VSCode后最大感受就是写代码变得舒服了。VSCode的代码高亮和Git操作真的很赞！鼠标悬停在某个函数或者属性上时还会有相应的说明，Git的操作也比Atom更可视化，一目了然。</p><p>总之，转战VSCode后并没有什么不适应，反而更加得心应手。当然不是说Atom不好了，一切都只是个人习惯问题罢了。但不得不说，VSCode绝对是编程利器。</p><p>最后，推荐一些常用的插件：</p><ul><li>Beautify</li><li>ESLint</li><li>One Dark Pro</li><li>vscode-icons</li><li>IntelliSense for CSS</li><li>Git Lens</li><li>ES7 React/Redux/React-Native/JS snippets</li><li>Path Intellisense</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最开始写前端时，使用的编辑器是SublimeText 3，后来发现Atom好像插件更丰富，而且比Sublime操作起来更容易上手。于是就开始用Atom。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://flyrk.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VSCode" scheme="https://flyrk.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>JS如何设置Cookies</title>
    <link href="https://flyrk.github.io/2017/08/12/how-to-set-cookie-in-js/"/>
    <id>https://flyrk.github.io/2017/08/12/how-to-set-cookie-in-js/</id>
    <published>2017-08-12T15:07:55.000Z</published>
    <updated>2017-08-13T10:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Cookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。<br><a id="more"></a></p><h1 id="调用浏览器的CookiesAPI"><a href="#调用浏览器的CookiesAPI" class="headerlink" title="调用浏览器的CookiesAPI"></a>调用浏览器的CookiesAPI</h1><p>为了使用浏览器的CookieAPI，我们首先要在<a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json">manifest.json</a>里设置Cookie<code>permission</code>，还要设置<code>host-permission</code>确定能获取Cookie的网址。</p><p>接下来就是调用CookieAPI方法。</p><h2 id="Cookie-set"><a href="#Cookie-set" class="headerlink" title="Cookie.set"></a>Cookie.set</h2><p>使用<code>set()</code>方法添加新的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setting = browser.cookies.set(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>是一个对象，其中有可选的几个参数：</p><ul><li><code>url</code>: 请求Cookie的url</li><li><code>name</code>: Cookie的名字</li><li><code>value</code>: Cookie的值</li><li><code>domin</code>: Cookie的作用域名</li><li><code>path</code>: Cookie的路径</li><li><code>secure</code>: Cookie是否安全（true／false）</li><li><code>httpOnly</code>: Cookie是否只能在http上（true／false）</li><li><code>expirationDate</code>: Cookie的截止时间，如果没有设置，则Cookie变为Session Cookie</li><li><code>storeId</code>: 代表Cookie的存储ID</li></ul><h2 id="Cookie-get"><a href="#Cookie-get" class="headerlink" title="Cookie.get"></a>Cookie.get</h2><p>使用<code>get()</code>方法获取已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getting = browser.cookies.get(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p><h2 id="Cookie-getAll"><a href="#Cookie-getAll" class="headerlink" title="Cookie.getAll"></a>Cookie.getAll</h2><p>使用<code>getAll()</code>方法获取Cookie集合中所有匹配details的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getting = browser.cookies.getAll(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>session</code>、<code>storeId</code>。其中<code>session</code>是bool值，代表是否要从cookies中过滤掉session cookie。</p><h2 id="Cookie-remove"><a href="#Cookie-remove" class="headerlink" title="Cookie.remove"></a>Cookie.remove</h2><p>使用<code>remove()</code>方法移除已有的Cookie，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removing = browser.cookies.remove(</span><br><span class="line">  details               <span class="comment">// object</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>details</code>可选的参数有：<code>url</code>、<code>name</code>、<code>storeId</code>。</p><h2 id="Cookie-getAllCookieStores"><a href="#Cookie-getAllCookieStores" class="headerlink" title="Cookie.getAllCookieStores"></a>Cookie.getAllCookieStores</h2><p>使用<code>getAllCookieStores()</code>方法获取所有的Cookie集合，返回的是一个<code>Promise</code>对象。语法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gettingStores = browser.cookies.getAllCookieStores();</span><br></pre></td></tr></table></figure></p><p>返回的<code>Promise</code>对象中包含的数据是包括所有cookiestore对象的数组。举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logStores</span>(<span class="params">cookieStores</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(store <span class="keyword">of</span> cookieStores) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Cookie store: <span class="subst">$&#123;store.id&#125;</span>\n Tab IDs: <span class="subst">$&#123;store.tabIds&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getting = browser.cookies.getAllCookieStores();</span><br><span class="line">getting.then(logStores);</span><br></pre></td></tr></table></figure></p><h2 id="Cookie-onChanged事件"><a href="#Cookie-onChanged事件" class="headerlink" title="Cookie.onChanged事件"></a>Cookie.onChanged事件</h2><p>当Cookie改变时，我们可以为它设置onChanged事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">browser.cookies.onChanged.addListener(callback)</span><br><span class="line">browser.cookies.onChanged.removeListener(listener)</span><br><span class="line">browser.cookies.onChanged.hasListener(listener)</span><br></pre></td></tr></table></figure></p><p>其中 <code>addListener</code>接受一个callback，callback有一个参数<code>changeInfo</code>，<code>changeInfo</code>有三个属性：</p><ul><li>removed：bool值，代表cookie是否移除</li><li>cookie：包含添加或移除信息的cookie对象</li><li>cause：Cookie改变的原因</li></ul><hr><h1 id="使用document-cookie"><a href="#使用document-cookie" class="headerlink" title="使用document.cookie"></a>使用document.cookie</h1><p>Cookie的结构很简单，就是键-值对，一般是以<code>key-value;expiration_date;path;domain;</code>的顺序。</p><p>最简单的设置当前页面Cookie的方法就是直接给<code>document.cookie</code>赋值，例如：<code>document.cookie = &quot;username=Simon, 12 Aug 2017 19:36:00 GMT; expires=Wed, 31 Oct 2017 11:00:00 GMT;&quot;;</code>，这样就设置了Cookie。但每次都这样设置很麻烦，我们可以用函数封装赋值方法。这里借鉴了网上的一些方法：</p><h2 id="setCookie"><a href="#setCookie" class="headerlink" title="setCookie()"></a>setCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cookie = name + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value) + <span class="string">";"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (expires) &#123;</span><br><span class="line">    <span class="comment">// If it's a date</span></span><br><span class="line">    <span class="keyword">if</span>(expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">      <span class="comment">// If it isn't a valid date</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isNaN</span>(expires.getTime()))</span><br><span class="line">       expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + <span class="built_in">parseInt</span>(expires) * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cookie += <span class="string">"expires="</span> + expires.toGMTString() + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    cookie += <span class="string">"path="</span> + path + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">    cookie += <span class="string">"domain="</span> + domain + <span class="string">";"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.cookie = cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>expires</code>可以是<code>Date</code>对象，也可以是代表天数的数字。</p><p>要创建新的Cookie，可以这样：<code>setCookie(&quot;website&quot;, &quot;xmflyrk.com&quot;, new Date(new Date().getTime() + 10000));</code> 或者 <code>setCookie(&quot;author&quot;, &quot;flyrk&quot;, 30);</code></p><h2 id="getCookie"><a href="#getCookie" class="headerlink" title="getCookie()"></a>getCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cok = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>),</span><br><span class="line">        length = cok.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> pairs = cok[i].trim();</span><br><span class="line">    <span class="keyword">if</span> (~pairs.indexOf(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> pairs.substring(pairs.indexOf(name) + name.length + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>getCookie()</code>的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getCookie(<span class="string">'author'</span>); <span class="comment">// "flyrk"</span></span><br><span class="line">getCookie(<span class="string">'Something'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><h2 id="removeCookie"><a href="#removeCookie" class="headerlink" title="removeCookie()"></a>removeCookie()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">name, path, domin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getCookie(name)) &#123;</span><br><span class="line">    setCookie(name, <span class="string">""</span>, <span class="number">-1</span>, path, domin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除某个Cookie我们就可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">removeCookie(<span class="string">"author"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(getCookie(<span class="string">"author"</span>)); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有了这些API和自己封装的函数，我们就能对Cookie进行操作，方便地设置Cookie数据。</p><blockquote><p>参考资料：<br><a href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/cookies">cookies</a><br><a href="https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/">How to deal with cookie</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cookie一般是用来在浏览器端存储用户的一些登录、浏览数据，方便缓存。要设置Cookie，可以有两种方法。&lt;br&gt;
    
    </summary>
    
      <category term="Web相关" scheme="https://flyrk.github.io/categories/Web%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Cookies" scheme="https://flyrk.github.io/tags/Cookies/"/>
    
  </entry>
  
  <entry>
    <title>JS中&quot;类&quot;的构造与继承</title>
    <link href="https://flyrk.github.io/2017/08/10/javascript-class-constructor/"/>
    <id>https://flyrk.github.io/2017/08/10/javascript-class-constructor/</id>
    <published>2017-08-10T13:46:33.000Z</published>
    <updated>2017-08-18T04:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Null</code>、<code>undefined</code>、<code>Symbol</code>。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。<br><a id="more"></a></p><p>我们知道，JS里没有类似于C++、Java一样的<code>class</code>类，于是也就没有私有、公有之说。但这并不代表我们不能模拟一个类，因为类的思想在面向对象编程里是很重要的一点，对于对象的继承与方法的引用和代码的重构等等都有极大好处。所以很多人就在JS里模拟类的用法，ES6甚至官方定义了一个<code>class</code>语法，但这也不是真正的类，只是<code>class</code>的语法糖。</p><p>说了这么多，JS里到底怎么实现类呢？利用函数的特性：所有的函数默认都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，也就是原型。</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>什么是构造函数？我们知道<code>function</code>也是对象的一种，而当我们想要声明一个构造函数，可以使用下列形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myConstructor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Simon'</span>;</span><br><span class="line">  <span class="keyword">var</span> car = <span class="string">'BMW'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(car);</span><br><span class="line">  &#125;</span><br><span class="line">  getCar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> myConstructor();</span><br></pre></td></tr></table></figure></p><p>使用上述方法我们就声明了一个构造函数<code>myConstructor</code>，但其实构造函数也是普通的对象，它和java里类的构造函数完全不一样。当我们使用<code>new</code>创建一个对象，实际上是把myObj的[[Prototype]]链接关联到myConstructor.prototype指向的对象。</p><p>我们知道，真正的面向类的语言中，类可以被复制或者实例化很多次，每创建一个实例相当于把类的方法属性复制到新实例中。但javascript没有类似的复制机制，要想让新对象与构造的“类”对象有关系，就必须把两个对象的prototype关联起来。</p><p>实际上并不存在所谓的“构造函数”，我们只是对函数的“构造调用”。</p><p>当使用new来进行构造函数调用时，会执行以下四个步骤：</p><ol><li>创建一个全新的对象</li><li>新对象会执行[[Prototype]]链接到constructor对象的prototype</li><li>新对象会绑定到函数调用的this</li><li>如果构造函数没有返回其他对象，那么new的函数调用会返回这个新对象</li></ol><p>这样一来，我们就把新对象与构造函数对象关联起来了。所以说函数不是构造函数，只是当且仅当使用new时，函数调用会变成“构造函数调用”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">a.constructor === Foo; <span class="comment">// true</span></span><br><span class="line">Foo.prototype.constructor === Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>当我们创建了Foo函数，Foo.prototype默认有一个公有且不可枚举的属性constructor，这个属性引用的是对象关联的函数（也就是Foo）。而调用a.constructor，实际上只是通过[[Prototype]]委托给了Foo.prototype，所以指向了Foo。</p><p>如果我们创建了新的原型对象，那么新对象并不会自动获得constructor属性，比如说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype = &#123; <span class="comment">/*....*/</span> &#125;; <span class="comment">// 创建了新的原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo; <span class="comment">// false</span></span><br><span class="line">a.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但问题来了，运行以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myObj.name; <span class="comment">// "Simon"</span></span><br><span class="line">myObj.car; <span class="comment">// undefined</span></span><br><span class="line">myObj.getCar(); <span class="comment">// Uncaught TypeError: myObj.getCar is not a function</span></span><br></pre></td></tr></table></figure></p><p>为什么会这样呢？原因就是构造函数有作用域。<code>this.name = &#39;Simon&#39;</code>相当于给构造函数这个对象的<code>name</code>属性赋值<code>&quot;Simon&quot;</code>，这里的<code>this</code>指代构造函数对象原型。而在构造函数里使用<code>var</code>、<code>function</code>创建的变量和函数都相当于 <em>局部变量</em>，也就是“私有方法”，因为作用域的问题，这些变量和属性在构造函数之外是不能访问的，“私有方法”中的函数可以访问其他的私有变量，构造函数的实例却不能访问这些方法。</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>那么，如果我们想要实例能继承构造函数的属性或者方法怎么办呢？JS使用的机制为 <em>原型继承</em>，请看以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myConstructor.prototype.car = <span class="string">"Farrari"</span>;</span><br><span class="line">myConstructor.prototype.getCar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.car);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObj.car; <span class="comment">// "Farrari"</span></span><br><span class="line">myObj.getCar(); <span class="comment">// "Farrari"</span></span><br></pre></td></tr></table></figure></p><p>一旦我们在构造函数的原型上添加了属性car，当新对象myObj调用car属性时，它本身没有这个属性，于是就通过委托，在原型链上找，最后在myConsrtuctor.prototype上找到。</p><p>但使用原型继承来实现子类继承父类更好的方法是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo,prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name, type</span>) </span>&#123;</span><br><span class="line">  Foo.call(<span class="keyword">this</span>, name); <span class="comment">// 相当于ES6的super(name);</span></span><br><span class="line">  <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype); <span class="comment">// 相当于ES6的extends</span></span><br><span class="line">Bar.prototype.constructor = Bar; <span class="comment">// 这里需要修复consructor</span></span><br><span class="line"></span><br><span class="line">Bar.prototype.getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.type);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">'a'</span>, <span class="string">'obj a'</span>);</span><br><span class="line">a.getName(); <span class="comment">// 'a'</span></span><br><span class="line">a.getType(); <span class="comment">// 'obj a'</span></span><br></pre></td></tr></table></figure></p><p>这里用到的核心语句就是<code>Bar.prototype = Object.create(Foo.prototype);</code>，调用Object.create(obj)会凭空创建一个新对象并把新对象的[[Prototype]]关联到obj上。</p><p>我们来看看Object.create()的polyfill:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">proto, propsObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(proto === <span class="literal">null</span> || <span class="keyword">typeof</span> proto === <span class="string">'object'</span> || <span class="keyword">typeof</span> proto === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Arguments must be object, or Null'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    temp.__proto__ = proto;</span><br><span class="line">    <span class="keyword">if</span> (propsObj) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(temp, propsObj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有的人可能会说，为什么不能直接<code>Bar.prototype = Foo.prototype;</code>呢？这样并不会创建一个关联到Foo.prototype的新对象，只是让Bar.prototype引用Foo.prototype对象，我们执行<code>Bar.prototype.getType = ....</code>也会在Foo.prototype上修改，跟预料的结果不一样。那这样根本不需要Bar，还不如直接在Foo上修改就好了。</p><p>而之前介绍的<code>Bar.prototype = new Foo()</code>虽然也能实现原型继承，但它会有一些副作用。比如Foo如果有（写日志、修改状态、注册到其他对象、给this添加属性等等）的行为，就会影响到Bar的子类，造成无法预料的结果。</p><p>所以，要创建一个关联的“子类”对象，我们必须使用Object.create()，但这样有一个缺点是要创建一个新对象而把旧对象抛弃。</p><p>好在ES6添加了<code>Object.setPrototypeOf(...)</code>方法，可以修改关联。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bar.prototype = <span class="built_in">Object</span>.create(Foo.prototype); <span class="comment">// ES6之前需要抛弃默认对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype, Foo.prototype); <span class="comment">// ES6可以直接修改Bar.prototype对象</span></span><br></pre></td></tr></table></figure></p><h1 id="检查“类”的关系"><a href="#检查“类”的关系" class="headerlink" title="检查“类”的关系"></a>检查“类”的关系</h1><p>考虑以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.blah = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p>我们如果想要判断a的原型是否与Foo关联起来了，我们可以有以下几种方法：</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>但这样有个缺点是只能处理对象和函数之间的关系。如果我们想判断两个对象之间是否通过[[Prototype]]关联。可以用下列方法：</p><h2 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a>isPrototypeOf()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo.prototype.isPrototypeOf(a); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要判断两个对象之间的关系，更直接：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.isPrototypeOf(c); <span class="comment">// 判断b是否出现在c的原型链中</span></span><br></pre></td></tr></table></figure></p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>我们可以直接用非标准的<code>__proto__</code>属性，<code>__proto__</code>实际上存在于内置的Object.prototype中，且不可枚举。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === Foo.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>要想创建类似于“类”的对象，可以使用构造函数调用，给构造函数添加公有方法，在构造函数的<code>prototype</code>上添加属性。新对象想要继承构造函数，使用Javascript的原型继承机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有句话说“JavaScript里一切都是对象”，这句话当然是错的，因为它还有六种基本类型：&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Number&lt;/code&gt;、&lt;code&gt;Boolean&lt;/code&gt;、&lt;code&gt;Null&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;、&lt;code&gt;Symbol&lt;/code&gt;。对象才有属性和方法，当我们想要操作基本类型，比如获取length、截取长度等方法，JS就会自动把基本类型转换为对应的对象实例，我们就在对象实例上操作。&lt;br&gt;
    
    </summary>
    
      <category term="前端必会" scheme="https://flyrk.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
      <category term="Object" scheme="https://flyrk.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>这些天的感想</title>
    <link href="https://flyrk.github.io/2017/08/09/thought-of-today/"/>
    <id>https://flyrk.github.io/2017/08/09/thought-of-today/</id>
    <published>2017-08-09T14:29:55.000Z</published>
    <updated>2017-08-09T15:13:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。<br><a id="more"></a></p><p>暑假以来，一直在找实习，然而很多公司基本人都招满了，而投的几个也了无音讯，说实话，我感受到了强烈的失落感。<br>我到底适不适合做前端？为什么没有公司要我呢？我应该怎么做？我应该坚持下去吗？</p><p>每天我都陷入深深地自省中，我学前端真的对吗？我是真心想做前端开发吗？</p><p>经过这段时间的思考，我还是决定了，继续走下去。既然选择了前端这条路，就不该放弃，即使没有公司实习，没关系，自己在家自学，写项目，看书，反正不让自己闲着。前端基础不好，补！静下心来看书、静下心来写代码！边学边准备校招。</p><p>我知道，自己严格来说前端只学了不到一年的时间，比不上别人已经学了好几年，进工作室、公司实习过的大佬，但我相信，现在仍然为时不晚。我只不过是比别人起步晚，那就比别人花的时间长呗！我以前都只是听说勤能补拙，这次，我要自己实践下去。</p><p>为什么选择前端？</p><p>一开始是在知乎看到前端的介绍，那个时候第一次听到前端这个名词，之前完全不知道它是干什么的。后来慢慢去了解，发现前端看似很简单，用HTML、CSS、JavaScript稍加组合就能写出一个网页，不像后台开发那么没头绪、可视化不强，前端是即写即见的。后来一步步去W3SCHOOL上跟着教程走，上网找各种资料，图书馆借书看，发现前端并没有想象中的那么简单，要学的东西多而杂，光学好HTML、CSS还不行，还得会响应式开发，会用<code>Sass</code>、<code>Less</code>预处理，会<code>CSS3</code>动画…光会原生JS也不行，写项目时效率太低，得学会使用各种库，比如伟大的<code>JQuery</code>、<code>underscore</code>等等，后来发现还得了解工程化，因为前端的逻辑越来越复杂，所包含的内容越来越多，需要框架的帮助和自动化工具来提高开发效率，比如三大框架：<code>React</code>、<code>Vue</code>、<code>Angular</code>，还有打包工具<code>Webpack</code>、<code>gulp</code>、<code>grunt</code>等等。这里面每一个知识都值得去深挖，去研究。这还不够，你不能光会前端写页面，你还得会移动端开发，随着页面的复杂度提高，资源的增多，你还得会性能优化，缓存处理，HTTP协议相关。因为前端既要和用户进行交互，还要与后端进行交接，所以服务器方面的知识也得略知一二，比如<code>NodeJS</code>。</p><p>当我刚了解这些我发现我头都大了一圈，前端要学的东西太多了吧！不光这样，每天关注技术博客、新闻、知乎等论坛时还会发现层出不穷的新名词，都是别人新写的库，宣传得多么多么厉害。让我这个前端小白看得眼花缭乱，不知道该不该去学。</p><p>三四月份的时候真是我陷入迷茫期的时候，感觉自己什么都想学，但又觉得学不过来，不知道先学哪一个。经历了春招实习生的挫败后，我终于发现了，我学的太浮躁了。</p><p>因为急于想要找到实习，希望学点新东西，新框架来显示自己的能力，但却忽略了最重要的一点：基础。基础不牢，学什么都白谈。基础没学好，去学那些花里胡哨的库却不能理解其中的源码、思想，只是机械地使用工具来码代码，那和最基本的劳动力有什么区别？别人凭什么招你呢？你的活完全可以找别人来替代，为什么要选你呢？</p><p>于是，我开始重新翻阅书籍，静下心来去看，看到有意思的地方、值得记忆的地方就写下来，以后随时翻阅。但同时光看书也不行，实践能力差别人一大截，于是我又使用React+Node写了一个<a href="https://github.com/flyrk/myblog">博客系统</a>，每天持续完善中。就这样，暑假过去了一个月。</p><p>这一个月来，我虽然没有找到实习，但我找到了自己的学习方向。我知道我要先打好基础，同时动手能力也不能落下。</p><p>我不知道即将到来的秋招会是怎样，但我唯有坚持下去，坚守自己的初心，不让自己后悔。</p><hr><p>说了这么多关于前端的思考和自己的打算，再说说前端之外的吧。最近身体不好，去医院做了检查，索性无大碍。但是今天又有点感冒头晕，让我很是烦躁。不管怎样，身体一定要养好，有了好身体才有好力气干活。</p><p>虽说自己没有出去找事做，但每天学习学习，码码代码，也还是过的挺充实的。加油吧，少年！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近这段时间昏昏碌碌，每天都处于焦虑之中，今天终于有心情坐下来好好写点东西了。&lt;br&gt;
    
    </summary>
    
      <category term="生活杂谈" scheme="https://flyrk.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="thoughts" scheme="https://flyrk.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>获取浏览器窗口大小</title>
    <link href="https://flyrk.github.io/2017/08/08/get-browser-size/"/>
    <id>https://flyrk.github.io/2017/08/08/get-browser-size/</id>
    <published>2017-08-08T12:57:31.000Z</published>
    <updated>2017-08-08T14:01:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？</p><p>先来看这样一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBrowserSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> de = <span class="built_in">document</span>.documentElement;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">'width'</span>: (</span><br><span class="line">      <span class="built_in">window</span>.innerWidth</span><br><span class="line">      || de &amp;&amp; de.clientWidth</span><br><span class="line">      || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'height'</span>: (</span><br><span class="line">      <span class="built_in">window</span>.innerHeight</span><br><span class="line">      || de &amp;&amp; de.clientHeight</span><br><span class="line">      || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。<br><a id="more"></a></p><ul><li><code>documentElement</code>:<code>document.documentElement</code>获取的是页面中的<code>&lt;html&gt;</code>元素，也就相当于整个页面。</li><li><code>innerWidth&amp;&amp;innerHeight</code>: innerWidth获取的是可视区域的宽度，但包括垂直滚动条；innerHeight则只包括可视区域高度，不包括功能框之类的。相比较之下，outerWidth和outerHeight则包含整个窗口的高度，包括功能框、滚动条之类的。</li><li><code>document.body</code>:获取页面中body元素。</li><li><code>Element.clientWidth</code>:获取元素的可视宽度（高度），它包括<code>padding</code>但不包括滚动条、<code>border</code>和<code>margin</code>。</li></ul><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>话不多说，直接上图：<br><img src="http://ou5mz529o.bkt.clouddn.com/browser-size-test.png" alt="browser-size-test"></p><p>我们可以得出结论：</p><ul><li><code>window.innerWidth</code>和<code>window.outerWidth</code>基本是一样的，因为innerWidth也包括了滚动条，但如果侧面有功能栏的话，innerWidth就会比outerWidth小；<code>window.innerHeight</code>和<code>window.outerHeight</code>差别较大，因为下面有调试栏。</li><li><code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>获取的就是页面的可视窗口宽高，不包括滚动条和功能栏之类的。</li><li><code>document.body.clientWidth</code>和<code>document.body.clientHeight</code>获取的是<code>body</code>元素的宽高，不包括滚动条，但因为<code>body</code>的内容高度有639px，所以比<code>document.documentElement.clientHeight</code>要高。</li></ul><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><code>document.documentElement</code>几乎每个浏览器都兼容；<code>window.outerWidth</code>和<code>window.innerWidth</code>IE8及以下都不支持；<code>document.body</code>和<code>clientWidth</code>IE6之前不支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>获取浏览器当前窗口大小，一般用<code>window.innerWidth</code>和<code>window.innerHeight</code>就好了，但如果不兼容，则次之用<code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>，再不行就只能用<code>document.body</code>获取了。</p><p>前面提到的<code>getBrowserSize()</code>方法就是使用了这种理念。</p><blockquote><p>参考资料:<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/documentElement">documentElement</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth">innerWidth</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/outerWidth">outerWidth</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/body">document.body</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth">clientWidth</a><br>《JavaScriptDOM高级程序设计》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会遇到这样的需求：获取当前浏览器窗口大小，然后根据其大小来对页面进行样式设计。那么怎么去获取呢？&lt;/p&gt;
&lt;p&gt;先来看这样一段代码：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getBrowserSize&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; de = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.documentElement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;width&#39;&lt;/span&gt;: (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.innerWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || de &amp;amp;&amp;amp; de.clientWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.body.clientWidth&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;height&#39;&lt;/span&gt;: (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.innerHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || de &amp;amp;&amp;amp; de.clientHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      || &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.body.clientHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码就是用来获取浏览器窗口大小的，我们来看看其中用到的一些知识点。&lt;br&gt;
    
    </summary>
    
      <category term="前端必会" scheme="https://flyrk.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>详解JavaScript对象</title>
    <link href="https://flyrk.github.io/2017/08/05/javascript-object/"/>
    <id>https://flyrk.github.io/2017/08/05/javascript-object/</id>
    <published>2017-08-05T06:32:12.000Z</published>
    <updated>2017-08-10T15:18:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。</p><a id="more"></a><h1 id="对象的复制"><a href="#对象的复制" class="headerlink" title="对象的复制"></a>对象的复制</h1><h2 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h2><p>对于 可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象来说，有一种巧妙的复制方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( someObj ));</span><br></pre></td></tr></table></figure></p><p>这种方法的好处是实现了 <strong>深复制</strong>，但必须要求原对象可以被解析成JSON字符串。</p><h2 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a><code>Object.assign()</code>方法</h2><p>ES6定义了<code>Object.assign()</code>方法实现 <strong>浅复制</strong>。该方法第一个参数是目标对象，之后可以跟若干个源对象。它会遍历源对象的所有可枚举的自有键并把它们复制到目标对象，比如说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = &#123;</span><br><span class="line">  a: <span class="number">12</span></span><br><span class="line">  b: anotherObj,</span><br><span class="line">  c: anotherArray,</span><br><span class="line">  d: anotherFunction</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.assign( &#123;&#125;, myObject);</span><br><span class="line">newObj.a; <span class="comment">// 12</span></span><br><span class="line">newObj.b === anotherObj; <span class="comment">// true</span></span><br><span class="line">newObj.c === anotherArray; <span class="comment">// true</span></span><br><span class="line">newObj.d === anotherFunction; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但要注意的是，浅复制只是简单的使用<code>=</code>操作符赋值，对于引用类型值来说，指向的是同一个对象。也就是说，<code>newObj.b === myObject.b</code>。</p><h1 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h1><p>ES5开始，所有的属性都有属性描述符。通过<code>Object.getOwnPropertyDesciptor(obj, prop)</code>可以获取对象的某个属性的属性描述符。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(myObj, <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//Object &#123;</span></span><br><span class="line"><span class="comment">//  value: 12,</span></span><br><span class="line"><span class="comment">//  writable: true,</span></span><br><span class="line"><span class="comment">//  enumerable: true,</span></span><br><span class="line"><span class="comment">//  configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></p><p>一般默认值<code>writable</code>、<code>enumerable</code>、<code>configurable</code>都为<code>true</code>，我们也可以用<code>Object.defineProperty()</code>来添加一个新属性或者修改一个已有属性（如果它是<code>configurable</code>）。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><h2 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们修改<code>writable</code>为false，则该属性不可写了。</p><h2 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>, <span class="comment">// 不可配置</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.a = <span class="number">5</span>;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">delete</span> myObject.a;</span><br><span class="line">myObject.a; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"a"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>一旦我们修改<code>configurable</code>为false，就无法撤销，并且不能重新配置属性，也无法删除该属性。</p><h2 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h2><p>这个属性描述符代表属性是否会出现在对象的属性枚举中，比如<code>for ..in</code>循环。如果设置<code>enumerable: false</code>，则该属性不会出现在枚举中。</p><h1 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h1><p>JavaScript不像其他语言，它是动态的，也就是可变的。但如果我们想属性或者对象是不可改变的，该怎么实现呢？</p><h2 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h2><p>结合<code>writable: false</code>和<code>configurable: false</code>可以创建一个常量属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"CONST_VARIABLE"</span>, &#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h2><p>如果想保留对象已有的属性并禁止向对象添加新的属性，则可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">12</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions( myObject );</span><br><span class="line"></span><br><span class="line">myObject.b = <span class="number">13</span>;</span><br><span class="line">myObject.b; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h2 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h2><p>使用<code>Object.seal(...)</code>会创建一个“密封”对象，相当于在对象上调用<code>Object.preventExtensions()</code>并且设置所有属性为<code>configurable: false</code>。</p><p>所以，密封之后的对象只能修改已有属性的值，而不能添加新属性，也不能重新配置或删除已有属性。</p><h2 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h2><p>使用<code>Object.freeze(...)</code>会创建一个冻结对象，相当于在对象上调用<code>Object.seal()</code>并且设置所有属性为<code>writable: false</code>。</p><p>这个方法完全使对象不可变，会禁止对于对象本身及其任意直接属性的修改。</p><blockquote><p>需要注意的是，之前所有的方法创建的都是浅不可变，也就是说，它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的。</p></blockquote><h1 id="Getter和Setter"><a href="#Getter和Setter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h1><p>当访问某个对象属性时，实际上实现了<code>[[Get]]</code>操作，对象默认的内置<code>[[Get]]</code>操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，则会遍历原型链，如果还是没找到，则返回<code>undefined</code>。</p><p>当设置某个对象属性的值，则有<code>[[Put]]</code>操作。<code>[[Put]]</code>会检查以下内容：</p><ol><li>属性是否存在setter，存在则调用setter</li><li>属性的<code>writable</code>是否是<code>false</code>，是的话则赋值失败</li><li>如果都不是，则对属性进行赋值</li></ol><p>我们可以给对象一个属性定义getter、setter，当访问或赋值对象的属性时，会忽略属性的<code>value</code>和<code>writable</code>特性，而关注<code>get</code>和<code>set</code>特性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  get a() &#123; <span class="comment">// 给属性a定义一个getter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span>; &#125;, <span class="comment">// 给属性b设置一个getter</span></span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">myObject.a; <span class="comment">// 11</span></span><br><span class="line">myObject.b; <span class="comment">// 22</span></span><br><span class="line">myObject.a = <span class="number">3</span>;</span><br><span class="line">myObject.a; <span class="comment">// 11</span></span><br></pre></td></tr></table></figure></p><p>当访问属性时会自动调用<code>get</code>函数，其返回值会被当作属性访问的返回值；注意的是，由于我们没有设置<code>set</code>，所以赋值操作被忽略了。而由于我们定义的<code>get</code>始终返回2，即使设置了<code>set</code>也没有意义。</p><p>我们可以这样设置<code>getter</code>和<code>setter</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  get a() &#123; <span class="comment">// 给属性a定义一个getter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._a;</span><br><span class="line">  &#125;,</span><br><span class="line">  set a(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>._a = val * <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span>;</span><br><span class="line">myObject.a; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></p><h1 id="属性的存在性"><a href="#属性的存在性" class="headerlink" title="属性的存在性"></a>属性的存在性</h1><p>当我们访问<code>object.a</code>返回的是<code>undefined</code>，可能是属性中本来存储的就是<code>undefined</code>，也可能是属性不存在，那么怎么判断属性是否存在呢？</p><p>我们可以用<code>in</code>或者<code>Object.hasOwnProperty()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">(<span class="string">"a"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"a"</span>); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"b"</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>这里要注意的是，<code>in</code>会检查属性是否在对象及其原型链中，而<code>hasOwnProperty</code>只会检查属性是否在对象中，不会检查原型链。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>要检查某个属性是否可枚举，通常有两种方法：<br>第一种方法，使用<code>for...in</code>循环：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObject.b; <span class="comment">// 2</span></span><br><span class="line">(<span class="string">"b"</span> <span class="keyword">in</span> myObject); <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">"b"</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> myObject) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;k&#125;</span>:<span class="subst">$&#123;myObject[k]&#125;</span>`</span>); <span class="comment">// a:1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myObject, <span class="string">"b"</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myObject.propertyIsEnumerable(<span class="string">"a"</span>); <span class="comment">// true</span></span><br><span class="line">myObject.propertyIsEnumerable(<span class="string">"b"</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(myObject); <span class="comment">// ["a"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(myObject); <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure></p><p><code>propertyIsEnumerable()</code>可以判断给定的属性名是否直接存在于对象中且<code>enumerable: true</code>；<code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code>会返回一个数组，包含所有属性，无论它们是否可枚举。</p><p>要注意的是，<code>Object.keys(..)</code>和<code>hasOwnProperty()</code>和<code>Object.getOwnPropertyNames(..)</code>不会查找原型链，而<code>in</code>和<code>for...in</code>会查找原型链。</p><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>对于数组来说，最常用的遍历就是<code>for</code>循环。然而javascript内置了一些数组的迭代器，包括<code>forEach(..)</code>、<code>every(..)</code>、<code>some(..)</code>、<code>map(..)</code>。它们都接受一个回调函数并把它应用到每个元素上，区别就是它们对回调函数返回值的处理方式不同。</p><p><code>forEach(..)</code>遍历所有元素并忽略返回值；<code>every(..)</code>会一直运行直到返回值为<code>false</code>；<code>some(..)</code>会一直运行直到返回值为<code>true</code>；<code>map(..)</code>遍历所有元素并且用返回值代替当前元素。</p><p>ES6还新增了遍历数组的<code>for...of</code>循环语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p><code>for..of</code>循环首先会向被访问对象请求一个 <strong>迭代器</strong> 对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。由于数组有内置的<code>@@iterator</code>，所以<code>for..of</code>可以直接应用在数组上，如果想让对象也使用<code>for..of</code>循环，则需要自定义<code>@@iterator</code>，这里就不多展开了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JavaScript对象是引用类型，我们可以给对象添加属性并修改属性描述符来控制属性的特征，还可以用<code>get</code>和<code>set</code>来修改属性的访问和赋值操作，对象的属性还可以枚举和遍历。</p><blockquote><p>参考资料：<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch3.md">You-Dont-Know-JS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中的对象是一种引用类型，也就是说一般新建一个对象给它赋给一个值a，则a只是指向该对象地址的一个“指针”，对象的存储方式是堆。&lt;/p&gt;
    
    </summary>
    
      <category term="前端必会" scheme="https://flyrk.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
      <category term="Object" scheme="https://flyrk.github.io/tags/Object/"/>
    
  </entry>
  
  <entry>
    <title>React中如何更新state</title>
    <link href="https://flyrk.github.io/2017/08/04/react-setState-update/"/>
    <id>https://flyrk.github.io/2017/08/04/react-setState-update/</id>
    <published>2017-08-04T11:12:19.000Z</published>
    <updated>2017-08-08T13:02:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，React中最重要的概念就是<code>state</code>和<code>props</code>，我们在写每一个组件时，都可以为该组件创建一个<code>state</code>，用以保存当前组件的数据。那么如何去更新<code>state</code>就是一个重要的问题了。<br><a id="more"></a></p><h1 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h1><p>首先我们来看一个<code>React Component</code>初始化的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'flyrk'</span>,</span><br><span class="line">      sex: <span class="string">'male'</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而当我们要更新<code>state</code>，不能直接赋值修改<code>this.state</code>，而是应该使用<code>this.setState()</code>方法。</p><p>但在最近写项目的过程中，我遇到了一个问题，我想实现从服务器异步获取数据，然后在React对收到的数据进行更新<code>state</code>，更新的<code>state</code>再进行处理，同步显示在某个<code>div</code>中。当我这样写的时候，发现视图层迟迟没有更新：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">''</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.getName().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;  <span class="comment">// 从服务器获取数据</span></span><br><span class="line">      <span class="keyword">const</span> name = res.data.name;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; name &#125;);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>后来上网查阅官方文档，才发现React的<code>setState()</code>可能是异步的。也就是说，当我们用<code>this.setState()</code>更新<code>state</code>时，<code>state</code>可能不会立即更新，React会将多个<code>setState()</code>合并在一起最后调用来提高性能，如果我们想立即使用更新后的<code>state</code>，有两种方法：</p><ul><li><p><code>setState()</code>接受函数参数，我们可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  name: prevState.name + props.name</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>这样我们就可以获取之前的<code>state</code>。</p></li><li><p>还有一种方法，<code>setState()</code>第二个参数接受一个<code>callback</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123; name &#125;, callback);</span><br></pre></td></tr></table></figure><p>在<code>callback</code>里我们可以对修改后的<code>state</code>进行操作。</p></li></ul><p>这两种方法，都可以保证操作的<code>state</code>是最新值，并且能在<code>render()</code>里展现出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，React中最重要的概念就是&lt;code&gt;state&lt;/code&gt;和&lt;code&gt;props&lt;/code&gt;，我们在写每一个组件时，都可以为该组件创建一个&lt;code&gt;state&lt;/code&gt;，用以保存当前组件的数据。那么如何去更新&lt;code&gt;state&lt;/code&gt;就是一个重要的问题了。&lt;br&gt;
    
    </summary>
    
      <category term="框架之用" scheme="https://flyrk.github.io/categories/%E6%A1%86%E6%9E%B6%E4%B9%8B%E7%94%A8/"/>
    
    
      <category term="React" scheme="https://flyrk.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>javascript类型转换</title>
    <link href="https://flyrk.github.io/2017/08/02/javascript-value-coercions/"/>
    <id>https://flyrk.github.io/2017/08/02/javascript-value-coercions/</id>
    <published>2017-08-02T07:28:20.000Z</published>
    <updated>2017-08-08T13:02:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。<br><a id="more"></a></p><h1 id="JavaScript类型"><a href="#JavaScript类型" class="headerlink" title="JavaScript类型"></a>JavaScript类型</h1><p>在JS中，有6种基本类型和一种引用类型，分别是：</p><ul><li>基本类型：<ul><li>null</li><li>undefined</li><li>boolean</li><li>number</li><li>string</li><li>symbol(ES6新增)</li></ul></li><li>引用类型：object</li></ul><p>一般来说，我们可以用<code>typeof</code>来检测某个值的数据类型，比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          === <span class="string">"boolean"</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">24</span>            === <span class="string">"number"</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"24"</span>          === <span class="string">"string"</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">age</span>: <span class="number">24</span> &#125;  === <span class="string">"object"</span>;    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// added in ES6!</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()      === <span class="string">"symbol"</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>但是有一个例外: null,这也是一个bug<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">"object"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>如果想检测某个值是否是null，则可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，function和array其实也是object，但它们有所区别：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* .. */</span> &#125; === <span class="string">"function"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] === <span class="string">"object"</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>如果要检测a是否是数组，可以用<code>instanceof</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">123</span>];</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="类型转换抽象操作"><a href="#类型转换抽象操作" class="headerlink" title="类型转换抽象操作"></a>类型转换抽象操作</h1><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><p>当一个非String类型的值要转换为String，我们可以用ToString操作。</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>对于基本类型来说，它们有自然的转换关系。如：<code>null</code>变成<code>&quot;null&quot;</code>,<code>undefined</code>变成<code>&quot;undefined&quot;</code>,<code>true</code>变成<code>&quot;true&quot;</code>,<code>number</code>自然转换为数字字符串，但如果对于非常大的数，则会转换为指数形式。</p><p>对于<code>object</code>来说，<code>toString()</code>(代表着<code>Object.prototype.toString()</code>)将会返回<code>[[class]]</code>原型，比如说<code>&quot;object Object&quot;</code>;但如果是数组，则重写了<code>toString()</code>方法，会返回一个以逗号分隔数组值的字符串。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.toString(); <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure></p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><p>另一种转换为字符串的方法就是<code>JSON.stringify</code>，对大多数基本类型，它的转换方法和<code>toString</code>是一样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify( <span class="number">42</span> );<span class="comment">// "42"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="string">"42"</span> );<span class="comment">// ""42"" (外面多加一层引号)</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">null</span> );<span class="comment">// "null"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">true</span> );<span class="comment">// "true"</span></span><br></pre></td></tr></table></figure></p><p>但不同的是，<code>JSON.stringify</code>会忽略掉<code>undefined</code>、<code>function</code>和<code>symbol</code>。请看下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify( <span class="literal">undefined</span> );<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; );<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( [<span class="number">1</span>,<span class="literal">undefined</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="number">4</span>] );<span class="comment">// "[1,null,null,4]"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify( &#123; <span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; );<span class="comment">// "&#123;"a":2&#125;"</span></span><br></pre></td></tr></table></figure></p><p>如果<code>JSON.stringify</code>调用了循环引用的<code>object</code>，则会抛出Error。如果<code>JSON.stringify</code>调用的对象有<code>toJSON()</code>方法，则会对<code>toJSON()</code>的返回值再进行stringify。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  b: <span class="number">111</span></span><br><span class="line">&#125;;</span><br><span class="line">a.toJSON = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="keyword">this</span>.b &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify( a ); <span class="comment">// "&#123;"b":111&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line">val: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line"></span><br><span class="line">toJSON: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.val.slice( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.stringify( c ); <span class="comment">// "[2,3]"</span></span><br></pre></td></tr></table></figure></p><h2 id="ToNumber"><a href="#ToNumber" class="headerlink" title="ToNumber"></a>ToNumber</h2><p>转换为number，我们可以用ToNumber操作。</p><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>对于基本类型，转换规则为：<code>true -&gt; 1</code>,<code>false -&gt; 0</code>,<code>undefined -&gt; NaN</code>,<code>null -&gt; 0</code>，字符串如果包含字母则转换为<code>NaN</code>。</p><p>对于将某值转换为基本数据类型，通常会调用<code>ToPrimitive</code>操作，首先看该值有没有<code>valueof()</code>方法，如果没有则调用<code>toString()</code>方法，如果二者都没有，则抛出<code>TypeError</code>。</p><p>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"12"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"12"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">c.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.join( <span class="string">""</span> );<span class="comment">// "12"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>( a );<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>( b );<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>( c );<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>( <span class="string">""</span> );<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>( [] );<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>( [ <span class="string">"abc"</span> ] );<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></p><h2 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h2><p>将一个值转换为Boolean值，我们先看一个false表：</p><ul><li>undefined</li><li>null</li><li>false</li><li>+0, -0, and NaN</li><li>“”</li></ul><p>任何不在这个表上的值都为<code>true</code>。<br>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">0</span> );</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">""</span> );</span><br><span class="line"><span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class="comment">// true</span></span><br><span class="line"><span class="comment">/***************/</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"false"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"''"</span>;</span><br><span class="line"><span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class="comment">// true</span></span><br><span class="line"><span class="comment">/***************/</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h1 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h1><p>之前提到过一些显式转换，但其实还有以下几种：</p><h2 id="字符串与数字的转换"><a href="#字符串与数字的转换" class="headerlink" title="字符串与数字的转换"></a>字符串与数字的转换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">"3.14"</span>;</span><br><span class="line"><span class="keyword">var</span> d = +c;</span><br><span class="line"></span><br><span class="line">b; <span class="comment">// "42"</span></span><br><span class="line">d; <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h2 id="日期转换为数字"><a href="#日期转换为数字" class="headerlink" title="日期转换为数字"></a>日期转换为数字</h2><p>Date转换为的数字为从1 January 1970 00:00:00 UTC 到Date的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="string">"Wed, 2 Aug 2017 08:53:06 CDT"</span> );</span><br><span class="line"></span><br><span class="line">+d; <span class="comment">// 1501681986000</span></span><br></pre></td></tr></table></figure></p><p><code>Date.now()</code>方法就是用的这种转换：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Date</span>.now) &#123;</span><br><span class="line"><span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="~操作符"></a><code>~</code>操作符</h2><p>Js里有<code>~</code>操作符，它首先将值转换为32bit的数字，然后在对它进行取补码，也就是说，<code>~x</code>相当于<code>-(x+1)</code>。</p><p>于是，<code>~</code>有一个用处就是判断<code>-1</code>，比如我们对字符串使用<code>indexOf()</code>时如果找不到则返回<code>-1</code>，我们可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">"lo"</span> );<span class="comment">// -4   &lt;-- truthy!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (~a.indexOf( <span class="string">"lo"</span> )) &#123;<span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 找到了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~a.indexOf( <span class="string">"ol"</span> );<span class="comment">// 0    &lt;-- falsy!</span></span><br><span class="line">!~a.indexOf( <span class="string">"ol"</span> );<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!~a.indexOf( <span class="string">"ol"</span> )) &#123;<span class="comment">// true</span></span><br><span class="line"><span class="comment">// 没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，<code>~~</code>可以用来对小数进行取整，但要注意的是，它是舍弃小数位数，而不是四舍五入，相当于<code>Math.ceil()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor( <span class="number">-49.6</span> );<span class="comment">// -50</span></span><br><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">-49.6</span>);  <span class="comment">// -49</span></span><br><span class="line">~~<span class="number">-49.6</span>;<span class="comment">// -49</span></span><br></pre></td></tr></table></figure></p><h2 id="parseInt-方法"><a href="#parseInt-方法" class="headerlink" title="parseInt()方法"></a><code>parseInt()</code>方法</h2><p>该方法可以将字符串转换为数字，而且可以接受第二个参数，表示要转换的进制。但要注意的是，它有几个特别的地方：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.000008</span> );<span class="comment">// 0   ("0" from "0.000008")</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="number">0.0000008</span> );<span class="comment">// 8   ("8" from "8e-7")</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="literal">false</span>, <span class="number">16</span> );<span class="comment">// 250 ("fa" from "false")</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="built_in">parseInt</span>, <span class="number">16</span> );<span class="comment">// 15  ("f" from "function..")</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">"0x10"</span> );<span class="comment">// 16</span></span><br><span class="line"><span class="built_in">parseInt</span>( <span class="string">"103"</span>, <span class="number">2</span> );<span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>所以，要谨慎使用<code>parseInt</code>。</p><h2 id="转换为Boolean"><a href="#转换为Boolean" class="headerlink" title="转换为Boolean"></a>转换为Boolean</h2><p>我们已经知道<code>Boolean()</code>方法可以将值转换为<code>Boolean</code>，但还有一个更快的方法，就是使用<code>!!</code>操作符：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">var</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> g;</span><br><span class="line"></span><br><span class="line">!!a;<span class="comment">// true</span></span><br><span class="line">!!b;<span class="comment">// true</span></span><br><span class="line">!!c;<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!!d;<span class="comment">// false</span></span><br><span class="line">!!e;<span class="comment">// false</span></span><br><span class="line">!!f;<span class="comment">// false</span></span><br><span class="line">!!g;<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><hr><h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><h2 id="数字转换为字符串"><a href="#数字转换为字符串" class="headerlink" title="数字转换为字符串"></a>数字转换为字符串</h2><p>因为字符串可以用<code>+</code>连接，所以当我们把数字和字符串用<code>+</code>连接时，数字会强制转换为字符串：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">122</span>;</span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">''</span>;  </span><br><span class="line">b;  <span class="comment">// "122"</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串转换为数字"><a href="#字符串转换为数字" class="headerlink" title="字符串转换为数字"></a>字符串转换为数字</h2><p>因为<code>-</code>只在数字运算符中才有定义，所以对字符串使用<code>-</code>会被强制转换为数字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"122"</span>;</span><br><span class="line"><span class="keyword">var</span> b = a - <span class="number">0</span>;  </span><br><span class="line">b;  <span class="comment">// 122</span></span><br></pre></td></tr></table></figure></p><h2 id="数组转换为数字"><a href="#数组转换为数字" class="headerlink" title="数组转换为数字"></a>数组转换为数字</h2><p>同样的，如果数组中只有一个值，使用<code>-</code>时，会先把数组转换为字符串，再转换为数字：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>];</span><br><span class="line">a - b; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><h1 id="操作符-和-amp-amp-的妙用"><a href="#操作符-和-amp-amp-的妙用" class="headerlink" title="操作符||和&amp;&amp;的妙用"></a>操作符<code>||</code>和<code>&amp;&amp;</code>的妙用</h1><p>我们都知道<code>||</code>代表‘或’，<code>&amp;&amp;</code>代表‘和’，但是与Java、C++等语言不同的是，使用这两个操作符时，它们返回的不是true或false，而是本身的值，举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">a || b;<span class="comment">// 42</span></span><br><span class="line">a &amp;&amp; b;<span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line">c || b;<span class="comment">// "abc"</span></span><br><span class="line">c &amp;&amp; b;<span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>于是我们就可以利用这两个操作符进行一些赋值操作：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a || b;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">a ? a : b;</span><br><span class="line"></span><br><span class="line">a &amp;&amp; b;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">a ? b : a;</span><br></pre></td></tr></table></figure></p><h1 id="与-的运用"><a href="#与-的运用" class="headerlink" title="==与===的运用"></a><code>==</code>与<code>===</code>的运用</h1><p>这两个符号我们应该很熟悉了，<code>==</code>代表值的比较，如果二者类型不同，会进行强制转换；<code>===</code>则是二者值与类型都相同才为true。这里需要注意一些问题：</p><ul><li><code>NaN</code>不等于它本身</li><li><code>+0</code>等于<code>-0</code></li></ul><h2 id="字符串与数字比较"><a href="#字符串与数字比较" class="headerlink" title="字符串与数字比较"></a>字符串与数字比较</h2><p>二者比较时，使用<code>===</code>结果肯定为false，因为二者类型不同，但如果使用<code>==</code>，则需要进行转换，简单来说就是把字符串转换为数字再对二者的值进行比较：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"22"</span>;</span><br><span class="line"></span><br><span class="line">a === b;<span class="comment">// false</span></span><br><span class="line">a == b;<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h2 id="任何值与Boolean比较"><a href="#任何值与Boolean比较" class="headerlink" title="任何值与Boolean比较"></a>任何值与Boolean比较</h2><p>当任何值与<code>Boolean</code>使用<code>==</code>比较时，首先会把<code>Boolean</code>转换为数字，然后再进行比较。也就是说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="string">"42"</span>;</span><br><span class="line"></span><br><span class="line">x == y; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>所以，在任何时候，都不要使用<code>== true</code>或者<code>== false</code>这样的语句。</p><h2 id="null与undefined比较"><a href="#null与undefined比较" class="headerlink" title="null与undefined比较"></a><code>null</code>与<code>undefined</code>比较</h2><p>当使用<code>==</code>比较<code>null</code>和<code>undefined</code>时，结果总为true。</p><h2 id="Object与非Object比较"><a href="#Object与非Object比较" class="headerlink" title="Object与非Object比较"></a><code>Object</code>与非<code>Object</code>比较</h2><p>当<code>object</code>/<code>function</code>/<code>array</code>与<code>String</code>或者<code>Number</code>进行<code>==</code>比较时，会先把<code>Object</code>转换为<code>String</code>或<code>Number</code>，然后再对值进行比较，而<code>Boolean</code>值会被转换为<code>Number</code>再进行比较。</p><h3 id="一些值得注意的比较"><a href="#一些值得注意的比较" class="headerlink" title="一些值得注意的比较"></a>一些值得注意的比较</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span> == [<span class="literal">null</span>];<span class="comment">// true</span></span><br><span class="line">[] == ![]; <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">"\n"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">"0"</span> == <span class="literal">false</span>;<span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>;<span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">""</span>;<span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == [];<span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span>;<span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == [];<span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == [];<span class="comment">// true</span></span><br></pre></td></tr></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>需要特别注意的就是隐式转换，将对象转换为基本类型时，会先调用<code>valueOf()</code>方法，没有才调用<code>toString()</code>方法，如果我们给自定义的对象添加<code>valueOf()</code>方法，并自己给返回值，也能能起到转换的效果。还有就是，在进行等于比较时，还是用<code>===</code>比较安全。</p><hr><blockquote><p>参考资料：<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md">You-Dont-Know-JS</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript中有七种类型，它们互相之间可以转换，但要搞清楚其中的转换关系可不简单。&lt;br&gt;
    
    </summary>
    
      <category term="前端必会" scheme="https://flyrk.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
      <category term="type-coercion" scheme="https://flyrk.github.io/tags/type-coercion/"/>
    
  </entry>
  
  <entry>
    <title>CSS外边距合并效应</title>
    <link href="https://flyrk.github.io/2017/07/27/css-margin-collapse/"/>
    <id>https://flyrk.github.io/2017/07/27/css-margin-collapse/</id>
    <published>2017-07-27T14:44:05.000Z</published>
    <updated>2017-08-08T13:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>大部分人都知道CSS布局时有外边距合并，也就是说如果给两个块元素设置margin-top或者margin-bottom值，它们上下之间的margin值会发生合并，但具体是根据什么来合并呢？我查了一下，大部分的解释都是<strong>叠加后的margin值取两者之间的最大值</strong>，也就是说，如果给上面的元素设置margin-bottom: 40px, 下面的元素设置margin-top: 50px,则最终两者之间的外边距为50px。但如果设置的值是负值呢？<br><a id="more"></a></p><h1 id="一个为负值，一个为正值"><a href="#一个为负值，一个为正值" class="headerlink" title="一个为负值，一个为正值"></a>一个为负值，一个为正值</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tops</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(94, 195, 27);</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bottoms</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(29, 141, 213);</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ou5mz529o.bkt.clouddn.com/imagemargin-top-bottom1.png" alt="margin"></p><p>可以看到，结果两者之间的外边距值为正负值相加，为10px。</p><h1 id="两个都为负值"><a href="#两个都为负值" class="headerlink" title="两个都为负值"></a>两个都为负值</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.tops</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(94, 195, 27);</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bottoms</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(29, 141, 213);</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ou5mz529o.bkt.clouddn.com/imagemargin-top-bottom2.png" alt="margin"></p><p>最后两者之间外边距为-20px，也就是两个负值绝对值更大的那个。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以说，外边距合并一般有三种情况：</p><ul><li>两者都是正值，取最大的；</li><li>两者一正一负，取二者相加的结果；</li><li>两者都是负值，取二者绝对值更大的；</li></ul><blockquote><p>但要注意的是，外边距合并只发生在块元素之间。一般有三种情况：</p><ul><li>相邻的兄弟姐妹元素：毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。</li><li>块级父元素与其第一个/最后一个子元素：如果块级父元素中，不存在上边框、上内边距、内联元素、 清除浮动 这四条属性（也可以说，当上边框宽度及上内边距距离为0时），那么这个块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。</li><li>空块元素：如果存在一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。</li></ul></blockquote><p><strong>参考文档</strong>：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">MDN-margin-collapsing</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大部分人都知道CSS布局时有外边距合并，也就是说如果给两个块元素设置margin-top或者margin-bottom值，它们上下之间的margin值会发生合并，但具体是根据什么来合并呢？我查了一下，大部分的解释都是&lt;strong&gt;叠加后的margin值取两者之间的最大值&lt;/strong&gt;，也就是说，如果给上面的元素设置margin-bottom: 40px, 下面的元素设置margin-top: 50px,则最终两者之间的外边距为50px。但如果设置的值是负值呢？&lt;br&gt;
    
    </summary>
    
      <category term="设计之美" scheme="https://flyrk.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="CSS" scheme="https://flyrk.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS边框的应用</title>
    <link href="https://flyrk.github.io/2017/07/24/csssecrets-border/"/>
    <id>https://flyrk.github.io/2017/07/24/csssecrets-border/</id>
    <published>2017-07-24T07:25:57.000Z</published>
    <updated>2017-08-08T13:01:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>CSS中盒模型里重要的一个部分就是<code>border</code>，常见的<code>border</code>方法就是设置一重边框：<code>border: 1px solid #494949</code>，但如果我们想实现其他效果，该怎么用呢？<br><a id="more"></a></p><h1 id="CSS实现多重边框"><a href="#CSS实现多重边框" class="headerlink" title="CSS实现多重边框"></a>CSS实现多重边框</h1><h2 id="一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。"><a href="#一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。" class="headerlink" title="一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。"></a>一般的边框设置border只能达到一重边框的效果，如果想达到多重边框，一般要使用各种hack，比如用多个元素来模拟边框。那么有没有更好的办法呢？有。以下方法也能实现多重边框，并且不需要添加多余元素来污染dom结构。</h2><h2 id="box-shadow方案"><a href="#box-shadow方案" class="headerlink" title="box-shadow方案"></a>box-shadow方案</h2><p>  我们知道box-shadow一般用来生成投影，MDN的box-shadow是这样定义的：</p><blockquote><p>Specify a single box-shadow using:</p><ul><li>Two, three, or four <length> values.</length></li><li>If only two values are given, they are interpreted as <offset-x><offset-y> values.</offset-y></offset-x></li><li>If a third value is given, it is interpreted as a <blur-radius>.</blur-radius></li><li>If a fourth value is given, it is interpreted as a <spread-radius>.</spread-radius></li><li>Optionally, the inset keyword.</li><li>Optionally, a <color> value.</color></li></ul></blockquote><p>  我们注意到，一般前两个值代表x和y方向的偏移，第三个值代表模糊值，而第四个参数代表扩张半径，通过指定该值为正或负可以让投影面积加大或减小。于是我们可以实现这样的效果：<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#533</span>;</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ou5mz529o.bkt.clouddn.com/imagebox-shadow.png" alt="one-shadow"></p><p>  当然这和border的效果没什么区别，但box-shadow的好处在于，它支持逗号分隔语法，我们可以创建任意数量的投影。于是我们可以实现多重投影：<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line"><span class="selector-tag">box-shadow</span>: 0 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#533</span>,</span><br><span class="line">                      0 0 0 15<span class="selector-tag">px</span> <span class="selector-id">#2f4</span>,</span><br><span class="line">                      0 2<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.6</span>);</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ou5mz529o.bkt.clouddn.com/imagebox-shadow2.png" alt="double-shadow"></p><p>  注意的是，box-shadow是层层叠加的，第一层投影位于最顶层，依此类推。所以我们如果想在之前的10px外圈上加一道5px的外框，则需要指定扩张半径的值为15px。</p><p>  需要注意的是：</p><blockquote><ul><li>投影的行为和边框不完全一致，因为它不会影响布局，也不会受到box-sizing的影响。</li><li>box-shadow创建出的边框不会响应鼠标事件。如果一定要响应的话，应该给box-shadow加上inset关键字，来使投影绘制在元素的内圈。</li></ul></blockquote><h2 id="outline方案"><a href="#outline方案" class="headerlink" title="outline方案"></a>outline方案</h2><p>  某些情况下可能只需要两层边框，这个时候可以用一层border再加上outline实现，好处是outline可以实现虚线边框，而box-shadow只能实现实线边框。<br>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#533</span>;</span><br><span class="line"><span class="selector-tag">outline</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#2f4</span>;</span><br></pre></td></tr></table></figure></p><p>  <img src="http://ou5mz529o.bkt.clouddn.com/imagebox-shadow2.png" alt="double-shadow"></p><p>需要注意的是：</p><blockquote><p>它只适用于双层边框，而且不一定会贴合border-radius属性产生的圆角。</p></blockquote><p><img src="http://ou5mz529o.bkt.clouddn.com/imageoutline-radius.png" alt="outline-radius"></p><hr><h1 id="边框内圆角实现"><a href="#边框内圆角实现" class="headerlink" title="边框内圆角实现"></a>边框内圆角实现</h1><p>有时候我们需要实现一个容器，只在内部有圆角，而边框外侧四个角则是直角。要实现这个效果，最容易想到的方法就是使用两个元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'container'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>This is a box<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#655</span>;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: tan;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: .<span class="number">8em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果：<br><img src="http://ou5mz529o.bkt.clouddn.com/imageborder-inner-radius.png" alt="border-inner-radius"></p><p>但使用两个元素总是有点不好，能不能只使用一个元素呢？答案是可以。我们可以利用box-shadow和outline达到同样的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: tan;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: .<span class="number">8em</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span> <span class="number">#655</span></span><br><span class="line">  outline: .<span class="number">6em</span> solid <span class="number">#655</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的效果和之前一样。<br>因为box-shadow会跟着元素的圆角走，而outline不会，所以利用两者叠加，box-shadow正好把border和outline之间的空隙填补了。</p><p>注意的是，box-shadow的扩张值不一定等于outline的宽度，一般使用稍小一点的值。根据学过的勾股定理，最小的扩张值一般要大于<code>(&amp;radic;2-1)*border-radius</code>，为了方便，一般取border-radius的一半。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS中盒模型里重要的一个部分就是&lt;code&gt;border&lt;/code&gt;，常见的&lt;code&gt;border&lt;/code&gt;方法就是设置一重边框：&lt;code&gt;border: 1px solid #494949&lt;/code&gt;，但如果我们想实现其他效果，该怎么用呢？&lt;br&gt;
    
    </summary>
    
      <category term="设计之美" scheme="https://flyrk.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="CSS" scheme="https://flyrk.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>最近一段时间的总结</title>
    <link href="https://flyrk.github.io/2017/05/10/Summary/"/>
    <id>https://flyrk.github.io/2017/05/10/Summary/</id>
    <published>2017-05-10T12:53:14.000Z</published>
    <updated>2017-08-08T13:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。<br><a id="more"></a></p><h1 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h1><blockquote><p>自从上个月面完腾讯以来就没有其他面试了。本以为腾讯会招我，毕竟三面都面了，面试过程也没有什么不愉快，没想到到现在等了都快一个月了，中间各种焦躁不安，每天等电话，然而还是没有消息。。。虽说还有一丝希望，但我也不报太大期望了，腾讯最后没要我也只能说明我的能力还是不够，我还是沉下心来继续努力学习吧。<br>不过说实话，这几个月是我前端进步最快的时候。为了找实习刷了很多面试题，计算机基础知识也恶补了一番，经过几次面试对自己的知识掌握程度也有了大概的了解，知道自己还有哪些不足，接下来的前端学习从以下几个方面开始吧：</p></blockquote><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><ul><li>继续阅读《You don’t know JS》和《Javascript设计模式与实践》，边读边做笔记和思维导图</li><li>完成FreeCodeCamp项目练习</li><li>练习百度前端学院有关项目</li></ul><h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><ul><li>阅读《CSS揭秘》</li><li>阅读图书馆借阅的设计方面相关书籍</li><li>在项目中模仿别人的页面设计</li><li>掌握bootstrap</li></ul><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><ul><li>掌握webpack的基本使用和配置</li><li>会用gulp</li><li>了解mocha测试工具</li><li>多了解前端性能优化</li><li>学会如何测试、发布上线项目</li><li>学会写文档</li></ul><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><ul><li>leetcode刷题</li><li>阅读算法导论</li><li>阅读http、tcp有关书籍</li></ul><h2 id="框架学习"><a href="#框架学习" class="headerlink" title="框架学习"></a>框架学习</h2><ul><li>通过阅读别人的React项目学习React基本结构和方法</li><li>自己开始用React+Redux+React-router模仿着写小组件</li><li>掌握React、Vue框架核心思想和区别</li><li>最好能阅读React源码分析</li></ul><h2 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h2><ul><li>阅读underscore源码</li><li>阅读jQuery源码</li><li>阅读Backbone源码</li></ul><hr><h1 id="规划生活"><a href="#规划生活" class="headerlink" title="规划生活"></a>规划生活</h1><p>感觉自己生活最近又变得没有节制了，没有一定的规划，常常是想到什么就做什么。这样很容易漏掉重要的事情，所以接下来我要好好规划一下了。</p><ul><li>首先每天最晚不能超过9点起床，必须要吃早餐，不能让胃空着。起来后边吃早餐边看点新闻、技术文章之类的，而不是无聊地刷手机。</li><li>上午一般用来看看前端书籍，保持至少连续1小时的阅读时间，中间休息十几分钟。</li><li>下午联系驾校练车，争取半个多月拿到证。</li><li>练完车后去锻炼锻炼，跑步或者打球。</li><li>晚上是码代码时间。</li><li>22：00后写博客总结一下当天的心得。</li><li>23：30上床</li></ul><blockquote><p>总之，让生活充实起来，做到学习娱乐两不误！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近半个多月忙于复习考试而没有怎么写博客，虽然其中还是在自学JS，但是没有认真的总结和记录自己的思想，总感觉少了点什么，也违背了当初开博客的初衷。昨天考完试了，这段时间也忙完了，该静下心来好好总结一下了。&lt;br&gt;
    
    </summary>
    
      <category term="生活杂谈" scheme="https://flyrk.github.io/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="thoughts" scheme="https://flyrk.github.io/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title>浅谈函数节流与函数去抖</title>
    <link href="https://flyrk.github.io/2017/05/01/throttle-debounce/"/>
    <id>https://flyrk.github.io/2017/05/01/throttle-debounce/</id>
    <published>2017-05-01T11:37:31.000Z</published>
    <updated>2017-08-08T13:00:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。<br><a id="more"></a></p><h1 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流:throttle"></a>函数节流:throttle</h1><h2 id="函数节流的目的"><a href="#函数节流的目的" class="headerlink" title="函数节流的目的"></a>函数节流的目的</h2><p>有些函数不是由用户直接控制触发的，函数有可能被<strong>频繁地调用</strong>而导致性能问题。一些常见的函数被频繁调用场景：</p><ul><li>window.onscroll事件。当绑定了scroll事件，只要浏览器的窗口滚动就会触发函数，触发频率非常高。如果绑定的函数里面还有DOM操作，则性能损耗非常大。</li><li>mousemove事件。给div绑定该事件，当鼠标拖曳节点时触发函数。</li><li>键盘keydown监听<blockquote><p>我们的目的就是减少函数触发的频率</p></blockquote></li></ul><h2 id="函数节流原理"><a href="#函数节流原理" class="headerlink" title="函数节流原理"></a>函数节流原理</h2><p>我们想到用setTimeout延迟时间执行函数，这样就可以避免函数在一段时间内执行多次。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params"> fn, delay </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _self = fn,             <span class="comment">// 保存将要延迟执行的函数</span></span><br><span class="line">          timer,                    <span class="comment">// 定时器</span></span><br><span class="line">          first_time = <span class="literal">true</span>;  <span class="comment">// 是否第一次调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">              _me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> ( first_time ) &#123;     <span class="comment">// 如果第一次执行则直接调用</span></span><br><span class="line">            _self.apply( _me, args );</span><br><span class="line">            <span class="keyword">return</span> first_time = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( timer ) &#123;           <span class="comment">// 如果timer存在说明之前延迟的函数还没有执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout( timer );</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            _self.apply( _me, args );</span><br><span class="line">        &#125;, delay );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"has changed"</span>);</span><br><span class="line">&#125;, <span class="number">500</span> );</span><br></pre></td></tr></table></figure></p><h1 id="函数去抖-debounce"><a href="#函数去抖-debounce" class="headerlink" title="函数去抖:debounce"></a>函数去抖:debounce</h1><h2 id="函数去抖的目的"><a href="#函数去抖的目的" class="headerlink" title="函数去抖的目的"></a>函数去抖的目的</h2><p>函数去抖其实和节流很像，但不同的是去抖是让函数在一段时间内只触发执行一次，而节流是改变函数触发的调用周期。应用场景：</p><ul><li>文字输入监听</li><li>onscroll事件</li><li>onresize事件。<h2 id="函数去抖原理"><a href="#函数去抖原理" class="headerlink" title="函数去抖原理"></a>函数去抖原理</h2>也是利用setTimeout和闭包的原理。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params"> fn, delay </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context,</span><br><span class="line">          args,</span><br><span class="line">          timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        context = <span class="keyword">this</span>, args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">if</span>( timer ) &#123;</span><br><span class="line">            clearTimeout( timer );</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fn.apply( context, args );</span><br><span class="line">        &#125;, delay );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize = debounce( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"has changed"</span>);</span><br><span class="line">&#125;, <span class="number">600</span> );</span><br></pre></td></tr></table></figure></li></ul><h1 id="underscore源码"><a href="#underscore源码" class="headerlink" title="underscore源码"></a>underscore源码</h1><p>underscore里对throttle和debounce有更完整的实现，这里把代码贴出来</p><ul><li><p>throttle</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, result;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> now = _.now();</span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>debounce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> last = _.now() - timestamp;       <span class="comment">// 上一次函数触发的时间</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class="number">0</span>) &#123;       <span class="comment">// 如果没有到达规定的wait时间则继续延迟，相当于计时器</span></span><br><span class="line">        timeout = setTimeout(later, wait - last);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">          result = func.apply(context, args);</span><br><span class="line">          <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      timestamp = _.now();</span><br><span class="line">      <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">      <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;        <span class="comment">// 如果是立即调用或者上一次函数已经调用完毕</span></span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数节流与函数去抖在很多场景都有着应用，对web性能有很大提升。但是这二者也有一些区别，在这里我简单的总结一些基本知识。&lt;br&gt;
    
    </summary>
    
      <category term="前端必会" scheme="https://flyrk.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
      <category term="throttle" scheme="https://flyrk.github.io/tags/throttle/"/>
    
      <category term="debounce" scheme="https://flyrk.github.io/tags/debounce/"/>
    
  </entry>
  
  <entry>
    <title>http状态码记录</title>
    <link href="https://flyrk.github.io/2017/04/23/http-status-codes-marks/"/>
    <id>https://flyrk.github.io/2017/04/23/http-status-codes-marks/</id>
    <published>2017-04-23T09:57:31.000Z</published>
    <updated>2017-08-08T13:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。<br><a id="more"></a></p><h2 id="100～199：信息性状态码"><a href="#100～199：信息性状态码" class="headerlink" title="100～199：信息性状态码"></a>100～199：信息性状态码</h2><ul><li>100 Continue，说明收到了请求的初始部分，请客户端继续。之后服务器收到请求后必须响应。一般是客户端需要发送一个有实体的主体部分给服务器，但发送之前希望知道服务器是否会接受这个实体。首先客户端要发送一个携带了值为100 Continue的Expect请求首部。</li></ul><h2 id="200～299：成功状态码"><a href="#200～299：成功状态码" class="headerlink" title="200～299：成功状态码"></a>200～299：成功状态码</h2><ul><li>200 OK，代表请求没问题，返回的主体包含请求资源</li><li>202 Accepted，请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求。</li><li>204 No Content，响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要是用来在浏览器不转为显示新文档的情况下，对其进行更新。如更新一个表单页面</li></ul><h2 id="300～399：重定向状态码"><a href="#300～399：重定向状态码" class="headerlink" title="300～399：重定向状态码"></a>300～399：重定向状态码</h2><ul><li>301 Moved Permanently，表示请求的URL已被移除。响应的Location首部中应包含资源现在所处的URL</li><li>302 Found，临时重定向，响应的Location首部包含临时定位资源的URL，以后的请求仍使用旧的URL。当HTTP/1.0客户端发起Post请求，收到302码后会向重定向的URL发起Get请求。</li><li>303 See Other，HTTP1.1规范用303状态码来重定向客户端的POST请求，在它后面跟上一个GET请求</li><li>304 Not Modified，说明请求的资源没有在服务器端更新修改，一般用在客户端请求协商缓存时，返回304代表缓存资源不需要更新，直接在本地获取即可。</li><li>307 Temporary Redirect，HTTP1.1客户端用307状态码取代302</li></ul><h2 id="400～499：客户端错误状态码"><a href="#400～499：客户端错误状态码" class="headerlink" title="400～499：客户端错误状态码"></a>400～499：客户端错误状态码</h2><ul><li>400 Bad Request，客户端发送了错误请求</li><li>401 Unauthorized，与适当的首部一起返回，这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。</li><li>403 Forbidden，说明请求被服务器拒绝了</li><li>404 Not Found，说明服务器无法找到所请求的URL</li><li>405 Method Not Allowed，说明发起的请求中带有所请求的URL不支持的方法。</li><li>406 Not Acceptable，服务器没有与客户端可接受的URL相匹配的资源</li><li>408 Request Timeout，说明客户端完成请求所花时间太长，返回408,并关闭连接。超时时长随服务器的不同有所不同。</li></ul><h2 id="500～599：服务器错误状态码"><a href="#500～599：服务器错误状态码" class="headerlink" title="500～599：服务器错误状态码"></a>500～599：服务器错误状态码</h2><ul><li>500 Internal Server Error，服务器遇到妨碍它为请求提供服务的错误</li><li>501 Not Implemented，客户端发起的请求超出服务器的能力范围</li><li>502 Bad Gateway，代理或网关使用的服务器从请求响应链的下一条链路上收到了伪响应，发生网关连接错误</li><li>503 Service Unavailable，服务器繁忙，暂时无法为请求提供服务</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来在阅读《http权威指南》，看到状态码相关部分，在这里记录下一些常用的状态码，以供以后翻阅。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="https://flyrk.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="https://flyrk.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>浅谈this和call、apply</title>
    <link href="https://flyrk.github.io/2017/04/19/GetToKnow-this-call-apply/"/>
    <id>https://flyrk.github.io/2017/04/19/GetToKnow-this-call-apply/</id>
    <published>2017-04-19T13:46:45.000Z</published>
    <updated>2017-08-08T13:00:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>this的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考<br><a id="more"></a></p><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><p> 一般可分为四种情况：</p><ol><li><p>作为普通函数调用：此时this总是指向全局对象，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var func = &#123;</span><br><span class="line">    name: &apos;Simon&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var name = &apos;Yuk&apos;;</span><br><span class="line">var getMyName = func.getName;</span><br><span class="line">getMyName();  // 输出&apos;Yuk&apos;</span><br></pre></td></tr></table></figure></li><li><p>作为对象方法调用：此时this指向该对象，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var func = &#123;</span><br><span class="line">    name: &apos;Simon&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var name = &apos;Yuk&apos;;</span><br><span class="line">func.getName();  // 输出&apos;Simon&apos;</span><br></pre></td></tr></table></figure></li><li><p>构造器调用：当用new运算符调用函数时，函数会返回一个对象，此时this就指向这个返回的对象。但如果构造器显式地返回了一个object类型的对象，则this会指向这个显式对象。</p></li><li>bind、call、apply方法调用：此时this指向方法中指定的obj。</li></ol><hr><h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><ol><li>call和apply的作用基本相同，区别仅在于传入的参数形式不同。call传入的参数数量不固定，第一个参数是代表函数体内this的指向，从第二个参数开始往后，每个参数被依次传入函数；apply接受两个参数，第一个也是代表函数体内this的指向，第二个参数为一个包含参数的数组或者类数组(arguments)。</li><li>当使用call或者apply，如果传入的第一个参数为null，函数体内的this会指向默认的宿主对象，浏览器中是window，node中是global。</li><li><p>call和apply的用途：</p><ul><li>改变this的指向</li><li><p>Function.prototype.bind的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> _this = <span class="keyword">this</span>,   <span class="comment">// 保存原函数</span></span><br><span class="line">       context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 需要绑定的this的上下文</span></span><br><span class="line">       args = [].slice.call(<span class="built_in">arguments</span>);  <span class="comment">// 剩余的参数转成数组</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;     <span class="comment">// 返回一个新的函数</span></span><br><span class="line">       <span class="keyword">return</span> _this.apply(context, [].concat.call(args, [].slice.call(<span class="built_in">arguments</span>) ) );</span><br><span class="line">           <span class="comment">//执行新的函数的时候，会把之前传入的context当做新函数体内的this</span></span><br><span class="line">           <span class="comment">//并且组合两次分别传入的参数，作为新函数的参数</span></span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>借用其它对象的方法：在操作arguments的时候，我们经常找Array.prototype对象借用方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].slice.call(<span class="built_in">arguments</span>);   <span class="comment">// 将arguments转换为数组</span></span><br><span class="line">[].shift.call(<span class="built_in">arguments</span>);   <span class="comment">// 截去arguments列表中的头一个元素</span></span><br><span class="line">[].push.call(<span class="built_in">arguments</span>, item); <span class="comment">// 向arguments里添加新元素</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;this的指向一直是很多人头疼的问题，我之前也经常弄混，后来整理了一下，感觉开朗了许多，在这里列出来以供参考&lt;br&gt;
    
    </summary>
    
      <category term="前端必会" scheme="https://flyrk.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A/"/>
    
    
      <category term="JavaScript" scheme="https://flyrk.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CVTE、阿里一面、去哪儿一面总结</title>
    <link href="https://flyrk.github.io/2017/04/16/Internship-interviews/"/>
    <id>https://flyrk.github.io/2017/04/16/Internship-interviews/</id>
    <published>2017-04-16T12:47:22.000Z</published>
    <updated>2017-04-18T12:57:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。<br><a id="more"></a></p><h2 id="CVTE一面、二面（3-28）"><a href="#CVTE一面、二面（3-28）" class="headerlink" title="CVTE一面、二面（3.28）"></a>CVTE一面、二面（3.28）</h2><blockquote><p>上午七点多起来匆忙赶地铁去酒店面试cvte，到了以后，发现人没预想的多，就两三个在等待。怀着忐忑的心情等了将近半小时，期间还喝了一瓶酸奶，终于等到了。<br>进去面试后，是一个很帅的小哥，上来先自我介绍，然后问我做了哪些项目，聊一下自己的项目。我刚准备开始聊，突然又问我如何实现一个函数链式调用，想了几分钟写了个闭包，差不多对了。又问之前笔试的题目，如何实现每隔两秒输出数组中的一个元素。手写了一遍，还比较好。然后又问跨域问题，聊了一下，又问http协议是什么，回答了有关域名解析的问题和tcp方面的问题。然后又问http报文关于缓存的首部有哪些，怎么实现，有哪些参数。又问了cookie的用法和使用条件，localstorage是否什么情况都适用，能永久保存吗？之后又问了一些基础知识。然后就叫我去门外等候了。当时一脸蒙蔽，这是算过了还是没过？没想到出来后通知我等候二面。</p></blockquote><blockquote><p>二面进去是一个三十多岁的男人，看样子应该是技术总监之类的。上来就叫我介绍如何入前端这个坑的。我提到自己接触过acm比赛，立即就在笔记本上让我在leetcode上做一道题，限时十分钟。我这时已经有点紧张了，什么也没管，就愣着头写了，就是让找出happy number：如果各个位数的数字平方之和相加然后再将平方和相加，如果能一直加到等于一，则是happy number，如果怎么加都不能为一，则不是。我慌张的写了半天，期间面试官一直在看我写，很慌张，写完又调试了半天，最后超时了。。。面试官提醒我可以调试，再给我点时间，但我已经有点慌了，最后还是没调试成功。他又出了一道题，操作字符串倒序并且空格间隔只能有一个，五分钟内完成。我自信满满地写完，发现空格没处理好，他这时候已经有点不耐烦了。。。说再给我一次机会调试，然而最后我还是没调出来。之后面试官又问了原生ajax怎么写，如果一个ajax请求五分钟都没响应该怎么办？这里我答的很慌张，也跟我实际用ajax处理数据不多有关。反正这里反复问了好几次，最后可能答的也不是很满意。然后又问我进cvte想学到些什么，这里我可能回答的太注重个人了，没有替公司想。然后又问我平时怎么学习前端知识的，遇到知识难点怎么解决之类的。回答完之后就叫我回去等结果了。</p></blockquote><blockquote><p>然而晚上10点多查询结果，果然还是悲剧了……其实也是意料中，二面很多都没答好，算法题也没写出来，被拒绝很正常，就当给自己增长经验吧。</p></blockquote><h2 id="阿里电话一面（3-28）"><a href="#阿里电话一面（3-28）" class="headerlink" title="阿里电话一面（3.28）"></a>阿里电话一面（3.28）</h2><blockquote><p>没想到的是，下午回学校上课，最后五分钟的时候突然杭州来电话！我当时就想到可能是阿里面试，因为之前内推显示成功了。然后出来接电话问我方不方便，我说给我五分钟准备时间，等下课我立即跑到湖边找个地方坐了下来。<br>电话打来了，一开始就让我自我介绍，然后介绍自己最满意的两个项目并说明其中遇到什么问题怎么解决的。我balabala一大堆，把能想到的都说了，但因为只做过小demo，所以说的技术含量也有限。然后问我有没有做过一个完整的有实际价值的项目，我惭愧的说没有。。。提到了自己在学习单页应用。然后就问我什么是SPA，什么是mvc，具体表现在哪些，我回答了一些项目有关的内容，又要我用一句话总结SPA的优势，这里回答的感觉不够好。<br>然后又问了我一些问题：</p><pre><code>1. 跨域问题，回答了一些，又问我了解jsonp吗？当时没听清反复问了几遍，但自己jsonp了解的也不是很多，就随便说了说。2. 了不了解http协议，回答了一些基本知识，又问我为什么http协议是无状态的，我直接回答不会。。。3. 什么是闭包，链式调用是怎么回事，还好上午面试也问到类似问题，回答的还好。4. 了解js的事件模型机制有哪些，我先没搞懂意思，就直接回答了事件循环，说了一大堆，面试官居然说和我想要问的不一样。。。提醒了我后我又回答了有dom操作，监听事件等。5. 用过jquery没有，看过jquery源码没有。。我说没有就没问了。。。6. 页面性能如何优化，我回答了一些基本知识，但感觉自己答得不完全，当时也是有点说累了。。。7. 什么是css盒模型，选择器有哪些，怎么做响应式设计，position有哪些。。。这些回答的自我感觉还行。8. 觉得自己相比其他人最大的优势是什么？当时听到瞬间觉得面试官可能是觉得我太菜了。。。硬着头皮说了一些自己的态度，说自己可能算法和数据结构接触比较多，英语比较好，但就说了这两点。</code></pre><p>然后阿里一面就结束了- -整个过程花了50分钟，是我面试以来最长时间。。。感觉自己会的基本都答了，但很多还是没答完全。基础知识还是不牢，底层的东西掌握不好，自己还有很多要学的东西。</p></blockquote><p>3.28号整个两场面试下来可以说基本快把我榨干了。。。可能面试效果没那么好，但我就当是增长经验，知道了自己的不足，今后继续努力吧！<br>总的来说，今天收获还是很大的，比我预期的要差那么一点，但我对自己第一次面试已经很满意了。只能说：技不如人，回去磨练吧！</p><h2 id="去哪儿一面-4-14"><a href="#去哪儿一面-4-14" class="headerlink" title="去哪儿一面(4.14)"></a>去哪儿一面(4.14)</h2><blockquote><p>接到短信4.14下午去面试去哪儿，去的时候找了半天地方最后终于找到一个小酒店，差点迟到。进去发现人很少，HR姐姐们在一个个点名打电话。我感觉很不对劲，自己的状态也不对。<br>很快轮到我了，上楼面试，进去是一个30岁不到的面试官。上来直接让我介绍简历上的项目，我完整地说完后，面试官又问我CSS怎么清除浮动，这个我也答上来了。之后问我有没有用过什么框架，我坦白回答用的少，没有写过完整框架的项目。这里我感觉面试官已经很不爽了。于是他又问我未来的规划，我大概回答了一下。他说我的方向是正确的，并给了我一些建议，然后就说今天的面试结束了！一周内出结果。这让我一脸懵逼。。。这么快就结束了？怎么不问我JS基础知识？算法也不问？性能什么的也不问？<br>我一脸难以置信地走了出去，总共就面了20分钟！感觉什么都没问的样子，面试官根本就不想问太多。只能落寞地走上地铁回学校了。<br>回去总结知道肯定是跪了，面试官只是不好意思当面拒绝，但我还是感觉面试很敷衍，什么都不问，不想招人了就直说嘛！这次面试就当去打了个酱油吧。。。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试比较多，把之前面过的写下来总结一下，也给自己一个借鉴。&lt;br&gt;
    
    </summary>
    
      <category term="面经" scheme="https://flyrk.github.io/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
      <category term="实习面试" scheme="https://flyrk.github.io/tags/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
